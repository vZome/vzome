import { java, javaemul } from "./candies/j4ts-2.1.0-SNAPSHOT/bundle.js"

(function (java) {
    var util;
    (function (util) {
        class UUID {
            constructor(s) {
                if (this.value === undefined) {
                    this.value = null;
                }
                this.value = s;
            }
            static randomUUID() {
                return new UUID(/* toString */ ('' + (Math.random())).substring(2));
            }
            toString() {
                return this.value;
            }
            static fromString(s) {
                return new UUID(s);
            }
        }
        util.UUID = UUID;
        UUID["__class"] = "java.util.UUID";
    })(util = java.util || (java.util = {}));
})(java);
(function (java) {
    var util;
    (function (util) {
        class Properties {
            getProperty(key) {
                return "";
            }
            load(inStream) {
            }
            isEmpty() {
                return true;
            }
        }
        util.Properties = Properties;
        Properties["__class"] = "java.util.Properties";
    })(util = java.util || (java.util = {}));
})(java);
(function (java) {
    var io;
    (function (io) {
        class File {
            constructor(parent, name) {
            }
            exists() {
                return false;
            }
            getAbsolutePath() {
                return null;
            }
            getName() {
                return null;
            }
            getParentFile() {
                return null;
            }
        }
        io.File = File;
        File["__class"] = "java.io.File";
    })(io = java.io || (java.io = {}));
})(java);
(function (java) {
    var io;
    (function (io) {
        class StringWriter extends java.io.Writer {
            constructor() {
                super();
                if (this.baos === undefined) {
                    this.baos = null;
                }
                if (this.w === undefined) {
                    this.w = null;
                }
                this.baos = new java.io.ByteArrayOutputStream();
                this.w = new java.io.OutputStreamWriter(this.baos);
            }
            toString() {
                return this.baos.toString();
            }
            flush() {
                try {
                    this.w.flush();
                }
                catch (e) {
                    console.error(e.message, e);
                }
            }
            close() {
                try {
                    this.w.close();
                }
                catch (e) {
                    console.error(e.message, e);
                }
            }
            write(cbuf, off, len) {
                try {
                    this.w.write(cbuf, off, len);
                }
                catch (e) {
                    console.error(e.message, e);
                }
            }
        }
        io.StringWriter = StringWriter;
        StringWriter["__class"] = "java.io.StringWriter";
        StringWriter["__interfaces"] = ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
    })(io = java.io || (java.io = {}));
})(java);
(function (java) {
    var io;
    (function (io) {
        class PrintWriter extends java.io.Writer {
            constructor(w) {
                super();
                if (this.w === undefined) {
                    this.w = null;
                }
                this.w = w;
            }
            flush() {
                try {
                    this.w.flush();
                }
                catch (e) {
                    console.error(e.message, e);
                }
            }
            close() {
                try {
                    this.w.close();
                }
                catch (e) {
                    console.error(e.message, e);
                }
            }
            write$char_A$int$int(cbuf, off, len) {
                try {
                    this.w.write(cbuf, off, len);
                }
                catch (e) {
                    console.error(e.message, e);
                }
            }
            write(cbuf, off, len) {
                if (((cbuf != null && cbuf instanceof Array && (cbuf.length == 0 || cbuf[0] == null || (typeof cbuf[0] === 'string'))) || cbuf === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return this.write$char_A$int$int(cbuf, off, len);
                }
                else if (((typeof cbuf === 'string') || cbuf === null) && off === undefined && len === undefined) {
                    return this.write$java_lang_String(cbuf);
                }
                else
                    throw new Error('invalid overload');
            }
            write$java_lang_String(str) {
                try {
                    this.w.write(str);
                }
                catch (e) {
                    console.error(e.message, e);
                }
            }
            println$() {
                this.print("\n");
            }
            print(x) {
                if (!(typeof x === 'string'))
                    x = x.toString();
                const chars = x.split('');
                this.write$char_A$int$int(chars, 0, chars.length);
            }
            println$java_lang_Object(x) {
                this.print(x);
                this.println$();
            }
            println(x) {
                if (((x != null) || x === null)) {
                    return this.println$java_lang_Object(x);
                }
                else if (x === undefined) {
                    return this.println$();
                }
                else
                    throw new Error('invalid overload');
            }
        }
        io.PrintWriter = PrintWriter;
        PrintWriter["__class"] = "java.io.PrintWriter";
        PrintWriter["__interfaces"] = ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
    })(io = java.io || (java.io = {}));
})(java);
(function (java) {
    var beans;
    (function (beans) {
        class PropertyChangeEvent extends java.util.EventObject {
            constructor(source, propertyName, oldValue, newValue) {
                super(source);
                if (this.propertyName === undefined) {
                    this.propertyName = null;
                }
                if (this.newValue === undefined) {
                    this.newValue = null;
                }
                if (this.oldValue === undefined) {
                    this.oldValue = null;
                }
                if (this.propagationId === undefined) {
                    this.propagationId = null;
                }
                this.propertyName = propertyName;
                this.newValue = newValue;
                this.oldValue = oldValue;
            }
            getPropertyName() {
                return this.propertyName;
            }
            getNewValue() {
                return this.newValue;
            }
            getOldValue() {
                return this.oldValue;
            }
            setPropagationId(propagationId) {
                this.propagationId = propagationId;
            }
            getPropagationId() {
                return this.propagationId;
            }
            toString() {
                const sb = new java.lang.StringBuilder(/* getName */ (c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])(this.constructor));
                sb.append("[propertyName=").append(this.getPropertyName());
                this.appendTo(sb);
                sb.append("; oldValue=").append(this.getOldValue());
                sb.append("; newValue=").append(this.getNewValue());
                sb.append("; propagationId=").append(this.getPropagationId());
                sb.append("; source=").append(this.getSource());
                return sb.append("]").toString();
            }
            appendTo(sb) {
            }
        }
        PropertyChangeEvent.__java_beans_PropertyChangeEvent_serialVersionUID = 7042693688939648123;
        beans.PropertyChangeEvent = PropertyChangeEvent;
        PropertyChangeEvent["__class"] = "java.beans.PropertyChangeEvent";
        PropertyChangeEvent["__interfaces"] = ["java.io.Serializable"];
    })(beans = java.beans || (java.beans = {}));
})(java);
(function (java) {
    var beans;
    (function (beans) {
        class ChangeListenerMap {
            constructor() {
                if (this.map === undefined) {
                    this.map = null;
                }
            }
            add(name, listener) {
                if (this.map == null) {
                    this.map = (new java.util.HashMap());
                }
                const array = this.map.get(name);
                const size = (array != null) ? array.length : 0;
                const clone = this.newArray(size + 1);
                clone[size] = listener;
                if (array != null) {
                    java.lang.System.arraycopy(array, 0, clone, 0, size);
                }
                this.map.put(name, clone);
            }
            remove(name, listener) {
                if (this.map != null) {
                    const array = this.map.get(name);
                    if (array != null) {
                        for (let i = 0; i < array.length; i++) {
                            {
                                if (listener.equals(array[i])) {
                                    const size = array.length - 1;
                                    if (size > 0) {
                                        const clone = this.newArray(size);
                                        java.lang.System.arraycopy(array, 0, clone, 0, i);
                                        java.lang.System.arraycopy(array, i + 1, clone, i, size - i);
                                        this.map.put(name, clone);
                                    }
                                    else {
                                        this.map.remove(name);
                                        if (this.map.isEmpty()) {
                                            this.map = null;
                                        }
                                    }
                                    break;
                                }
                            }
                            ;
                        }
                    }
                }
            }
            /**
             * Returns the list of listeners for the specified property.
             *
             * @param {string} name
             * the name of the property
             * @return {L[]} the corresponding list of listeners
             */
            get(name) {
                return (this.map != null) ? this.map.get(name) : null;
            }
            /**
             * Sets new list of listeners for the specified property.
             *
             * @param {string} name
             * the name of the property
             * @param {L[]} listeners
             * new list of listeners
             */
            set(name, listeners) {
                if (listeners != null) {
                    if (this.map == null) {
                        this.map = (new java.util.HashMap());
                    }
                    this.map.put(name, listeners);
                }
                else if (this.map != null) {
                    this.map.remove(name);
                    if (this.map.isEmpty()) {
                        this.map = null;
                    }
                }
            }
            getListeners$() {
                if (this.map == null) {
                    return this.newArray(0);
                }
                const list = (new java.util.ArrayList());
                const listeners = this.map.get(null);
                if (listeners != null) {
                    for (let index = 0; index < listeners.length; index++) {
                        let listener = listeners[index];
                        {
                            list.add(listener);
                        }
                    }
                }
                for (let index = this.map.entrySet().iterator(); index.hasNext();) {
                    let entry = index.next();
                    {
                        const name = entry.getKey();
                        if (name != null) {
                            {
                                let array = entry.getValue();
                                for (let index = 0; index < array.length; index++) {
                                    let listener = array[index];
                                    {
                                        list.add(this.newProxy(name, listener));
                                    }
                                }
                            }
                        }
                    }
                }
                return list.toArray(this.newArray(list.size()));
            }
            getListeners$java_lang_String(name) {
                if (name != null) {
                    const listeners = this.get(name);
                    if (listeners != null) {
                        return (listeners).slice(0);
                    }
                }
                return this.newArray(0);
            }
            /**
             * Returns listeners that have been associated with the named property.
             *
             * @param {string} name
             * the name of the property
             * @return {L[]} an array of listeners for the named property
             */
            getListeners(name) {
                if (((typeof name === 'string') || name === null)) {
                    return this.getListeners$java_lang_String(name);
                }
                else if (name === undefined) {
                    return this.getListeners$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Indicates whether the map contains at least one listener to be notified.
             *
             * @param {string} name
             * the name of the property
             * @return {boolean} {@code true} if at least one listener exists or {@code false}
             * otherwise
             */
            hasListeners(name) {
                if (this.map == null) {
                    return false;
                }
                const array = this.map.get(null);
                return (array != null) || ((name != null) && (null != this.map.get(name)));
            }
            /**
             * Returns a set of entries from the map. Each entry is a pair consisted of
             * the property name and the corresponding list of listeners.
             *
             * @return {*} a set of entries from the map
             */
            getEntries() {
                return (this.map != null) ? this.map.entrySet() : java.util.Collections.emptySet();
            }
        }
        beans.ChangeListenerMap = ChangeListenerMap;
        ChangeListenerMap["__class"] = "java.beans.ChangeListenerMap";
    })(beans = java.beans || (java.beans = {}));
})(java);
(function (java) {
    var beans;
    (function (beans) {
        /**
         * Constructor which binds the {@code PropertyChangeListener}
         * to a specific property.
         *
         * @param {string} propertyName  the name of the property to listen on
         * @param {*} listener      the listener object
         * @class
         * @extends java.util.EventListenerProxy
         */
        class PropertyChangeListenerProxy extends java.util.EventListenerProxy {
            constructor(propertyName, listener) {
                super(listener);
                if (this.propertyName === undefined) {
                    this.propertyName = null;
                }
                this.propertyName = propertyName;
            }
            /**
             * Forwards the property change event to the listener delegate.
             *
             * @param {java.beans.PropertyChangeEvent} event  the property change event
             */
            propertyChange(event) {
                this.getListener().propertyChange(event);
            }
            /**
             * Returns the name of the named property associated with the listener.
             *
             * @return {string} the name of the named property associated with the listener
             */
            getPropertyName() {
                return this.propertyName;
            }
        }
        beans.PropertyChangeListenerProxy = PropertyChangeListenerProxy;
        PropertyChangeListenerProxy["__class"] = "java.beans.PropertyChangeListenerProxy";
        PropertyChangeListenerProxy["__interfaces"] = ["java.util.EventListener", "java.beans.PropertyChangeListener"];
    })(beans = java.beans || (java.beans = {}));
})(java);
(function (java) {
    var nio;
    (function (nio) {
        class FloatBuffer {
            put(offset, x) {
            }
        }
        nio.FloatBuffer = FloatBuffer;
        FloatBuffer["__class"] = "java.nio.FloatBuffer";
    })(nio = java.nio || (java.nio = {}));
})(java);
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            class GeneralPath {
                constructor() {
                    this.xs = (new java.util.ArrayList());
                    this.ys = (new java.util.ArrayList());
                    this.actions = (new java.util.ArrayList());
                }
                moveTo(x, y) {
                    this.xs.add(x);
                    this.ys.add(y);
                    this.actions.add(java.awt.geom.PathIterator.SEG_MOVETO);
                }
                lineTo(x, y) {
                    this.xs.add(x);
                    this.ys.add(y);
                    this.actions.add(java.awt.geom.PathIterator.SEG_LINETO);
                }
                closePath() {
                    this.xs.add(0);
                    this.ys.add(0);
                    this.actions.add(java.awt.geom.PathIterator.SEG_CLOSE);
                }
                getPathIterator(at) {
                    return new GeneralPath.GeneralPath$0(this);
                }
            }
            geom.GeneralPath = GeneralPath;
            GeneralPath["__class"] = "java.awt.geom.GeneralPath";
            (function (GeneralPath) {
                class GeneralPath$0 {
                    constructor(__parent) {
                        this.__parent = __parent;
                        this.index = 0;
                    }
                    isDone() {
                        return this.index === this.__parent.actions.size();
                    }
                    currentSegment(coords) {
                        coords[0] = this.__parent.xs.get(this.index);
                        coords[1] = this.__parent.ys.get(this.index);
                        return (this.__parent.actions.get(this.index) | 0);
                    }
                    next() {
                        ++this.index;
                    }
                }
                GeneralPath.GeneralPath$0 = GeneralPath$0;
                GeneralPath$0["__interfaces"] = ["java.awt.geom.PathIterator"];
            })(GeneralPath = geom.GeneralPath || (geom.GeneralPath = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java);
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            let PathIterator;
            (function (PathIterator) {
                PathIterator.SEG_MOVETO = 0;
                PathIterator.SEG_LINETO = 1;
                PathIterator.SEG_CLOSE = 4;
            })(PathIterator = geom.PathIterator || (geom.PathIterator = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java);
(function (java) {
    var awt;
    (function (awt) {
        var geom;
        (function (geom) {
            class Rectangle2D {
            }
            geom.Rectangle2D = Rectangle2D;
            Rectangle2D["__class"] = "java.awt.geom.Rectangle2D";
            (function (Rectangle2D) {
                class Float extends java.awt.geom.Rectangle2D {
                    constructor(x, y, w, h) {
                        super();
                        if (this.width === undefined) {
                            this.width = 0;
                        }
                        if (this.height === undefined) {
                            this.height = 0;
                        }
                        this.width = w;
                        this.height = h;
                    }
                    getWidth() {
                        return this.width;
                    }
                    getHeight() {
                        return this.height;
                    }
                }
                Rectangle2D.Float = Float;
                Float["__class"] = "java.awt.geom.Rectangle2D.Float";
            })(Rectangle2D = geom.Rectangle2D || (geom.Rectangle2D = {}));
        })(geom = awt.geom || (awt.geom = {}));
    })(awt = java.awt || (java.awt = {}));
})(java);
(function (java) {
    var awt;
    (function (awt) {
        class Dimension {
            constructor(width, height) {
                if (this.width === undefined) {
                    this.width = 0;
                }
                if (this.height === undefined) {
                    this.height = 0;
                }
                this.width = width;
                this.height = height;
            }
        }
        awt.Dimension = Dimension;
        Dimension["__class"] = "java.awt.Dimension";
    })(awt = java.awt || (java.awt = {}));
})(java);
(function (java) {
    var awt;
    (function (awt) {
        class Color {
            constructor(r, g, b, a) {
                if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && ((typeof a === 'number') || a === null)) {
                    let __args = arguments;
                    if (this.value === undefined) {
                        this.value = 0;
                    }
                    this.value = ((a & 255) << 24) | ((r & 255) << 16) | ((g & 255) << 8) | ((b & 255) << 0);
                }
                else if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && a === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let a = 255;
                        if (this.value === undefined) {
                            this.value = 0;
                        }
                        this.value = ((a & 255) << 24) | ((r & 255) << 16) | ((g & 255) << 8) | ((b & 255) << 0);
                    }
                }
                else if (((typeof r === 'number') || r === null) && g === undefined && b === undefined && a === undefined) {
                    let __args = arguments;
                    let rgb = __args[0];
                    if (this.value === undefined) {
                        this.value = 0;
                    }
                    this.value = -16777216 | rgb;
                }
                else
                    throw new Error('invalid overload');
            }
            static WHITE_$LI$() { if (Color.WHITE == null) {
                Color.WHITE = new Color(255, 255, 255);
            } return Color.WHITE; }
            static BLACK_$LI$() { if (Color.BLACK == null) {
                Color.BLACK = new Color(0, 0, 0);
            } return Color.BLACK; }
            getRed() {
                return (this.value >> 16) & 255;
            }
            getGreen() {
                return (this.value >> 8) & 255;
            }
            getBlue() {
                return (this.value >> 0) & 255;
            }
            getRGB() {
                return this.value;
            }
            getRGBColorComponents(compArray) {
                const f = [0, 0, 0];
                f[0] = Math.fround(this.getRed() / 255.0);
                f[1] = Math.fround(this.getGreen() / 255.0);
                f[2] = Math.fround(this.getBlue() / 255.0);
                return f;
            }
        }
        awt.Color = Color;
        Color["__class"] = "java.awt.Color";
    })(awt = java.awt || (java.awt = {}));
})(java);
(function (java) {
    var text;
    (function (text) {
        class NumberFormat {
            static getNumberInstance(us) {
                return new NumberFormat();
            }
            static getInstance() {
                return new NumberFormat();
            }
            setMaximumFractionDigits(i) {
            }
            setMinimumFractionDigits(i) {
            }
            format(x) {
                return /* toString */ ('' + (x));
            }
            setGroupingUsed(newValue) {
            }
        }
        text.NumberFormat = NumberFormat;
        NumberFormat["__class"] = "java.text.NumberFormat";
    })(text = java.text || (java.text = {}));
})(java);
export var com;
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsSelection {
                constructor(field, adapter) {
                    if (this.adapter === undefined) {
                        this.adapter = null;
                    }
                    if (this.field === undefined) {
                        this.field = null;
                    }
                    this.field = field;
                    this.adapter = adapter;
                }
                setAdapter(adapter) {
                    this.adapter = adapter;
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    if (this.adapter == null)
                        return java.util.Collections.emptyIterator();
                    const f = (this.adapter["selectedIterator"]);
                    const jSiterator = f.apply(this.adapter);
                    return new JsSelection.JsSelection$0(this, jSiterator);
                }
                /**
                 *
                 */
                clear() {
                    (this.adapter["clearSelection"]).apply(this.adapter);
                }
                /**
                 *
                 * @param {*} man
                 * @return {boolean}
                 */
                manifestationSelected(man) {
                    const vectors = man.getVectors();
                    return (this.adapter["manifestationSelected"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {*} man
                 */
                select(man) {
                    const vectors = man.getVectors();
                    (this.adapter["select"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {*} man
                 */
                unselect(man) {
                    const vectors = man.getVectors();
                    (this.adapter["unselect"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return ((this.adapter["selectionSize"]).apply(this.adapter) | 0);
                }
                /**
                 *
                 */
                gatherGroup() {
                    (this.adapter["createGroup"]).apply(this.adapter);
                }
                /**
                 *
                 */
                scatterGroup() {
                    (this.adapter["disbandGroup"]).apply(this.adapter);
                }
                /**
                 *
                 */
                gatherGroup211() {
                    (this.adapter["createLegacyGroup"]).apply(this.adapter);
                }
                /**
                 *
                 */
                scatterGroup211() {
                    (this.adapter["disbandLegacyGroup"]).apply(this.adapter);
                }
                /**
                 *
                 * @param {*} man
                 */
                selectWithGrouping(man) {
                    if (man == null)
                        return;
                    const vectors = man.getVectors();
                    (this.adapter["selectWithGrouping"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {*} man
                 */
                unselectWithGrouping(man) {
                    if (man == null)
                        return;
                    const vectors = man.getVectors();
                    (this.adapter["unselectWithGrouping"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @return {boolean}
                 */
                isSelectionAGroup() {
                    return (this.adapter["selectionIsGroup"]).apply(this.adapter);
                }
                /**
                 *
                 * @param {java.lang.Class} class1
                 * @return {*}
                 */
                getSingleSelection(class1) {
                    throw new java.lang.RuntimeException("unimplemented getSingleSelection");
                }
                /**
                 *
                 * @param {*} bookmarkedSelection
                 */
                copy(bookmarkedSelection) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
            }
            jsweet.JsSelection = JsSelection;
            JsSelection["__class"] = "com.vzome.jsweet.JsSelection";
            JsSelection["__interfaces"] = ["com.vzome.core.editor.api.Selection", "java.lang.Iterable"];
            (function (JsSelection) {
                class JsSelection$0 {
                    constructor(__parent, jSiterator) {
                        this.jSiterator = jSiterator;
                        this.__parent = __parent;
                        this.peek = this.jSiterator.next();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        return !this.peek.done;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    next() {
                        const result = com.vzome.jsweet.JsManifestation.manifest(this.peek.value, this.__parent.field, this.__parent.adapter);
                        this.peek = this.jSiterator.next();
                        return result;
                    }
                }
                JsSelection.JsSelection$0 = JsSelection$0;
                JsSelection$0["__interfaces"] = ["java.util.Iterator"];
            })(JsSelection = jsweet.JsSelection || (jsweet.JsSelection = {}));
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsEditContext {
                constructor() {
                }
                /**
                 *
                 * @param {*} xml
                 * @return {com.vzome.core.editor.api.UndoableEdit}
                 */
                createEdit(xml) {
                    throw new java.lang.RuntimeException("unimplemented createEdit");
                }
                /**
                 *
                 * @param {com.vzome.core.editor.api.UndoableEdit} edit
                 */
                performAndRecord(edit) {
                    throw new java.lang.RuntimeException("unimplemented performAndRecord");
                }
                /**
                 *
                 * @param {string} cmdName
                 * @return {*}
                 */
                createLegacyCommand(cmdName) {
                    throw new java.lang.RuntimeException("unimplemented createLegacyCommand");
                }
                /**
                 *
                 * @param {string} action
                 * @param {*} props
                 * @return {boolean}
                 */
                doEdit(action, props) {
                    throw new java.lang.RuntimeException("unimplemented doEdit");
                }
            }
            jsweet.JsEditContext = JsEditContext;
            JsEditContext["__class"] = "com.vzome.jsweet.JsEditContext";
            JsEditContext["__interfaces"] = ["com.vzome.core.editor.api.Context"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsRealizedModel {
                constructor(field, adapter) {
                    if (this.field === undefined) {
                        this.field = null;
                    }
                    if (this.adapter === undefined) {
                        this.adapter = null;
                    }
                    this.field = field;
                    this.adapter = adapter;
                }
                setAdapter(adapter) {
                    this.adapter = adapter;
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    const f = (this.adapter["allIterator"]);
                    const jSiterator = f.apply(this.adapter);
                    return new JsRealizedModel.JsRealizedModel$0(this, jSiterator);
                }
                /**
                 *
                 * @return {*}
                 */
                getField() {
                    return this.field;
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} c
                 * @return {*}
                 */
                findConstruction(c) {
                    if (c == null)
                        return null;
                    let vectors = com.vzome.jsweet.JsManifestation.canonicalizeConstruction(c);
                    if (vectors == null)
                        return null;
                    vectors = (this.adapter["findOrCreateManifestation"]).apply(this.adapter, [vectors]);
                    if (vectors == null)
                        return null;
                    return com.vzome.jsweet.JsManifestation.manifest(vectors, this.field, this.adapter);
                }
                /**
                 *
                 * @param {*} man
                 */
                remove(man) {
                    const vectors = man.getVectors();
                    (this.adapter["delete"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} c
                 * @return {*}
                 */
                getManifestation(c) {
                    return this.findConstruction(c);
                }
                /**
                 *
                 * @param {*} man
                 */
                show(man) {
                    const vectors = man.getVectors();
                    (this.adapter["showManifestation"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {*} man
                 */
                hide(man) {
                    const vectors = man.getVectors();
                    (this.adapter["hideManifestation"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {*} man
                 * @param {com.vzome.core.construction.Color} color
                 */
                setColor(man, color) {
                    man.setColor(color);
                }
                /**
                 *
                 * @param {*} man
                 * @param {string} label
                 */
                setLabel(man, label) {
                    man.setLabel(label);
                }
                /**
                 *
                 * @param {*} man
                 */
                add(man) {
                    const vectors = man.getVectors();
                    (this.adapter["showManifestation"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {string} signature
                 * @return {*}
                 */
                findPerEditManifestation(signature) {
                    return null;
                }
                /**
                 *
                 * @param {string} signature
                 * @param {*} m
                 */
                addPerEditManifestation(signature, m) {
                }
                /**
                 *
                 */
                clearPerEditManifestations() {
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} c
                 * @return {*}
                 */
                removeConstruction(c) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
            }
            jsweet.JsRealizedModel = JsRealizedModel;
            JsRealizedModel["__class"] = "com.vzome.jsweet.JsRealizedModel";
            JsRealizedModel["__interfaces"] = ["com.vzome.core.model.RealizedModel", "java.lang.Iterable"];
            (function (JsRealizedModel) {
                class JsRealizedModel$0 {
                    constructor(__parent, jSiterator) {
                        this.jSiterator = jSiterator;
                        this.__parent = __parent;
                        this.peek = this.jSiterator.next();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        return !this.peek.done;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    next() {
                        const result = com.vzome.jsweet.JsManifestation.manifest(this.peek.value, this.__parent.field, this.__parent.adapter);
                        this.peek = this.jSiterator.next();
                        return result;
                    }
                }
                JsRealizedModel.JsRealizedModel$0 = JsRealizedModel$0;
                JsRealizedModel$0["__interfaces"] = ["java.util.Iterator"];
            })(JsRealizedModel = jsweet.JsRealizedModel || (jsweet.JsRealizedModel = {}));
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsAlgebraicField {
                constructor(delegate) {
                    if (this.delegate === undefined) {
                        this.delegate = null;
                    }
                    if (this.positivePowers === undefined) {
                        this.positivePowers = null;
                    }
                    if (this.negativePowers === undefined) {
                        this.negativePowers = null;
                    }
                    if (this.zomicModule === undefined) {
                        this.zomicModule = null;
                    }
                    if (this.vzomePkg === undefined) {
                        this.vzomePkg = null;
                    }
                    this.delegate = delegate;
                    const order = (delegate["order"]);
                    this.positivePowers = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(order - 1);
                    this.negativePowers = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(order - 1);
                }
                /* Default method injected from com.vzome.core.algebra.AlgebraicField */
                supportsSubfield(fieldName) {
                    if (fieldName === this.getName())
                        return true;
                    return (fieldName === ("golden")) && this.getGoldenRatio() != null;
                }
                /**
                 *
                 * @return {string}
                 */
                getName() {
                    return (this.delegate["name"]);
                }
                /**
                 *
                 * @return {number}
                 */
                getOrder() {
                    return (this.delegate["order"]);
                }
                /**
                 *
                 * @return {*}
                 */
                getAffineScalar() {
                    const scalar = (this.delegate["scalarTerm"]);
                    return this.getUnitTerm(scalar);
                }
                /**
                 *
                 * @return {number}
                 */
                getNumIrrationals() {
                    return this.getOrder() - 1;
                }
                /**
                 *
                 * @return {number}
                 */
                getNumMultipliers() {
                    return this.getNumIrrationals();
                }
                add(v1, v2) {
                    const f = (this.delegate["plus"]);
                    return (f((v1), (v2)));
                }
                subtract(v1, v2) {
                    const f = (this.delegate["minus"]);
                    return (f((v1), (v2)));
                }
                multiply(v1, v2) {
                    const f = (this.delegate["times"]);
                    return (f((v1), (v2)));
                }
                evaluateNumber(factors) {
                    const f = (this.delegate["embed"]);
                    return (f((factors)));
                }
                reciprocal(factors) {
                    const f = (this.delegate["reciprocal"]);
                    return (f((factors)));
                }
                negate(factors) {
                    const f = (this.delegate["negate"]);
                    return (f((factors)));
                }
                toString(factors, format) {
                    const f = (this.delegate["toString"]);
                    return (f((factors), (format)));
                }
                getMathML(v1) {
                    const f = (this.delegate["toString"]);
                    return (f((v1), (4)));
                }
                /**
                 *
                 * @return {*}
                 */
                zero() {
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, (this.delegate["zero"]));
                }
                /**
                 *
                 * @return {*}
                 */
                one() {
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, (this.delegate["one"]));
                }
                /**
                 *
                 * @param {int[][]} nums
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                createVector(nums) {
                    const x = this.createAlgebraicNumberFromPairs(nums[0]);
                    const y = this.createAlgebraicNumberFromPairs(nums[1]);
                    const z = this.createAlgebraicNumberFromPairs(nums[2]);
                    return new com.vzome.core.algebra.AlgebraicVector(x, y, z);
                }
                /**
                 *
                 * @param {int[][]} nums
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                createVectorFromTDs(nums) {
                    const dims = nums.length;
                    const coords = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(dims);
                    for (let c = 0; c < coords.length; c++) {
                        {
                            coords[c] = this.createAlgebraicNumberFromTD(nums[c]);
                        }
                        ;
                    }
                    return new com.vzome.core.algebra.AlgebraicVector(coords);
                }
                /**
                 *
                 * @param {number} dims
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                origin(dims) {
                    const zero = this.zero();
                    switch ((dims)) {
                        case 1:
                            return new com.vzome.core.algebra.AlgebraicVector(zero);
                        case 2:
                            return new com.vzome.core.algebra.AlgebraicVector(zero, zero);
                        case 3:
                            return new com.vzome.core.algebra.AlgebraicVector(zero, zero, zero);
                        case 4:
                            return new com.vzome.core.algebra.AlgebraicVector(zero, zero, zero, zero);
                        case 5:
                            return new com.vzome.core.algebra.AlgebraicVector(zero, zero, zero, zero, zero);
                        default:
                            return null;
                    }
                }
                /**
                 *
                 * @return {boolean}
                 */
                scale4dRoots() {
                    return false;
                }
                /**
                 *
                 * @return {boolean}
                 */
                doubleFrameVectors() {
                    return false;
                }
                /**
                 *
                 * @param {number} dims
                 * @param {number} axis
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                basisVector(dims, axis) {
                    const result = this.origin(dims);
                    return result.setComponent(axis, this.one());
                }
                createPower$int(power) {
                    return this.createPower$int$int(power, 1);
                }
                createPower$int$int(power, irr) {
                    const one = this.one();
                    if (power === 0 || irr === 0)
                        return one;
                    irr -= 1;
                    if (power > 0) {
                        if (this.positivePowers[irr] == null)
                            this.positivePowers[irr] = (new java.util.ArrayList(8));
                        if (power >= this.positivePowers[irr].size()) {
                            if (this.positivePowers[irr].isEmpty()) {
                                this.positivePowers[irr].add(one);
                                this.positivePowers[irr].add(this.getUnitTerm(irr + 1));
                            }
                            const size = this.positivePowers[irr].size();
                            const irrat = this.positivePowers[irr].get(1);
                            let last = this.positivePowers[irr].get(size - 1);
                            for (let i = size; i <= power; i++) {
                                {
                                    const next = last['times$com_vzome_core_algebra_AlgebraicNumber'](irrat);
                                    this.positivePowers[irr].add(next);
                                    last = next;
                                }
                                ;
                            }
                        }
                        return this.positivePowers[irr].get(power);
                    }
                    else {
                        power = -power;
                        if (this.negativePowers[irr] == null)
                            this.negativePowers[irr] = (new java.util.ArrayList(8));
                        if (power >= this.negativePowers[irr].size()) {
                            if (this.negativePowers[irr].isEmpty()) {
                                this.negativePowers[irr].add(one);
                                this.negativePowers[irr].add(this.getUnitTerm(irr + 1).reciprocal());
                            }
                            const size = this.negativePowers[irr].size();
                            const irrat = this.negativePowers[irr].get(1);
                            let last = this.negativePowers[irr].get(size - 1);
                            for (let i = size; i <= power; i++) {
                                {
                                    const next = last['times$com_vzome_core_algebra_AlgebraicNumber'](irrat);
                                    this.negativePowers[irr].add(next);
                                    last = next;
                                }
                                ;
                            }
                        }
                        return this.negativePowers[irr].get(power);
                    }
                }
                /**
                 *
                 * @param {number} power
                 * @param {number} irr
                 * @return {*}
                 */
                createPower(power, irr) {
                    if (((typeof power === 'number') || power === null) && ((typeof irr === 'number') || irr === null)) {
                        return this.createPower$int$int(power, irr);
                    }
                    else if (((typeof power === 'number') || power === null) && irr === undefined) {
                        return this.createPower$int(power);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * @param {number} n specifies the ordinal of the term in the AlgebraicNumber which will be set to one.
                 * When {@code n == 0}, the result is the same as {@code createRational(1)}.
                 * When {@code n == 1}, the result is the same as {@code createPower(1)}.
                 * When {@code n < 0}, the result will be {@code zero()}.
                 * When {@code n >= getOrder()}, an IndexOutOfBoundsException will be thrown.
                 * @return {*} an AlgebraicNumber with the factor specified by {@code n} set to one.
                 */
                getUnitTerm(n) {
                    if (n < 0) {
                        return this.zero();
                    }
                    const factors = this.zero().toTrailingDivisor();
                    factors[n] = factors[factors.length - 1];
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, factors);
                }
                createRational$long(wholeNumber) {
                    return this.createRational$long$long(wholeNumber, 1);
                }
                /**
                 *
                 * @param {int[]} trailingDivisorForm
                 * @return {*}
                 */
                createAlgebraicNumberFromTD(trailingDivisorForm) {
                    const f = (this.delegate["createNumber"]);
                    const simplified = (f((trailingDivisorForm)));
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, simplified);
                }
                createAlgebraicNumberFromPairs(pairs) {
                    const f = (this.delegate["createNumberFromPairs"]);
                    const simplified = (f((pairs)));
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, simplified);
                }
                createRational$long$long(numerator, denominator) {
                    const f = (this.delegate["createNumberFromPairs"]);
                    const simplified = (f(([numerator, denominator])));
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, simplified);
                }
                /**
                 *
                 * @param {number} numerator
                 * @param {number} denominator
                 * @return {*}
                 */
                createRational(numerator, denominator) {
                    if (((typeof numerator === 'number') || numerator === null) && ((typeof denominator === 'number') || denominator === null)) {
                        return this.createRational$long$long(numerator, denominator);
                    }
                    else if (((typeof numerator === 'number') || numerator === null) && denominator === undefined) {
                        return this.createRational$long(numerator);
                    }
                    else
                        throw new Error('invalid overload');
                }
                createAlgebraicNumber$int_A(terms) {
                    return this.createAlgebraicNumber$int_A$int(terms, 1);
                }
                createAlgebraicNumber$int_A$int(numerators, denominator) {
                    const factors = this.zero().toTrailingDivisor();
                    java.lang.System.arraycopy(numerators, 0, factors, 0, numerators.length);
                    factors[numerators.length] = denominator;
                    return this.createAlgebraicNumberFromTD(factors);
                }
                /**
                 *
                 * @return {*}
                 */
                getGoldenRatio() {
                    const value = (this.delegate["goldenRatio"]);
                    if (value == null)
                        return null;
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, value);
                }
                /**
                 *
                 * @param {number} dims
                 * @return {com.vzome.core.algebra.AlgebraicMatrix}
                 */
                identityMatrix(dims) {
                    const columns = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(dims);
                    for (let i = 0; i < columns.length; i++) {
                        {
                            columns[i] = this.basisVector(dims, i);
                        }
                        ;
                    }
                    return new com.vzome.core.algebra.AlgebraicMatrix(columns);
                }
                /**
                 * Modeled after AbstractAlgebraicField, with a switch from BigRationals to int[]s.
                 * @param {string} string
                 * @param {boolean} isRational
                 * @return {*}
                 */
                parseVefNumber(string, isRational) {
                    const pairs = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(this.getOrder() + 1);
                    if ((!isRational) && /* startsWith */ ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "(") && /* endsWith */ ((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(string, ")")) {
                        const tokens = new java.util.StringTokenizer(string.substring(1, string.length - 1), ",");
                        const numStack = (new java.util.Stack());
                        const denomStack = (new java.util.Stack());
                        while ((tokens.hasMoreTokens())) {
                            {
                                if (numStack.size() >= this.getOrder()) {
                                    throw new java.lang.RuntimeException("VEF format error: \"" + string + "\" has too many factors for " + this.getName() + " field");
                                }
                                const parts = tokens.nextToken().split("/");
                                numStack.push(javaemul.internal.IntegerHelper.parseInt(parts[0]));
                                denomStack.push((parts.length > 1) ? javaemul.internal.IntegerHelper.parseInt(parts[1]) : 1);
                            }
                        }
                        ;
                        let i = 0;
                        while ((!numStack.empty())) {
                            {
                                pairs[i++] = numStack.pop();
                                pairs[i++] = denomStack.pop();
                            }
                        }
                        ;
                    }
                    else {
                        const parts = string.split("/");
                        pairs[0] = javaemul.internal.IntegerHelper.parseInt(parts[0]);
                        pairs[1] = (parts.length > 1) ? javaemul.internal.IntegerHelper.parseInt(parts[1]) : 1;
                    }
                    return this.createAlgebraicNumberFromPairs(pairs);
                }
                /**
                 * Drop one coordinate from the 4D vector. If wFirst (the usual), then drop
                 * the first coordinate, taking the "imaginary part" of the vector. If
                 * !wFirst (for old VEF import, etc.), drop the last coordinate.
                 *
                 * @param {com.vzome.core.algebra.AlgebraicVector} source
                 * @param {boolean} wFirst
                 * @return
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                projectTo3d(source, wFirst) {
                    if (source.dimension() === 3)
                        return source;
                    else {
                        const result = this.origin(3);
                        for (let i = 0; i < 3; i++) {
                            result.setComponent(i, source.getComponent(wFirst ? i + 1 : i));
                        }
                        return result;
                    }
                }
                createAlgebraicNumber$int$int$int$int(ones, irrat, denominator, scalePower) {
                    const result = this.createAlgebraicNumberFromTD([ones, irrat, denominator]);
                    if (scalePower !== 0) {
                        const multiplier = this.createPower$int(scalePower);
                        return result['times$com_vzome_core_algebra_AlgebraicNumber'](multiplier);
                    }
                    else
                        return result;
                }
                /**
                 *
                 * @param {number} ones
                 * @param {number} irrat
                 * @param {number} denominator
                 * @param {number} scalePower
                 * @return {*}
                 */
                createAlgebraicNumber(ones, irrat, denominator, scalePower) {
                    if (((typeof ones === 'number') || ones === null) && ((typeof irrat === 'number') || irrat === null) && ((typeof denominator === 'number') || denominator === null) && ((typeof scalePower === 'number') || scalePower === null)) {
                        return this.createAlgebraicNumber$int$int$int$int(ones, irrat, denominator, scalePower);
                    }
                    else if (((ones != null && ones instanceof Array && (ones.length == 0 || ones[0] == null || (typeof ones[0] === 'number'))) || ones === null) && ((typeof irrat === 'number') || irrat === null) && denominator === undefined && scalePower === undefined) {
                        return this.createAlgebraicNumber$int_A$int(ones, irrat);
                    }
                    else if (((ones != null && ones instanceof Array && (ones.length == 0 || ones[0] == null || (typeof ones[0] === 'number'))) || ones === null) && irrat === undefined && denominator === undefined && scalePower === undefined) {
                        return this.createAlgebraicNumber$int_A(ones);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {string} nums
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                parseVector(nums) {
                    const noLF = nums.split('\n').join(' ');
                    const noCRLF = noLF.split('\r').join(' ');
                    const tokens = new java.util.StringTokenizer(noCRLF, " ");
                    const numToks = tokens.countTokens();
                    if (numToks % this.getOrder() !== 0)
                        throw new java.lang.IllegalStateException("Field order (" + this.getOrder() + ") does not divide token count: " + numToks + ", for \'" + noCRLF + "\'");
                    const dims = (numToks / this.getOrder() | 0);
                    const coords = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(dims);
                    for (let i = 0; i < dims; i++) {
                        {
                            coords[i] = this.parseNumber$java_util_StringTokenizer(tokens);
                        }
                        ;
                    }
                    return new com.vzome.core.algebra.AlgebraicVector(coords);
                }
                parseNumber$java_lang_String(nums) {
                    const tokens = new java.util.StringTokenizer(nums, " ");
                    return this.parseNumber$java_util_StringTokenizer(tokens);
                }
                /**
                 *
                 * @param {string} nums
                 * @return {*}
                 */
                parseNumber(nums) {
                    if (((typeof nums === 'string') || nums === null)) {
                        return this.parseNumber$java_lang_String(nums);
                    }
                    else if (((nums != null && nums instanceof java.util.StringTokenizer) || nums === null)) {
                        return this.parseNumber$java_util_StringTokenizer(nums);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /*private*/ parseNumber$java_util_StringTokenizer(tokens) {
                    const order = this.getOrder();
                    const pairs = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(order * 2);
                    for (let i = 0; i < order; i++) {
                        {
                            const digit = tokens.nextToken();
                            const parts = digit.split("/");
                            pairs[i * 2] = javaemul.internal.IntegerHelper.parseInt(parts[0]);
                            if (parts.length > 1)
                                pairs[i * 2 + 1] = javaemul.internal.IntegerHelper.parseInt(parts[1]);
                            else
                                pairs[i * 2 + 1] = 1;
                        }
                        ;
                    }
                    return this.createAlgebraicNumberFromPairs(pairs);
                }
                /**
                 *
                 * @param {string} string
                 * @return {*}
                 */
                parseLegacyNumber(string) {
                    let div = 1;
                    if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "(")) {
                        const closeParen = string.indexOf(')');
                        div = javaemul.internal.IntegerHelper.parseInt(string.substring(closeParen + 2));
                        string = string.substring(1, closeParen);
                    }
                    let phis = 0;
                    const phiIndex = string.indexOf("phi");
                    if (phiIndex >= 0) {
                        const part = string.substring(0, phiIndex);
                        if (part.length === 0)
                            phis = 1;
                        else if (part === ("-"))
                            phis = -1;
                        else
                            phis = javaemul.internal.IntegerHelper.parseInt(part);
                        string = string.substring(phiIndex + 3);
                    }
                    let ones;
                    if (string.length === 0)
                        ones = 0;
                    else {
                        if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "+"))
                            string = string.substring(1);
                        ones = javaemul.internal.IntegerHelper.parseInt(string);
                    }
                    return this.createAlgebraicNumber$int$int$int$int(ones, phis, div, 0);
                }
                getIrrational$int$int(i, format) {
                    const f = (this.delegate["getIrrational"]);
                    return (f((i)));
                }
                /**
                 *
                 * @param {number} i
                 * @param {number} format
                 * @return {string}
                 */
                getIrrational(i, format) {
                    if (((typeof i === 'number') || i === null) && ((typeof format === 'number') || format === null)) {
                        return this.getIrrational$int$int(i, format);
                    }
                    else if (((typeof i === 'number') || i === null) && format === undefined) {
                        return this.getIrrational$int(i);
                    }
                    else
                        throw new Error('invalid overload');
                }
                getIrrational$int(which) {
                    return this.getIrrational$int$int(which, 0);
                }
                setInterpreterModule(module, vzomePkg) {
                    this.zomicModule = module;
                    this.vzomePkg = vzomePkg;
                }
                interpretScript(script, language, offset, symmetry, effects) {
                    if (this.zomicModule == null)
                        throw new Error("The Zomic module was not loaded.");
                    const f = (this.zomicModule["interpretScript"]);
                    f((script), (language), (offset), (symmetry), (effects), (this.vzomePkg));
                }
                getNumberByName(name) {
                    throw new java.lang.RuntimeException("unimplemented JsAlgebraicField.getNumberByName");
                }
                scaleBy(factors, whichIrrational) {
                    throw new java.lang.RuntimeException("unimplemented JsAlgebraicField.scaleBy");
                }
                /**
                 *
                 * @param {com.vzome.core.math.RealVector} target
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                nearestAlgebraicVector(target) {
                    throw new java.lang.RuntimeException("unimplemented JsAlgebraicField.nearestAlgebraicVector");
                }
                /**
                 *
                 * @param {int[][]} nums
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                createIntegerVector(nums) {
                    throw new java.lang.RuntimeException("unimplemented JsAlgebraicField.createIntegerVector");
                }
                /**
                 *
                 * @param {int[][][]} data
                 * @return {com.vzome.core.algebra.AlgebraicMatrix}
                 */
                createMatrix(data) {
                    throw new java.lang.RuntimeException("unimplemented JsAlgebraicField.createMatrix");
                }
            }
            jsweet.JsAlgebraicField = JsAlgebraicField;
            JsAlgebraicField["__class"] = "com.vzome.jsweet.JsAlgebraicField";
            JsAlgebraicField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsManifestation {
                constructor(field, adapter, vectors) {
                    if (this.vectors === undefined) {
                        this.vectors = null;
                    }
                    if (this.field === undefined) {
                        this.field = null;
                    }
                    if (this.adapter === undefined) {
                        this.adapter = null;
                    }
                    this.field = field;
                    this.adapter = adapter;
                    this.vectors = vectors;
                }
                getVectors() {
                    return this.vectors;
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Color}
                 */
                getColor() {
                    const colorful = (this.adapter["manifestationHasColor"]).apply(this.adapter, [this.vectors]);
                    if (!colorful)
                        return null;
                    const rgb = ((this.adapter["manifestationColor"]).apply(this.adapter, [this.vectors]) | 0);
                    return new com.vzome.core.construction.Color(rgb);
                }
                /**
                 *
                 * @return {string}
                 */
                getLabel() {
                    return null;
                }
                /**
                 *
                 * @param {string} label
                 */
                setLabel(label) {
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Color} color
                 */
                setColor(color) {
                    if (color != null)
                        (this.adapter["setManifestationColor"]).apply(this.adapter, [this.vectors, color.getRGB()]);
                }
                /**
                 *
                 * @return {boolean}
                 */
                isRendered() {
                    return (this.adapter["manifestationRendered"]).apply(this.adapter, [this.vectors]);
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} mConstruction
                 */
                addConstruction(mConstruction) {
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} mConstruction
                 */
                removeConstruction(mConstruction) {
                }
                /**
                 *
                 * @return {boolean}
                 */
                isUnnecessary() {
                    return true;
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Construction}
                 */
                getFirstConstruction() {
                    return this.toConstruction();
                }
                static canonicalizeNumbers(...ns) {
                    return java.util.Arrays.stream(ns).map((n) => n.toTrailingDivisor()).toArray();
                }
                /**
                 * Note: this does NOT order the vectors canonically in the outermost array
                 * @param {com.vzome.core.algebra.AlgebraicVector[]} vs
                 * @return
                 * @return {int[][][]}
                 */
                static canonicalizeVectors(...vs) {
                    return java.util.Arrays.stream(vs).map((v) => JsManifestation.canonicalizeNumbers.apply(this, v.getComponents())).toArray();
                }
                static canonicalizeConstruction(c) {
                    if (c != null && c instanceof com.vzome.core.construction.Point) {
                        const p = c;
                        return JsManifestation.canonicalizeVectors(p.getLocation());
                    }
                    else if (c != null && c instanceof com.vzome.core.construction.Segment) {
                        const s = c;
                        return JsManifestation.canonicalizeVectors(s.getStart(), s.getEnd());
                    }
                    else if (c != null && c instanceof com.vzome.core.construction.Polygon) {
                        return JsManifestation.canonicalizeVectors.apply(this, c.getVertices());
                    }
                    return null;
                }
                static manifest(vectors, field, adapter) {
                    switch ((vectors.length)) {
                        case 1:
                            return new com.vzome.jsweet.JsBall(field, adapter, vectors);
                        case 2:
                            const strut = new com.vzome.jsweet.JsStrut(field, adapter, vectors);
                            if (strut.getOffset().isOrigin())
                                return null;
                            else
                                return strut;
                        default:
                            return new com.vzome.jsweet.JsPanel(field, adapter, vectors);
                    }
                }
                /**
                 *
                 * @param {boolean} b
                 */
                setHidden(b) {
                }
                /**
                 *
                 * @return {boolean}
                 */
                isHidden() {
                    return (this.adapter["manifestationHidden"]).apply(this.adapter, [this.vectors]);
                }
                /**
                 *
                 * @param {com.vzome.core.model.Group} container
                 */
                setContainer(container) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @return {com.vzome.core.model.Group}
                 */
                getContainer() {
                    const members = (this.adapter["getLargestGroup"]).apply(this.adapter, [this.vectors]);
                    if (members == null)
                        return null;
                    const group = new com.vzome.core.model.Group();
                    for (let i = 0; i < members.length; i++) {
                        {
                            group.add(JsManifestation.manifest(members[i], this.field, this.adapter));
                        }
                        ;
                    }
                    return group;
                }
                /**
                 *
                 * @param {*} renderedObject
                 */
                setRenderedObject(renderedObject) {
                }
                /**
                 *
                 * @return {*}
                 */
                getConstructions() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {*} doc
                 * @return {*}
                 */
                getXml(doc) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getCentroid() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
            }
            jsweet.JsManifestation = JsManifestation;
            JsManifestation["__class"] = "com.vzome.jsweet.JsManifestation";
            JsManifestation["__interfaces"] = ["com.vzome.core.model.GroupElement", "com.vzome.core.model.Manifestation"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsAlgebraicNumber {
                constructor(field, factors) {
                    if (this.field === undefined) {
                        this.field = null;
                    }
                    if (this.factors === undefined) {
                        this.factors = null;
                    }
                    this.field = field;
                    this.factors = (factors).slice();
                }
                /**
                 *
                 * @return {*}
                 */
                getField() {
                    return this.field;
                }
                /**
                 *
                 * @return {number}
                 */
                evaluate() {
                    return this.field.evaluateNumber(this.factors);
                }
                /**
                 *
                 * @return {int[]}
                 */
                toTrailingDivisor() {
                    return (this.factors).slice();
                }
                /**
                 *
                 * @param {number} n is the value to be added
                 * @return {*} this + n
                 */
                plusInt(n) {
                    return n === 0 ? this : this.plus$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long(n));
                }
                /**
                 *
                 * @param {number} num is the numerator of the rational value to be added
                 * @param {number} den is the denominator of the rational value to be added
                 * @return {*} this + (num / den)
                 */
                plusRational(num, den) {
                    return this.plus$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long$long(num, den));
                }
                plus$com_vzome_core_algebra_AlgebraicNumber(that) {
                    const factors = this.field.add(this.factors, that.factors);
                    return new JsAlgebraicNumber(this.field, factors);
                }
                /**
                 *
                 * @param {*} that
                 * @return {*}
                 */
                plus(that) {
                    if (((that != null && (that.constructor != null && that.constructor["__interfaces"] != null && that.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || that === null)) {
                        return this.plus$com_vzome_core_algebra_AlgebraicNumber(that);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {number} n
                 * @return {*}
                 */
                minusInt(n) {
                    return n === 0 ? this : this.minus$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long(n));
                }
                /**
                 *
                 * @param {number} num
                 * @param {number} den
                 * @return {*}
                 */
                minusRational(num, den) {
                    return this.minus$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long$long(num, den));
                }
                minus$com_vzome_core_algebra_AlgebraicNumber(that) {
                    const factors = this.field.subtract(this.factors, that.factors);
                    return new JsAlgebraicNumber(this.field, factors);
                }
                /**
                 *
                 * @param {*} that
                 * @return {*}
                 */
                minus(that) {
                    if (((that != null && (that.constructor != null && that.constructor["__interfaces"] != null && that.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || that === null)) {
                        return this.minus$com_vzome_core_algebra_AlgebraicNumber(that);
                    }
                    else
                        throw new Error('invalid overload');
                }
                times$com_vzome_core_algebra_AlgebraicNumber(that) {
                    const factors = this.field.multiply(this.factors, that.factors);
                    return new JsAlgebraicNumber(this.field, factors);
                }
                /**
                 *
                 * @param {*} that
                 * @return {*}
                 */
                times(that) {
                    if (((that != null && (that.constructor != null && that.constructor["__interfaces"] != null && that.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || that === null)) {
                        return this.times$com_vzome_core_algebra_AlgebraicNumber(that);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {number} divisor
                 * @return {*}
                 */
                dividedByInt(divisor) {
                    return divisor === 1 ? this : this.times$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long$long(1, divisor));
                }
                /**
                 *
                 * @param {number} num
                 * @param {number} den
                 * @return {*}
                 */
                dividedByRational(num, den) {
                    return this.times$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long$long(den, num));
                }
                /**
                 *
                 * @param {*} that
                 * @return {*}
                 */
                dividedBy(that) {
                    const recip = this.field.reciprocal(that.factors);
                    const factors = this.field.multiply(this.factors, recip);
                    return new JsAlgebraicNumber(this.field, factors);
                }
                equals(that) {
                    return java.util.Arrays.equals(this.factors, that.factors);
                }
                /**
                 *
                 * @return {*}
                 */
                negate() {
                    const factors = this.field.negate(this.factors);
                    return new JsAlgebraicNumber(this.field, factors);
                }
                /**
                 *
                 * @return {boolean}
                 */
                isZero() {
                    return this.equals(this.field.zero());
                }
                /**
                 *
                 * @return {boolean}
                 */
                isOne() {
                    return this.equals(this.field.one());
                }
                /**
                 *
                 * @return {*}
                 */
                reciprocal() {
                    return new JsAlgebraicNumber(this.field, this.field.reciprocal(this.factors));
                }
                /**
                 * @param {java.lang.StringBuffer} buf
                 * @param {number} format must be one of the following values.
                 * The result is formatted as follows:
                 * <br>
                 * {@code DEFAULT_FORMAT    // 4 + 3}<br>
                 * {@code EXPRESSION_FORMAT // 4 +3*phi}<br>
                 * {@code ZOMIC_FORMAT      // 4 3}<br>
                 * {@code VEF_FORMAT        // (3,4)}<br>
                 */
                getNumberExpression(buf, format) {
                    buf.append(this.toString(format));
                }
                /**
                 * @param {number} format must be one of the following values.
                 * The result is formatted as follows:
                 * <br>
                 * {@code DEFAULT_FORMAT    // 4 + 3}<br>
                 * {@code EXPRESSION_FORMAT // 4 +3*phi}<br>
                 * {@code ZOMIC_FORMAT      // 4 3}<br>
                 * {@code VEF_FORMAT        // (3,4)}
                 * @return {string}
                 */
                toString(format) {
                    return this.field.toString(this.factors, format);
                }
                /**
                 *
                 * @return {string}
                 */
                getMathML() {
                    return this.field.getMathML(this.factors);
                }
                /**
                 *
                 * @param {*} other
                 * @return {number}
                 */
                compareTo(other) {
                    if (this === other) {
                        return 0;
                    }
                    if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(other, this)) {
                        return 0;
                    }
                    const d1 = this.evaluate();
                    const d2 = other.evaluate();
                    return /* compareTo */ ((o1, o2) => { if (o1 && o1.compareTo) {
                        return o1.compareTo(o2);
                    }
                    else {
                        return o1 < o2 ? -1 : o2 < o1 ? 1 : 0;
                    } })(d1, d2);
                }
                /**
                 *
                 * @param {*} other
                 * @return {boolean}
                 */
                greaterThan(other) {
                    return this.compareTo(other) > 0;
                }
                /**
                 *
                 * @param {*} other
                 * @return {boolean}
                 */
                lessThan(other) {
                    return this.compareTo(other) < 0;
                }
                /**
                 *
                 * @param {*} other
                 * @return {boolean}
                 */
                greaterThanOrEqualTo(other) {
                    return this.compareTo(other) >= 0;
                }
                /**
                 *
                 * @param {*} other
                 * @return {boolean}
                 */
                lessThanOrEqualTo(other) {
                    return this.compareTo(other) <= 0;
                }
                /**
                 *
                 * @return {number}
                 */
                signum() {
                    return /* intValue */ (javaemul.internal.DoubleHelper.valueOf(/* signum */ (f => { if (f > 0) {
                        return 1;
                    }
                    else if (f < 0) {
                        return -1;
                    }
                    else {
                        return 0;
                    } })(this.evaluate())) | 0);
                }
                /**
                 *
                 * @param {number} n
                 * @return {*}
                 */
                timesInt(n) {
                    throw new java.lang.RuntimeException("unimplemented JsAlgebraicNumber.timesInt");
                }
                /**
                 *
                 * @param {number} num
                 * @param {number} den
                 * @return {*}
                 */
                timesRational(num, den) {
                    throw new java.lang.RuntimeException("unimplemented JsAlgebraicNumber.times");
                }
                /**
                 *
                 * @return {boolean}
                 */
                isRational() {
                    throw new java.lang.RuntimeException("unimplemented JsAlgebraicNumber.isRational");
                }
            }
            jsweet.JsAlgebraicNumber = JsAlgebraicNumber;
            JsAlgebraicNumber["__class"] = "com.vzome.jsweet.JsAlgebraicNumber";
            JsAlgebraicNumber["__interfaces"] = ["com.vzome.core.algebra.Fields.Element", "com.vzome.core.algebra.AlgebraicNumber", "java.lang.Comparable"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsEditorModel {
                constructor(realizedModel, selection, kind, symmetries, symmetrySystems) {
                    if (this.realizedModel === undefined) {
                        this.realizedModel = null;
                    }
                    if (this.selection === undefined) {
                        this.selection = null;
                    }
                    if (this.kind === undefined) {
                        this.kind = null;
                    }
                    if (this.symmetrySegment === undefined) {
                        this.symmetrySegment = null;
                    }
                    if (this.symmetryCenter === undefined) {
                        this.symmetryCenter = null;
                    }
                    if (this.symmetries === undefined) {
                        this.symmetries = null;
                    }
                    if (this.symmetrySystems === undefined) {
                        this.symmetrySystems = null;
                    }
                    if (this.selectionSummary === undefined) {
                        this.selectionSummary = null;
                    }
                    this.realizedModel = realizedModel;
                    this.selection = selection;
                    this.kind = kind;
                    this.symmetries = symmetries;
                    this.symmetrySystems = symmetrySystems;
                    this.symmetryCenter = new com.vzome.core.construction.FreePoint(realizedModel.getField().origin(3));
                    this.selectionSummary = new com.vzome.core.editor.SelectionSummary(this.selection);
                    this.selection.addListener(this.selectionSummary);
                }
                setAdapter(adapter) {
                }
                /**
                 *
                 * @return {*}
                 */
                getRealizedModel() {
                    return this.realizedModel;
                }
                /**
                 *
                 * @return {*}
                 */
                getSelection() {
                    return this.selection;
                }
                /**
                 *
                 * @return {*}
                 */
                get4dSymmetries() {
                    return this.kind;
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Segment}
                 */
                getSymmetrySegment() {
                    return this.symmetrySegment;
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Point}
                 */
                getCenterPoint() {
                    return this.symmetryCenter;
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} cons
                 * @return {boolean}
                 */
                hasFailedConstruction(cons) {
                    return false;
                }
                getSymmetrySystem$() {
                    return this.symmetries;
                }
                getSymmetrySystem$java_lang_String(name) {
                    return (this.symmetrySystems[name]);
                }
                /**
                 *
                 * @param {string} name
                 * @return {*}
                 */
                getSymmetrySystem(name) {
                    if (((typeof name === 'string') || name === null)) {
                        return this.getSymmetrySystem$java_lang_String(name);
                    }
                    else if (name === undefined) {
                        return this.getSymmetrySystem$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} cons
                 */
                addFailedConstruction(cons) {
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} point
                 */
                setCenterPoint(point) {
                    this.symmetryCenter = point;
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Segment} segment
                 */
                setSymmetrySegment(segment) {
                    this.symmetrySegment = segment;
                }
                /**
                 *
                 * @param {*} listener
                 */
                addSelectionSummaryListener(listener) {
                    this.selectionSummary.addListener(listener);
                }
                notifyListeners() {
                    this.selectionSummary.notifyListeners();
                }
                /**
                 *
                 * @param {java.lang.Class} kind
                 * @return {com.vzome.core.construction.Construction}
                 */
                getSelectedConstruction(kind) {
                    let manifestationClass;
                    if (kind === com.vzome.core.construction.Point)
                        manifestationClass = "com.vzome.core.model.Connector";
                    else if (kind === com.vzome.core.construction.Segment)
                        manifestationClass = "com.vzome.core.model.Strut";
                    else
                        return null;
                    const focus = this.selection.getSingleSelection(manifestationClass);
                    if (focus != null)
                        return focus.getFirstConstruction();
                    return null;
                }
            }
            jsweet.JsEditorModel = JsEditorModel;
            JsEditorModel["__class"] = "com.vzome.jsweet.JsEditorModel";
            JsEditorModel["__interfaces"] = ["com.vzome.core.editor.api.EditorModel", "com.vzome.core.editor.api.LegacyEditorModel", "com.vzome.core.editor.api.ImplicitSymmetryParameters", "com.vzome.core.editor.api.SymmetryAware"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsAdapter {
                static mapVectorToJava(vector, field) {
                    const ans = java.util.stream.Stream.of(vector).map((ints) => new com.vzome.jsweet.JsAlgebraicNumber(field, ints)).toArray();
                    return new com.vzome.core.algebra.AlgebraicVector(ans);
                }
                static mapVectorToJavascript(vector) {
                    return java.util.stream.Stream.of(vector.getComponents()).map((an) => an.toTrailingDivisor()).toArray();
                }
                static getZoneGrid(orbits, planeNormal) {
                    const field = orbits.getSymmetry().getField();
                    const normal = JsAdapter.mapVectorToJava(planeNormal, field);
                    const planeColor = orbits.getVectorColor(normal).toWebString();
                    const planeName = orbits.getSymmetry()['getAxis$com_vzome_core_algebra_AlgebraicVector'](normal).getOrbit().getName();
                    const zonesList = (new java.util.ArrayList());
                    const planeOrbits = new com.vzome.core.math.symmetry.PlaneOrbitSet(orbits.getOrbits(), normal);
                    for (const iterator = planeOrbits.zones(); iterator.hasNext();) {
                        {
                            const zone = iterator.next();
                            const orbit = zone.getDirection();
                            if (!orbit.isStandard())
                                continue;
                            const gridPoints = (new java.util.ArrayList());
                            const zoneNormal = zone.normal();
                            const zoneColor = orbits.getVectorColor(zoneNormal).toWebString();
                            let scale = orbit.getUnitLength();
                            for (let i = 0; i < 5; i++) {
                                {
                                    scale = scale['times$com_vzome_core_algebra_AlgebraicNumber'](field.createPower$int(1));
                                    const gridPoint = zoneNormal.scale(scale);
                                    gridPoints.add(gridPoint);
                                }
                                ;
                            }
                            const vectors = gridPoints.stream().toArray((size) => (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(size));
                            const zoneObj = ((target) => {
                                target["color"] = zoneColor;
                                target["vectors"] = vectors;
                                return target;
                            })(new Object());
                            zonesList.add(zoneObj);
                        }
                        ;
                    }
                    const zones = zonesList.stream().toArray((size) => (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(size));
                    return ((target) => {
                        target["color"] = planeColor;
                        target["zones"] = zones;
                        return target;
                    })(new Object());
                }
            }
            jsweet.JsAdapter = JsAdapter;
            JsAdapter["__class"] = "com.vzome.jsweet.JsAdapter";
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                class AbstractSymmetryPerspective {
                    constructor(symmetry) {
                        if (this.symmetry === undefined) {
                            this.symmetry = null;
                        }
                        this.geometries = (new java.util.ArrayList());
                        this.defaultShapes = null;
                        this.symmetry = symmetry;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetry() {
                        return this.symmetry;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return this.getSymmetry().getName();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return this.getSymmetry().getName();
                    }
                    addShapes(shapes) {
                        const old = this.getGeometry(shapes.getName());
                        if (old != null) {
                            this.geometries.remove(old);
                        }
                        this.geometries.add(shapes);
                    }
                    clearShapes() {
                        this.geometries.clear();
                        this.defaultShapes = null;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getGeometries() {
                        return this.geometries;
                    }
                    /*private*/ getGeometry(name) {
                        for (let index = this.geometries.iterator(); index.hasNext();) {
                            let shapes = index.next();
                            {
                                if (shapes.getName() === name) {
                                    return shapes;
                                }
                            }
                        }
                        return null;
                    }
                    setDefaultGeometry(shapes) {
                        this.defaultShapes = shapes;
                        this.addShapes(shapes);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getDefaultGeometry() {
                        return this.defaultShapes;
                    }
                    /**
                     *
                     * @param {string} action
                     * @return {*}
                     */
                    getLegacyCommand(action) {
                        switch ((action)) {
                            case "octasymm":
                                {
                                    let octaSymm = this.getSymmetry();
                                    if (!(octaSymm != null && octaSymm instanceof com.vzome.core.math.symmetry.OctahedralSymmetry)) {
                                        octaSymm = new com.vzome.core.math.symmetry.OctahedralSymmetry(octaSymm.getField());
                                    }
                                    return new com.vzome.core.commands.CommandSymmetry(octaSymm);
                                }
                                ;
                            case "tetrasymm":
                                {
                                    const symmetry = this.getSymmetry();
                                    const closure = symmetry.subgroup(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL);
                                    return new com.vzome.core.commands.CommandTetrahedralSymmetry(symmetry);
                                }
                                ;
                            default:
                                return null;
                        }
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} orbit
                     * @return {boolean}
                     */
                    orbitIsStandard(orbit) {
                        return orbit.isStandard();
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} orbit
                     * @return {boolean}
                     */
                    orbitIsBuildDefault(orbit) {
                        const zone0 = orbit.getAxis$int$int(0, 0);
                        return zone0.getRotationPermutation() != null;
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} orbit
                     * @return {*}
                     */
                    getOrbitUnitLength(orbit) {
                        return orbit.getUnitLength();
                    }
                }
                kinds.AbstractSymmetryPerspective = AbstractSymmetryPerspective;
                AbstractSymmetryPerspective["__class"] = "com.vzome.core.kinds.AbstractSymmetryPerspective";
                AbstractSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                class DefaultFieldApplication {
                    constructor(field) {
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        if (this.octahedralPerspective === undefined) {
                            this.octahedralPerspective = null;
                        }
                        this.groups4d = (new java.util.HashMap());
                        this.pointsymm = new com.vzome.core.commands.CommandCentralSymmetry();
                        this.mirrorsymm = new com.vzome.core.commands.CommandMirrorSymmetry();
                        this.translate = new com.vzome.core.commands.CommandTranslate();
                        this.centroid = new com.vzome.core.commands.CommandCentroid();
                        this.hideball = new com.vzome.core.commands.CommandHide();
                        this.hide = new com.vzome.core.commands.CommandHide();
                        this.panel = new com.vzome.core.commands.CommandPolygon();
                        this.midpoint = new com.vzome.core.commands.CommandMidpoint();
                        this.field = field;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return this.field.getName();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return null;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getField() {
                        return this.field;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getDefaultSymmetryPerspective() {
                        return this.getSymmetryPerspective("octahedral");
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetryPerspectives() {
                        return java.util.Arrays.asList(this.getDefaultSymmetryPerspective());
                    }
                    /**
                     *
                     * @param {string} symmName
                     * @return {*}
                     */
                    getSymmetryPerspective(symmName) {
                        switch ((symmName)) {
                            case "octahedral":
                                if (this.octahedralPerspective == null) {
                                    this.octahedralPerspective = new com.vzome.core.kinds.OctahedralSymmetryPerspective(this.field);
                                }
                                return this.octahedralPerspective;
                            default:
                                return null;
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {com.vzome.core.math.symmetry.QuaternionicSymmetry}
                     */
                    getQuaternionSymmetry(name) {
                        return null;
                    }
                    /**
                     *
                     * @param {*} toolFactories
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     */
                    registerToolFactories(toolFactories, tools) {
                        toolFactories.put("SymmetryTool", new com.vzome.core.tools.OctahedralToolFactory(tools, null));
                        toolFactories.put("RotationTool", new com.vzome.core.tools.RotationToolFactory(tools, null));
                        toolFactories.put("ScalingTool", new com.vzome.core.tools.ScalingToolFactory(tools, null));
                        toolFactories.put("InversionTool", new com.vzome.core.tools.InversionToolFactory(tools));
                        toolFactories.put("LineReflectionTool", new com.vzome.core.tools.LineReflectionToolFactory(tools));
                        toolFactories.put("MirrorTool", new com.vzome.core.tools.MirrorToolFactory(tools));
                        toolFactories.put("TranslationTool", new com.vzome.core.tools.TranslationToolFactory(tools));
                        toolFactories.put("ProjectionTool", new com.vzome.core.tools.ProjectionToolFactory(tools));
                        toolFactories.put("PerspectiveProjectionTool", new com.vzome.core.tools.PerspectiveProjectionToolFactory(tools));
                        toolFactories.put("BookmarkTool", new com.vzome.core.tools.BookmarkToolFactory(tools));
                        toolFactories.put("LinearTransformTool", new com.vzome.core.tools.LinearMapToolFactory(tools, null, false));
                        toolFactories.put("LinearMapTool", new com.vzome.core.tools.LinearMapToolFactory(tools, null, true));
                        toolFactories.put("ModuleTool", new com.vzome.core.tools.ModuleToolFactory(tools));
                        toolFactories.put("PlaneSelectionTool", new com.vzome.core.tools.PlaneSelectionToolFactory(tools));
                    }
                    /**
                     *
                     * @param {string} groupName
                     * @param {number} index
                     * @param {number} edgesToRender
                     * @param {com.vzome.core.algebra.AlgebraicNumber[]} edgeScales
                     * @param {*} listener
                     */
                    constructPolytope(groupName, index, edgesToRender, edgeScales, listener) {
                        let group = this.groups4d.get(groupName);
                        if (group == null) {
                            switch ((groupName)) {
                                case "A4":
                                    group = new com.vzome.core.math.symmetry.A4Group(this.field);
                                    break;
                                case "D4":
                                    group = new com.vzome.core.math.symmetry.D4Group(this.field);
                                    break;
                                case "F4":
                                    group = new com.vzome.core.math.symmetry.F4Group(this.field);
                                    break;
                                default:
                                    group = new com.vzome.core.math.symmetry.B4Group(this.field);
                                    break;
                            }
                            this.groups4d.put(groupName, group);
                        }
                        com.vzome.core.math.symmetry.WythoffConstruction.constructPolytope(group, index, edgesToRender, edgeScales, group, listener);
                    }
                    /**
                     *
                     * @param {string} action
                     * @return {*}
                     */
                    getLegacyCommand(action) {
                        switch ((action)) {
                            case "pointsymm":
                                return this.pointsymm;
                            case "mirrorsymm":
                                return this.mirrorsymm;
                            case "translate":
                                return this.translate;
                            case "centroid":
                                return this.centroid;
                            case "hideball":
                                return this.hideball;
                            case "hide":
                                return this.hide;
                            case "panel":
                                return this.panel;
                            case "midpoint":
                                return this.midpoint;
                            case "octasymm":
                                return this.getDefaultSymmetryPerspective().getLegacyCommand(action);
                            default:
                                return null;
                        }
                    }
                }
                kinds.DefaultFieldApplication = DefaultFieldApplication;
                DefaultFieldApplication["__class"] = "com.vzome.core.kinds.DefaultFieldApplication";
                DefaultFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D", "com.vzome.core.editor.FieldApplication"];
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class GitHubShare {
                    constructor(fileName, date, time, xml, png, shapesJson) {
                        if (this.designName === undefined) {
                            this.designName = null;
                        }
                        if (this.date === undefined) {
                            this.date = null;
                        }
                        if (this.time === undefined) {
                            this.time = null;
                        }
                        if (this.xml === undefined) {
                            this.xml = null;
                        }
                        if (this.png === undefined) {
                            this.png = null;
                        }
                        if (this.shapesJson === undefined) {
                            this.shapesJson = null;
                        }
                        if (this.handler === undefined) {
                            this.handler = null;
                        }
                        this.date = date;
                        this.time = time;
                        this.xml = xml;
                        this.png = png;
                        this.shapesJson = shapesJson;
                        this.designName = /* replaceAll */ fileName.trim().replace(new RegExp(" ", 'g'), "-");
                        const index = this.designName.toLowerCase().lastIndexOf(".vZome".toLowerCase());
                        if (index > 0)
                            this.designName = this.designName.substring(0, index);
                        while (( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(this.designName, "-"))) {
                            this.designName = this.designName.substring(1);
                        }
                        ;
                        while (( /* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(this.designName, "-"))) {
                            this.designName = this.designName.substring(0, this.designName.lastIndexOf('-'));
                        }
                        ;
                    }
                    getDesignName() {
                        return this.designName;
                    }
                    setEntryHandler(handler) {
                        this.handler = handler;
                    }
                    generateContent(orgName, repoName, branchName, title, description, blog, publish, style) {
                        const dateFolder = this.date.split('-').join('/');
                        const postSrcPath = "_posts/" + this.date + "-" + this.designName + "-" + this.time + ".md";
                        const postPath = dateFolder + "/" + this.designName + "-" + this.time + ".html";
                        const assetPath = dateFolder + "/" + this.time + "-" + this.designName + "/";
                        const designPath = assetPath + this.designName + ".vZome";
                        const imagePath = assetPath + this.designName + ".png";
                        this.handler.addEntry(designPath, this.xml, "utf-8");
                        this.handler.addEntry(imagePath, this.png, "base64");
                        this.handler.addEntry(assetPath + this.designName + ".shapes.json", this.shapesJson, "utf-8");
                        const viewerTemplate = com.vzome.xml.ResourceLoader.loadStringResource("com/vzome/core/exporters/github/viewerTemplate.md");
                        const instructionsTemplate = com.vzome.xml.ResourceLoader.loadStringResource("com/vzome/core/exporters/github/instructionsTemplate.md");
                        let viewerControls = "";
                        let viewerParameters = "";
                        let viewerScript = "";
                        let componentTemplate = viewerTemplate;
                        let postLayout = "vzome";
                        let simpleLayout = "design";
                        switch ((style)) {
                            case "indexed":
                                {
                                    viewerControls = "<div style=\'display:flex;\'><div style=\'margin: auto;\'><vzome-viewer-previous label=\'prev step\'></vzome-viewer-previous><vzome-viewer-next label=\'next step\'></vzome-viewer-next></div></div>";
                                    viewerParameters = "indexed=\'true\'";
                                    break;
                                }
                                ;
                            case "indexed (load-camera)":
                                {
                                    viewerControls = "<div style=\'display:flex;\'><div style=\'margin: auto;\'><vzome-viewer-previous load-camera=\'true\' label=\'prev step\'></vzome-viewer-previous><vzome-viewer-next load-camera=\'true\' label=\'next step\'></vzome-viewer-next></div></div>";
                                    viewerParameters = "indexed=\'true\'";
                                    break;
                                }
                                ;
                            case "menu":
                            case "menu (named)":
                                {
                                    viewerParameters = "show-scenes=\'named\'";
                                    break;
                                }
                                ;
                            case "menu (all)":
                                {
                                    viewerParameters = "show-scenes=\'all\'";
                                    break;
                                }
                                ;
                            case "javascript":
                                {
                                    viewerParameters = "id=\'vzome-viewer\' reactive=\'false\'";
                                    viewerScript = "<script type=\'module\'>\n  const viewer = document.querySelector( \'#vzome-viewer\' );\n  // viewer.scene = \'your scene\';\n  viewer.update();\n</script>\n";
                                    break;
                                }
                                ;
                            case "zometool":
                                {
                                    componentTemplate = instructionsTemplate;
                                    postLayout = "zometool";
                                    simpleLayout = "zometool";
                                }
                                ;
                            default:
                        }
                        const siteUrl = "https://" + orgName + ".github.io/" + repoName;
                        const repoUrl = "https://github.com/" + orgName + "/" + repoName;
                        const gitUrl = repoUrl + "/tree/" + branchName + "/" + assetPath;
                        const rawUrl = "https://raw.githubusercontent.com/" + orgName + "/" + repoName + "/" + branchName + "/" + designPath;
                        const postUrl = siteUrl + "/" + postPath;
                        const postSrcUrl = repoUrl + "/edit/" + branchName + "/" + postSrcPath;
                        const indexSrcUrl = repoUrl + "/edit/" + branchName + "/" + assetPath + "index.md";
                        const descriptionClean = description.split('\n').join(' ').split('\r').join(' ');
                        const viewerComponent = componentTemplate.split("${siteUrl}").join(siteUrl).split("${imagePath}").join(imagePath).split("${designPath}").join(designPath).split("${viewerControls}").join(viewerControls).split("${viewerParameters}").join(viewerParameters);
                        const indexTemplate = com.vzome.xml.ResourceLoader.loadStringResource("com/vzome/core/exporters/github/indexTemplate.md");
                        let indexMd = indexTemplate.split("${simpleLayout}").join(simpleLayout).split("${viewerComponent}").join(viewerComponent).split("${title}").join(title).split("${description}").join(descriptionClean).split("${siteUrl}").join(siteUrl).split("${imagePath}").join(imagePath).split("${assetsUrl}").join(gitUrl);
                        if (viewerScript !== "")
                            indexMd = indexMd + viewerScript;
                        this.handler.addEntry(assetPath + "index.md", indexMd, "utf-8");
                        const readmeTemplate = com.vzome.xml.ResourceLoader.loadStringResource("com/vzome/core/exporters/github/readmeTemplate.md");
                        let readmeMd = readmeTemplate.split("${viewerComponent}").join(viewerComponent).split("${imageFile}").join(this.designName + ".png").split("${siteUrl}").join(siteUrl).split("${assetPath}").join(assetPath).split("${imagePath}").join(imagePath).split("${viewerScript}").join(viewerScript).split("${indexSrcUrl}").join(indexSrcUrl).split("${rawUrl}").join(rawUrl);
                        if (blog) {
                            const githubReadmeBlogPrefixTemplate = com.vzome.xml.ResourceLoader.loadStringResource("com/vzome/core/exporters/github/readmeBlogPrefixTemplate.md");
                            const blogPostPrefix = githubReadmeBlogPrefixTemplate.split("${postUrl}").join(postUrl).split("${postSrcUrl}").join(postSrcUrl);
                            readmeMd = blogPostPrefix + readmeMd;
                            const postTemplate = com.vzome.xml.ResourceLoader.loadStringResource("com/vzome/core/exporters/github/postTemplate.md");
                            let postMd = postTemplate.split("${viewerComponent}").join(viewerComponent).split("${postLayout}").join(postLayout).split("${title}").join(title).split("${description}").join(descriptionClean).split("${published}").join(publish.toString()).split("${siteUrl}").join(siteUrl).split("${postPath}").join(postPath).split("${imagePath}").join(imagePath).split("${assetsUrl}").join(gitUrl);
                            if (viewerScript !== "")
                                postMd = postMd + viewerScript;
                            this.handler.addEntry(postSrcPath, postMd, "utf-8");
                        }
                        this.handler.addEntry(assetPath + "README.md", readmeMd, "utf-8");
                        return gitUrl;
                    }
                }
                exporters.GitHubShare = GitHubShare;
                GitHubShare["__class"] = "com.vzome.core.exporters.GitHubShare";
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class GeometryExporter {
                    constructor() {
                        if (this.output === undefined) {
                            this.output = null;
                        }
                        if (this.mColors === undefined) {
                            this.mColors = null;
                        }
                        if (this.mModel === undefined) {
                            this.mModel = null;
                        }
                    }
                    getContentType() {
                        return "text/plain";
                    }
                    /**
                     * Subclasses can override this if they don't rely on Manifestations and therefore can operate on article pages
                     * See the comments below DocumentModel.getNaiveExporter() for a more complete explanation.
                     * @return {boolean}
                     */
                    needsManifestations() {
                        return true;
                    }
                    getBoilerplate(resourcePath) {
                        return com.vzome.xml.ResourceLoader.loadStringResource(resourcePath);
                    }
                    exportGeometry(model, file, writer, height, width) {
                        this.mModel = model;
                        this.doExport(file, writer, height, width);
                        this.mModel = null;
                    }
                }
                exporters.GeometryExporter = GeometryExporter;
                GeometryExporter["__class"] = "com.vzome.core.exporters.GeometryExporter";
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var render;
            (function (render) {
                class Colors {
                    constructor(props) {
                        this.mColors = (new java.util.TreeMap());
                        this.mListeners = (new java.util.ArrayList());
                        if (this.properties === undefined) {
                            this.properties = null;
                        }
                        this.mNextNewColor = 3221;
                        this.STEP = 73;
                        this.properties = props;
                    }
                    static BACKGROUND_$LI$() { if (Colors.BACKGROUND == null) {
                        Colors.BACKGROUND = Colors.PREFIX + "background";
                    } return Colors.BACKGROUND; }
                    static PANEL_$LI$() { if (Colors.PANEL == null) {
                        Colors.PANEL = Colors.PREFIX + "panel";
                    } return Colors.PANEL; }
                    static HIGHLIGHT_$LI$() { if (Colors.HIGHLIGHT == null) {
                        Colors.HIGHLIGHT = Colors.PREFIX + "highlight";
                    } return Colors.HIGHLIGHT; }
                    static HIGHLIGHT_MAC_$LI$() { if (Colors.HIGHLIGHT_MAC == null) {
                        Colors.HIGHLIGHT_MAC = Colors.HIGHLIGHT_$LI$() + ".mac";
                    } return Colors.HIGHLIGHT_MAC; }
                    static CONNECTOR_$LI$() { if (Colors.CONNECTOR == null) {
                        Colors.CONNECTOR = Colors.PREFIX + "connector";
                    } return Colors.CONNECTOR; }
                    static DIRECTION_$LI$() { if (Colors.DIRECTION == null) {
                        Colors.DIRECTION = Colors.PREFIX + "direction.";
                    } return Colors.DIRECTION; }
                    static PLANE_$LI$() { if (Colors.PLANE == null) {
                        Colors.PLANE = Colors.DIRECTION_$LI$() + "plane.";
                    } return Colors.PLANE; }
                    addColor(name, color) {
                        this.mColors.put(name, color);
                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                            let next = index.next();
                            {
                                next.colorAdded(name, color);
                            }
                        }
                    }
                    setColor(name, color) {
                        this.mColors.put(name, color);
                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                            let next = index.next();
                            {
                                next.colorChanged(name, color);
                            }
                        }
                    }
                    addListener(changes) {
                        this.mListeners.add(changes);
                    }
                    removeListener(changes) {
                        this.mListeners.remove(changes);
                    }
                    static NO_VECTOR_$LI$() { if (Colors.NO_VECTOR == null) {
                        Colors.NO_VECTOR = [0.0, 0.0, 0.0];
                    } return Colors.NO_VECTOR; }
                    getVectorPref(name) {
                        let result = Colors.NO_VECTOR_$LI$();
                        const pref = this.properties.getProperty(name);
                        if (pref == null || (pref === ("")))
                            return result;
                        result = /* clone */ ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(result);
                        const tokens = new java.util.StringTokenizer(pref, ", ");
                        let i = 0;
                        while ((tokens.hasMoreTokens())) {
                            result[i++] = javaemul.internal.FloatHelper.parseFloat(tokens.nextToken());
                        }
                        ;
                        return result;
                    }
                    getColorPref(name) {
                        const percents = this.getVectorPref("color.percent." + name);
                        if (percents !== Colors.NO_VECTOR_$LI$()) {
                            return new com.vzome.core.construction.Color(Math.round(Math.fround(Math.fround(percents[0] * 255) / 100)), Math.round(Math.fround(Math.fround(percents[1] * 255) / 100)), Math.round(Math.fround(Math.fround(percents[2] * 255) / 100)));
                        }
                        const pref = this.properties.getProperty("color." + name);
                        return Colors.parseColor(pref);
                    }
                    static parseColor(colorString) {
                        if (colorString == null || (colorString === ("")))
                            return com.vzome.core.construction.Color.WHITE_$LI$();
                        const tokens = new java.util.StringTokenizer(colorString, ", ");
                        const rgb = [0, 0, 0];
                        let i = 0;
                        while ((tokens.hasMoreTokens())) {
                            rgb[i++] = javaemul.internal.IntegerHelper.parseInt(tokens.nextToken());
                        }
                        ;
                        return new com.vzome.core.construction.Color(rgb[0], rgb[1], rgb[2]);
                    }
                    static getColorName(color) {
                        return Colors.RGB_ORBIT + " " + color.getRed() + " " + color.getGreen() + " " + color.getBlue();
                    }
                    getColor(name) {
                        let color = this.mColors.get(name);
                        if (color == null) {
                            if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, Colors.DIRECTION_$LI$())) {
                                const prefName = name.substring(Colors.DIRECTION_$LI$().length);
                                color = this.getColorPref(prefName);
                            }
                            else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, Colors.PLANE_$LI$())) {
                                const prefName = name.substring(Colors.PLANE_$LI$().length);
                                color = this.getColorPref(prefName);
                                color = color.getPastel();
                            }
                            else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, Colors.RGB_ORBIT) || /* startsWith */ ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, Colors.RGB_CUSTOM)) {
                                const tokens = new java.util.StringTokenizer(name);
                                tokens.nextToken();
                                const r = javaemul.internal.IntegerHelper.parseInt(tokens.nextToken());
                                const g = javaemul.internal.IntegerHelper.parseInt(tokens.nextToken());
                                const b = javaemul.internal.IntegerHelper.parseInt(tokens.nextToken());
                                color = new com.vzome.core.construction.Color(r, g, b);
                            }
                            else if (name === Colors.CONNECTOR_$LI$())
                                color = this.getColorPref("white");
                            else if (name === Colors.HIGHLIGHT_$LI$())
                                color = this.getColorPref("highlight");
                            else if (name === Colors.HIGHLIGHT_MAC_$LI$())
                                color = this.getColorPref("highlight.mac");
                            else if (name === Colors.PANEL_$LI$())
                                color = this.getColorPref("panels");
                            else if (name === Colors.BACKGROUND_$LI$())
                                color = this.getColorPref("background");
                            if (color == null) {
                                this.mNextNewColor = (this.mNextNewColor + this.STEP) % 4096;
                                let i = this.mNextNewColor;
                                const r = 135 + ((i % 16) << 3);
                                i = i >> 4;
                                const g = 135 + ((i % 16) << 3);
                                i = i >> 4;
                                const b = 135 + ((i % 16) << 3);
                                i = i >> 4;
                                color = new com.vzome.core.construction.Color(r, g, b);
                            }
                            this.addColor(name, color);
                        }
                        return color;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    iterator() {
                        return this.mColors.keySet().iterator();
                    }
                    reset() {
                    }
                }
                Colors.RGB_CUSTOM = "rgb.custom";
                Colors.RGB_ORBIT = "rgb.orbit";
                Colors.PREFIX = "";
                render.Colors = Colors;
                Colors["__class"] = "com.vzome.core.render.Colors";
                Colors["__interfaces"] = ["java.lang.Iterable"];
            })(render = core.render || (core.render = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var render;
            (function (render) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} m
                 * @param {*} orbitSource
                 * @class
                 */
                class RenderedManifestation {
                    constructor(m, orbitSource) {
                        if (this.mManifestation === undefined) {
                            this.mManifestation = null;
                        }
                        if (this.mShape === undefined) {
                            this.mShape = null;
                        }
                        this.color = null;
                        if (this.mOrientation === undefined) {
                            this.mOrientation = null;
                        }
                        this.mGlow = 0.0;
                        this.mTransparency = 0.0;
                        if (this.mGraphicsObject === undefined) {
                            this.mGraphicsObject = null;
                        }
                        this.mPickable = true;
                        this.isOffset = false;
                        if (this.location === undefined) {
                            this.location = null;
                        }
                        if (this.fixedLocation === undefined) {
                            this.fixedLocation = null;
                        }
                        this.strutZone = -1;
                        this.strutLength = null;
                        this.strutOrbit = null;
                        if (this.strutSense === undefined) {
                            this.strutSense = 0;
                        }
                        this.guid = java.util.UUID.randomUUID();
                        if (this.orbitSource === undefined) {
                            this.orbitSource = null;
                        }
                        if (this.label === undefined) {
                            this.label = null;
                        }
                        this.mManifestation = m;
                        this.orbitSource = orbitSource;
                        if (m != null)
                            this.location = m.getLocation();
                        this.fixedLocation = this.location;
                        this.mOrientation = null;
                    }
                    static logger_$LI$() { if (RenderedManifestation.logger == null) {
                        RenderedManifestation.logger = java.util.logging.Logger.getLogger("com.vzome.core.render.RenderedManifestation");
                    } return RenderedManifestation.logger; }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return this.mManifestation.toString();
                    }
                    getGuid() {
                        return this.guid;
                    }
                    setGraphicsObject(go) {
                        this.mGraphicsObject = go;
                    }
                    getGraphicsObject() {
                        return this.mGraphicsObject;
                    }
                    setGlow(glow) {
                        this.mGlow = glow;
                    }
                    getGlow() {
                        return this.mGlow;
                    }
                    setTransparency(trans) {
                        this.mTransparency = trans;
                    }
                    getTransparency() {
                        return this.mTransparency;
                    }
                    getShapeId() {
                        return this.mShape.getGuid();
                    }
                    getShape() {
                        return this.mShape;
                    }
                    setPickable(value) {
                        this.mPickable = value;
                    }
                    isPickable() {
                        return this.mPickable;
                    }
                    getManifestation() {
                        return this.mManifestation;
                    }
                    getColor() {
                        return this.color;
                    }
                    getColorWeb() {
                        return this.color.toWebString();
                    }
                    setColor(color) {
                        this.color = color;
                    }
                    setOrientation(m) {
                        this.mOrientation = m;
                    }
                    getOrientation() {
                        return this.mOrientation;
                    }
                    getLocation() {
                        if (this.location != null)
                            return this.getEmbedding().embedInR3(this.location);
                        else
                            return new com.vzome.core.math.RealVector(0.0, 0.0, 0.0);
                    }
                    getLocationAV() {
                        return this.location;
                    }
                    getEmbedding() {
                        return this.orbitSource.getSymmetry();
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        return /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.guid);
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj) {
                            return true;
                        }
                        if (obj == null) {
                            return false;
                        }
                        if (this.constructor !== obj.constructor) {
                            return false;
                        }
                        const other = obj;
                        if (this.fixedLocation == null) {
                            if (other.fixedLocation != null) {
                                return false;
                            }
                        }
                        else if (!this.fixedLocation.equals(other.fixedLocation)) {
                            return false;
                        }
                        if (this.isOffset !== other.isOffset) {
                            return false;
                        }
                        if (this.mOrientation == null) {
                            if (other.mOrientation != null) {
                                return false;
                            }
                        }
                        else if (!this.mOrientation.equals(other.mOrientation)) {
                            return false;
                        }
                        if (this.mShape == null) {
                            if (other.mShape != null) {
                                return false;
                            }
                        }
                        else if (!this.mShape.equals(other.mShape)) {
                            return false;
                        }
                        if (this.strutSense !== other.strutSense) {
                            return false;
                        }
                        return true;
                    }
                    copy() {
                        const copy = new RenderedManifestation(null, this.orbitSource);
                        copy.location = this.location;
                        copy.fixedLocation = this.fixedLocation;
                        copy.color = this.color;
                        copy.mGlow = this.mGlow;
                        copy.mOrientation = this.mOrientation;
                        copy.mShape = this.mShape;
                        copy.mTransparency = this.mTransparency;
                        copy.strutLength = this.strutLength;
                        copy.strutZone = this.strutZone;
                        copy.label = this.label;
                        return copy;
                    }
                    setStrut(orbit, zone, sense, length) {
                        this.strutOrbit = orbit;
                        this.strutZone = zone;
                        this.strutSense = sense;
                        this.strutLength = length;
                    }
                    getStrutZone() {
                        return this.strutZone;
                    }
                    getStrutSense() {
                        return this.strutSense;
                    }
                    getStrutLength() {
                        return this.strutLength;
                    }
                    getStrutOrbit() {
                        return this.strutOrbit;
                    }
                    offsetLocation() {
                        if (this.mManifestation != null) {
                            const strut = this.mManifestation;
                            this.location = strut.getEnd();
                            this.isOffset = true;
                        }
                    }
                    resetLocation() {
                        if (this.mManifestation != null) {
                            this.location = this.mManifestation.getLocation();
                            this.isOffset = false;
                        }
                    }
                    getSymmetryShapes() {
                        return this.orbitSource.getName() + ":" + this.orbitSource.getShapes().getName();
                    }
                    resetAttributes(oneSidedPanels, colorPanels) {
                        const label = this.mManifestation.getLabel();
                        if (null != label) {
                            this.setLabel(label);
                        }
                        if (this.mManifestation != null && (this.mManifestation.constructor != null && this.mManifestation.constructor["__interfaces"] != null && this.mManifestation.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                            this.resetPanelAttributes(oneSidedPanels, colorPanels);
                        }
                        else if (this.orbitSource.getShapes() == null) {
                            return;
                        }
                        else if (this.mManifestation != null && (this.mManifestation.constructor != null && this.mManifestation.constructor["__interfaces"] != null && this.mManifestation.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                            this.resetConnectorAttributes(this.mManifestation);
                        }
                        else if (this.mManifestation != null && (this.mManifestation.constructor != null && this.mManifestation.constructor["__interfaces"] != null && this.mManifestation.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                            const strut = this.mManifestation;
                            this.resetStrutAttributes(strut);
                        }
                        else
                            throw new java.lang.UnsupportedOperationException("only strut, ball, and panel shapes currently supported");
                    }
                    /*private*/ resetPanelAttributes(oneSidedPanels, colorPanels) {
                        const shapes = this.orbitSource.getShapes();
                        const panel = this.mManifestation;
                        this.location = panel.getFirstVertex();
                        const relativeVertices = (new java.util.ArrayList());
                        for (let index = panel.iterator(); index.hasNext();) {
                            let vertex = index.next();
                            {
                                relativeVertices.add(vertex.minus(this.location));
                            }
                        }
                        const normal = panel['getNormal$']();
                        if (normal.isOrigin())
                            return;
                        const zone = this.orbitSource.getAxis(normal);
                        const shape = shapes.getPanelShape(panel.getVertexCount(), panel.getQuadrea(), zone, relativeVertices, oneSidedPanels);
                        if (shape == null)
                            return;
                        this.mShape = shape;
                        if (zone == null) {
                            this.setColor(com.vzome.core.construction.Color.WHITE_$LI$());
                            return;
                        }
                        const orn = zone.getOrientation();
                        const orientation = shapes.getSymmetry().getMatrix(orn);
                        this.setOrientation(orientation);
                        this.strutZone = zone.getOrientation();
                        if (!colorPanels)
                            return;
                        try {
                            panel.setZoneVector(zone.normal());
                            const orbit = zone.getDirection();
                            let color = this.mManifestation.getColor();
                            if (color == null) {
                                color = this.orbitSource.getColor(orbit);
                                if (color != null)
                                    color = color.getPastel();
                            }
                            this.setColor(color);
                        }
                        catch (e) {
                            if (RenderedManifestation.logger_$LI$().isLoggable(java.util.logging.Level.WARNING))
                                RenderedManifestation.logger_$LI$().warning("Unable to set color for panel, normal = " + normal.toString());
                        }
                    }
                    resetStrutAttributes(strut) {
                        const shapes = this.orbitSource.getShapes();
                        const offset = strut.getOffset();
                        if (offset.isOrigin())
                            return;
                        const axis = this.orbitSource.getAxis(offset);
                        if (axis == null)
                            return;
                        strut.setZoneVector(axis.normal());
                        const orbit = axis.getDirection();
                        const len = axis.getLength(offset);
                        const prototypeLengthShape = shapes.getStrutShape(orbit, len);
                        if (prototypeLengthShape == null)
                            return;
                        this.mShape = prototypeLengthShape;
                        const orn = axis.getOrientation();
                        const orientation = shapes.getSymmetry().getMatrix(orn);
                        const reflection = this.orbitSource.getSymmetry().getPrincipalReflection();
                        if (reflection != null) {
                            if (RenderedManifestation.logger_$LI$().isLoggable(java.util.logging.Level.FINE)) {
                                RenderedManifestation.logger_$LI$().fine("rendering " + offset + " as " + axis);
                            }
                            if (axis.getSense() === com.vzome.core.math.symmetry.Axis.MINUS) {
                                if (RenderedManifestation.logger_$LI$().isLoggable(java.util.logging.Level.FINER)) {
                                    RenderedManifestation.logger_$LI$().finer("mirroring orientation " + orn);
                                }
                                this.mShape = prototypeLengthShape.getEvilTwin(reflection);
                            }
                            if (!axis.isOutbound()) {
                                this.offsetLocation();
                            }
                            else
                                this.resetLocation();
                        }
                        else {
                            if (axis.getSense() === com.vzome.core.math.symmetry.Axis.MINUS) {
                                this.offsetLocation();
                            }
                            else
                                this.resetLocation();
                        }
                        this.setStrut(orbit, orn, axis.getSense(), len);
                        this.setOrientation(orientation);
                        let color = this.getManifestation().getColor();
                        if (color == null)
                            color = shapes.getColor(orbit);
                        if (color == null)
                            color = this.orbitSource.getColor(orbit);
                        this.setColor(color);
                    }
                    resetConnectorAttributes(m) {
                        const shapes = this.orbitSource.getShapes();
                        this.mShape = shapes.getConnectorShape();
                        let color = this.getManifestation().getColor();
                        if (color == null)
                            color = shapes.getColor(null);
                        if (color == null)
                            color = this.orbitSource.getColor(null);
                        this.setColor(color);
                        this.setOrientation(this.orbitSource.getSymmetry().getField().identityMatrix(3));
                    }
                    setOrbitSource(orbitSource) {
                        this.orbitSource = orbitSource;
                    }
                    getOrbitSource() {
                        return this.orbitSource;
                    }
                    getLabel() {
                        return this.label;
                    }
                    setLabel(label) {
                        this.label = label;
                    }
                }
                render.RenderedManifestation = RenderedManifestation;
                RenderedManifestation["__class"] = "com.vzome.core.render.RenderedManifestation";
                RenderedManifestation["__interfaces"] = ["com.vzome.core.model.RenderedObject"];
            })(render = core.render || (core.render = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var render;
            (function (render) {
                let ZomicEventHandler;
                (function (ZomicEventHandler) {
                    /**
                     * Constants for use with save();
                     */
                    ZomicEventHandler.ALL = 15;
                    /**
                     * Constants for use with save();
                     */
                    ZomicEventHandler.LOCATION = 1;
                    /**
                     * Constants for use with save();
                     */
                    ZomicEventHandler.SCALE = 2;
                    /**
                     * Constants for use with save();
                     */
                    ZomicEventHandler.ORIENTATION = 4;
                    /**
                     * Constants for use with save();
                     */
                    ZomicEventHandler.ACTION = 8;
                    /**
                     * Constants for use with action().
                     */
                    ZomicEventHandler.JUST_MOVE = 0;
                    /**
                     * Constants for use with action().
                     */
                    ZomicEventHandler.BUILD = 1;
                    /**
                     * Constants for use with action().
                     */
                    ZomicEventHandler.DESTROY = 2;
                })(ZomicEventHandler = render.ZomicEventHandler || (render.ZomicEventHandler = {}));
            })(render = core.render || (core.render = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var render;
            (function (render) {
                class RenderedModel {
                    constructor(field, orbitSource) {
                        if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((orbitSource != null && (orbitSource.constructor != null && orbitSource.constructor["__interfaces"] != null && orbitSource.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.OrbitSource") >= 0)) || orbitSource === null)) {
                            let __args = arguments;
                            if (this.mPolyhedra === undefined) {
                                this.mPolyhedra = null;
                            }
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            if (this.orbitSource === undefined) {
                                this.orbitSource = null;
                            }
                            if (this.mainListener === undefined) {
                                this.mainListener = null;
                            }
                            this.mListeners = (new java.util.ArrayList());
                            this.mSelectionGlow = 0.8;
                            this.mRendered = (new java.util.HashSet());
                            this.byID = (new java.util.HashMap());
                            this.oneSidedPanels = false;
                            this.enabled = true;
                            this.colorPanels = true;
                            this.field = field;
                            this.orbitSource = orbitSource;
                            this.mPolyhedra = (orbitSource == null) ? null : orbitSource.getShapes();
                        }
                        else if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || field === null) && orbitSource === undefined) {
                            let __args = arguments;
                            let symmetry = __args[0];
                            {
                                let __args = arguments;
                                let field = symmetry.getField();
                                let orbitSource = new RenderedModel.SymmetryOrbitSource(symmetry);
                                if (this.mPolyhedra === undefined) {
                                    this.mPolyhedra = null;
                                }
                                if (this.field === undefined) {
                                    this.field = null;
                                }
                                if (this.orbitSource === undefined) {
                                    this.orbitSource = null;
                                }
                                if (this.mainListener === undefined) {
                                    this.mainListener = null;
                                }
                                this.mListeners = (new java.util.ArrayList());
                                this.mSelectionGlow = 0.8;
                                this.mRendered = (new java.util.HashSet());
                                this.byID = (new java.util.HashMap());
                                this.oneSidedPanels = false;
                                this.enabled = true;
                                this.colorPanels = true;
                                this.field = field;
                                this.orbitSource = orbitSource;
                                this.mPolyhedra = (orbitSource == null) ? null : orbitSource.getShapes();
                            }
                            (() => {
                                this.enabled = false;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    withColorPanels(setting) {
                        this.colorPanels = setting;
                        return this;
                    }
                    getField() {
                        return this.field;
                    }
                    addListener(listener) {
                        if (this.mainListener == null)
                            this.mainListener = listener;
                        else
                            this.mListeners.add(listener);
                    }
                    removeListener(listener) {
                        if (this.mainListener === listener)
                            this.mainListener = null;
                        else
                            this.mListeners.remove(listener);
                    }
                    render(manifestation) {
                        const rm = new com.vzome.core.render.RenderedManifestation(manifestation, this.orbitSource);
                        rm.resetAttributes(this.oneSidedPanels, this.colorPanels);
                        return rm;
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    manifestationAdded(m) {
                        if (!this.enabled) {
                            m.setRenderedObject(new com.vzome.core.render.RenderedManifestation(m, this.orbitSource));
                            return;
                        }
                        const rm = this.render(m);
                        const poly = rm.getShape();
                        if (poly == null)
                            return;
                        m.setRenderedObject(rm);
                        this.mRendered.add(rm);
                        this.byID.put(rm.getGuid().toString(), rm);
                        if (this.mainListener != null)
                            this.mainListener.manifestationAdded(rm);
                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                            let listener = index.next();
                            {
                                listener.manifestationAdded(rm);
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    manifestationRemoved(m) {
                        if (!this.enabled) {
                            m.setRenderedObject(null);
                            return;
                        }
                        const rendered = m.getRenderedObject();
                        if (rendered == null)
                            return;
                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                            let listener = index.next();
                            {
                                listener.manifestationRemoved(rendered);
                            }
                        }
                        if (this.mainListener != null)
                            this.mainListener.manifestationRemoved(rendered);
                        if (!this.mRendered.remove(rendered))
                            throw new java.lang.IllegalStateException("unable to remove RenderedManifestation");
                        this.byID.remove(rendered.getGuid().toString());
                        m.setRenderedObject(null);
                    }
                    getRenderedManifestation(guid) {
                        return this.byID.get(guid);
                    }
                    setManifestationGlow(m, on) {
                        const rendered = m.getRenderedObject();
                        if (rendered == null)
                            return;
                        rendered.setGlow(on ? this.mSelectionGlow : 0.0);
                        if (this.mainListener != null)
                            this.mainListener.glowChanged(rendered);
                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                            let listener = index.next();
                            {
                                listener.glowChanged(rendered);
                            }
                        }
                    }
                    setManifestationColor(m, color) {
                        const rendered = m.getRenderedObject();
                        if (rendered == null)
                            return;
                        rendered.setColor(color);
                        if (this.mainListener != null)
                            this.mainListener.colorChanged(rendered);
                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                            let listener = index.next();
                            {
                                listener.colorChanged(rendered);
                            }
                        }
                    }
                    setManifestationLabel(m, label) {
                        const rendered = m.getRenderedObject();
                        if (rendered == null)
                            return;
                        rendered.setLabel(label);
                        if (this.mainListener != null)
                            this.mainListener.labelChanged(rendered);
                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                            let listener = index.next();
                            {
                                listener.labelChanged(rendered);
                            }
                        }
                    }
                    setManifestationTransparency(m, on) {
                        const rendered = m.getRenderedObject();
                        if (rendered == null)
                            return;
                        rendered.setTransparency(on ? this.mSelectionGlow : 0.0);
                        if (this.mainListener != null)
                            this.mainListener.colorChanged(rendered);
                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                            let listener = index.next();
                            {
                                listener.colorChanged(rendered);
                            }
                        }
                    }
                    /**
                     *
                     * @return {*}
                     */
                    iterator() {
                        return this.mRendered.iterator();
                    }
                    getOrbitSource() {
                        return this.orbitSource;
                    }
                    setShapes(shapes) {
                        const supported = this.mainListener.shapesChanged(shapes);
                        if (!supported)
                            this.setOrbitSource(this.orbitSource);
                    }
                    setOrbitSource(orbitSource) {
                        this.orbitSource = orbitSource;
                        this.enabled = true;
                        this.mPolyhedra = orbitSource.getShapes();
                        if (this.mPolyhedra == null)
                            return;
                        {
                            const newSet = (new java.util.HashSet());
                            for (const rms = this.mRendered.iterator(); rms.hasNext();) {
                                {
                                    const rendered = rms.next();
                                    rms.remove();
                                    const m = rendered.getManifestation();
                                    if (m.isHidden())
                                        continue;
                                    if (rendered.getShape() != null) {
                                        if (this.mainListener != null) {
                                            this.mainListener.manifestationRemoved(rendered);
                                        }
                                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                                            let listener = index.next();
                                            {
                                                listener.manifestationRemoved(rendered);
                                            }
                                        }
                                    }
                                    rendered.setOrbitSource(this.orbitSource);
                                    rendered.resetAttributes(this.oneSidedPanels, this.colorPanels);
                                    newSet.add(rendered);
                                    const glow = rendered.getGlow();
                                    if (rendered.getShape() != null) {
                                        if (this.mainListener != null) {
                                            this.mainListener.manifestationAdded(rendered);
                                            if (glow !== 0.0)
                                                this.mainListener.glowChanged(rendered);
                                        }
                                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                                            let listener = index.next();
                                            {
                                                listener.manifestationAdded(rendered);
                                                if (glow !== 0.0)
                                                    listener.glowChanged(rendered);
                                            }
                                        }
                                    }
                                }
                                ;
                            }
                            this.mRendered.addAll(newSet);
                            for (let index = newSet.iterator(); index.hasNext();) {
                                let rm = index.next();
                                {
                                    this.byID.put(rm.getGuid().toString(), rm);
                                }
                            }
                        }
                        ;
                    }
                    /**
                     *
                     * @param {*} m
                     * @param {com.vzome.core.construction.Color} color
                     */
                    manifestationColored(m, color) {
                        if (this.enabled)
                            this.setManifestationColor(m, color);
                    }
                    /**
                     *
                     * @param {*} m
                     * @param {string} label
                     */
                    manifestationLabeled(m, label) {
                        if (this.enabled)
                            this.setManifestationLabel(m, label);
                    }
                    snapshot() {
                        const snapshot = new RenderedModel(this.orbitSource.getSymmetry());
                        for (let index = this.mRendered.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const copy = rm.copy();
                                snapshot.mRendered.add(copy);
                            }
                        }
                        return snapshot;
                    }
                    /**
                     * Switch a scene graph (changes) from rendering one RenderedModel to another one.
                     * For RenderedManifestations that show the same object in both, just update the
                     * attributes.
                     * When "from" is empty, this is the initial rendering of the "to" RenderedModel.
                     * @param {com.vzome.core.render.RenderedModel} from is an empty RenderedModel in some cases
                     * @param {com.vzome.core.render.RenderedModel} to
                     * @param {*} changes is a scene graph
                     */
                    static renderChange(from, to, changes) {
                        const toRemove = (new java.util.HashSet(from.mRendered));
                        toRemove.removeAll(to.mRendered);
                        for (let index = toRemove.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                changes.manifestationRemoved(rm);
                            }
                        }
                        const toAdd = (new java.util.HashSet(to.mRendered));
                        toAdd.removeAll(from.mRendered);
                        for (let index = toAdd.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                changes.manifestationAdded(rm);
                            }
                        }
                        for (let index = from.mRendered.iterator(); index.hasNext();) {
                            let fromRm = index.next();
                            {
                                for (let index = to.mRendered.iterator(); index.hasNext();) {
                                    let toRm = index.next();
                                    {
                                        if (fromRm.equals(toRm)) {
                                            changes.manifestationSwitched(fromRm, toRm);
                                            if (javaemul.internal.FloatHelper.floatToIntBits(fromRm.getGlow()) !== javaemul.internal.FloatHelper.floatToIntBits(toRm.getGlow()))
                                                changes.glowChanged(toRm);
                                            const fromColor = fromRm.getColor();
                                            const toColor = toRm.getColor();
                                            if (fromColor == null && toColor == null)
                                                continue;
                                            if ((fromColor == null && toColor != null) || (fromColor != null && toColor == null) || !fromColor.equals(toColor))
                                                changes.colorChanged(toRm);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    renderVector(av) {
                        if (av != null)
                            return this.getEmbedding().embedInR3(av);
                        else
                            return new com.vzome.core.math.RealVector(0.0, 0.0, 0.0);
                    }
                    renderVectorDouble(av) {
                        if (av != null)
                            return this.getEmbedding().embedInR3Double(av);
                        else
                            return [0.0, 0.0, 0.0];
                    }
                    getEmbedding() {
                        return this.orbitSource.getSymmetry();
                    }
                    measureDistanceCm(c1, c2) {
                        return this.measureLengthCm$com_vzome_core_math_RealVector(this.renderVector(c1.getLocation().minus(c2.getLocation())));
                    }
                    getCmScaling() {
                        return this.mPolyhedra.getCmScaling();
                    }
                    measureLengthCm$com_vzome_core_math_RealVector(rv) {
                        return rv.length() * this.mPolyhedra.getCmScaling();
                    }
                    measureLengthCm(rv) {
                        if (((rv != null && rv instanceof com.vzome.core.math.RealVector) || rv === null)) {
                            return this.measureLengthCm$com_vzome_core_math_RealVector(rv);
                        }
                        else if (((rv != null && (rv.constructor != null && rv.constructor["__interfaces"] != null && rv.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || rv === null)) {
                            return this.measureLengthCm$com_vzome_core_model_Strut(rv);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    measureLengthCm$com_vzome_core_model_Strut(strut) {
                        return this.measureLengthCm$com_vzome_core_math_RealVector(this.renderVector(strut.getOffset()));
                    }
                    measureDihedralAngle(p1, p2) {
                        const v1 = p1['getNormal$com_vzome_core_math_symmetry_Embedding'](this.getEmbedding());
                        const v2 = p2['getNormal$com_vzome_core_math_symmetry_Embedding'](this.getEmbedding());
                        return RenderedModel.safeAcos(v1, v2);
                    }
                    measureAngle(s1, s2) {
                        const v1 = this.renderVector(s1.getOffset());
                        const v2 = this.renderVector(s2.getOffset());
                        return RenderedModel.safeAcos(v1, v2);
                    }
                    static safeAcos(v1, v2) {
                        let cosine = v1.dot(v2) / (v1.length() * v2.length());
                        cosine = Math.min(1.0, cosine);
                        cosine = Math.max(-1.0, cosine);
                        return Math.acos(cosine);
                    }
                    getNearbyBall(location, tolerance) {
                        for (let index = this.mRendered.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                if (rm.getManifestation() != null && (rm.getManifestation().constructor != null && rm.getManifestation().constructor["__interfaces"] != null && rm.getManifestation().constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    const ballLoc = rm.getLocation();
                                    const distance = ballLoc.minus(location).length();
                                    if (distance < tolerance)
                                        return rm;
                                }
                            }
                        }
                        return null;
                    }
                    getManifestations() {
                        return (this.mRendered.stream().map((rm) => rm.getManifestation()).collect(java.util.stream.Collectors.toList()));
                    }
                }
                render.RenderedModel = RenderedModel;
                RenderedModel["__class"] = "com.vzome.core.render.RenderedModel";
                RenderedModel["__interfaces"] = ["com.vzome.core.model.ManifestationChanges", "java.lang.Iterable"];
                (function (RenderedModel) {
                    class SymmetryOrbitSource {
                        constructor(symmetry) {
                            if (this.symmetry === undefined) {
                                this.symmetry = null;
                            }
                            if (this.orbits === undefined) {
                                this.orbits = null;
                            }
                            this.symmetry = symmetry;
                            this.orbits = new com.vzome.core.math.symmetry.OrbitSet(symmetry);
                        }
                        /* Default method injected from com.vzome.core.editor.api.OrbitSource */
                        getOrientations$() {
                            return this.getOrientations(false);
                        }
                        /* Default method injected from com.vzome.core.editor.api.OrbitSource */
                        getEmbedding() {
                            const symmetry = this.getSymmetry();
                            const field = symmetry.getField();
                            const embedding = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(16);
                            for (let i = 0; i < 3; i++) {
                                {
                                    const columnSelect = field.basisVector(3, i);
                                    const colRV = symmetry.embedInR3(columnSelect);
                                    embedding[i * 4 + 0] = colRV.x;
                                    embedding[i * 4 + 1] = colRV.y;
                                    embedding[i * 4 + 2] = colRV.z;
                                    embedding[i * 4 + 3] = 0.0;
                                }
                                ;
                            }
                            embedding[12] = 0.0;
                            embedding[13] = 0.0;
                            embedding[14] = 0.0;
                            embedding[15] = 1.0;
                            return embedding;
                        }
                        /* Default method injected from com.vzome.core.editor.api.OrbitSource */
                        getZone(orbit, orientation) {
                            return this.getSymmetry().getDirection(orbit).getAxis(com.vzome.core.math.symmetry.Symmetry.PLUS, orientation);
                        }
                        /* Default method injected from com.vzome.core.editor.api.OrbitSource */
                        getOrientations(rowMajor) {
                            if (((typeof rowMajor === 'boolean') || rowMajor === null)) {
                                let __args = arguments;
                                if (this.symmetry === undefined) {
                                    this.symmetry = null;
                                }
                                if (this.orbits === undefined) {
                                    this.orbits = null;
                                }
                                return (() => {
                                    const symmetry = this.getSymmetry();
                                    const field = symmetry.getField();
                                    const order = symmetry.getChiralOrder();
                                    const orientations = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(order);
                                    for (let orientation = 0; orientation < order; orientation++) {
                                        {
                                            if (rowMajor) {
                                                orientations[orientation] = symmetry.getMatrix(orientation).getRowMajorRealElements();
                                                continue;
                                            }
                                            const asFloats = (s => { let a = []; while (s-- > 0)
                                                a.push(0); return a; })(16);
                                            const transform = symmetry.getMatrix(orientation);
                                            for (let i = 0; i < 3; i++) {
                                                {
                                                    const columnSelect = field.basisVector(3, i);
                                                    const columnI = transform.timesColumn(columnSelect);
                                                    const colRV = columnI.toRealVector();
                                                    asFloats[i * 4 + 0] = colRV.x;
                                                    asFloats[i * 4 + 1] = colRV.y;
                                                    asFloats[i * 4 + 2] = colRV.z;
                                                    asFloats[i * 4 + 3] = 0.0;
                                                }
                                                ;
                                            }
                                            asFloats[12] = 0.0;
                                            asFloats[13] = 0.0;
                                            asFloats[14] = 0.0;
                                            asFloats[15] = 1.0;
                                            orientations[orientation] = asFloats;
                                        }
                                        ;
                                    }
                                    return orientations;
                                })();
                            }
                            else if (rowMajor === undefined) {
                                return this.getOrientations$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.Direction} orbit
                         * @return {com.vzome.core.construction.Color}
                         */
                        getColor(orbit) {
                            return new com.vzome.core.construction.Color(128, 123, 128);
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getAxis(vector) {
                            return this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
                        }
                        /**
                         *
                         * @return {com.vzome.core.math.symmetry.OrbitSet}
                         */
                        getOrbits() {
                            return this.orbits;
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getShapes() {
                            return null;
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getSymmetry() {
                            return this.symmetry;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @return {com.vzome.core.construction.Color}
                         */
                        getVectorColor(vector) {
                            return null;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return null;
                        }
                    }
                    RenderedModel.SymmetryOrbitSource = SymmetryOrbitSource;
                    SymmetryOrbitSource["__class"] = "com.vzome.core.render.RenderedModel.SymmetryOrbitSource";
                    SymmetryOrbitSource["__interfaces"] = ["com.vzome.core.editor.api.OrbitSource"];
                })(RenderedModel = render.RenderedModel || (render.RenderedModel = {}));
            })(render = core.render || (core.render = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var render;
            (function (render) {
                class TransparentRendering {
                    constructor(realOne) {
                        if (this.mRealOne === undefined) {
                            this.mRealOne = null;
                        }
                        this.mRealOne = realOne;
                    }
                    /**
                     *
                     */
                    reset() {
                        this.mRealOne.reset();
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    manifestationAdded(manifestation) {
                        manifestation.setTransparency(0.5);
                        manifestation.setPickable(false);
                        this.mRealOne.manifestationAdded(manifestation);
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    manifestationRemoved(manifestation) {
                        this.mRealOne.manifestationRemoved(manifestation);
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    glowChanged(manifestation) {
                        this.mRealOne.glowChanged(manifestation);
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    labelChanged(manifestation) {
                        this.mRealOne.labelChanged(manifestation);
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    colorChanged(manifestation) {
                        this.mRealOne.colorChanged(manifestation);
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    locationChanged(manifestation) {
                        this.mRealOne.locationChanged(manifestation);
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    orientationChanged(manifestation) {
                        this.mRealOne.orientationChanged(manifestation);
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    shapeChanged(manifestation) {
                        this.mRealOne.shapeChanged(manifestation);
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} from
                     * @param {com.vzome.core.render.RenderedManifestation} to
                     */
                    manifestationSwitched(from, to) {
                        throw new java.lang.IllegalStateException();
                    }
                    /**
                     *
                     * @param {*} shapes
                     * @return {boolean}
                     */
                    shapesChanged(shapes) {
                        return this.mRealOne.shapesChanged(shapes);
                    }
                }
                render.TransparentRendering = TransparentRendering;
                TransparentRendering["__class"] = "com.vzome.core.render.TransparentRendering";
                TransparentRendering["__interfaces"] = ["com.vzome.core.render.RenderingChanges"];
            })(render = core.render || (core.render = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var render;
            (function (render) {
                let RealZomeScaling;
                (function (RealZomeScaling) {
                    RealZomeScaling.VZOME_BLUE_DIAMETER = 2.0;
                    RealZomeScaling.RZOME_BLUE_DIAMETER_INCHES = 0.6958;
                    RealZomeScaling.RZOME_BLUE_DIAMETER_CM = 1.7673;
                    RealZomeScaling.RZOME_INCH_SCALING = RealZomeScaling.RZOME_BLUE_DIAMETER_INCHES / RealZomeScaling.VZOME_BLUE_DIAMETER;
                    RealZomeScaling.RZOME_CM_SCALING = RealZomeScaling.RZOME_BLUE_DIAMETER_CM / RealZomeScaling.VZOME_BLUE_DIAMETER;
                    RealZomeScaling.RZOME_MM_SCALING = RealZomeScaling.RZOME_CM_SCALING * 10.0;
                    RealZomeScaling.VZOME_STRUT_MODEL_BALL_DIAMETER = 44.36;
                    RealZomeScaling.VZOME_STRUT_MODEL_INCH_SCALING = RealZomeScaling.RZOME_BLUE_DIAMETER_INCHES / RealZomeScaling.VZOME_STRUT_MODEL_BALL_DIAMETER;
                })(RealZomeScaling = render.RealZomeScaling || (render.RealZomeScaling = {}));
            })(render = core.render || (core.render = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var render;
            (function (render) {
                /**
                 * @author vorth
                 * @param {*} symm
                 * @class
                 */
                class AbstractZomicEventHandler {
                    constructor(symm) {
                        if (this.mSymmetry === undefined) {
                            this.mSymmetry = null;
                        }
                        if (this.mOrientation === undefined) {
                            this.mOrientation = null;
                        }
                        this.mHandedNess = com.vzome.core.math.symmetry.Symmetry.PLUS;
                        if (this.mScale === undefined) {
                            this.mScale = null;
                        }
                        this.mAction = com.vzome.core.render.ZomicEventHandler.BUILD;
                        this.mSymmetry = symm;
                        this.mScale = symm.getField().one();
                        this.mOrientation = this.mSymmetry.getPermutation(0);
                    }
                    getPermutation() {
                        return this.mOrientation;
                    }
                    getDirection(name) {
                        return this.mSymmetry.getDirection(name);
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Permutation} permutation
                     * @param {number} sense
                     */
                    permute(permutation, sense) {
                        this.mOrientation = permutation.compose(this.mOrientation);
                        this.mHandedNess = (this.mHandedNess + sense) % 2;
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Axis} axis
                     * @param {number} steps
                     */
                    rotate(axis, steps) {
                        axis = this.mOrientation.permute(axis, this.mHandedNess);
                        if (axis.getSense() === this.mHandedNess)
                            steps *= -1;
                        this.permute(axis.getRotationPermutation().power(steps), com.vzome.core.math.symmetry.Symmetry.PLUS);
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Axis} blueAxis
                     */
                    reflect(blueAxis) {
                        if (blueAxis == null)
                            this.permute(this.mSymmetry.getPermutation(0), com.vzome.core.math.symmetry.Symmetry.MINUS);
                        else {
                            blueAxis = this.mOrientation.permute(blueAxis, this.mHandedNess);
                            this.permute(blueAxis.getRotationPermutation(), com.vzome.core.math.symmetry.Symmetry.MINUS);
                        }
                    }
                    /**
                     *
                     * @param {*} scale
                     */
                    scale(scale) {
                        this.mScale = this.mScale['times$com_vzome_core_algebra_AlgebraicNumber'](scale);
                    }
                    /**
                     *
                     * @param {number} action
                     */
                    action(action) {
                        this.mAction = action;
                    }
                    /**
                     *
                     * @param {number} variables
                     * @return {*}
                     */
                    save(variables) {
                        const newVM = this.copyLocation();
                        newVM.mAction = this.mAction;
                        newVM.mOrientation = this.mOrientation;
                        newVM.mHandedNess = this.mHandedNess;
                        newVM.mScale = this.mScale;
                        return newVM;
                    }
                    /**
                     *
                     * @param {*} changes
                     * @param {number} variables
                     */
                    restore(changes, variables) {
                        const changedVM = changes;
                        if ((com.vzome.core.render.ZomicEventHandler.LOCATION & variables) === 0)
                            this.restoreLocation(changedVM);
                        if ((com.vzome.core.render.ZomicEventHandler.SCALE & variables) === 0)
                            this.mScale = changedVM.mScale;
                        if ((com.vzome.core.render.ZomicEventHandler.ORIENTATION & variables) === 0) {
                            this.mOrientation = changedVM.mOrientation;
                            this.mHandedNess = changedVM.mHandedNess;
                        }
                        if ((com.vzome.core.render.ZomicEventHandler.ACTION & variables) === 0)
                            this.mAction = changedVM.mAction;
                    }
                }
                render.AbstractZomicEventHandler = AbstractZomicEventHandler;
                AbstractZomicEventHandler["__class"] = "com.vzome.core.render.AbstractZomicEventHandler";
                AbstractZomicEventHandler["__interfaces"] = ["com.vzome.core.render.ZomicEventHandler"];
            })(render = core.render || (core.render = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var viewing;
            (function (viewing) {
                class AbstractShapes {
                    constructor(pkgName, name, alias, symm) {
                        this.strutShapesByLengthAndOrbit = (new java.util.HashMap());
                        this.strutGeometriesByOrbit = (new java.util.HashMap());
                        this.panelShapes = (new java.util.HashMap());
                        if (this.mPkgName === undefined) {
                            this.mPkgName = null;
                        }
                        if (this.mName === undefined) {
                            this.mName = null;
                        }
                        if (this.alias === undefined) {
                            this.alias = null;
                        }
                        if (this.mSymmetry === undefined) {
                            this.mSymmetry = null;
                        }
                        if (this.mConnectorGeometry === undefined) {
                            this.mConnectorGeometry = null;
                        }
                        this.mPkgName = pkgName;
                        this.mName = name;
                        this.alias = alias;
                        this.mConnectorGeometry = null;
                        this.mSymmetry = symm;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return /* getSimpleName */ (c => typeof c === 'string' ? c.substring(c.lastIndexOf('.') + 1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))(this.constructor) + "( Symmetry:" + this.mSymmetry.getName() + ", PkgName:" + this.mPkgName + ", Name:" + this.mName + (this.alias == null ? "" : (", Alias:" + this.alias)) + " )";
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} dir
                     * @return {com.vzome.core.construction.Color}
                     */
                    getColor(dir) {
                        return null;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasColors() {
                        return false;
                    }
                    createStrutGeometry(dir) {
                        return new com.vzome.core.parts.FastDefaultStrutGeometry(dir);
                    }
                    /*private*/ getStrutGeometry(orbit) {
                        let orbitStrutGeometry = this.strutGeometriesByOrbit.get(orbit);
                        if (orbitStrutGeometry == null) {
                            orbitStrutGeometry = this.createStrutGeometry(orbit);
                            this.strutGeometriesByOrbit.put(orbit, orbitStrutGeometry);
                        }
                        return orbitStrutGeometry;
                    }
                    getStrutGeometries() {
                        return (java.util.Arrays.stream(this.mSymmetry.getDirectionNames()).collect(java.util.stream.Collectors.toMap((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                            return funcInst;
                        } return (arg0) => (funcInst['apply'] ? funcInst['apply'] : funcInst).call(funcInst, arg0); })((x => x))), (name) => this.getStrutGeometry(this.mSymmetry.getDirection(name)))));
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return this.mName;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getAlias() {
                        return this.alias;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getPackage() {
                        return this.mPkgName;
                    }
                    /**
                     *
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    getConnectorShape() {
                        if (this.mConnectorGeometry == null) {
                            this.mConnectorGeometry = this.buildConnectorShape(this.mPkgName);
                            this.mConnectorGeometry.setName("ball");
                        }
                        return this.mConnectorGeometry;
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} orbit
                     * @param {*} length
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    getStrutShape(orbit, length) {
                        let strutShapesByLength = this.strutShapesByLengthAndOrbit.get(orbit);
                        if (strutShapesByLength == null) {
                            strutShapesByLength = (new java.util.HashMap());
                            this.strutShapesByLengthAndOrbit.put(orbit, strutShapesByLength);
                        }
                        let lengthShape = strutShapesByLength.get(length);
                        if (lengthShape == null) {
                            const orbitStrutGeometry = this.getStrutGeometry(orbit);
                            lengthShape = orbitStrutGeometry.getStrutPolyhedron(length);
                            strutShapesByLength.put(length, lengthShape);
                            if (lengthShape != null) {
                                lengthShape.setName(orbit.getName() + strutShapesByLength.size());
                                lengthShape.setOrbit(orbit);
                                lengthShape.setLength(orbit.getLengthInUnits(length));
                            }
                        }
                        return lengthShape;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetry() {
                        return this.mSymmetry;
                    }
                    /*private*/ makePanelPolyhedron(vertices, oneSided) {
                        const poly = new com.vzome.core.math.Polyhedron(this.mSymmetry.getField());
                        poly.setPanel(true);
                        let arity = 0;
                        for (let index = vertices.iterator(); index.hasNext();) {
                            let gv = index.next();
                            {
                                arity++;
                                poly.addVertex(gv);
                            }
                        }
                        if (poly.getVertexList().size() < arity)
                            return null;
                        const front = poly.newFace();
                        const back = poly.newFace();
                        for (let i = 0; i < arity; i++) {
                            {
                                const j = i;
                                front.add(j);
                                back.add(0, j);
                            }
                            ;
                        }
                        poly.addFace(front);
                        if (!oneSided)
                            poly.addFace(back);
                        return poly;
                    }
                    /**
                     *
                     * @param {number} vertexCount
                     * @param {*} quadrea
                     * @param {com.vzome.core.math.symmetry.Axis} zone
                     * @param {*} vertices
                     * @param {boolean} oneSidedPanels
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    getPanelShape(vertexCount, quadrea, zone, vertices, oneSidedPanels) {
                        let map1 = this.panelShapes.get(vertexCount);
                        if (map1 == null) {
                            map1 = (new java.util.HashMap());
                            this.panelShapes.put(vertexCount, map1);
                        }
                        let map2 = map1.get(quadrea);
                        if (map2 == null) {
                            map2 = (new java.util.HashMap());
                            map1.put(quadrea, map2);
                        }
                        const orbit = zone.getDirection();
                        let map3 = map2.get(orbit);
                        if (map3 == null) {
                            map3 = (new java.util.HashMap());
                            map2.put(orbit, map3);
                        }
                        const orientation = zone.getOrientation();
                        const perm = this.mSymmetry.getPermutation(orientation).inverse();
                        const inverseOrientation = perm.mapIndex(0);
                        const inverseTrans = this.mSymmetry.getMatrix(inverseOrientation);
                        const canonicalVertices = (new java.util.ArrayList());
                        for (let index = vertices.iterator(); index.hasNext();) {
                            let vertex = index.next();
                            {
                                canonicalVertices.add(inverseTrans.timesColumn(vertex));
                            }
                        }
                        let shape = map3.get(canonicalVertices);
                        if (shape == null) {
                            shape = this.makePanelPolyhedron(canonicalVertices, oneSidedPanels);
                            map3.put(canonicalVertices, shape);
                        }
                        return shape;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getCmScaling() {
                        return com.vzome.core.render.RealZomeScaling.RZOME_CM_SCALING;
                    }
                }
                viewing.AbstractShapes = AbstractShapes;
                AbstractShapes["__class"] = "com.vzome.core.viewing.AbstractShapes";
                AbstractShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];
            })(viewing = core.viewing || (core.viewing = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var viewing;
            (function (viewing) {
                class ExportedVEFStrutGeometry {
                    constructor(vertices, faces, prototype, fullScaleVertices, halfScaleVertices, field) {
                        if (((vertices != null && (vertices.constructor != null && vertices.constructor["__interfaces"] != null && vertices.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || vertices === null) && ((faces != null && (faces.constructor != null && faces.constructor["__interfaces"] != null && faces.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || faces === null) && ((prototype != null && prototype instanceof com.vzome.core.algebra.AlgebraicVector) || prototype === null) && ((fullScaleVertices != null && (fullScaleVertices.constructor != null && fullScaleVertices.constructor["__interfaces"] != null && fullScaleVertices.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || fullScaleVertices === null) && ((halfScaleVertices != null && (halfScaleVertices.constructor != null && halfScaleVertices.constructor["__interfaces"] != null && halfScaleVertices.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || halfScaleVertices === null) && ((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null)) {
                            let __args = arguments;
                            if (this.prototypeVertices === undefined) {
                                this.prototypeVertices = null;
                            }
                            if (this.prototypeFaces === undefined) {
                                this.prototypeFaces = null;
                            }
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            if (this.prototypeVector === undefined) {
                                this.prototypeVector = null;
                            }
                            if (this.fullScaleVertices === undefined) {
                                this.fullScaleVertices = null;
                            }
                            if (this.halfScaleVertices === undefined) {
                                this.halfScaleVertices = null;
                            }
                            this.shortGeometry = null;
                            this.prototypeVertices = vertices;
                            this.prototypeFaces = faces;
                            this.prototypeVector = prototype;
                            this.fullScaleVertices = fullScaleVertices;
                            this.halfScaleVertices = halfScaleVertices;
                            this.field = field;
                        }
                        else if (((vertices != null && (vertices.constructor != null && vertices.constructor["__interfaces"] != null && vertices.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || vertices === null) && ((faces != null && (faces.constructor != null && faces.constructor["__interfaces"] != null && faces.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || faces === null) && ((prototype != null && prototype instanceof com.vzome.core.algebra.AlgebraicVector) || prototype === null) && ((fullScaleVertices != null && (fullScaleVertices.constructor != null && fullScaleVertices.constructor["__interfaces"] != null && fullScaleVertices.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || fullScaleVertices === null) && ((halfScaleVertices != null && (halfScaleVertices.constructor != null && halfScaleVertices.constructor["__interfaces"] != null && halfScaleVertices.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || halfScaleVertices === null) && field === undefined) {
                            let __args = arguments;
                            let field = __args[4];
                            {
                                let __args = arguments;
                                let halfScaleVertices = null;
                                if (this.prototypeVertices === undefined) {
                                    this.prototypeVertices = null;
                                }
                                if (this.prototypeFaces === undefined) {
                                    this.prototypeFaces = null;
                                }
                                if (this.field === undefined) {
                                    this.field = null;
                                }
                                if (this.prototypeVector === undefined) {
                                    this.prototypeVector = null;
                                }
                                if (this.fullScaleVertices === undefined) {
                                    this.fullScaleVertices = null;
                                }
                                if (this.halfScaleVertices === undefined) {
                                    this.halfScaleVertices = null;
                                }
                                this.shortGeometry = null;
                                this.prototypeVertices = vertices;
                                this.prototypeFaces = faces;
                                this.prototypeVector = prototype;
                                this.fullScaleVertices = fullScaleVertices;
                                this.halfScaleVertices = halfScaleVertices;
                                this.field = field;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static LOGGER_$LI$() { if (ExportedVEFStrutGeometry.LOGGER == null) {
                        ExportedVEFStrutGeometry.LOGGER = java.util.logging.Logger.getLogger("com.vzome.core.viewing.ExportedVEFStrutGeometry");
                    } return ExportedVEFStrutGeometry.LOGGER; }
                    getTriangles() {
                        return this.getStrutPolyhedron(this.field.one()).getTriangleFaces();
                    }
                    /**
                     *
                     * @param {*} length
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    getStrutPolyhedron(length) {
                        const tipVertex = this.prototypeVector.scale(length);
                        let maxNonTipDistance = 0;
                        let minTipDistance = tipVertex.toRealVector().length();
                        const midpoint = tipVertex.scale(this.field['createRational$long$long'](1, 2));
                        if ((this.field.getName() === ("snubDodec")) && ExportedVEFStrutGeometry.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE)) {
                            ExportedVEFStrutGeometry.LOGGER_$LI$().fine("proto length = " + this.prototypeVector.toRealVector().length());
                            ExportedVEFStrutGeometry.LOGGER_$LI$().fine("strut length = " + length.evaluate());
                            ExportedVEFStrutGeometry.LOGGER_$LI$().fine("tip length = " + tipVertex.toRealVector().length());
                        }
                        const result = new com.vzome.core.math.Polyhedron(this.field);
                        for (let i = 0; i < this.prototypeVertices.size(); i++) {
                            {
                                let vertex = this.prototypeVertices.get(i);
                                if (this.fullScaleVertices.contains(i)) {
                                    vertex = vertex.plus(tipVertex);
                                    minTipDistance = Math.min(minTipDistance, vertex.toRealVector().length());
                                }
                                else {
                                    if (this.halfScaleVertices != null && this.halfScaleVertices.contains(i)) {
                                        vertex = vertex.plus(midpoint);
                                    }
                                    maxNonTipDistance = Math.max(maxNonTipDistance, vertex.toRealVector().length());
                                }
                                result.addVertex(vertex);
                            }
                            ;
                        }
                        if (maxNonTipDistance > minTipDistance) {
                            if (this.shortGeometry != null) {
                                return this.shortGeometry.getStrutPolyhedron(length);
                            }
                            else
                                return null;
                        }
                        for (let index = this.prototypeFaces.iterator(); index.hasNext();) {
                            let prototypeFace = index.next();
                            {
                                const face = result.newFace();
                                face.addAll(prototypeFace);
                                result.addFace(face);
                            }
                        }
                        return result;
                    }
                    setShortGeometry(shortGeometry) {
                        this.shortGeometry = shortGeometry;
                    }
                }
                viewing.ExportedVEFStrutGeometry = ExportedVEFStrutGeometry;
                ExportedVEFStrutGeometry["__class"] = "com.vzome.core.viewing.ExportedVEFStrutGeometry";
                ExportedVEFStrutGeometry["__interfaces"] = ["com.vzome.core.parts.StrutGeometry"];
            })(viewing = core.viewing || (core.viewing = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var viewing;
            (function (viewing) {
                /**
                 * This is really a SceneModel
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.viewing.Lights} prototype
                 * @class
                 */
                class Lights {
                    constructor(prototype) {
                        if (((prototype != null && prototype instanceof com.vzome.core.viewing.Lights) || prototype === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                if (this.mAmbientLightColor === undefined) {
                                    this.mAmbientLightColor = null;
                                }
                                if (this.backgroundColor === undefined) {
                                    this.backgroundColor = null;
                                }
                                this.pcs = new java.beans.PropertyChangeSupport(this);
                                this.directionalLights = (new java.util.ArrayList(3));
                            }
                            (() => {
                                this.backgroundColor = prototype.backgroundColor;
                                this.mAmbientLightColor = prototype.mAmbientLightColor;
                                for (let i = 0; i < prototype.directionalLights.size(); i++) {
                                    {
                                        this.addDirectionLight$com_vzome_core_viewing_Lights_DirectionalLight(prototype.directionalLights.get(i));
                                    }
                                    ;
                                }
                            })();
                        }
                        else if (((prototype != null && (prototype.constructor != null && prototype.constructor["__interfaces"] != null && prototype.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || prototype === null)) {
                            let __args = arguments;
                            let element = __args[0];
                            {
                                let __args = arguments;
                                if (this.mAmbientLightColor === undefined) {
                                    this.mAmbientLightColor = null;
                                }
                                if (this.backgroundColor === undefined) {
                                    this.backgroundColor = null;
                                }
                                this.pcs = new java.beans.PropertyChangeSupport(this);
                                this.directionalLights = (new java.util.ArrayList(3));
                            }
                            (() => {
                                let str = element.getAttribute("background");
                                this.backgroundColor = com.vzome.core.construction.Color.parseColor(str);
                                str = element.getAttribute("ambientLight");
                                this.mAmbientLightColor = com.vzome.core.construction.Color.parseColor(str);
                                const nodes = element.getChildNodes();
                                for (let i = 0; i < nodes.getLength(); i++) {
                                    {
                                        const node = nodes.item(i);
                                        if (node != null && (node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) {
                                            const viewElem = node;
                                            str = viewElem.getAttribute("color");
                                            const color = com.vzome.core.construction.Color.parseColor(str);
                                            const pos = new com.vzome.core.math.RealVector(javaemul.internal.FloatHelper.parseFloat(viewElem.getAttribute("x")), javaemul.internal.FloatHelper.parseFloat(viewElem.getAttribute("y")), javaemul.internal.FloatHelper.parseFloat(viewElem.getAttribute("z")));
                                            this.addDirectionLight$com_vzome_core_viewing_Lights_DirectionalLight(new Lights.DirectionalLight(pos, color));
                                        }
                                    }
                                    ;
                                }
                            })();
                        }
                        else if (prototype === undefined) {
                            let __args = arguments;
                            if (this.mAmbientLightColor === undefined) {
                                this.mAmbientLightColor = null;
                            }
                            if (this.backgroundColor === undefined) {
                                this.backgroundColor = null;
                            }
                            this.pcs = new java.beans.PropertyChangeSupport(this);
                            this.directionalLights = (new java.util.ArrayList(3));
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    addPropertyListener(listener) {
                        this.pcs.addPropertyChangeListener$java_beans_PropertyChangeListener(listener);
                    }
                    removePropertyListener(listener) {
                        this.pcs.removePropertyChangeListener$java_beans_PropertyChangeListener(listener);
                    }
                    setProperty(cmd, value) {
                        if ("backgroundColor" === cmd) {
                            this.backgroundColor = new com.vzome.core.construction.Color(javaemul.internal.IntegerHelper.parseInt(value, 16));
                            this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(cmd, null, value);
                        }
                    }
                    size() {
                        return this.directionalLights.size();
                    }
                    addDirectionLight$com_vzome_core_viewing_Lights_DirectionalLight(light) {
                        this.directionalLights.add(light);
                    }
                    setAmbientColor(color) {
                        this.mAmbientLightColor = color;
                    }
                    getAmbientColor() {
                        return this.mAmbientLightColor;
                    }
                    getAmbientColorWeb() {
                        return this.mAmbientLightColor.toWebString();
                    }
                    getDirectionalLights() {
                    }
                    getBackgroundColor() {
                        return this.backgroundColor;
                    }
                    getBackgroundColorWeb() {
                        return this.backgroundColor.toWebString();
                    }
                    setBackgroundColor(color) {
                        this.backgroundColor = color;
                    }
                    getXml(doc) {
                        const result = doc.createElement("sceneModel");
                        com.vzome.xml.DomUtils.addAttribute(result, "ambientLight", this.mAmbientLightColor.toString());
                        com.vzome.xml.DomUtils.addAttribute(result, "background", this.backgroundColor.toString());
                        for (let i = 0; i < this.directionalLights.size(); i++) {
                            {
                                const light = this.directionalLights.get(i);
                                const child = doc.createElement("directionalLight");
                                com.vzome.xml.DomUtils.addAttribute(child, "x", /* toString */ ('' + (light.direction.x)));
                                com.vzome.xml.DomUtils.addAttribute(child, "y", /* toString */ ('' + (light.direction.y)));
                                com.vzome.xml.DomUtils.addAttribute(child, "z", /* toString */ ('' + (light.direction.z)));
                                com.vzome.xml.DomUtils.addAttribute(child, "color", light.color.toString());
                                result.appendChild(child);
                            }
                            ;
                        }
                        return result;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    iterator() {
                        return this.directionalLights.iterator();
                    }
                    addDirectionLight$com_vzome_core_construction_Color$com_vzome_core_math_RealVector(color, dir) {
                        this.addDirectionLight$com_vzome_core_viewing_Lights_DirectionalLight(new Lights.DirectionalLight(dir, color));
                    }
                    addDirectionLight(color, dir) {
                        if (((color != null && color instanceof com.vzome.core.construction.Color) || color === null) && ((dir != null && dir instanceof com.vzome.core.math.RealVector) || dir === null)) {
                            return this.addDirectionLight$com_vzome_core_construction_Color$com_vzome_core_math_RealVector(color, dir);
                        }
                        else if (((color != null && color instanceof com.vzome.core.viewing.Lights.DirectionalLight) || color === null) && dir === undefined) {
                            return this.addDirectionLight$com_vzome_core_viewing_Lights_DirectionalLight(color);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getDirectionalLightVector(i) {
                        const light = this.directionalLights.get(i);
                        return new com.vzome.core.math.RealVector(light.direction.x, light.direction.y, light.direction.z);
                    }
                    getDirectionalLightColor(i) {
                        const light = this.directionalLights.get(i);
                        return light.color;
                    }
                }
                viewing.Lights = Lights;
                Lights["__class"] = "com.vzome.core.viewing.Lights";
                Lights["__interfaces"] = ["java.lang.Iterable"];
                (function (Lights) {
                    class DirectionalLight {
                        constructor(direction, color) {
                            if (this.direction === undefined) {
                                this.direction = null;
                            }
                            if (this.color === undefined) {
                                this.color = null;
                            }
                            this.direction = direction;
                            this.color = color;
                        }
                        getColor() {
                            return this.color.toWebString();
                        }
                        getDirection() {
                            return [this.direction.x, this.direction.y, this.direction.z];
                        }
                    }
                    Lights.DirectionalLight = DirectionalLight;
                    DirectionalLight["__class"] = "com.vzome.core.viewing.Lights.DirectionalLight";
                })(Lights = viewing.Lights || (viewing.Lights = {}));
            })(viewing = core.viewing || (core.viewing = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                /**
                 * An exception thrown by the Zomic parser or interpreter.
                 * A ZomeException may wrap another exception.
                 * Handlers are obligated to "unwrap" a ZomeException
                 * before reporting it, by calling getCulprit().
                 * @param {java.lang.Exception} culprit
                 * @class
                 * @extends java.lang.Exception
                 */
                class ZomicException extends Error {
                    constructor(culprit) {
                        if (((culprit != null && culprit instanceof Error) || culprit === null)) {
                            let __args = arguments;
                            super("wrapped");
                            this.message = "wrapped";
                            if (this.m_culprit === undefined) {
                                this.m_culprit = null;
                            }
                            this.m_culprit = culprit;
                        }
                        else if (((typeof culprit === 'string') || culprit === null)) {
                            let __args = arguments;
                            let msg = __args[0];
                            super(msg);
                            this.message = msg;
                            if (this.m_culprit === undefined) {
                                this.m_culprit = null;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Return the original culprit wrapped by this ZomeException.
                     * Arbitrarily deep wrapping will be unwrapped by a single call
                     * to getCulprit.  If there is no culprit, returns this ZomeException.
                     * @return {java.lang.Exception}
                     */
                    getCulprit() {
                        if (this.m_culprit == null) {
                            return this;
                        }
                        if (this.m_culprit != null && this.m_culprit instanceof com.vzome.core.zomic.ZomicException) {
                            return this.m_culprit.getCulprit();
                        }
                        else {
                            return this.m_culprit;
                        }
                    }
                }
                zomic.ZomicException = ZomicException;
                ZomicException["__class"] = "com.vzome.core.zomic.ZomicException";
                ZomicException["__interfaces"] = ["java.io.Serializable"];
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    let Visitor;
                    (function (Visitor) {
                        class Default {
                            /**
                             *
                             * @param {com.vzome.core.zomic.program.Walk} walk
                             */
                            visitWalk(walk) {
                                for (let index = walk.iterator(); index.hasNext();) {
                                    let stmt = index.next();
                                    {
                                        stmt.accept(this);
                                    }
                                }
                            }
                            /**
                             *
                             * @param {string} id
                             */
                            visitLabel(id) {
                            }
                            /**
                             *
                             * @param {com.vzome.core.zomic.program.Nested} compound
                             */
                            visitNested(compound) {
                                compound.getBody().accept(this);
                            }
                            /**
                             *
                             * @param {com.vzome.core.zomic.program.Repeat} repeated
                             * @param {number} repetitions
                             */
                            visitRepeat(repeated, repetitions) {
                                for (let i = 0; i < repetitions; i++) {
                                    {
                                        this.visitNested(repeated);
                                    }
                                    ;
                                }
                            }
                            /**
                             *
                             * @param {com.vzome.core.math.symmetry.Axis} axis
                             * @param {number} steps
                             */
                            visitRotate(axis, steps) {
                            }
                            /**
                             *
                             * @param {com.vzome.core.math.symmetry.Axis} blueAxis
                             */
                            visitReflect(blueAxis) {
                            }
                            /**
                             *
                             * @param {com.vzome.core.math.symmetry.Axis} axis
                             * @param {*} length
                             */
                            visitMove(axis, length) {
                            }
                            /**
                             *
                             * @param {com.vzome.core.zomic.program.Symmetry} model
                             * @param {com.vzome.core.zomic.program.Permute} permute
                             */
                            visitSymmetry(model, permute) {
                                this.visitNested(model);
                            }
                            /**
                             *
                             * @param {com.vzome.core.zomic.program.Save} stmt
                             * @param {number} state
                             */
                            visitSave(stmt, state) {
                                this.visitNested(stmt);
                            }
                            /**
                             *
                             * @param {*} size
                             */
                            visitScale(size) {
                            }
                            /**
                             *
                             * @param {boolean} build
                             * @param {boolean} destroy
                             */
                            visitBuild(build, destroy) {
                            }
                            /**
                             *
                             * @param {string} message
                             */
                            visitUntranslatable(message) {
                            }
                            constructor() {
                            }
                        }
                        Visitor.Default = Default;
                        Default["__class"] = "com.vzome.core.zomic.program.Visitor.Default";
                        Default["__interfaces"] = ["com.vzome.core.zomic.program.Visitor"];
                    })(Visitor = program.Visitor || (program.Visitor = {}));
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    class ZomicStatement {
                        constructor() {
                            if (this.mErrors === undefined) {
                                this.mErrors = null;
                            }
                        }
                        setErrors(errors) {
                            this.mErrors = errors;
                        }
                        getErrors() {
                            return this.mErrors;
                        }
                    }
                    program.ZomicStatement = ZomicStatement;
                    ZomicStatement["__class"] = "com.vzome.core.zomic.program.ZomicStatement";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                class ZomicCompilerState {
                    constructor(icosaSymm) {
                        if (this.icosaSymmetry === undefined) {
                            this.icosaSymmetry = null;
                        }
                        if (this.namingConvention === undefined) {
                            this.namingConvention = null;
                        }
                        this.statements = (new java.util.Stack());
                        this.templates = (new java.util.Stack());
                        this.icosaSymmetry = icosaSymm;
                        this.namingConvention = new com.vzome.core.zomic.ZomicNamingConvention(icosaSymm);
                    }
                    getProgram() {
                        return this.statements.size() === 0 ? new com.vzome.core.zomic.program.Walk() : this.statements.firstElement();
                    }
                    prepareStatement(statement) {
                        this.statements.push(statement);
                    }
                    peekTemplate() {
                        return this.templates.peek();
                    }
                    popTemplate() {
                        return this.templates.pop();
                    }
                    commitLastStatement() {
                        const statement = this.statements.pop();
                        if (statement != null && statement instanceof com.vzome.core.zomic.program.Nested) {
                            const body = statement.getBody();
                            if ((body == null) || ((body != null && body instanceof com.vzome.core.zomic.program.Walk) && body.size() === 0)) {
                                return;
                            }
                        }
                        this.commit(statement);
                    }
                    commit(newStatement) {
                        const currentStatement = this.statements.peek();
                        if (currentStatement != null && currentStatement instanceof com.vzome.core.zomic.program.Walk) {
                            currentStatement.addStatement(newStatement);
                        }
                        else {
                            currentStatement.setBody(newStatement);
                        }
                    }
                    reset() {
                        this.statements.clear();
                        this.templates.clear();
                    }
                    setCurrentScale(scale) {
                        this.templates.peek().scale = scale;
                    }
                    prepareSymmetryTemplate(symmetryMode) {
                        const template = new ZomicCompilerState.SymmetryTemplate(this, symmetryMode);
                        this.templates.push(template);
                    }
                    prepareMoveTemplate() {
                        const template = new ZomicCompilerState.MoveTemplate(this);
                        this.templates.push(template);
                    }
                    prepareScaleTemplate() {
                        const template = new ZomicCompilerState.ScaleTemplate(this);
                        this.templates.push(template);
                    }
                    prepareReflectTemplate(isThruCenter) {
                        const template = new ZomicCompilerState.ReflectTemplate(this, isThruCenter);
                        this.templates.push(template);
                    }
                    prepareRotateTemplate() {
                        const template = new ZomicCompilerState.RotateTemplate(this);
                        this.templates.push(template);
                    }
                }
                zomic.ZomicCompilerState = ZomicCompilerState;
                ZomicCompilerState["__class"] = "com.vzome.core.zomic.ZomicCompilerState";
                (function (ZomicCompilerState) {
                    class AxisInfo {
                        constructor(__parent) {
                            this.__parent = __parent;
                            this.__axisColor = "";
                            this.__indexNumber = "";
                            this.__handedness = "";
                        }
                        generate() {
                            try {
                                const axis = this.__parent.namingConvention.getAxis(this.__axisColor, this.indexFullName());
                                if (axis == null) {
                                    const msg = "bad axis specification: \'" + this.__axisColor + " " + this.indexFullName() + "\'";
                                    throw new Error(msg);
                                }
                                return axis;
                            }
                            catch (ex) {
                                const msg = "bad axis specification: \'" + this.__axisColor + " " + this.indexFullName() + "\'";
                                throw new Error(msg);
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        axisColor() {
                            return this.__axisColor;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setAxisColor(s) {
                            this.__axisColor = s;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        indexNumber() {
                            return this.__indexNumber;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setIndexNumber(s) {
                            this.__indexNumber = s;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        handedness() {
                            return this.__handedness;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setHandedness(s) {
                            this.__handedness = s;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        indexFullName() {
                            return this.__indexNumber + this.__handedness;
                        }
                    }
                    ZomicCompilerState.AxisInfo = AxisInfo;
                    AxisInfo["__class"] = "com.vzome.core.zomic.ZomicCompilerState.AxisInfo";
                    AxisInfo["__interfaces"] = ["com.vzome.core.zomic.ZomicCompilerState.IHaveAxisInfo"];
                    class ScaleInfo {
                        constructor(__parent) {
                            this.__parent = __parent;
                            this.ones = 1;
                            this.phis = 0;
                            this.scale = 1;
                        }
                        generate(symmetry) {
                            return symmetry.getField()['createAlgebraicNumber$int$int$int$int'](this.ones, this.phis, 1, this.scale);
                        }
                    }
                    ZomicCompilerState.ScaleInfo = ScaleInfo;
                    ScaleInfo["__class"] = "com.vzome.core.zomic.ZomicCompilerState.ScaleInfo";
                    class RotateTemplate {
                        constructor(__parent) {
                            this.__parent = __parent;
                            this.axisInfo = new ZomicCompilerState.AxisInfo(this.__parent);
                            this.steps = 1;
                        }
                        /**
                         *
                         * @return {com.vzome.core.zomic.program.Rotate}
                         */
                        generate() {
                            const axis = this.axisInfo.generate();
                            return new com.vzome.core.zomic.program.Rotate(axis, this.steps);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        axisColor() {
                            return this.axisInfo.__axisColor;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setAxisColor(s) {
                            this.axisInfo.setAxisColor(s);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        indexNumber() {
                            return this.axisInfo.__indexNumber;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setIndexNumber(s) {
                            this.axisInfo.setIndexNumber(s);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        handedness() {
                            return this.axisInfo.__handedness;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setHandedness(s) {
                            this.axisInfo.setHandedness(s);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        indexFullName() {
                            return this.axisInfo.indexFullName();
                        }
                    }
                    ZomicCompilerState.RotateTemplate = RotateTemplate;
                    RotateTemplate["__class"] = "com.vzome.core.zomic.ZomicCompilerState.RotateTemplate";
                    RotateTemplate["__interfaces"] = ["com.vzome.core.zomic.ZomicCompilerState.IHaveAxisInfo", "com.vzome.core.zomic.ZomicCompilerState.ZomicStatementTemplate"];
                    class ReflectTemplate {
                        constructor(__parent, isThruCenter) {
                            this.__parent = __parent;
                            this.axisInfo = new ZomicCompilerState.AxisInfo(this.__parent);
                            if (this.isThroughCenter === undefined) {
                                this.isThroughCenter = false;
                            }
                            this.isThroughCenter = isThruCenter;
                        }
                        /**
                         *
                         * @return {com.vzome.core.zomic.program.Reflect}
                         */
                        generate() {
                            const result = new com.vzome.core.zomic.program.Reflect();
                            if (!this.isThroughCenter) {
                                if (("" === this.axisColor()) && !("" === this.indexNumber())) {
                                    this.setAxisColor("blue");
                                }
                                const axis = this.axisInfo.generate();
                                result.setAxis(axis);
                            }
                            return result;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        axisColor() {
                            return this.axisInfo.__axisColor;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setAxisColor(s) {
                            if (!("blue" === s)) {
                                this.enforceBlueAxis();
                            }
                            else {
                                this.axisInfo.setAxisColor(s);
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        indexNumber() {
                            return this.axisInfo.__indexNumber;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setIndexNumber(s) {
                            if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "-"))
                                s = s.substring(1);
                            this.axisInfo.setIndexNumber(s);
                            if (this.isThroughCenter && !("" === this.indexNumber())) {
                                this.setAxisColor("blue");
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        handedness() {
                            return this.axisInfo.__handedness;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setHandedness(s) {
                            this.enforceBlueAxis();
                        }
                        /**
                         *
                         * @return {string}
                         */
                        indexFullName() {
                            return this.axisInfo.indexFullName();
                        }
                        enforceBlueAxis() {
                            throw new java.lang.IllegalStateException("Only \'center\' or blue axis indexes are allowed.");
                        }
                    }
                    ZomicCompilerState.ReflectTemplate = ReflectTemplate;
                    ReflectTemplate["__class"] = "com.vzome.core.zomic.ZomicCompilerState.ReflectTemplate";
                    ReflectTemplate["__interfaces"] = ["com.vzome.core.zomic.ZomicCompilerState.IHaveAxisInfo", "com.vzome.core.zomic.ZomicCompilerState.ZomicStatementTemplate"];
                    let SymmetryModeEnum;
                    (function (SymmetryModeEnum) {
                        SymmetryModeEnum[SymmetryModeEnum["Icosahedral"] = 0] = "Icosahedral";
                        SymmetryModeEnum[SymmetryModeEnum["RotateAroundAxis"] = 1] = "RotateAroundAxis";
                        SymmetryModeEnum[SymmetryModeEnum["MirrorThroughBlueAxis"] = 2] = "MirrorThroughBlueAxis";
                        SymmetryModeEnum[SymmetryModeEnum["ReflectThroughOrigin"] = 3] = "ReflectThroughOrigin";
                    })(SymmetryModeEnum = ZomicCompilerState.SymmetryModeEnum || (ZomicCompilerState.SymmetryModeEnum = {}));
                    class SymmetryTemplate {
                        constructor(__parent, mode) {
                            this.__parent = __parent;
                            this.axisInfo = new ZomicCompilerState.AxisInfo(this.__parent);
                            if (this.symmetryMode === undefined) {
                                this.symmetryMode = null;
                            }
                            this.symmetryMode = mode;
                        }
                        /**
                         *
                         * @return {com.vzome.core.zomic.program.Symmetry}
                         */
                        generate() {
                            const result = this.__parent.statements.peek();
                            switch ((this.symmetryMode)) {
                                case com.vzome.core.zomic.ZomicCompilerState.SymmetryModeEnum.Icosahedral:
                                    break;
                                case com.vzome.core.zomic.ZomicCompilerState.SymmetryModeEnum.RotateAroundAxis:
                                    {
                                        const rotate = new com.vzome.core.zomic.program.Rotate(null, -1);
                                        const axis = this.axisInfo.generate();
                                        rotate.setAxis(axis);
                                        result.setPermute(rotate);
                                    }
                                    ;
                                    break;
                                case com.vzome.core.zomic.ZomicCompilerState.SymmetryModeEnum.MirrorThroughBlueAxis:
                                    {
                                        const reflect = new com.vzome.core.zomic.program.Reflect();
                                        const axis = this.axisInfo.generate();
                                        reflect.setAxis(axis);
                                        result.setPermute(reflect);
                                    }
                                    ;
                                    break;
                                case com.vzome.core.zomic.ZomicCompilerState.SymmetryModeEnum.ReflectThroughOrigin:
                                    result.setPermute(new com.vzome.core.zomic.program.Reflect());
                                    break;
                                default:
                                    throw new java.lang.IllegalStateException("Unexpected SymmetryModeEnum: " + this.symmetryMode == null ? "<null>" : com.vzome.core.zomic.ZomicCompilerState.SymmetryModeEnum["_$wrappers"][this.symmetryMode].toString());
                            }
                            return result;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        axisColor() {
                            return this.axisInfo.__axisColor;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setAxisColor(s) {
                            this.axisInfo.setAxisColor(s);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        indexNumber() {
                            return this.axisInfo.__indexNumber;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setIndexNumber(s) {
                            if (this.symmetryMode === ZomicCompilerState.SymmetryModeEnum.MirrorThroughBlueAxis) {
                                if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "-"))
                                    s = s.substring(1);
                            }
                            this.axisInfo.setIndexNumber(s);
                            if (this.symmetryMode === ZomicCompilerState.SymmetryModeEnum.MirrorThroughBlueAxis) {
                                this.setAxisColor("blue");
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        handedness() {
                            return this.axisInfo.__handedness;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setHandedness(s) {
                            this.axisInfo.setHandedness(s);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        indexFullName() {
                            return this.axisInfo.indexFullName();
                        }
                    }
                    ZomicCompilerState.SymmetryTemplate = SymmetryTemplate;
                    SymmetryTemplate["__class"] = "com.vzome.core.zomic.ZomicCompilerState.SymmetryTemplate";
                    SymmetryTemplate["__interfaces"] = ["com.vzome.core.zomic.ZomicCompilerState.IHaveAxisInfo", "com.vzome.core.zomic.ZomicCompilerState.ZomicStatementTemplate"];
                    class ScaleTemplate extends ZomicCompilerState.ScaleInfo {
                        constructor(__parent) {
                            super(__parent);
                            this.__parent = __parent;
                        }
                        generate(symmetry) {
                            if (((symmetry != null && symmetry instanceof com.vzome.core.math.symmetry.IcosahedralSymmetry) || symmetry === null)) {
                                return super.generate(symmetry);
                            }
                            else if (symmetry === undefined) {
                                return this.generate$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        generate$() {
                            const algebraicNumber = this.generate(this.__parent.icosaSymmetry);
                            return new com.vzome.core.zomic.program.Scale(algebraicNumber);
                        }
                    }
                    ZomicCompilerState.ScaleTemplate = ScaleTemplate;
                    ScaleTemplate["__class"] = "com.vzome.core.zomic.ZomicCompilerState.ScaleTemplate";
                    ScaleTemplate["__interfaces"] = ["com.vzome.core.zomic.ZomicCompilerState.ZomicStatementTemplate"];
                    class MoveTemplate extends ZomicCompilerState.ScaleInfo {
                        constructor(__parent) {
                            super(__parent);
                            this.__parent = __parent;
                            this.axisInfo = new ZomicCompilerState.AxisInfo(this.__parent);
                            this.denominator = 1;
                            this.sizeRef = null;
                            this.__isVariableLength = false;
                            this.scale = com.vzome.core.zomic.ZomicNamingConvention.MEDIUM;
                        }
                        isVariableLength$() {
                            return (this.__isVariableLength || (-99 === this.scale));
                        }
                        isVariableLength$boolean(is) {
                            this.__isVariableLength = is;
                        }
                        isVariableLength(is) {
                            if (((typeof is === 'boolean') || is === null)) {
                                return this.isVariableLength$boolean(is);
                            }
                            else if (is === undefined) {
                                return this.isVariableLength$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        generate$java_lang_String(axisColor) {
                            if (this.denominator !== 1) {
                                const direction = this.__parent.icosaSymmetry.getDirection(axisColor);
                                if (direction == null || !direction.hasHalfSizes()) {
                                    const msg = "half struts are not allowed on \'" + axisColor + "\' axes.";
                                    throw new Error(msg);
                                }
                            }
                            if (this.isVariableLength$()) {
                                return this.__parent.icosaSymmetry.getField().zero();
                            }
                            let lengthFactor = 1;
                            let scaleOffset = 0;
                            switch ((axisColor)) {
                                case "blue":
                                    lengthFactor = 2;
                                    break;
                                case "green":
                                    lengthFactor = 2;
                                    break;
                                case "yellow":
                                    scaleOffset = -1;
                                    break;
                                case "purple":
                                    scaleOffset = -1;
                                    break;
                                default:
                                    break;
                            }
                            return this.__parent.icosaSymmetry.getField()['createAlgebraicNumber$int$int$int$int'](this.ones * lengthFactor, this.phis * lengthFactor, this.denominator, this.scale + scaleOffset);
                        }
                        generate(axisColor) {
                            if (((typeof axisColor === 'string') || axisColor === null)) {
                                return this.generate$java_lang_String(axisColor);
                            }
                            else if (((axisColor != null && axisColor instanceof com.vzome.core.math.symmetry.IcosahedralSymmetry) || axisColor === null)) {
                                return super.generate(axisColor);
                            }
                            else if (axisColor === undefined) {
                                return this.generate$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        generate$() {
                            const axis = this.axisInfo.generate();
                            const strutLength = this.generate$java_lang_String(this.axisColor());
                            return new com.vzome.core.zomic.program.Move(axis, strutLength);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        axisColor() {
                            return this.axisInfo.__axisColor;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setAxisColor(s) {
                            this.axisInfo.setAxisColor(s);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        indexNumber() {
                            return this.axisInfo.__indexNumber;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setIndexNumber(s) {
                            this.axisInfo.setIndexNumber(s);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        handedness() {
                            return this.axisInfo.__handedness;
                        }
                        /**
                         *
                         * @param {string} s
                         */
                        setHandedness(s) {
                            this.axisInfo.setHandedness(s);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        indexFullName() {
                            return this.axisInfo.indexFullName();
                        }
                    }
                    ZomicCompilerState.MoveTemplate = MoveTemplate;
                    MoveTemplate["__class"] = "com.vzome.core.zomic.ZomicCompilerState.MoveTemplate";
                    MoveTemplate["__interfaces"] = ["com.vzome.core.zomic.ZomicCompilerState.IHaveAxisInfo", "com.vzome.core.zomic.ZomicCompilerState.ZomicStatementTemplate"];
                })(ZomicCompilerState = zomic.ZomicCompilerState || (zomic.ZomicCompilerState = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 */
                class Recorder {
                    constructor() {
                        if (this.mOutput === undefined) {
                            this.mOutput = null;
                        }
                        this.mSaves = (new java.util.Stack());
                    }
                    setOutput(output) {
                        this.mOutput = output;
                    }
                    record(stmt) {
                        if (!this.mSaves.isEmpty())
                            this.mSaves.peek().addStatement(stmt);
                        else if (this.mOutput != null)
                            this.mOutput.statement(stmt);
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Axis} axis
                     * @param {*} length
                     */
                    step(axis, length) {
                        this.record(new com.vzome.core.zomic.program.Move(axis, length));
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Axis} axis
                     * @param {number} steps
                     */
                    rotate(axis, steps) {
                        this.record(new com.vzome.core.zomic.program.Rotate(axis, steps));
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Axis} blueAxis
                     */
                    reflect(blueAxis) {
                        const r = new com.vzome.core.zomic.program.Reflect();
                        r.setAxis(blueAxis);
                        this.record(r);
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Permutation} permutation
                     * @param {number} sense
                     */
                    permute(permutation, sense) {
                        this.record(new com.vzome.core.zomic.program.Untranslatable("permutation"));
                    }
                    /**
                     *
                     * @param {*} scale
                     */
                    scale(scale) {
                        this.record(new com.vzome.core.zomic.program.Scale(scale));
                    }
                    /**
                     *
                     * @param {number} action
                     */
                    action(action) {
                        this.record(new com.vzome.core.zomic.program.Build((action & com.vzome.core.render.ZomicEventHandler.BUILD) !== 0, (action & com.vzome.core.render.ZomicEventHandler.DESTROY) !== 0));
                    }
                    /**
                     *
                     * @param {number} variables
                     * @return {*}
                     */
                    save(variables) {
                        this.mSaves.push(new com.vzome.core.zomic.program.Walk());
                        return this;
                    }
                    getLocation() {
                        throw new java.lang.UnsupportedOperationException();
                    }
                    getPermutation() {
                        throw new java.lang.UnsupportedOperationException();
                    }
                    /**
                     *
                     * @param {*} changes
                     * @param {number} variables
                     */
                    restore(changes, variables) {
                        const walk = this.mSaves.pop();
                        const save = new com.vzome.core.zomic.program.Save(variables);
                        save.setBody(walk);
                        this.record(save);
                    }
                }
                zomic.Recorder = Recorder;
                Recorder["__class"] = "com.vzome.core.zomic.Recorder";
                Recorder["__interfaces"] = ["com.vzome.core.render.ZomicEventHandler"];
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                /**
                 * @author David Hall
                 * @param {*} field
                 * @class
                 */
                class TetrahedralProjection {
                    constructor(field) {
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        if (this.basis === undefined) {
                            this.basis = null;
                        }
                        this.field = field;
                        const pos = field.one();
                        const neg = pos.negate();
                        this.basis = [null, null, null, null];
                        this.basis[0] = new com.vzome.core.algebra.AlgebraicVector(pos, pos, pos);
                        this.basis[1] = new com.vzome.core.algebra.AlgebraicVector(pos, neg, neg);
                        this.basis[2] = new com.vzome.core.algebra.AlgebraicVector(neg, pos, neg);
                        this.basis[3] = new com.vzome.core.algebra.AlgebraicVector(neg, neg, pos);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} source
                     * @param {boolean} wFirst
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    projectImage(source, wFirst) {
                        let result = this.field.origin(this.basis[0].dimension());
                        let pos = wFirst ? 0 : this.basis.length - 1;
                        for (let index = 0; index < this.basis.length; index++) {
                            let unitVector = this.basis[index];
                            {
                                const scalar = source.getComponent(pos);
                                result = result.plus(unitVector.scale(scalar));
                                pos = (pos + 1) % this.basis.length;
                            }
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    setXmlAttributes(xml) {
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getProjectionName() {
                        return "Tetrahedral";
                    }
                }
                math.TetrahedralProjection = TetrahedralProjection;
                TetrahedralProjection["__class"] = "com.vzome.core.math.TetrahedralProjection";
                TetrahedralProjection["__interfaces"] = ["com.vzome.core.math.Projection"];
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                class Polyhedron {
                    constructor(field) {
                        this.numVertices = 0;
                        this.m_vertices = (new java.util.HashMap());
                        this.m_vertexList = (new java.util.ArrayList());
                        this.m_faces = (new java.util.HashSet());
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        if (this.evilTwin === undefined) {
                            this.evilTwin = null;
                        }
                        this.isEvil = false;
                        this.__isPanel = false;
                        this.guid = java.util.UUID.randomUUID();
                        if (this.name === undefined) {
                            this.name = null;
                        }
                        if (this.orbit === undefined) {
                            this.orbit = null;
                        }
                        if (this.length === undefined) {
                            this.length = null;
                        }
                        this.field = field;
                    }
                    static logger_$LI$() { if (Polyhedron.logger == null) {
                        Polyhedron.logger = java.util.logging.Logger.getLogger("com.vzome.core.math.Polyhedron");
                    } return Polyhedron.logger; }
                    /**
                     * Get the mirror twin of this Polyhedron.
                     * The vertices are transformed by the given reflection.
                     * The faces are oriented in reverse, so that when oriented with
                     * a mirroring transformation, the face normals will still point
                     * outward.
                     * @return
                     * @param {com.vzome.core.algebra.AlgebraicMatrix} reflection
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    getEvilTwin(reflection) {
                        if (this.evilTwin == null) {
                            try {
                                this.evilTwin = ((o) => { if (o.clone != undefined) {
                                    return o.clone();
                                }
                                else {
                                    let clone = Object.create(o);
                                    for (let p in o) {
                                        if (o.hasOwnProperty(p))
                                            clone[p] = o[p];
                                    }
                                    return clone;
                                } })(this);
                            }
                            catch (e) {
                                console.error(e.message, e);
                            }
                            this.evilTwin.isEvil = true;
                            this.evilTwin.guid = java.util.UUID.randomUUID();
                            this.evilTwin.m_vertexList = (new java.util.ArrayList());
                            for (let index = this.m_vertexList.iterator(); index.hasNext();) {
                                let vertex = index.next();
                                {
                                    this.evilTwin.addVertex(reflection.timesColumn(vertex));
                                }
                            }
                            this.evilTwin.m_faces = (new java.util.HashSet());
                            for (let index = this.m_faces.iterator(); index.hasNext();) {
                                let face = index.next();
                                {
                                    this.evilTwin.addFace(face.createReverse());
                                }
                            }
                        }
                        return this.evilTwin;
                    }
                    getField() {
                        return this.field;
                    }
                    setName(name) {
                        this.name = name;
                    }
                    getName() {
                        return this.name;
                    }
                    addVertex(location) {
                        this.m_vertexList.add(location);
                    }
                    /**
                     * Only used in ZomicPolyhedronModelInterpreter.
                     * This used to be the implementation of addVertex, but all other callers
                     * don't use the return value, and have already assigned their own indices,
                     * so the collisions here are a bad idea.
                     * @param halfLoc
                     * @return
                     * @param {com.vzome.core.algebra.AlgebraicVector} location
                     * @return {number}
                     */
                    addIndexedVertex(location) {
                        let vertexObj = this.m_vertices.get(location);
                        if (vertexObj == null) {
                            this.m_vertexList.add(location);
                            this.m_vertices.put(location, vertexObj = this.numVertices++);
                        }
                        return vertexObj;
                    }
                    addFace(face) {
                        face.canonicallyOrder();
                        if (!this.m_faces.contains(face)) {
                            this.m_faces.add(face);
                        }
                    }
                    newFace() {
                        return new Polyhedron.Face(this);
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        const prime = 31;
                        let result = 1;
                        result = prime * result + (this.isEvil ? 1231 : 1237);
                        result = prime * result + ((this.length == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.length));
                        result = prime * result + ((this.m_faces == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.m_faces));
                        result = prime * result + ((this.m_vertexList == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.m_vertexList));
                        result = prime * result + this.numVertices;
                        result = prime * result + ((this.orbit == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.orbit));
                        return result;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj) {
                            return true;
                        }
                        if (obj == null) {
                            return false;
                        }
                        if (this.constructor !== obj.constructor) {
                            return false;
                        }
                        const other = obj;
                        if (this.isEvil !== other.isEvil) {
                            return false;
                        }
                        if (this.length == null) {
                            if (other.length != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.length, other.length)) {
                            return false;
                        }
                        if (this.m_faces == null) {
                            if (other.m_faces != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.m_faces, other.m_faces)) {
                            return false;
                        }
                        if (this.m_vertexList == null) {
                            if (other.m_vertexList != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.m_vertexList, other.m_vertexList)) {
                            return false;
                        }
                        if (this.numVertices !== other.numVertices) {
                            return false;
                        }
                        if (this.orbit == null) {
                            if (other.orbit != null) {
                                return false;
                            }
                        }
                        else if (!this.orbit.equals(other.orbit)) {
                            return false;
                        }
                        return true;
                    }
                    setOrbit(orbit) {
                        this.orbit = orbit;
                    }
                    setLength(length) {
                        this.length = length;
                    }
                    getOrbit() {
                        return this.orbit;
                    }
                    getLength() {
                        return this.length;
                    }
                    isPanel() {
                        return this.__isPanel;
                    }
                    setPanel(isPanel) {
                        this.__isPanel = isPanel;
                    }
                    getVertexList() {
                        return this.m_vertexList;
                    }
                    getFaceSet() {
                        return this.m_faces;
                    }
                    getGuid() {
                        return this.guid;
                    }
                    getTriangleFaces() {
                        const result = (new java.util.ArrayList());
                        for (let index = this.m_faces.iterator(); index.hasNext();) {
                            let face = index.next();
                            {
                                result.addAll(face.getTriangles());
                            }
                        }
                        return result;
                    }
                    getTriangles() {
                        let index = 0;
                        const result = (new java.util.ArrayList());
                        for (let index1 = this.m_faces.iterator(); index1.hasNext();) {
                            let face = index1.next();
                            {
                                for (let index1 = face.getTriangles().iterator(); index1.hasNext();) {
                                    let triangle = index1.next();
                                    {
                                        result.add(index++);
                                        result.add(index++);
                                        result.add(index++);
                                    }
                                }
                            }
                        }
                        return result;
                    }
                    getTriangleVertices() {
                        const result = (new java.util.ArrayList());
                        for (let index = this.m_faces.iterator(); index.hasNext();) {
                            let face = index.next();
                            {
                                for (let index = face.getTriangles().iterator(); index.hasNext();) {
                                    let triangle = index.next();
                                    {
                                        for (let loopIndex = 0; loopIndex < triangle.vertices.length; loopIndex++) {
                                            let index = triangle.vertices[loopIndex];
                                            {
                                                const vertex = this.m_vertexList.get(index);
                                                result.add(vertex.toRealVector());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return result;
                    }
                    getNormals() {
                        const result = (new java.util.ArrayList());
                        for (let index = this.m_faces.iterator(); index.hasNext();) {
                            let face = index.next();
                            {
                                const normal = face.getNormal(this.m_vertexList).toRealVector();
                                for (let index = face.getTriangles().iterator(); index.hasNext();) {
                                    let triangle = index.next();
                                    {
                                        result.add(normal);
                                        result.add(normal);
                                        result.add(normal);
                                    }
                                }
                            }
                        }
                        return result;
                    }
                }
                math.Polyhedron = Polyhedron;
                Polyhedron["__class"] = "com.vzome.core.math.Polyhedron";
                Polyhedron["__interfaces"] = ["java.lang.Cloneable"];
                (function (Polyhedron) {
                    class Face extends java.util.ArrayList {
                        constructor(__parent) {
                            super();
                            this.__parent = __parent;
                        }
                        createReverse() {
                            const vertices = ((o) => { if (o.clone != undefined) {
                                return o.clone();
                            }
                            else {
                                let clone = Object.create(o);
                                for (let p in o) {
                                    if (o.hasOwnProperty(p))
                                        clone[p] = o[p];
                                }
                                return clone;
                            } })(this);
                            java.util.Collections.reverse(vertices);
                            const mirrorFace = new Polyhedron.Face(this.__parent);
                            mirrorFace.addAll(vertices);
                            return mirrorFace;
                        }
                        getVertex(index) {
                            if (index >= this.size()) {
                                const msg = "index larger than Face size";
                                com.vzome.core.math.Polyhedron.logger_$LI$().severe(msg);
                                throw new java.lang.IllegalStateException(msg);
                            }
                            return this.get(index);
                        }
                        getTriangles() {
                            const arity = this.size();
                            const result = (new java.util.ArrayList());
                            let v0 = -1;
                            let v1 = -1;
                            for (let j = 0; j < arity; j++) {
                                {
                                    const index = this.get(j);
                                    if (v0 === -1) {
                                        v0 = index;
                                    }
                                    else if (v1 === -1) {
                                        v1 = index;
                                    }
                                    else {
                                        const triangle = new com.vzome.core.math.Polyhedron.Face.Triangle(this, v0, v1, index);
                                        result.add(triangle);
                                        v1 = index;
                                    }
                                }
                                ;
                            }
                            return result;
                        }
                        getNormal(vertices) {
                            return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(vertices.get(this.getVertex(0)), vertices.get(this.getVertex(1)), vertices.get(this.getVertex(2)));
                        }
                        canonicallyOrder() {
                            let minIndex = -1;
                            let minVertex = javaemul.internal.IntegerHelper.MAX_VALUE;
                            const sz = this.size();
                            for (let i = 0; i < sz; i++) {
                                if (this.getVertex(i) <= minVertex) {
                                    minVertex = this.getVertex(i);
                                    minIndex = i;
                                }
                                ;
                            }
                            const temp = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(sz);
                            for (let j = 0; j < sz; j++) {
                                {
                                    temp[j] = this.get((j + minIndex) % sz);
                                }
                                ;
                            }
                            for (let k = 0; k < sz; k++) {
                                this.set(k, temp[k]);
                            }
                        }
                        /**
                         *
                         * @return {number}
                         */
                        hashCode() {
                            let tot = 0;
                            for (let i = 0; i < this.size(); i++) {
                                tot += this.getVertex(i);
                            }
                            return tot;
                        }
                        /**
                         *
                         * @param {*} other
                         * @return {boolean}
                         */
                        equals(other) {
                            if (other == null)
                                return false;
                            if (other === this)
                                return true;
                            if (!(other != null && other instanceof com.vzome.core.math.Polyhedron.Face))
                                return false;
                            const otherFace = other;
                            if (otherFace.size() !== this.size())
                                return false;
                            for (let i = 0; i < this.size(); i++) {
                                if (!(this.get(i) === otherFace.get(i)))
                                    return false;
                                ;
                            }
                            return true;
                        }
                    }
                    Polyhedron.Face = Face;
                    Face["__class"] = "com.vzome.core.math.Polyhedron.Face";
                    Face["__interfaces"] = ["java.util.RandomAccess", "java.lang.Cloneable", "java.util.List", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
                    (function (Face) {
                        class Triangle {
                            constructor(__parent, v0, v1, v2) {
                                this.__parent = __parent;
                                this.vertices = [0, 0, 0];
                                this.vertices[0] = v0;
                                this.vertices[1] = v1;
                                this.vertices[2] = v2;
                            }
                        }
                        Face.Triangle = Triangle;
                        Triangle["__class"] = "com.vzome.core.math.Polyhedron.Face.Triangle";
                    })(Face = Polyhedron.Face || (Polyhedron.Face = {}));
                    class Views {
                        constructor() {
                        }
                    }
                    Polyhedron.Views = Views;
                    Views["__class"] = "com.vzome.core.math.Polyhedron.Views";
                })(Polyhedron = math.Polyhedron || (math.Polyhedron = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                /**
                 * @param {float[]} m 16 elements in column-major order
                 * @param {boolean} transpose
                 * @class
                 */
                class RealMatrix4 {
                    constructor(m, transpose) {
                        if (((m != null && m instanceof Array && (m.length == 0 || m[0] == null || (typeof m[0] === 'number'))) || m === null) && ((typeof transpose === 'boolean') || transpose === null)) {
                            let __args = arguments;
                            if (this.m00 === undefined) {
                                this.m00 = 0;
                            }
                            if (this.m01 === undefined) {
                                this.m01 = 0;
                            }
                            if (this.m02 === undefined) {
                                this.m02 = 0;
                            }
                            if (this.m03 === undefined) {
                                this.m03 = 0;
                            }
                            if (this.m10 === undefined) {
                                this.m10 = 0;
                            }
                            if (this.m11 === undefined) {
                                this.m11 = 0;
                            }
                            if (this.m12 === undefined) {
                                this.m12 = 0;
                            }
                            if (this.m13 === undefined) {
                                this.m13 = 0;
                            }
                            if (this.m20 === undefined) {
                                this.m20 = 0;
                            }
                            if (this.m21 === undefined) {
                                this.m21 = 0;
                            }
                            if (this.m22 === undefined) {
                                this.m22 = 0;
                            }
                            if (this.m23 === undefined) {
                                this.m23 = 0;
                            }
                            if (this.m30 === undefined) {
                                this.m30 = 0;
                            }
                            if (this.m31 === undefined) {
                                this.m31 = 0;
                            }
                            if (this.m32 === undefined) {
                                this.m32 = 0;
                            }
                            if (this.m33 === undefined) {
                                this.m33 = 0;
                            }
                            this.m00 = m[0];
                            this.m01 = m[4];
                            this.m02 = m[8];
                            this.m03 = m[12];
                            this.m10 = m[1];
                            this.m11 = m[5];
                            this.m12 = m[9];
                            this.m13 = m[13];
                            this.m20 = m[2];
                            this.m21 = m[6];
                            this.m22 = m[10];
                            this.m23 = m[14];
                            this.m30 = m[3];
                            this.m31 = m[7];
                            this.m32 = m[11];
                            this.m33 = m[15];
                        }
                        else if (((m != null && m instanceof Array && (m.length == 0 || m[0] == null || (typeof m[0] === 'number'))) || m === null) && transpose === undefined) {
                            let __args = arguments;
                            if (this.m00 === undefined) {
                                this.m00 = 0;
                            }
                            if (this.m01 === undefined) {
                                this.m01 = 0;
                            }
                            if (this.m02 === undefined) {
                                this.m02 = 0;
                            }
                            if (this.m03 === undefined) {
                                this.m03 = 0;
                            }
                            if (this.m10 === undefined) {
                                this.m10 = 0;
                            }
                            if (this.m11 === undefined) {
                                this.m11 = 0;
                            }
                            if (this.m12 === undefined) {
                                this.m12 = 0;
                            }
                            if (this.m13 === undefined) {
                                this.m13 = 0;
                            }
                            if (this.m20 === undefined) {
                                this.m20 = 0;
                            }
                            if (this.m21 === undefined) {
                                this.m21 = 0;
                            }
                            if (this.m22 === undefined) {
                                this.m22 = 0;
                            }
                            if (this.m23 === undefined) {
                                this.m23 = 0;
                            }
                            if (this.m30 === undefined) {
                                this.m30 = 0;
                            }
                            if (this.m31 === undefined) {
                                this.m31 = 0;
                            }
                            if (this.m32 === undefined) {
                                this.m32 = 0;
                            }
                            if (this.m33 === undefined) {
                                this.m33 = 0;
                            }
                            this.m00 = m[0];
                            this.m01 = m[1];
                            this.m02 = m[2];
                            this.m03 = m[3];
                            this.m10 = m[4];
                            this.m11 = m[5];
                            this.m12 = m[6];
                            this.m13 = m[7];
                            this.m20 = m[8];
                            this.m21 = m[9];
                            this.m22 = m[10];
                            this.m23 = m[11];
                            this.m30 = m[12];
                            this.m31 = m[13];
                            this.m32 = m[14];
                            this.m33 = m[15];
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.RealVector} v 4th component treated as 1
                     * @return
                     * @return {com.vzome.core.math.RealVector}
                     */
                    transform3dPt(v) {
                        return new com.vzome.core.math.RealVector(Math.fround(Math.fround(Math.fround(Math.fround(this.m00 * v.x) + Math.fround(this.m01 * v.y)) + Math.fround(this.m02 * v.z)) + this.m03), Math.fround(Math.fround(Math.fround(Math.fround(this.m10 * v.x) + Math.fround(this.m11 * v.y)) + Math.fround(this.m12 * v.z)) + this.m13), Math.fround(Math.fround(Math.fround(Math.fround(this.m20 * v.x) + Math.fround(this.m21 * v.y)) + Math.fround(this.m22 * v.z)) + this.m23));
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.RealVector} v 4th component treated as 0
                     * @return
                     * @return {com.vzome.core.math.RealVector}
                     */
                    transform3dVec(v) {
                        return new com.vzome.core.math.RealVector(Math.fround(Math.fround(Math.fround(this.m00 * v.x) + Math.fround(this.m01 * v.y)) + Math.fround(this.m02 * v.z)), Math.fround(Math.fround(Math.fround(this.m10 * v.x) + Math.fround(this.m11 * v.y)) + Math.fround(this.m12 * v.z)), Math.fround(Math.fround(Math.fround(this.m20 * v.x) + Math.fround(this.m21 * v.y)) + Math.fround(this.m22 * v.z)));
                    }
                    transform4d(v) {
                        const x = Math.fround(Math.fround(Math.fround(Math.fround(this.m00 * v[0]) + Math.fround(this.m01 * v[1])) + Math.fround(this.m02 * v[2])) + Math.fround(this.m03 * v[3]));
                        const y = Math.fround(Math.fround(Math.fround(Math.fround(this.m10 * v[0]) + Math.fround(this.m11 * v[1])) + Math.fround(this.m12 * v[2])) + Math.fround(this.m13 * v[3]));
                        const z = Math.fround(Math.fround(Math.fround(Math.fround(this.m20 * v[0]) + Math.fround(this.m21 * v[1])) + Math.fround(this.m22 * v[2])) + Math.fround(this.m23 * v[3]));
                        const w = Math.fround(Math.fround(Math.fround(Math.fround(this.m30 * v[0]) + Math.fround(this.m31 * v[1])) + Math.fround(this.m32 * v[2])) + Math.fround(this.m33 * v[3]));
                        return [x, y, z, w];
                    }
                    /**
                     * Helping function that specifies the position and orientation of a
                     * view matrix. The inverse of this transform can be used to control
                     * the ViewPlatform object within the scene graph.
                     * @param {com.vzome.core.math.RealVector} eye the location of the eye
                     * @param {com.vzome.core.math.RealVector} center a point in the virtual world where the eye is looking
                     * @param {com.vzome.core.math.RealVector} up an up vector specifying the frustum's up direction
                     * @return {com.vzome.core.math.RealMatrix4}
                     */
                    static lookAt(eye, center, up) {
                        let forwardx;
                        let forwardy;
                        let forwardz;
                        let invMag;
                        let upx;
                        let upy;
                        let upz;
                        let sidex;
                        let sidey;
                        let sidez;
                        forwardx = Math.fround(eye.x - center.x);
                        forwardy = Math.fround(eye.y - center.y);
                        forwardz = Math.fround(eye.z - center.z);
                        invMag = Math.fround((1.0 / Math.sqrt(Math.fround(Math.fround(Math.fround(forwardx * forwardx) + Math.fround(forwardy * forwardy)) + Math.fround(forwardz * forwardz)))));
                        forwardx = Math.fround(forwardx * invMag);
                        forwardy = Math.fround(forwardy * invMag);
                        forwardz = Math.fround(forwardz * invMag);
                        invMag = Math.fround((1.0 / Math.sqrt(Math.fround(Math.fround(Math.fround(up.x * up.x) + Math.fround(up.y * up.y)) + Math.fround(up.z * up.z)))));
                        upx = Math.fround(up.x * invMag);
                        upy = Math.fround(up.y * invMag);
                        upz = Math.fround(up.z * invMag);
                        sidex = Math.fround(Math.fround(upy * forwardz) - Math.fround(forwardy * upz));
                        sidey = Math.fround(Math.fround(upz * forwardx) - Math.fround(upx * forwardz));
                        sidez = Math.fround(Math.fround(upx * forwardy) - Math.fround(upy * forwardx));
                        invMag = Math.fround((1.0 / Math.sqrt(Math.fround(Math.fround(Math.fround(sidex * sidex) + Math.fround(sidey * sidey)) + Math.fround(sidez * sidez)))));
                        sidex *= invMag;
                        sidey *= invMag;
                        sidez *= invMag;
                        upx = Math.fround(Math.fround(forwardy * sidez) - Math.fround(sidey * forwardz));
                        upy = Math.fround(Math.fround(forwardz * sidex) - Math.fround(forwardx * sidez));
                        upz = Math.fround(Math.fround(forwardx * sidey) - Math.fround(forwardy * sidex));
                        const m00 = sidex;
                        const m01 = sidey;
                        const m02 = sidez;
                        const m10 = upx;
                        const m11 = upy;
                        const m12 = upz;
                        const m20 = forwardx;
                        const m21 = forwardy;
                        const m22 = forwardz;
                        const m03 = Math.fround(Math.fround(Math.fround(-eye.x * m00) + Math.fround(-eye.y * m01)) + Math.fround(-eye.z * m02));
                        const m13 = Math.fround(Math.fround(Math.fround(-eye.x * m10) + Math.fround(-eye.y * m11)) + Math.fround(-eye.z * m12));
                        const m23 = Math.fround(Math.fround(Math.fround(-eye.x * m20) + Math.fround(-eye.y * m21)) + Math.fround(-eye.z * m22));
                        return new RealMatrix4([m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, 0, 0, 0, 1]);
                    }
                    /**
                     * Creates a perspective projection transform that mimics a standard,
                     * camera-based,
                     * view-model.
                     * (From javax.media.j3d.Transform3d.java)
                     * This transform maps coordinates from Eye Coordinates (EC)
                     * to Clipping Coordinates (CC).  Note that unlike the similar function
                     * in OpenGL, the clipping coordinates generated by the resulting
                     * transform are in a right-handed coordinate system
                     * (as are all other coordinate systems in Java 3D). Also note that the
                     * field of view is specified in radians.
                     * @param {number} fovx specifies the field of view in the x direction, in radians
                     * @param {number} aspect specifies the aspect ratio and thus the field of
                     * view in the x direction. The aspect ratio is the ratio of x to y,
                     * or width to height.
                     * @param {number} zNear the distance to the frustum's near clipping plane.
                     * This value must be positive, (the value -zNear is the location of the
                     * near clip plane).
                     * @param {number} zFar the distance to the frustum's far clipping plane
                     * @return {com.vzome.core.math.RealMatrix4}
                     */
                    static perspective(fovx, aspect, zNear, zFar) {
                        let sine;
                        let cotangent;
                        let deltaZ;
                        const half_fov = Math.fround(fovx * 0.5);
                        deltaZ = Math.fround(zFar - zNear);
                        sine = Math.fround(Math.sin(half_fov));
                        cotangent = Math.fround((Math.cos(half_fov) / sine));
                        const m00 = cotangent;
                        const m11 = Math.fround(cotangent * aspect);
                        const m22 = Math.fround((Math.fround(zFar + zNear)) / deltaZ);
                        const m23 = Math.fround(Math.fround(Math.fround(2.0 * zNear) * zFar) / deltaZ);
                        const m32 = -1.0;
                        return new RealMatrix4([m00, 0, 0, 0, 0, m11, 0, 0, 0, 0, m22, m23, 0, 0, m32, 0]);
                    }
                    /**
                     * Creates an orthographic projection transform that mimics a standard,
                     * camera-based,
                     * view-model.
                     * (From javax.media.j3d.Transform3d.java)
                     * This transform maps coordinates from Eye Coordinates (EC)
                     * to Clipping Coordinates (CC).  Note that unlike the similar function
                     * in OpenGL, the clipping coordinates generated by the resulting
                     * transform are in a right-handed coordinate system
                     * (as are all other coordinate systems in Java 3D).
                     * @param {number} left the vertical line on the left edge of the near
                     * clipping plane mapped to the left edge of the graphics window
                     * @param {number} right the vertical line on the right edge of the near
                     * clipping plane mapped to the right edge of the graphics window
                     * @param {number} bottom the horizontal line on the bottom edge of the near
                     * clipping plane mapped to the bottom edge of the graphics window
                     * @param {number} top the horizontal line on the top edge of the near
                     * clipping plane mapped to the top edge of the graphics window
                     * @param {number} near the distance to the frustum's near clipping plane
                     * (the value -near is the location of the near clip plane)
                     * @param {number} far the distance to the frustum's far clipping plane
                     * @return {com.vzome.core.math.RealMatrix4}
                     */
                    static ortho(left, right, bottom, top, near, far) {
                        const deltax = Math.fround(1 / (Math.fround(right - left)));
                        const deltay = Math.fround(1 / (Math.fround(top - bottom)));
                        const deltaz = Math.fround(1 / (Math.fround(far - near)));
                        const m00 = Math.fround(2.0 * deltax);
                        const m03 = Math.fround(-(Math.fround(right + left)) * deltax);
                        const m11 = Math.fround(2.0 * deltay);
                        const m13 = Math.fround(-(Math.fround(top + bottom)) * deltay);
                        const m22 = Math.fround(2.0 * deltaz);
                        const m23 = Math.fround((Math.fround(far + near)) * deltaz);
                        const m33 = 1;
                        return new RealMatrix4([m00, 0.0, 0.0, m03, 0.0, m11, 0.0, m13, 0.0, 0.0, m22, m23, 0.0, 0.0, 0.0, m33]);
                    }
                    toArray() {
                        return [this.m00, this.m01, this.m02, this.m03, this.m10, this.m11, this.m12, this.m13, this.m20, this.m21, this.m22, this.m23, this.m30, this.m31, this.m32, this.m33];
                    }
                }
                math.RealMatrix4 = RealMatrix4;
                RealMatrix4["__class"] = "com.vzome.core.math.RealMatrix4";
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var convexhull;
                (function (convexhull) {
                    /**
                     * Constructs a vertex with the specified coordinates and index.
                     * @param {com.vzome.core.algebra.AlgebraicVector} v
                     * @param {number} idx
                     * @class
                     * @author John E. Lloyd, Fall 2004
                     */
                    class Vertex {
                        constructor(v, idx) {
                            if (this.pnt === undefined) {
                                this.pnt = null;
                            }
                            if (this.index === undefined) {
                                this.index = 0;
                            }
                            if (this.prev === undefined) {
                                this.prev = null;
                            }
                            if (this.next === undefined) {
                                this.next = null;
                            }
                            if (this.face === undefined) {
                                this.face = null;
                            }
                            this.pnt = v;
                            this.index = idx;
                        }
                    }
                    convexhull.Vertex = Vertex;
                    Vertex["__class"] = "com.vzome.core.math.convexhull.Vertex";
                })(convexhull = math.convexhull || (math.convexhull = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var convexhull;
                (function (convexhull) {
                    class GrahamScan2D {
                        constructor() {
                        }
                        /**
                         * Constructs the 2d convex hull of a coplanar set of 3d points.
                         *
                         * @param {*} points
                         * a set of 3d input points
                         * @return  {com.vzome.core.algebra.AlgebraicVector[]} an array of the vertices of the planar convex hull.
                         * The points are ordered so that the normal of the resulting polygon points AWAY from the origin.
                         * The points in the array are unique, so the last point is NOT the same as the first.
                         * This means that polygon edges derived from this array must connect the last to the first.
                         * @throws Failure
                         * if the number of input points is less than three,
                         * or if the points are collinear
                         * or if the points are not coplanar.
                         */
                        static buildHull(points) {
                            if (points.size() < 3) {
                                GrahamScan2D.fail("At least three input points are required for a 2d convex hull.\n\n" + points.size() + " specified.");
                            }
                            const normal = com.vzome.core.algebra.AlgebraicVectors.getNormal$java_util_Collection(points);
                            if (normal.isOrigin()) {
                                GrahamScan2D.fail("Cannot generate a 2d convex hull from collinear points");
                            }
                            if (!com.vzome.core.algebra.AlgebraicVectors.areOrthogonalTo(normal, points)) {
                                GrahamScan2D.fail("Cannot generate a 2d convex hull from non-coplanar points");
                            }
                            const keySet = (new java.util.ArrayList());
                            const xyTo3dMap = GrahamScan2D.map3dToXY(points, normal, keySet);
                            const stack2d = GrahamScan2D.getHull2d(keySet);
                            const vertices3d = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(stack2d.size());
                            let i = 0;
                            for (let index = stack2d.iterator(); index.hasNext();) {
                                let point2d = index.next();
                                {
                                    const point3d = xyTo3dMap.get(point2d.toString(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
                                    vertices3d[i++] = point3d;
                                }
                            }
                            return vertices3d;
                        }
                        /*private*/ static map3dToXY(points3d, normal, keySet) {
                            const maxAxis = com.vzome.core.algebra.AlgebraicVectors.getMaxComponentIndex(normal);
                            const mapX = (maxAxis + 1) % 3;
                            const mapY = (maxAxis + 2) % 3;
                            const map = (new java.util.HashMap());
                            for (let index = points3d.iterator(); index.hasNext();) {
                                let point3d = index.next();
                                {
                                    const point2d = new com.vzome.core.algebra.AlgebraicVector(point3d.getComponent(mapX), point3d.getComponent(mapY));
                                    keySet.add(point2d);
                                    map.put(point2d.toString(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT), point3d);
                                }
                            }
                            return map;
                        }
                        /*private*/ static getHull2d(points2d) {
                            const sortedPoints2d = GrahamScan2D.getSortedPoints(points2d);
                            const stack2d = (new java.util.ArrayDeque());
                            stack2d.push(sortedPoints2d.get(0));
                            stack2d.push(sortedPoints2d.get(1));
                            for (let i = 2; i < sortedPoints2d.size(); i++) {
                                {
                                    const head = sortedPoints2d.get(i);
                                    const middle = stack2d.pop();
                                    const tail = stack2d.peek();
                                    const turn = GrahamScan2D.getWindingDirection(tail, middle, head);
                                    switch ((turn)) {
                                        case 1:
                                            stack2d.push(middle);
                                            stack2d.push(head);
                                            break;
                                        case -1:
                                            i--;
                                            break;
                                        case 0:
                                            stack2d.push(head);
                                            break;
                                        default:
                                            throw new java.lang.IllegalStateException("Illegal turn: " + turn);
                                    }
                                }
                                ;
                            }
                            return stack2d;
                        }
                        /**
                         * @param {*} points2d set of 2d points to be sorted
                         * @return {*} a list of points sorted:
                         * 1) in increasing order of the angle they and the lowest point make with the x-axis.
                         * 2) by increasing distance from the lowest point.
                         * @private
                         */
                        /*private*/ static getSortedPoints(points2d) {
                            const lowest = GrahamScan2D.getLowest2dPoint(points2d);
                            const list = (new java.util.ArrayList(points2d));
                            java.util.Collections.sort(list, (a, b) => {
                                if (a.equals(b)) {
                                    return 0;
                                }
                                if (a.equals(lowest)) {
                                    return -1;
                                }
                                if (b.equals(lowest)) {
                                    return 1;
                                }
                                const turn = GrahamScan2D.getWindingDirection(lowest, a, b);
                                if (turn !== 0) {
                                    return -turn;
                                }
                                const lengthSqA = com.vzome.core.algebra.AlgebraicVectors.getMagnitudeSquared(a.minus(lowest));
                                const lengthSqB = com.vzome.core.algebra.AlgebraicVectors.getMagnitudeSquared(b.minus(lowest));
                                return lengthSqA.compareTo(lengthSqB);
                            });
                            return list;
                        }
                        /**
                         * @param {*} points2d a collection of 2d points from which to determine the lowest point.
                         * @return  {com.vzome.core.algebra.AlgebraicVector} the point with the lowest y coordinate.
                         * In case more than one point has the same minimum y coordinate,
                         * the one with the lowest x coordinate is returned.
                         */
                        static getLowest2dPoint(points2d) {
                            let lowest = null;
                            for (let index = points2d.iterator(); index.hasNext();) {
                                let point2d = index.next();
                                {
                                    if (lowest == null) {
                                        lowest = point2d;
                                    }
                                    else {
                                        const signum = point2d.getComponent(com.vzome.core.algebra.AlgebraicVector.Y)['minus$com_vzome_core_algebra_AlgebraicNumber'](lowest.getComponent(com.vzome.core.algebra.AlgebraicVector.Y)).signum();
                                        switch ((signum)) {
                                            case -1:
                                                lowest = point2d;
                                                break;
                                            case 0:
                                                if (point2d.getComponent(com.vzome.core.algebra.AlgebraicVector.X).lessThan(lowest.getComponent(com.vzome.core.algebra.AlgebraicVector.X))) {
                                                    lowest = point2d;
                                                }
                                                break;
                                        }
                                    }
                                }
                            }
                            return lowest;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} a 2d coordinate
                         * @param {com.vzome.core.algebra.AlgebraicVector} b 2d coordinate
                         * @param {com.vzome.core.algebra.AlgebraicVector} c 2d coordinate
                         * @return {number} -1, 0 or 1, depending on the orientation of vector ac with respect to vector ab:
                         * 1: COUNTER_CLOCKWISE
                         * c
                         * /
                         * /
                         * a-----b
                         * -1: CLOCKWISE
                         * b
                         * /
                         * /
                         * a-----c
                         * 0: COLLINEAR
                         * a-----b--c
                         * @private
                         */
                        /*private*/ static getWindingDirection(a, b, c) {
                            const ab = b.minus(a);
                            const ac = c.minus(a);
                            return (new com.vzome.core.algebra.AlgebraicMatrix(ab, ac)).determinant().signum();
                        }
                        /*private*/ static fail(msg) {
                            throw new com.vzome.core.commands.Command.Failure(msg);
                        }
                    }
                    convexhull.GrahamScan2D = GrahamScan2D;
                    GrahamScan2D["__class"] = "com.vzome.core.math.convexhull.GrahamScan2D";
                })(convexhull = math.convexhull || (math.convexhull = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var convexhull;
                (function (convexhull) {
                    /**
                     * Basic triangular face used to form the hull.
                     *
                     * <p>
                     * The information stored for each face consists of a planar normal, a planar
                     * offset, and a doubly-linked list of three <a href=HalfEdge>HalfEdges</a>
                     * which surround the face in a counter-clockwise direction.
                     *
                     * @author John E. Lloyd, Fall 2004
                     * @class
                     */
                    class Face {
                        constructor() {
                            if (this.he0 === undefined) {
                                this.he0 = null;
                            }
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            if (this.area === undefined) {
                                this.area = 0;
                            }
                            if (this.centroid === undefined) {
                                this.centroid = null;
                            }
                            if (this.planeOffset === undefined) {
                                this.planeOffset = null;
                            }
                            if (this.index === undefined) {
                                this.index = 0;
                            }
                            if (this.numVerts === undefined) {
                                this.numVerts = 0;
                            }
                            if (this.next === undefined) {
                                this.next = null;
                            }
                            this.mark = Face.VISIBLE;
                            if (this.outside === undefined) {
                                this.outside = null;
                            }
                            this.mark = Face.VISIBLE;
                        }
                        computeCentroid() {
                            const vectors = (new java.util.HashSet());
                            let he = this.he0;
                            do {
                                {
                                    vectors.add(he.head().pnt);
                                    he = he.next;
                                }
                            } while ((he !== this.he0));
                            this.centroid = com.vzome.core.algebra.AlgebraicVectors.calculateCentroid(vectors);
                            return this.centroid;
                        }
                        computeNormal() {
                            let he1 = this.he0.next;
                            let he2 = he1.next;
                            const p0 = this.he0.head().pnt;
                            let p2 = he1.head().pnt;
                            let d2 = p2.minus(p0);
                            this.normal = p0.getField().origin(3);
                            this.numVerts = 2;
                            while ((he2 !== this.he0)) {
                                {
                                    const d1 = d2;
                                    p2 = he2.head().pnt;
                                    d2 = p2.minus(p0);
                                    this.normal = this.normal.plus(d1.cross(d2));
                                    he1 = he2;
                                    he2 = he2.next;
                                    this.numVerts++;
                                }
                            }
                            ;
                            return this.normal;
                        }
                        /*private*/ computeNormalAndCentroid$() {
                            this.normal = this.computeNormal();
                            this.centroid = this.computeCentroid();
                            this.planeOffset = this.normal.dot(this.centroid);
                            let numv = 0;
                            let he = this.he0;
                            do {
                                {
                                    numv++;
                                    he = he.next;
                                }
                            } while ((he !== this.he0));
                            if (numv !== this.numVerts) {
                                this.fail("face " + this.getVertexString() + " numVerts=" + this.numVerts + " should be " + numv);
                            }
                        }
                        computeNormalAndCentroid$double(minArea) {
                            this.normal = this.computeNormal();
                            this.centroid = this.computeCentroid();
                            this.planeOffset = this.normal.dot(this.centroid);
                        }
                        computeNormalAndCentroid(minArea) {
                            if (((typeof minArea === 'number') || minArea === null)) {
                                return this.computeNormalAndCentroid$double(minArea);
                            }
                            else if (minArea === undefined) {
                                return this.computeNormalAndCentroid$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(v0, v1, v2) {
                            return Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$double(v0, v1, v2, 0);
                        }
                        static createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$double(v0, v1, v2, minArea) {
                            const face = new Face();
                            const he0 = new com.vzome.core.math.convexhull.HalfEdge(v0, face);
                            const he1 = new com.vzome.core.math.convexhull.HalfEdge(v1, face);
                            const he2 = new com.vzome.core.math.convexhull.HalfEdge(v2, face);
                            he0.prev = he2;
                            he0.next = he1;
                            he1.prev = he0;
                            he1.next = he2;
                            he2.prev = he1;
                            he2.next = he0;
                            face.he0 = he0;
                            face.computeNormalAndCentroid$double(minArea);
                            return face;
                        }
                        /**
                         * Constructs a triangule Face from vertices v0, v1, and v2.
                         *
                         * @param {com.vzome.core.math.convexhull.Vertex} v0
                         * first vertex
                         * @param {com.vzome.core.math.convexhull.Vertex} v1
                         * second vertex
                         * @param {com.vzome.core.math.convexhull.Vertex} v2
                         * third vertex
                         * @param {number} minArea
                         * @return {com.vzome.core.math.convexhull.Face}
                         */
                        static createTriangle(v0, v1, v2, minArea) {
                            if (((v0 != null && v0 instanceof com.vzome.core.math.convexhull.Vertex) || v0 === null) && ((v1 != null && v1 instanceof com.vzome.core.math.convexhull.Vertex) || v1 === null) && ((v2 != null && v2 instanceof com.vzome.core.math.convexhull.Vertex) || v2 === null) && ((typeof minArea === 'number') || minArea === null)) {
                                return com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$double(v0, v1, v2, minArea);
                            }
                            else if (((v0 != null && v0 instanceof com.vzome.core.math.convexhull.Vertex) || v0 === null) && ((v1 != null && v1 instanceof com.vzome.core.math.convexhull.Vertex) || v1 === null) && ((v2 != null && v2 instanceof com.vzome.core.math.convexhull.Vertex) || v2 === null) && minArea === undefined) {
                                return com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(v0, v1, v2);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static create(vtxArray, indices) {
                            const face = new Face();
                            let hePrev = null;
                            for (let i = 0; i < indices.length; i++) {
                                {
                                    const he = new com.vzome.core.math.convexhull.HalfEdge(vtxArray[indices[i]], face);
                                    if (hePrev != null) {
                                        he.setPrev(hePrev);
                                        hePrev.setNext(he);
                                    }
                                    else {
                                        face.he0 = he;
                                    }
                                    hePrev = he;
                                }
                                ;
                            }
                            face.he0.setPrev(hePrev);
                            hePrev.setNext(face.he0);
                            face.computeNormalAndCentroid$();
                            return face;
                        }
                        /**
                         * Gets the i-th half-edge associated with the face.
                         *
                         * @param {number} i
                         * the half-edge index, in the range 0-2.
                         * @return {com.vzome.core.math.convexhull.HalfEdge} the half-edge
                         */
                        getEdge(i) {
                            let he = this.he0;
                            while ((i > 0)) {
                                {
                                    he = he.next;
                                    i--;
                                }
                            }
                            ;
                            while ((i < 0)) {
                                {
                                    he = he.prev;
                                    i++;
                                }
                            }
                            ;
                            return he;
                        }
                        getFirstEdge() {
                            return this.he0;
                        }
                        /**
                         * Finds the half-edge within this face which has tail <code>vt</code> and head
                         * <code>vh</code>.
                         *
                         * @param {com.vzome.core.math.convexhull.Vertex} vt
                         * tail point
                         * @param {com.vzome.core.math.convexhull.Vertex} vh
                         * head point
                         * @return {com.vzome.core.math.convexhull.HalfEdge} the half-edge, or null if none is found.
                         */
                        findEdge(vt, vh) {
                            let he = this.he0;
                            do {
                                {
                                    if (he.head() === vh && he.tail() === vt) {
                                        return he;
                                    }
                                    he = he.next;
                                }
                            } while ((he !== this.he0));
                            return null;
                        }
                        /**
                         * Computes the distance from a point p to the plane of this face.
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} p
                         * the point
                         * @return {*} distance from the point to the plane
                         */
                        distanceToPlane(p) {
                            return this.normal.dot(p)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.planeOffset);
                        }
                        /**
                         * Returns the normal of the plane associated with this face.
                         *
                         * @return {com.vzome.core.algebra.AlgebraicVector} the planar normal
                         */
                        getNormal() {
                            return this.normal;
                        }
                        getCentroid() {
                            return this.centroid;
                        }
                        numVertices() {
                            return this.numVerts;
                        }
                        getVertexString() {
                            let s = null;
                            let he = this.he0;
                            do {
                                {
                                    if (s == null) {
                                        s = "" + he.head().index;
                                    }
                                    else {
                                        s += " " + he.head().index;
                                    }
                                    he = he.next;
                                }
                            } while ((he !== this.he0));
                            return s;
                        }
                        getVertexIndices(idxs) {
                            let he = this.he0;
                            let i = 0;
                            do {
                                {
                                    idxs[i++] = he.head().index;
                                    he = he.next;
                                }
                            } while ((he !== this.he0));
                        }
                        /*private*/ connectHalfEdges(hedgePrev, hedge) {
                            let discardedFace = null;
                            if (hedgePrev.oppositeFace() === hedge.oppositeFace()) {
                                const oppFace = hedge.oppositeFace();
                                let hedgeOpp;
                                if (hedgePrev === this.he0) {
                                    this.he0 = hedge;
                                }
                                if (oppFace.numVertices() === 3) {
                                    hedgeOpp = hedge.getOpposite().prev.getOpposite();
                                    oppFace.mark = Face.DELETED;
                                    discardedFace = oppFace;
                                }
                                else {
                                    hedgeOpp = hedge.getOpposite().next;
                                    if (oppFace.he0 === hedgeOpp.prev) {
                                        oppFace.he0 = hedgeOpp;
                                    }
                                    hedgeOpp.prev = hedgeOpp.prev.prev;
                                    hedgeOpp.prev.next = hedgeOpp;
                                }
                                hedge.prev = hedgePrev.prev;
                                hedge.prev.next = hedge;
                                hedge.opposite = hedgeOpp;
                                hedgeOpp.opposite = hedge;
                                oppFace.computeNormalAndCentroid$();
                            }
                            else {
                                hedgePrev.next = hedge;
                                hedge.prev = hedgePrev;
                            }
                            return discardedFace;
                        }
                        /*private*/ fail(msg) {
                            throw new com.vzome.core.commands.Command.Failure(msg);
                        }
                        checkConsistency() {
                            let hedge = this.he0;
                            let maxd = 0;
                            let numv = 0;
                            if (this.numVerts < 3) {
                                this.fail("degenerate face: " + this.getVertexString());
                            }
                            do {
                                {
                                    const hedgeOpp = hedge.getOpposite();
                                    if (hedgeOpp == null) {
                                        this.fail("face " + this.getVertexString() + ": unreflected half edge " + hedge.getVertexString());
                                    }
                                    else if (hedgeOpp.getOpposite() !== hedge) {
                                        this.fail("face " + this.getVertexString() + ": opposite half edge " + hedgeOpp.getVertexString() + " has opposite " + hedgeOpp.getOpposite().getVertexString());
                                    }
                                    if (hedgeOpp.head() !== hedge.tail() || hedge.head() !== hedgeOpp.tail()) {
                                        this.fail("face " + this.getVertexString() + ": half edge " + hedge.getVertexString() + " reflected by " + hedgeOpp.getVertexString());
                                    }
                                    const oppFace = hedgeOpp.face;
                                    if (oppFace == null) {
                                        this.fail("face " + this.getVertexString() + ": no face on half edge " + hedgeOpp.getVertexString());
                                    }
                                    else if (oppFace.mark === Face.DELETED) {
                                        this.fail("face " + this.getVertexString() + ": opposite face " + oppFace.getVertexString() + " not on hull");
                                    }
                                    const d = Math.abs(this.distanceToPlane(hedge.head().pnt).evaluate());
                                    if (d > maxd) {
                                        maxd = d;
                                    }
                                    numv++;
                                    hedge = hedge.next;
                                }
                            } while ((hedge !== this.he0));
                            if (numv !== this.numVerts) {
                                this.fail("face " + this.getVertexString() + " numVerts=" + this.numVerts + " should be " + numv);
                            }
                        }
                        mergeAdjacentFace(hedgeAdj, discarded) {
                            const oppFace = hedgeAdj.oppositeFace();
                            let numDiscarded = 0;
                            discarded[numDiscarded++] = oppFace;
                            oppFace.mark = Face.DELETED;
                            const hedgeOpp = hedgeAdj.getOpposite();
                            let hedgeAdjPrev = hedgeAdj.prev;
                            let hedgeAdjNext = hedgeAdj.next;
                            let hedgeOppPrev = hedgeOpp.prev;
                            let hedgeOppNext = hedgeOpp.next;
                            let foo = 0;
                            while ((hedgeAdjPrev.oppositeFace() === oppFace)) {
                                {
                                    hedgeAdjPrev = hedgeAdjPrev.prev;
                                    hedgeOppNext = hedgeOppNext.next;
                                    if (++foo > 1000) {
                                        this.fail("Oops, it\'s hung.");
                                    }
                                }
                            }
                            ;
                            foo = 0;
                            while ((hedgeAdjNext.oppositeFace() === oppFace)) {
                                {
                                    hedgeOppPrev = hedgeOppPrev.prev;
                                    hedgeAdjNext = hedgeAdjNext.next;
                                    if (++foo > 1000) {
                                        this.fail("Oops, it\'s hung.");
                                    }
                                }
                            }
                            ;
                            let hedge;
                            foo = 0;
                            for (hedge = hedgeOppNext; hedge !== hedgeOppPrev.next; hedge = hedge.next) {
                                {
                                    hedge.face = this;
                                    if (++foo > 1000) {
                                        this.fail("Oops, it\'s hung.");
                                    }
                                }
                                ;
                            }
                            if (hedgeAdj === this.he0) {
                                this.he0 = hedgeAdjNext;
                            }
                            let discardedFace;
                            discardedFace = this.connectHalfEdges(hedgeOppPrev, hedgeAdjNext);
                            if (discardedFace != null) {
                                discarded[numDiscarded++] = discardedFace;
                            }
                            discardedFace = this.connectHalfEdges(hedgeAdjPrev, hedgeOppNext);
                            if (discardedFace != null) {
                                discarded[numDiscarded++] = discardedFace;
                            }
                            this.computeNormalAndCentroid$();
                            this.checkConsistency();
                            return numDiscarded;
                        }
                        triangulate(newFaces) {
                            const minArea = 0;
                            let hedge;
                            if (this.numVertices() < 4) {
                                return;
                            }
                            const v0 = this.he0.head();
                            hedge = this.he0.next;
                            let oppPrev = hedge.opposite;
                            let face0 = null;
                            for (hedge = hedge.next; hedge !== this.he0.prev; hedge = hedge.next) {
                                {
                                    const face = Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$double(v0, hedge.prev.head(), hedge.head(), minArea);
                                    face.he0.next.setOpposite(oppPrev);
                                    face.he0.prev.setOpposite(hedge.opposite);
                                    oppPrev = face.he0;
                                    newFaces.add(face);
                                    if (face0 == null) {
                                        face0 = face;
                                    }
                                }
                                ;
                            }
                            hedge = new com.vzome.core.math.convexhull.HalfEdge(this.he0.prev.prev.head(), this);
                            hedge.setOpposite(oppPrev);
                            hedge.prev = this.he0;
                            hedge.prev.next = hedge;
                            hedge.next = this.he0.prev;
                            hedge.next.prev = hedge;
                            this.computeNormalAndCentroid$double(minArea);
                            this.checkConsistency();
                            for (let face = face0; face != null; face = face.next) {
                                {
                                    face.checkConsistency();
                                }
                                ;
                            }
                        }
                    }
                    Face.VISIBLE = 1;
                    Face.NON_CONVEX = 2;
                    Face.DELETED = 3;
                    convexhull.Face = Face;
                    Face["__class"] = "com.vzome.core.math.convexhull.Face";
                })(convexhull = math.convexhull || (math.convexhull = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var convexhull;
                (function (convexhull) {
                    /**
                     * Creates an empty convex hull object.
                     * @class
                     * @author John E. Lloyd, Fall 2004
                     */
                    class QuickHull3D {
                        constructor() {
                            this.findIndex = -1;
                            this.debug = false;
                            this.pointBuffer = [];
                            this.vertexPointIndices = [];
                            this.discardedFaces = [null, null, null];
                            this.maxVtxs = [null, null, null];
                            this.minVtxs = [null, null, null];
                            this.faces = (new java.util.Vector(16));
                            this.newFaces = (new java.util.LinkedList());
                            this.unclaimed = new com.vzome.core.math.convexhull.VertexList();
                            this.claimed = new com.vzome.core.math.convexhull.VertexList();
                            if (this.numVertices === undefined) {
                                this.numVertices = 0;
                            }
                            if (this.numFaces === undefined) {
                                this.numFaces = 0;
                            }
                            if (this.numPoints === undefined) {
                                this.numPoints = 0;
                            }
                        }
                        /**
                         * Returns true if debugging is enabled.
                         *
                         * @return {boolean} true is debugging is enabled
                         * @see QuickHull3D#setDebug
                         */
                        getDebug() {
                            return this.debug;
                        }
                        /**
                         * Enables the printing of debugging diagnostics.
                         *
                         * @param {boolean} enable
                         * if true, enables debugging
                         */
                        setDebug(enable) {
                            this.debug = enable;
                        }
                        /*private*/ addPointToFace(vtx, face) {
                            vtx.face = face;
                            if (face.outside == null) {
                                this.claimed.add(vtx);
                            }
                            else {
                                this.claimed.insertBefore(vtx, face.outside);
                            }
                            face.outside = vtx;
                        }
                        /*private*/ removePointFromFace(vtx, face) {
                            if (vtx === face.outside) {
                                if (vtx.next != null && vtx.next.face === face) {
                                    face.outside = vtx.next;
                                }
                                else {
                                    face.outside = null;
                                }
                            }
                            this.claimed.delete$com_vzome_core_math_convexhull_Vertex(vtx);
                        }
                        /*private*/ removeAllPointsFromFace(face) {
                            if (face.outside != null) {
                                let end = face.outside;
                                while ((end.next != null && end.next.face === face)) {
                                    {
                                        end = end.next;
                                    }
                                }
                                ;
                                this.claimed.delete$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(face.outside, end);
                                end.next = null;
                                return face.outside;
                            }
                            else {
                                return null;
                            }
                        }
                        /*private*/ findHalfEdge(tail, head) {
                            for (let index = this.faces.iterator(); index.hasNext();) {
                                let face = index.next();
                                {
                                    const he = face.findEdge(tail, head);
                                    if (he != null) {
                                        return he;
                                    }
                                }
                            }
                            return null;
                        }
                        setHull(coords, nump, faceIndices, numf) {
                            this.initBuffers(nump);
                            this.setPoints(coords, nump);
                            this.computeMaxAndMin();
                            for (let i = 0; i < numf; i++) {
                                {
                                    const face = com.vzome.core.math.convexhull.Face.create(this.pointBuffer, faceIndices[i]);
                                    let he = face.he0;
                                    do {
                                        {
                                            const heOpp = this.findHalfEdge(he.head(), he.tail());
                                            if (heOpp != null) {
                                                he.setOpposite(heOpp);
                                            }
                                            he = he.next;
                                        }
                                    } while ((he !== face.he0));
                                    this.faces.add(face);
                                }
                                ;
                            }
                        }
                        build$java_util_Collection(points) {
                            this.build$com_vzome_core_algebra_AlgebraicVector_A(points.toArray((s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(points.size())));
                        }
                        build$com_vzome_core_algebra_AlgebraicVector_A(points) {
                            this.build$com_vzome_core_algebra_AlgebraicVector_A$int(points, points.length);
                        }
                        build$com_vzome_core_algebra_AlgebraicVector_A$int(points, nump) {
                            if (nump < 4) {
                                throw new com.vzome.core.commands.Command.Failure("At least four input points are required for a 3d convex hull.\n\n" + nump + " specified.");
                            }
                            if (points.length < nump) {
                                throw new com.vzome.core.commands.Command.Failure("Point array too small for specified number of points");
                            }
                            this.printPointSet(points, nump);
                            this.initBuffers(nump);
                            this.setPoints(points, nump);
                            this.buildHull();
                        }
                        /**
                         * Constructs the convex hull of an array of points.
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector[]} points
                         * input points
                         * @param {number} nump
                         * number of input points
                         * @throws Failure
                         * if the number of input points is less than four or greater than the
                         * length of <code>points</code>, or the points are
                         * coincident, collinear, or coplanar.
                         */
                        build(points, nump) {
                            if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof com.vzome.core.algebra.AlgebraicVector))) || points === null) && ((typeof nump === 'number') || nump === null)) {
                                return this.build$com_vzome_core_algebra_AlgebraicVector_A$int(points, nump);
                            }
                            else if (((points != null && (points.constructor != null && points.constructor["__interfaces"] != null && points.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || points === null) && nump === undefined) {
                                return this.build$java_util_Collection(points);
                            }
                            else if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof com.vzome.core.algebra.AlgebraicVector))) || points === null) && nump === undefined) {
                                return this.build$com_vzome_core_algebra_AlgebraicVector_A(points);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         * prints the initial set of points.
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector[]} points
                         * input points
                         * @param {number} nump
                         * number of input points
                         */
                        printPointSet(points, nump) {
                            if (this.debug) {
                                console.info("initial point set:");
                                for (let i = 0; i < nump; i++) {
                                    {
                                        console.info(i + ": " + points[i]);
                                    }
                                    ;
                                }
                            }
                        }
                        /**
                         * Triangulates any non-triangular hull faces. In some cases, due to precision
                         * issues, the resulting triangles may be very thin or small, and hence appear
                         * to be non-convex (this same limitation is present in <a href=http://www.qhull.org>qhull</a>).
                         * @throws Failure
                         */
                        triangulate() {
                            this.newFaces.clear();
                            for (let index = this.faces.iterator(); index.hasNext();) {
                                let face = index.next();
                                {
                                    if (face.mark === com.vzome.core.math.convexhull.Face.VISIBLE) {
                                        face.triangulate(this.newFaces);
                                    }
                                }
                            }
                            for (let index = this.newFaces.iterator(); index.hasNext();) {
                                let face = index.next();
                                {
                                    this.faces.add(face);
                                }
                            }
                        }
                        initBuffers(nump) {
                            if (this.pointBuffer.length < nump) {
                                const newBuffer = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(nump);
                                this.vertexPointIndices = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(nump);
                                for (let i = 0; i < this.pointBuffer.length; i++) {
                                    {
                                        newBuffer[i] = this.pointBuffer[i];
                                    }
                                    ;
                                }
                                for (let i = this.pointBuffer.length; i < nump; i++) {
                                    {
                                        newBuffer[i] = null;
                                    }
                                    ;
                                }
                                this.pointBuffer = newBuffer;
                            }
                            this.faces.clear();
                            this.claimed.clear();
                            this.numFaces = 0;
                            this.numPoints = nump;
                        }
                        setPoints(pnts, nump) {
                            this.pointBuffer = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(nump);
                            for (let i = 0; i < nump; i++) {
                                {
                                    this.pointBuffer[i] = new com.vzome.core.math.convexhull.Vertex(pnts[i], i);
                                }
                                ;
                            }
                        }
                        computeMaxAndMin() {
                            for (let i = 0; i < 3; i++) {
                                {
                                    this.maxVtxs[i] = this.minVtxs[i] = this.pointBuffer[0];
                                }
                                ;
                            }
                            const max = this.pointBuffer[0].pnt;
                            let maxx = max.getComponent(com.vzome.core.algebra.AlgebraicVector.X).evaluate();
                            let maxy = max.getComponent(com.vzome.core.algebra.AlgebraicVector.Y).evaluate();
                            let maxz = max.getComponent(com.vzome.core.algebra.AlgebraicVector.Z).evaluate();
                            let minx = maxx;
                            let miny = maxy;
                            let minz = maxz;
                            for (let i = 1; i < this.numPoints; i++) {
                                {
                                    const pnt = this.pointBuffer[i].pnt;
                                    const pntx = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.X).evaluate();
                                    const pnty = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.Y).evaluate();
                                    const pntz = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.Z).evaluate();
                                    if (pntx > maxx) {
                                        maxx = pntx;
                                        this.maxVtxs[0] = this.pointBuffer[i];
                                    }
                                    else if (pntx < minx) {
                                        minx = pntx;
                                        this.minVtxs[0] = this.pointBuffer[i];
                                    }
                                    if (pnty > maxy) {
                                        maxy = pnty;
                                        this.maxVtxs[1] = this.pointBuffer[i];
                                    }
                                    else if (pnty < miny) {
                                        miny = pnty;
                                        this.minVtxs[1] = this.pointBuffer[i];
                                    }
                                    if (pntz > maxz) {
                                        maxz = pntz;
                                        this.maxVtxs[2] = this.pointBuffer[i];
                                    }
                                    else if (pntz < minz) {
                                        minz = pntz;
                                        this.minVtxs[2] = this.pointBuffer[i];
                                    }
                                }
                                ;
                            }
                        }
                        /**
                         * Creates the initial simplex from which the hull will be built.
                         */
                        createInitialSimplex() {
                            let max = 0;
                            let imax = 0;
                            for (let i = 0; i < 3; i++) {
                                {
                                    const diff = this.maxVtxs[i].pnt.getComponent(i)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.minVtxs[i].pnt.getComponent(i)).evaluate();
                                    if (diff > max) {
                                        max = diff;
                                        imax = i;
                                    }
                                }
                                ;
                            }
                            if (max <= 0) {
                                throw new com.vzome.core.commands.Command.Failure("Input points are coincident");
                            }
                            const vtx = [null, null, null, null];
                            vtx[0] = this.maxVtxs[imax];
                            vtx[1] = this.minVtxs[imax];
                            let diff02;
                            let nrml = null;
                            let maxSqr = 0;
                            const u01 = vtx[1].pnt.minus(vtx[0].pnt);
                            for (let i = 0; i < this.numPoints; i++) {
                                {
                                    diff02 = this.pointBuffer[i].pnt.minus(vtx[0].pnt);
                                    const xprod = u01.cross(diff02);
                                    const lenSqr = xprod.dot(xprod);
                                    if (lenSqr.evaluate() > maxSqr && this.pointBuffer[i] !== vtx[0] && this.pointBuffer[i] !== vtx[1]) {
                                        maxSqr = lenSqr.evaluate();
                                        vtx[2] = this.pointBuffer[i];
                                        nrml = xprod;
                                    }
                                }
                                ;
                            }
                            if (maxSqr === 0) {
                                throw new com.vzome.core.commands.Command.Failure("Input points are collinear");
                            }
                            const res = u01.scale(nrml.dot(u01));
                            nrml = nrml.minus(res);
                            let maxDist = 0.0;
                            const d0 = vtx[2].pnt.dot(nrml);
                            for (let i = 0; i < this.numPoints; i++) {
                                {
                                    const dist = Math.abs(this.pointBuffer[i].pnt.dot(nrml)['minus$com_vzome_core_algebra_AlgebraicNumber'](d0).evaluate());
                                    if (dist > maxDist && this.pointBuffer[i] !== vtx[0] && this.pointBuffer[i] !== vtx[1] && this.pointBuffer[i] !== vtx[2]) {
                                        maxDist = dist;
                                        vtx[3] = this.pointBuffer[i];
                                    }
                                }
                                ;
                            }
                            if (maxDist === 0.0) {
                                throw new com.vzome.core.commands.Command.Failure("Input points are coplanar");
                            }
                            if (this.debug) {
                                console.info("initial vertices:");
                                console.info(vtx[0].index + ": " + vtx[0].pnt);
                                console.info(vtx[1].index + ": " + vtx[1].pnt);
                                console.info(vtx[2].index + ": " + vtx[2].pnt);
                                console.info(vtx[3].index + ": " + vtx[3].pnt);
                            }
                            const tris = [null, null, null, null];
                            if (vtx[3].pnt.dot(nrml)['minus$com_vzome_core_algebra_AlgebraicNumber'](d0).evaluate() < 0) {
                                tris[0] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[0], vtx[1], vtx[2]);
                                tris[1] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[1], vtx[0]);
                                tris[2] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[2], vtx[1]);
                                tris[3] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[0], vtx[2]);
                                for (let i = 0; i < 3; i++) {
                                    {
                                        const k = (i + 1) % 3;
                                        tris[i + 1].getEdge(1).setOpposite(tris[k + 1].getEdge(0));
                                        tris[i + 1].getEdge(2).setOpposite(tris[0].getEdge(k));
                                    }
                                    ;
                                }
                            }
                            else {
                                tris[0] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[0], vtx[2], vtx[1]);
                                tris[1] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[0], vtx[1]);
                                tris[2] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[1], vtx[2]);
                                tris[3] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[2], vtx[0]);
                                for (let i = 0; i < 3; i++) {
                                    {
                                        const k = (i + 1) % 3;
                                        tris[i + 1].getEdge(0).setOpposite(tris[k + 1].getEdge(1));
                                        tris[i + 1].getEdge(2).setOpposite(tris[0].getEdge((3 - i) % 3));
                                    }
                                    ;
                                }
                            }
                            for (let i = 0; i < 4; i++) {
                                {
                                    this.faces.add(tris[i]);
                                }
                                ;
                            }
                            for (let i = 0; i < this.numPoints; i++) {
                                {
                                    const v = this.pointBuffer[i];
                                    if (v === vtx[0] || v === vtx[1] || v === vtx[2] || v === vtx[3]) {
                                        continue;
                                    }
                                    maxDist = 0.0;
                                    let maxFace = null;
                                    for (let k = 0; k < 4; k++) {
                                        {
                                            const dist = tris[k].distanceToPlane(v.pnt).evaluate();
                                            if (dist > maxDist) {
                                                maxFace = tris[k];
                                                maxDist = dist;
                                            }
                                        }
                                        ;
                                    }
                                    if (maxFace != null) {
                                        this.addPointToFace(v, maxFace);
                                    }
                                }
                                ;
                            }
                        }
                        /**
                         * Returns the number of vertices in this hull.
                         *
                         * @return {number} number of vertices
                         */
                        getNumVertices() {
                            return this.numVertices;
                        }
                        getVertices$() {
                            const vtxs = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(this.numVertices);
                            for (let i = 0; i < this.numVertices; i++) {
                                {
                                    vtxs[i] = this.pointBuffer[this.vertexPointIndices[i]].pnt;
                                }
                                ;
                            }
                            return vtxs;
                        }
                        getVertices$com_vzome_core_algebra_AlgebraicNumber_A(coords) {
                            for (let i = 0; i < this.numVertices; i++) {
                                {
                                    const pnt = this.pointBuffer[this.vertexPointIndices[i]].pnt;
                                    coords[i * 3 + 0] = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.X);
                                    coords[i * 3 + 1] = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.Y);
                                    coords[i * 3 + 2] = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.Z);
                                }
                                ;
                            }
                            return this.numVertices;
                        }
                        /**
                         * Returns the coordinates of the vertex points of this hull.
                         *
                         * @param {com.vzome.core.algebra.AlgebraicNumber[]} coords
                         * returns the x, y, z coordinates of each vertex. This length of
                         * this array must be at least three times the number of vertices.
                         * @return {number} the number of vertices
                         * @see QuickHull3D#getVertices()
                         * @see QuickHull3D#getFaces()
                         */
                        getVertices(coords) {
                            if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (coords[0] != null && (coords[0].constructor != null && coords[0].constructor["__interfaces"] != null && coords[0].constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)))) || coords === null)) {
                                return this.getVertices$com_vzome_core_algebra_AlgebraicNumber_A(coords);
                            }
                            else if (coords === undefined) {
                                return this.getVertices$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         * Returns an array specifing the index of each hull vertex with respect to the
                         * original input points.
                         *
                         * @return {int[]} vertex indices with respect to the original points
                         */
                        getVertexPointIndices() {
                            const indices = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(this.numVertices);
                            for (let i = 0; i < this.numVertices; i++) {
                                {
                                    indices[i] = this.vertexPointIndices[i];
                                }
                                ;
                            }
                            return indices;
                        }
                        /**
                         * Returns the number of edges in this hull.
                         *
                         * @return {number} number of edges
                         */
                        getNumEdges() {
                            let count = 0;
                            for (let index = this.faces.iterator(); index.hasNext();) {
                                let face = index.next();
                                {
                                    count += face.numVertices();
                                }
                            }
                            return (count / 2 | 0);
                        }
                        /**
                         * Returns the number of faces in this hull.
                         *
                         * @return {number} number of faces
                         */
                        getNumFaces() {
                            return this.faces.size();
                        }
                        getFaces$() {
                            return this.getFaces$int(0);
                        }
                        getFaces$int(indexFlags) {
                            const allFaces = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(this.faces.size());
                            let k = 0;
                            for (let index = this.faces.iterator(); index.hasNext();) {
                                let face = index.next();
                                {
                                    allFaces[k] = (s => { let a = []; while (s-- > 0)
                                        a.push(0); return a; })(face.numVertices());
                                    this.getFaceIndices(allFaces[k], face, indexFlags);
                                    k++;
                                }
                            }
                            return allFaces;
                        }
                        /**
                         * Returns the faces associated with this hull.
                         *
                         * <p>
                         * Each face is represented by an integer array which gives the indices of the
                         * vertices. By default, these indices are numbered with respect to the hull
                         * vertices (as opposed to the input points), are zero-based, and are arranged
                         * counter-clockwise. However, this can be changed by setting
                         * {@link #POINT_RELATIVE}, {@link #INDEXED_FROM_ONE}, or {@link #CLOCKWISE} in the indexFlags
                         * parameter.
                         *
                         * @param {number} indexFlags
                         * specifies index characteristics (0 results in the default)
                         * @return {int[][]} array of integer arrays, giving the vertex indices for each face.
                         * @see QuickHull3D#getVertices()
                         */
                        getFaces(indexFlags) {
                            if (((typeof indexFlags === 'number') || indexFlags === null)) {
                                return this.getFaces$int(indexFlags);
                            }
                            else if (indexFlags === undefined) {
                                return this.getFaces$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        print$java_io_PrintStream(ps) {
                            this.print$java_io_PrintStream$int(ps, 0);
                        }
                        print$java_io_PrintStream$int(ps, indexFlags) {
                            if ((indexFlags & QuickHull3D.INDEXED_FROM_ZERO) === 0) {
                                indexFlags |= QuickHull3D.INDEXED_FROM_ONE;
                            }
                            for (let i = 0; i < this.numVertices; i++) {
                                {
                                    const pnt = this.pointBuffer[this.vertexPointIndices[i]].pnt;
                                    ps.println(pnt);
                                }
                                ;
                            }
                            for (let index = this.faces.iterator(); index.hasNext();) {
                                let face = index.next();
                                {
                                    const indices = (s => { let a = []; while (s-- > 0)
                                        a.push(0); return a; })(face.numVertices());
                                    this.getFaceIndices(indices, face, indexFlags);
                                    ps.print("f");
                                    for (let k = 0; k < indices.length; k++) {
                                        {
                                            ps.print(" " + indices[k]);
                                        }
                                        ;
                                    }
                                    ps.println("");
                                }
                            }
                        }
                        /**
                         * Prints the vertices and faces of this hull to the stream ps.
                         *
                         * <p>
                         * This is done using the Alias Wavefront .obj file format, with the vertices
                         * printed first (each preceding by the letter <code>v</code>), followed by the
                         * vertex indices for each face (each preceded by the letter <code>f</code>).
                         *
                         * <p>
                         * By default, the face indices are numbered with respect to the hull vertices
                         * (as opposed to the input points), with a lowest index of 1, and are arranged
                         * counter-clockwise. However, this can be changed by setting
                         * {@link #POINT_RELATIVE}, {@link #INDEXED_FROM_ONE}, or {@link #CLOCKWISE} in the indexFlags
                         * parameter.
                         *
                         * @param {java.io.PrintStream} ps
                         * stream used for printing
                         * @param {number} indexFlags
                         * specifies index characteristics (0 results in the default).
                         * @see QuickHull3D#getVertices()
                         * @see QuickHull3D#getFaces()
                         */
                        print(ps, indexFlags) {
                            if (((ps != null && ps instanceof java.io.PrintStream) || ps === null) && ((typeof indexFlags === 'number') || indexFlags === null)) {
                                return this.print$java_io_PrintStream$int(ps, indexFlags);
                            }
                            else if (((ps != null && ps instanceof java.io.PrintStream) || ps === null) && indexFlags === undefined) {
                                return this.print$java_io_PrintStream(ps);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /*private*/ getFaceIndices(indices, face, flags) {
                            const ccw = ((flags & QuickHull3D.CLOCKWISE) === 0);
                            const indexedFromOne = ((flags & QuickHull3D.INDEXED_FROM_ONE) !== 0);
                            const pointRelative = ((flags & QuickHull3D.POINT_RELATIVE) !== 0);
                            let hedge = face.he0;
                            let k = 0;
                            do {
                                {
                                    let idx = hedge.head().index;
                                    if (pointRelative) {
                                        idx = this.vertexPointIndices[idx];
                                    }
                                    if (indexedFromOne) {
                                        idx++;
                                    }
                                    indices[k++] = idx;
                                    hedge = (ccw ? hedge.next : hedge.prev);
                                }
                            } while ((hedge !== face.he0));
                        }
                        resolveUnclaimedPoints(newFaces) {
                            let vtxNext = this.unclaimed.first();
                            for (let vtx = vtxNext; vtx != null; vtx = vtxNext) {
                                {
                                    vtxNext = vtx.next;
                                    let maxDist = 0;
                                    let maxFace = null;
                                    for (let index = newFaces.iterator(); index.hasNext();) {
                                        let newFace = index.next();
                                        {
                                            if (newFace.mark === com.vzome.core.math.convexhull.Face.VISIBLE) {
                                                const dist = newFace.distanceToPlane(vtx.pnt).evaluate();
                                                if (dist > maxDist) {
                                                    maxDist = dist;
                                                    maxFace = newFace;
                                                }
                                                if (maxDist > 0) {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (maxFace != null) {
                                        this.addPointToFace(vtx, maxFace);
                                        if (this.debug && vtx.index === this.findIndex) {
                                            console.info(this.findIndex + " CLAIMED BY " + maxFace.getVertexString());
                                        }
                                    }
                                    else {
                                        if (this.debug && vtx.index === this.findIndex) {
                                            console.info(this.findIndex + " DISCARDED");
                                        }
                                    }
                                }
                                ;
                            }
                        }
                        deleteFacePoints(face, absorbingFace) {
                            const faceVtxs = this.removeAllPointsFromFace(face);
                            if (faceVtxs != null) {
                                if (absorbingFace == null) {
                                    this.unclaimed.addAll(faceVtxs);
                                }
                                else {
                                    let vtxNext = faceVtxs;
                                    for (let vtx = vtxNext; vtx != null; vtx = vtxNext) {
                                        {
                                            vtxNext = vtx.next;
                                            const dist = absorbingFace.distanceToPlane(vtx.pnt).evaluate();
                                            if (dist > 0) {
                                                this.addPointToFace(vtx, absorbingFace);
                                            }
                                            else {
                                                this.unclaimed.add(vtx);
                                            }
                                        }
                                        ;
                                    }
                                }
                            }
                        }
                        oppFaceDistance(he) {
                            return he.face.distanceToPlane(he.opposite.face.getCentroid());
                        }
                        /*private*/ doAdjacentMerge(face, mergeType) {
                            let hedge = face.he0;
                            let convex = true;
                            do {
                                {
                                    const oppFace = hedge.oppositeFace();
                                    let merge = false;
                                    const tolerance = 0;
                                    if (mergeType === QuickHull3D.NONCONVEX) {
                                        if (this.oppFaceDistance(hedge).evaluate() > -tolerance || this.oppFaceDistance(hedge.opposite).evaluate() > -tolerance) {
                                            merge = true;
                                        }
                                    }
                                    else {
                                        if (face.area > oppFace.area) {
                                            if (this.oppFaceDistance(hedge).evaluate() > -tolerance) {
                                                merge = true;
                                            }
                                            else if (this.oppFaceDistance(hedge.opposite).evaluate() > -tolerance) {
                                                convex = false;
                                            }
                                        }
                                        else {
                                            if (this.oppFaceDistance(hedge.opposite).evaluate() >= -tolerance) {
                                                merge = true;
                                            }
                                            else if (this.oppFaceDistance(hedge).evaluate() >= -tolerance) {
                                                convex = false;
                                            }
                                        }
                                    }
                                    if (merge) {
                                        if (this.debug) {
                                            console.info("  merging " + face.getVertexString() + "  and  " + oppFace.getVertexString());
                                        }
                                        const numd = face.mergeAdjacentFace(hedge, this.discardedFaces);
                                        for (let i = 0; i < numd; i++) {
                                            {
                                                this.deleteFacePoints(this.discardedFaces[i], face);
                                            }
                                            ;
                                        }
                                        if (this.debug) {
                                            console.info("  result: " + face.getVertexString());
                                        }
                                        return true;
                                    }
                                    hedge = hedge.next;
                                }
                            } while ((hedge !== face.he0));
                            if (!convex) {
                                face.mark = com.vzome.core.math.convexhull.Face.NON_CONVEX;
                            }
                            return false;
                        }
                        calculateHorizon(eyePnt, edge0, face, horizon) {
                            this.deleteFacePoints(face, null);
                            face.mark = com.vzome.core.math.convexhull.Face.DELETED;
                            if (this.debug) {
                                console.info("  visiting face " + face.getVertexString());
                            }
                            let edge;
                            if (edge0 == null) {
                                edge0 = face.getEdge(0);
                                edge = edge0;
                            }
                            else {
                                edge = edge0.getNext();
                            }
                            const tolerance = 0;
                            do {
                                {
                                    const oppFace = edge.oppositeFace();
                                    if (oppFace.mark === com.vzome.core.math.convexhull.Face.VISIBLE) {
                                        if (oppFace.distanceToPlane(eyePnt).evaluate() > tolerance) {
                                            this.calculateHorizon(eyePnt, edge.getOpposite(), oppFace, horizon);
                                        }
                                        else {
                                            horizon.add(edge);
                                            if (this.debug) {
                                                console.info("  adding horizon edge " + edge.getVertexString());
                                            }
                                        }
                                    }
                                    edge = edge.getNext();
                                }
                            } while ((edge !== edge0));
                        }
                        /*private*/ addAdjoiningFace(eyeVtx, he) {
                            const face = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(eyeVtx, he.tail(), he.head());
                            this.faces.add(face);
                            face.getEdge(-1).setOpposite(he.getOpposite());
                            return face.getEdge(0);
                        }
                        addNewFaces(newFaces, eyeVtx, horizon) {
                            newFaces.clear();
                            let hedgeSidePrev = null;
                            let hedgeSideBegin = null;
                            for (let index = horizon.iterator(); index.hasNext();) {
                                let horizonHe = index.next();
                                {
                                    const hedgeSide = this.addAdjoiningFace(eyeVtx, horizonHe);
                                    if (this.debug) {
                                        console.info("new face: " + hedgeSide.face.getVertexString());
                                    }
                                    if (hedgeSidePrev != null) {
                                        hedgeSide.next.setOpposite(hedgeSidePrev);
                                    }
                                    else {
                                        hedgeSideBegin = hedgeSide;
                                    }
                                    newFaces.add(hedgeSide.getFace());
                                    hedgeSidePrev = hedgeSide;
                                }
                            }
                            hedgeSideBegin.next.setOpposite(hedgeSidePrev);
                        }
                        nextPointToAdd() {
                            if (!this.claimed.isEmpty()) {
                                const eyeFace = this.claimed.first().face;
                                let eyeVtx = null;
                                let maxDist = 0;
                                for (let vtx = eyeFace.outside; vtx != null && vtx.face === eyeFace; vtx = vtx.next) {
                                    {
                                        const dist = eyeFace.distanceToPlane(vtx.pnt).evaluate();
                                        if (dist > maxDist) {
                                            maxDist = dist;
                                            eyeVtx = vtx;
                                        }
                                    }
                                    ;
                                }
                                return eyeVtx;
                            }
                            else {
                                return null;
                            }
                        }
                        addPointToHull(eyeVtx) {
                            const horizon = (new java.util.Vector());
                            this.unclaimed.clear();
                            if (this.debug) {
                                console.info("Adding point: " + eyeVtx.index);
                                console.info(" which is " + eyeVtx.face.distanceToPlane(eyeVtx.pnt) + " above face " + eyeVtx.face.getVertexString());
                            }
                            this.removePointFromFace(eyeVtx, eyeVtx.face);
                            this.calculateHorizon(eyeVtx.pnt, null, eyeVtx.face, horizon);
                            this.newFaces.clear();
                            this.addNewFaces(this.newFaces, eyeVtx, horizon);
                            for (let index = this.newFaces.iterator(); index.hasNext();) {
                                let face = index.next();
                                {
                                    if (face.mark === com.vzome.core.math.convexhull.Face.VISIBLE) {
                                        while ((this.doAdjacentMerge(face, QuickHull3D.NONCONVEX_WRT_LARGER_FACE))) { }
                                        ;
                                    }
                                }
                            }
                            for (let index = this.newFaces.iterator(); index.hasNext();) {
                                let face = index.next();
                                {
                                    if (face.mark === com.vzome.core.math.convexhull.Face.NON_CONVEX) {
                                        face.mark = com.vzome.core.math.convexhull.Face.VISIBLE;
                                        while ((this.doAdjacentMerge(face, QuickHull3D.NONCONVEX))) { }
                                        ;
                                    }
                                }
                            }
                            this.resolveUnclaimedPoints(this.newFaces);
                        }
                        buildHull() {
                            let cnt = 0;
                            let eyeVtx;
                            this.computeMaxAndMin();
                            this.createInitialSimplex();
                            while (((eyeVtx = this.nextPointToAdd()) != null)) {
                                {
                                    this.addPointToHull(eyeVtx);
                                    cnt++;
                                    if (this.debug) {
                                        console.info("iteration " + cnt + " done");
                                    }
                                }
                            }
                            ;
                            this.reindexFacesAndVertices();
                            if (this.debug) {
                                console.info("hull done");
                            }
                        }
                        /*private*/ markFaceVertices(face, mark) {
                            const he0 = face.getFirstEdge();
                            let he = he0;
                            do {
                                {
                                    he.head().index = mark;
                                    he = he.next;
                                }
                            } while ((he !== he0));
                        }
                        reindexFacesAndVertices() {
                            for (let i = 0; i < this.numPoints; i++) {
                                {
                                    this.pointBuffer[i].index = -1;
                                }
                                ;
                            }
                            this.numFaces = 0;
                            for (const it = this.faces.iterator(); it.hasNext();) {
                                {
                                    const face = it.next();
                                    if (face.mark !== com.vzome.core.math.convexhull.Face.VISIBLE) {
                                        it.remove();
                                    }
                                    else {
                                        this.markFaceVertices(face, 0);
                                        this.numFaces++;
                                    }
                                }
                                ;
                            }
                            this.numVertices = 0;
                            for (let i = 0; i < this.numPoints; i++) {
                                {
                                    const vtx = this.pointBuffer[i];
                                    if (vtx.index === 0) {
                                        this.vertexPointIndices[this.numVertices] = i;
                                        vtx.index = this.numVertices++;
                                    }
                                }
                                ;
                            }
                        }
                        checkFaceConvexity(face, ps) {
                            let he = face.he0;
                            do {
                                {
                                    face.checkConsistency();
                                    let dist = this.oppFaceDistance(he);
                                    if (!dist.isZero()) {
                                        if (ps != null) {
                                            ps.println("Edge " + he.getVertexString() + " non-convex by " + dist);
                                        }
                                        return false;
                                    }
                                    dist = this.oppFaceDistance(he.opposite);
                                    if (!dist.isZero()) {
                                        if (ps != null) {
                                            ps.println("Opposite edge " + he.opposite.getVertexString() + " non-convex by " + dist);
                                        }
                                        return false;
                                    }
                                    if (he.next.oppositeFace() === he.oppositeFace()) {
                                        if (ps != null) {
                                            ps.println("Redundant vertex " + he.head().index + " in face " + face.getVertexString());
                                        }
                                        return false;
                                    }
                                    he = he.next;
                                }
                            } while ((he !== face.he0));
                            return true;
                        }
                        checkFaces(ps) {
                            let convex = true;
                            for (let index = this.faces.iterator(); index.hasNext();) {
                                let face = index.next();
                                {
                                    if (face.mark === com.vzome.core.math.convexhull.Face.VISIBLE) {
                                        if (!this.checkFaceConvexity(face, ps)) {
                                            convex = false;
                                        }
                                    }
                                }
                            }
                            return convex;
                        }
                        /**
                         * Checks the correctness of the hull. This is done by making sure that no faces
                         * are non-convex and that no points are outside any face. These tests are
                         * performed using the distance tolerance <i>tol</i>. Faces are considered
                         * non-convex if any edge is non-convex, and an edge is non-convex if the
                         * centroid of either adjoining face is more than <i>tol</i> above the plane of
                         * the other face. Similarly, a point is considered outside a face if its
                         * distance to that face's plane is more than 10 times <i>tol</i>.
                         *
                         * <p>
                         * If the hull has been {@link #triangulate}, then this routine may
                         * fail if some of the resulting triangles are very small or thin.
                         *
                         * @param {java.io.PrintStream} ps
                         * print stream for diagnostic messages; may be set to
                         * <code>null</code> if no messages are desired.
                         * @return {boolean} true if the hull is valid
                         * @throws Failure
                         * @see QuickHull3D#check(PrintStream)
                         */
                        check(ps) {
                            if (!this.checkFaces(ps)) {
                                return false;
                            }
                            for (let i = 0; i < this.numPoints; i++) {
                                {
                                    const pnt = this.pointBuffer[i].pnt;
                                    for (let index = this.faces.iterator(); index.hasNext();) {
                                        let face = index.next();
                                        {
                                            if (face.mark === com.vzome.core.math.convexhull.Face.VISIBLE) {
                                                const dist = face.distanceToPlane(pnt);
                                                if (!dist.isZero()) {
                                                    if (ps != null) {
                                                        ps.println("Point " + i + " " + dist + " above face " + face.getVertexString());
                                                    }
                                                    return false;
                                                }
                                            }
                                        }
                                    }
                                }
                                ;
                            }
                            return true;
                        }
                    }
                    /**
                     * Specifies that (on output) vertex indices for a face should be listed in
                     * clockwise order.
                     */
                    QuickHull3D.CLOCKWISE = 1;
                    /**
                     * Specifies that (on output) the vertex indices for a face should be numbered
                     * starting from 1.
                     */
                    QuickHull3D.INDEXED_FROM_ONE = 2;
                    /**
                     * Specifies that (on output) the vertex indices for a face should be numbered
                     * starting from 0.
                     */
                    QuickHull3D.INDEXED_FROM_ZERO = 4;
                    /**
                     * Specifies that (on output) the vertex indices for a face should be numbered
                     * with respect to the original input points.
                     */
                    QuickHull3D.POINT_RELATIVE = 8;
                    QuickHull3D.NONCONVEX_WRT_LARGER_FACE = 1;
                    QuickHull3D.NONCONVEX = 2;
                    convexhull.QuickHull3D = QuickHull3D;
                    QuickHull3D["__class"] = "com.vzome.core.math.convexhull.QuickHull3D";
                })(convexhull = math.convexhull || (math.convexhull = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var convexhull;
                (function (convexhull) {
                    /**
                     * Maintains a double-linked list of vertices for use by QuickHull3D
                     * @class
                     */
                    class VertexList {
                        constructor() {
                            if (this.head === undefined) {
                                this.head = null;
                            }
                            if (this.tail === undefined) {
                                this.tail = null;
                            }
                        }
                        /**
                         * Clears this list.
                         */
                        clear() {
                            this.head = this.tail = null;
                        }
                        /**
                         * Adds a vertex to the end of this list.
                         * @param {com.vzome.core.math.convexhull.Vertex} vtx
                         */
                        add(vtx) {
                            if (this.head == null) {
                                this.head = vtx;
                            }
                            else {
                                this.tail.next = vtx;
                            }
                            vtx.prev = this.tail;
                            vtx.next = null;
                            this.tail = vtx;
                        }
                        /**
                         * Adds a chain of vertices to the end of this list.
                         * @param {com.vzome.core.math.convexhull.Vertex} vtx
                         */
                        addAll(vtx) {
                            if (this.head == null) {
                                this.head = vtx;
                            }
                            else {
                                this.tail.next = vtx;
                            }
                            vtx.prev = this.tail;
                            while ((vtx.next != null)) {
                                {
                                    vtx = vtx.next;
                                }
                            }
                            ;
                            this.tail = vtx;
                        }
                        delete$com_vzome_core_math_convexhull_Vertex(vtx) {
                            if (vtx.prev == null) {
                                this.head = vtx.next;
                            }
                            else {
                                vtx.prev.next = vtx.next;
                            }
                            if (vtx.next == null) {
                                this.tail = vtx.prev;
                            }
                            else {
                                vtx.next.prev = vtx.prev;
                            }
                        }
                        delete$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx1, vtx2) {
                            if (vtx1.prev == null) {
                                this.head = vtx2.next;
                            }
                            else {
                                vtx1.prev.next = vtx2.next;
                            }
                            if (vtx2.next == null) {
                                this.tail = vtx1.prev;
                            }
                            else {
                                vtx2.next.prev = vtx1.prev;
                            }
                        }
                        /**
                         * Deletes a chain of vertices from this list.
                         * @param {com.vzome.core.math.convexhull.Vertex} vtx1
                         * @param {com.vzome.core.math.convexhull.Vertex} vtx2
                         */
                        delete(vtx1, vtx2) {
                            if (((vtx1 != null && vtx1 instanceof com.vzome.core.math.convexhull.Vertex) || vtx1 === null) && ((vtx2 != null && vtx2 instanceof com.vzome.core.math.convexhull.Vertex) || vtx2 === null)) {
                                return this.delete$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx1, vtx2);
                            }
                            else if (((vtx1 != null && vtx1 instanceof com.vzome.core.math.convexhull.Vertex) || vtx1 === null) && vtx2 === undefined) {
                                return this.delete$com_vzome_core_math_convexhull_Vertex(vtx1);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         * Inserts a vertex into this list before another specificed vertex.
                         * @param {com.vzome.core.math.convexhull.Vertex} vtx
                         * @param {com.vzome.core.math.convexhull.Vertex} next
                         */
                        insertBefore(vtx, next) {
                            vtx.prev = next.prev;
                            if (next.prev == null) {
                                this.head = vtx;
                            }
                            else {
                                next.prev.next = vtx;
                            }
                            vtx.next = next;
                            next.prev = vtx;
                        }
                        /**
                         * Returns the first element in this list.
                         * @return {com.vzome.core.math.convexhull.Vertex}
                         */
                        first() {
                            return this.head;
                        }
                        /**
                         * Returns true if this list is empty.
                         * @return {boolean}
                         */
                        isEmpty() {
                            return this.head == null;
                        }
                    }
                    convexhull.VertexList = VertexList;
                    VertexList["__class"] = "com.vzome.core.math.convexhull.VertexList";
                })(convexhull = math.convexhull || (math.convexhull = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var convexhull;
                (function (convexhull) {
                    /**
                     * Constructs a HalfEdge with head vertex <code>v</code> and left-hand
                     * triangular face <code>f</code>.
                     *
                     * @param {com.vzome.core.math.convexhull.Vertex} v
                     * head vertex
                     * @param {com.vzome.core.math.convexhull.Face} f
                     * left-hand triangular face
                     * @class
                     * @author John E. Lloyd, Fall 2004
                     */
                    class HalfEdge {
                        constructor(v, f) {
                            if (((v != null && v instanceof com.vzome.core.math.convexhull.Vertex) || v === null) && ((f != null && f instanceof com.vzome.core.math.convexhull.Face) || f === null)) {
                                let __args = arguments;
                                if (this.vertex === undefined) {
                                    this.vertex = null;
                                }
                                if (this.face === undefined) {
                                    this.face = null;
                                }
                                if (this.next === undefined) {
                                    this.next = null;
                                }
                                if (this.prev === undefined) {
                                    this.prev = null;
                                }
                                if (this.opposite === undefined) {
                                    this.opposite = null;
                                }
                                this.vertex = v;
                                this.face = f;
                            }
                            else if (v === undefined && f === undefined) {
                                let __args = arguments;
                                if (this.vertex === undefined) {
                                    this.vertex = null;
                                }
                                if (this.face === undefined) {
                                    this.face = null;
                                }
                                if (this.next === undefined) {
                                    this.next = null;
                                }
                                if (this.prev === undefined) {
                                    this.prev = null;
                                }
                                if (this.opposite === undefined) {
                                    this.opposite = null;
                                }
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         * Sets the value of the next edge adjacent (counter-clockwise) to this one
                         * within the triangle.
                         *
                         * @param {com.vzome.core.math.convexhull.HalfEdge} edge
                         * next adjacent edge
                         */
                        setNext(edge) {
                            this.next = edge;
                        }
                        /**
                         * Gets the value of the next edge adjacent (counter-clockwise) to this one
                         * within the triangle.
                         *
                         * @return {com.vzome.core.math.convexhull.HalfEdge} next adjacent edge
                         */
                        getNext() {
                            return this.next;
                        }
                        /**
                         * Sets the value of the previous edge adjacent (clockwise) to this one within
                         * the triangle.
                         *
                         * @param {com.vzome.core.math.convexhull.HalfEdge} edge
                         * previous adjacent edge
                         */
                        setPrev(edge) {
                            this.prev = edge;
                        }
                        /**
                         * Gets the value of the previous edge adjacent (clockwise) to this one within
                         * the triangle.
                         *
                         * @return {com.vzome.core.math.convexhull.HalfEdge} previous adjacent edge
                         */
                        getPrev() {
                            return this.prev;
                        }
                        /**
                         * Returns the triangular face located to the left of this half-edge.
                         *
                         * @return {com.vzome.core.math.convexhull.Face} left-hand triangular face
                         */
                        getFace() {
                            return this.face;
                        }
                        /**
                         * Returns the half-edge opposite to this half-edge.
                         *
                         * @return {com.vzome.core.math.convexhull.HalfEdge} opposite half-edge
                         */
                        getOpposite() {
                            return this.opposite;
                        }
                        /**
                         * Sets the half-edge opposite to this half-edge.
                         *
                         * @param {com.vzome.core.math.convexhull.HalfEdge} edge
                         * opposite half-edge
                         */
                        setOpposite(edge) {
                            this.opposite = edge;
                            edge.opposite = this;
                        }
                        /**
                         * Returns the head vertex associated with this half-edge.
                         *
                         * @return {com.vzome.core.math.convexhull.Vertex} head vertex
                         */
                        head() {
                            return this.vertex;
                        }
                        /**
                         * Returns the tail vertex associated with this half-edge.
                         *
                         * @return {com.vzome.core.math.convexhull.Vertex} tail vertex
                         */
                        tail() {
                            return this.prev != null ? this.prev.vertex : null;
                        }
                        /**
                         * Returns the opposite triangular face associated with this half-edge.
                         *
                         * @return {com.vzome.core.math.convexhull.Face} opposite triangular face
                         */
                        oppositeFace() {
                            return this.opposite == null ? null : this.opposite.face;
                        }
                        /**
                         * Produces a string identifying this half-edge by the point index values of its
                         * tail and head vertices.
                         *
                         * @return {string} identifying string
                         */
                        getVertexString() {
                            if (this.tail() != null) {
                                return "" + this.tail().index + "-" + this.head().index;
                            }
                            else {
                                return "?-" + this.head().index;
                            }
                        }
                        /**
                         * Returns the length squared of this half-edge.
                         *
                         * @return {*} half-edge length squared
                         */
                        lengthSquared() {
                            if (this.tail() == null) {
                                return this.head().pnt.getField()['createRational$long'](-1);
                            }
                            const offset = this.head().pnt.minus(this.tail().pnt);
                            return offset.dot(offset);
                        }
                    }
                    convexhull.HalfEdge = HalfEdge;
                    HalfEdge["__class"] = "com.vzome.core.math.convexhull.HalfEdge";
                })(convexhull = math.convexhull || (math.convexhull = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} field
                 * @class
                 */
                class SixCubeProjection {
                    constructor(field) {
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        if (this.basis === undefined) {
                            this.basis = null;
                        }
                        this.field = field;
                        const zero = field.zero();
                        const one = field.one();
                        const nOne = one.negate();
                        const phi = field['createPower$int'](1);
                        this.basis = [null, null, null, null, null, null];
                        this.basis[0] = new com.vzome.core.algebra.AlgebraicVector(phi, one, zero);
                        this.basis[1] = new com.vzome.core.algebra.AlgebraicVector(phi, nOne, zero);
                        this.basis[2] = new com.vzome.core.algebra.AlgebraicVector(zero, phi, one);
                        this.basis[3] = new com.vzome.core.algebra.AlgebraicVector(zero, phi, nOne);
                        this.basis[4] = new com.vzome.core.algebra.AlgebraicVector(one, zero, phi);
                        this.basis[5] = new com.vzome.core.algebra.AlgebraicVector(nOne, zero, phi);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} source
                     * @param {boolean} wFirst
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    projectImage(source, wFirst) {
                        let result = this.field.origin(this.basis[0].dimension());
                        let pos = wFirst ? 0 : this.basis.length - 1;
                        for (let index = 0; index < this.basis.length; index++) {
                            let unitVector = this.basis[index];
                            {
                                const scalar = source.getComponent(pos);
                                result = result.plus(unitVector.scale(scalar));
                                pos = (pos + 1) % this.basis.length;
                            }
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    setXmlAttributes(xml) {
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getProjectionName() {
                        return "SixCube";
                    }
                }
                math.SixCubeProjection = SixCubeProjection;
                SixCubeProjection["__class"] = "com.vzome.core.math.SixCubeProjection";
                SixCubeProjection["__interfaces"] = ["com.vzome.core.math.Projection"];
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class A4Group {
                        constructor(field) {
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            this.ROOTS = [null, null, null, null];
                            this.WEIGHTS = [null, null, null, null];
                            this.ROOTS_R4 = [null, null, null, null];
                            if (this.ONE_FIFTH === undefined) {
                                this.ONE_FIFTH = null;
                            }
                            if (this.TWO_FIFTHS === undefined) {
                                this.TWO_FIFTHS = null;
                            }
                            if (this.THREE_FIFTHS === undefined) {
                                this.THREE_FIFTHS = null;
                            }
                            if (this.FOUR_FIFTHS === undefined) {
                                this.FOUR_FIFTHS = null;
                            }
                            this.field = field;
                            this.ONE_FIFTH = field['createRational$long$long'](1, 5);
                            this.TWO_FIFTHS = field['createRational$long$long'](2, 5);
                            this.THREE_FIFTHS = field['createRational$long$long'](3, 5);
                            this.FOUR_FIFTHS = field['createRational$long$long'](4, 5);
                            const neg_one = field['createRational$long'](-1);
                            this.ROOTS[0] = field.basisVector(5, 0);
                            this.ROOTS[0].setComponent(1, neg_one);
                            this.ROOTS[1] = field.basisVector(5, 1);
                            this.ROOTS[1].setComponent(2, neg_one);
                            this.ROOTS[2] = field.basisVector(5, 2);
                            this.ROOTS[2].setComponent(3, neg_one);
                            this.ROOTS[3] = field.basisVector(5, 3);
                            this.ROOTS[3].setComponent(4, neg_one);
                            this.WEIGHTS[0] = field.basisVector(5, 0);
                            this.WEIGHTS[0].setComponent(0, this.FOUR_FIFTHS);
                            this.WEIGHTS[0].setComponent(1, this.ONE_FIFTH.negate());
                            this.WEIGHTS[0].setComponent(2, this.ONE_FIFTH.negate());
                            this.WEIGHTS[0].setComponent(3, this.ONE_FIFTH.negate());
                            this.WEIGHTS[0].setComponent(4, this.ONE_FIFTH.negate());
                            this.WEIGHTS[1] = field.basisVector(5, 0);
                            this.WEIGHTS[1].setComponent(0, this.THREE_FIFTHS);
                            this.WEIGHTS[1].setComponent(1, this.THREE_FIFTHS);
                            this.WEIGHTS[1].setComponent(2, this.TWO_FIFTHS.negate());
                            this.WEIGHTS[1].setComponent(3, this.TWO_FIFTHS.negate());
                            this.WEIGHTS[1].setComponent(4, this.TWO_FIFTHS.negate());
                            this.WEIGHTS[2] = field.basisVector(5, 0);
                            this.WEIGHTS[2].setComponent(0, this.TWO_FIFTHS);
                            this.WEIGHTS[2].setComponent(1, this.TWO_FIFTHS);
                            this.WEIGHTS[2].setComponent(2, this.TWO_FIFTHS);
                            this.WEIGHTS[2].setComponent(3, this.THREE_FIFTHS.negate());
                            this.WEIGHTS[2].setComponent(4, this.THREE_FIFTHS.negate());
                            this.WEIGHTS[3] = field.basisVector(5, 0);
                            this.WEIGHTS[3].setComponent(0, this.ONE_FIFTH);
                            this.WEIGHTS[3].setComponent(1, this.ONE_FIFTH);
                            this.WEIGHTS[3].setComponent(2, this.ONE_FIFTH);
                            this.WEIGHTS[3].setComponent(3, this.ONE_FIFTH);
                            this.WEIGHTS[3].setComponent(4, this.FOUR_FIFTHS.negate());
                            const two = field['createRational$long'](2);
                            const two_neg = field['createRational$long'](-2);
                            this.ROOTS_R4[0] = field.basisVector(4, 1);
                            this.ROOTS_R4[0].setComponent(1, two);
                            this.ROOTS_R4[0].setComponent(2, two_neg);
                            this.ROOTS_R4[1] = field.basisVector(4, 1);
                            this.ROOTS_R4[1].setComponent(3, two_neg);
                            this.ROOTS_R4[1].setComponent(1, two_neg);
                            this.ROOTS_R4[2] = field.basisVector(4, 1);
                            this.ROOTS_R4[2].setComponent(1, two);
                            this.ROOTS_R4[2].setComponent(2, two);
                            this.ROOTS_R4[3] = field.basisVector(4, 3);
                            const root5 = field['createAlgebraicNumber$int$int$int$int'](-1, 2, 1, 0);
                            this.ROOTS_R4[3].setComponent(1, neg_one);
                            this.ROOTS_R4[3].setComponent(2, neg_one);
                            this.ROOTS_R4[3].setComponent(0, root5);
                        }
                        static S5_PERMS_$LI$() { if (A4Group.S5_PERMS == null) {
                            A4Group.S5_PERMS = [[0, 1, 2, 3, 4], [1, 2, 3, 4, 0], [2, 3, 4, 0, 1], [3, 4, 0, 1, 2], [4, 0, 1, 2, 3], [1, 2, 0, 3, 4], [2, 0, 3, 4, 1], [0, 3, 4, 1, 2], [3, 4, 1, 2, 0], [4, 1, 2, 0, 3], [0, 2, 3, 1, 4], [2, 3, 1, 4, 0], [3, 1, 4, 0, 2], [1, 4, 0, 2, 3], [4, 0, 2, 3, 1], [0, 1, 3, 4, 2], [1, 3, 4, 2, 0], [3, 4, 2, 0, 1], [4, 2, 0, 1, 3], [2, 0, 1, 3, 4], [3, 1, 2, 4, 0], [1, 2, 4, 0, 3], [2, 4, 0, 3, 1], [4, 0, 3, 1, 2], [0, 3, 1, 2, 4], [1, 4, 2, 3, 0], [4, 2, 3, 0, 1], [2, 3, 0, 1, 4], [3, 0, 1, 4, 2], [0, 1, 4, 2, 3], [1, 3, 2, 0, 4], [3, 2, 0, 4, 1], [2, 0, 4, 1, 3], [0, 4, 1, 3, 2], [4, 1, 3, 2, 0], [0, 2, 4, 3, 1], [2, 4, 3, 1, 0], [4, 3, 1, 0, 2], [3, 1, 0, 2, 4], [1, 0, 2, 4, 3], [2, 1, 3, 0, 4], [1, 3, 0, 4, 2], [3, 0, 4, 2, 1], [0, 4, 2, 1, 3], [4, 2, 1, 3, 0], [0, 3, 2, 4, 1], [3, 2, 4, 1, 0], [2, 4, 1, 0, 3], [4, 1, 0, 3, 2], [1, 0, 3, 2, 4], [2, 1, 4, 3, 0], [1, 4, 3, 0, 2], [4, 3, 0, 2, 1], [3, 0, 2, 1, 4], [0, 2, 1, 4, 3], [4, 3, 2, 1, 0], [3, 2, 1, 0, 4], [2, 1, 0, 4, 3], [1, 0, 4, 3, 2], [0, 4, 3, 2, 1], [0, 1, 3, 2, 4], [0, 2, 1, 3, 4], [0, 3, 2, 1, 4], [1, 0, 2, 3, 4], [1, 2, 3, 0, 4], [1, 3, 0, 2, 4], [2, 1, 0, 3, 4], [2, 0, 3, 1, 4], [2, 3, 1, 0, 4], [3, 1, 2, 0, 4], [3, 2, 0, 1, 4], [3, 0, 1, 2, 4], [0, 1, 2, 4, 3], [0, 2, 3, 4, 1], [0, 3, 1, 4, 2], [1, 0, 3, 4, 2], [1, 2, 0, 4, 3], [1, 3, 2, 4, 0], [2, 1, 3, 4, 0], [2, 0, 1, 4, 3], [2, 3, 0, 4, 1], [3, 1, 0, 4, 2], [3, 2, 1, 4, 0], [3, 0, 2, 4, 1], [0, 2, 4, 1, 3], [0, 3, 4, 2, 1], [1, 0, 4, 2, 3], [1, 2, 4, 3, 0], [1, 3, 4, 0, 2], [2, 1, 4, 0, 3], [2, 0, 4, 3, 1], [2, 3, 4, 1, 0], [3, 1, 4, 2, 0], [3, 2, 4, 0, 1], [3, 0, 4, 1, 2], [0, 4, 1, 2, 3], [0, 4, 2, 3, 1], [0, 4, 3, 1, 2], [1, 4, 0, 3, 2], [1, 4, 2, 0, 3], [1, 4, 3, 2, 0], [2, 4, 1, 3, 0], [2, 4, 0, 1, 3], [2, 4, 3, 0, 1], [3, 4, 1, 0, 2], [3, 4, 2, 1, 0], [3, 4, 0, 2, 1], [4, 0, 1, 3, 2], [4, 0, 2, 1, 3], [4, 0, 3, 2, 1], [4, 1, 0, 2, 3], [4, 1, 2, 3, 0], [4, 1, 3, 0, 2], [4, 2, 1, 0, 3], [4, 2, 0, 3, 1], [4, 2, 3, 1, 0], [4, 3, 1, 2, 0], [4, 3, 2, 0, 1], [0, 1, 4, 3, 2], [4, 3, 0, 1, 2]];
                        } return A4Group.S5_PERMS; }
                        /**
                         *
                         * @return {number}
                         */
                        getOrder() {
                            return A4Group.S5_PERMS_$LI$().length;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        groupAction(model, element) {
                            let result = this.field.origin(4);
                            let sum = this.field['createRational$long'](0);
                            for (let c = 0; c < 4; c++) {
                                {
                                    const source = model.getComponent(A4Group.S5_PERMS_$LI$()[element][c]);
                                    sum = sum['plus$com_vzome_core_algebra_AlgebraicNumber'](source);
                                    const scaled = this.ROOTS_R4[c].scale(sum);
                                    result = result.plus(scaled);
                                }
                                ;
                            }
                            return result.scale(this.field['createPower$int'](-1));
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getOrigin() {
                            return this.field.origin(5);
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getWeight(i) {
                            return this.WEIGHTS[i];
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getSimpleRoot(i) {
                            return this.ROOTS[i];
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getField() {
                            return this.field;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        chiralSubgroupAction(model, element) {
                            if (element >= 60)
                                return null;
                            let result = this.field.origin(4);
                            let sum = this.field['createRational$long'](0);
                            for (let c = 0; c < 4; c++) {
                                {
                                    const source = model.getComponent(A4Group.S5_PERMS_$LI$()[element][c]);
                                    sum = sum['plus$com_vzome_core_algebra_AlgebraicNumber'](source);
                                    const scaled = this.ROOTS_R4[c].scale(sum);
                                    result = result.plus(scaled);
                                }
                                ;
                            }
                            return result.scale(this.field['createPower$int'](-1));
                        }
                    }
                    symmetry.A4Group = A4Group;
                    A4Group["__class"] = "com.vzome.core.math.symmetry.A4Group";
                    A4Group["__interfaces"] = ["com.vzome.core.math.symmetry.CoxeterGroup"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class WythoffConstruction {
                        static constructPolytope(group, index, edgesToRender, edgeScales, renderingGroup, listener) {
                            const neighbors = [null, null, null, null];
                            const chiral = false;
                            if (chiral) {
                                index = edgesToRender = 15;
                            }
                            const origin = group.getOrigin();
                            let model = origin;
                            let bits = index;
                            for (let i = 0; i < 4; i++) {
                                {
                                    if (bits % 2 === 1)
                                        model = model.plus(group.getWeight(i).scale(edgeScales[i]));
                                    bits >>= 1;
                                }
                                ;
                            }
                            bits = index;
                            for (let i = 0; i < 4; i++) {
                                {
                                    if ((bits % 2 === 1) && (edgesToRender % 2 === 1))
                                        neighbors[i] = model.minus(group.getSimpleRoot(i).scale(edgeScales[i]));
                                    else
                                        neighbors[i] = origin;
                                    bits >>= 1;
                                    edgesToRender >>= 1;
                                }
                                ;
                            }
                            const order = renderingGroup.getOrder();
                            if (chiral) {
                                for (let i = 0; i < order; i++) {
                                    {
                                        const vector = renderingGroup.chiralSubgroupAction(model, i);
                                        if (vector == null)
                                            continue;
                                        for (let e = 0; e < 4; e++) {
                                            for (let f = e + 1; f < 4; f++) {
                                                {
                                                    const v1 = renderingGroup.chiralSubgroupAction(neighbors[e], i);
                                                    const p1 = listener.addVertex(v1);
                                                    const v2 = renderingGroup.chiralSubgroupAction(neighbors[f], i);
                                                    const p2 = listener.addVertex(v2);
                                                    listener.addEdge(p1, p2);
                                                }
                                                ;
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                            else
                                for (let i = 0; i < order; i++) {
                                    {
                                        const vector = renderingGroup.groupAction(model, i);
                                        const p = listener.addVertex(vector);
                                        for (let e = 0; e < 4; e++) {
                                            {
                                                if (neighbors[e].equals(origin))
                                                    continue;
                                                const other = renderingGroup.groupAction(neighbors[e], i);
                                                if (!other.equals(vector)) {
                                                    const p2 = listener.addVertex(other);
                                                    listener.addEdge(p, p2);
                                                }
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                        }
                    }
                    symmetry.WythoffConstruction = WythoffConstruction;
                    WythoffConstruction["__class"] = "com.vzome.core.math.symmetry.WythoffConstruction";
                    (function (WythoffConstruction) {
                        class VefPrinter {
                            constructor(field2) {
                                this.vefVertices = new java.lang.StringBuffer();
                                this.vefEdges = new java.lang.StringBuffer();
                                this.numEdges = 0;
                                this.numVertices = 0;
                                if (this.field === undefined) {
                                    this.field = null;
                                }
                                this.field = field2;
                            }
                            /**
                             *
                             * @param {*} p1
                             * @param {*} p2
                             * @return {*}
                             */
                            addEdge(p1, p2) {
                                this.vefEdges.append(p1 + "\t" + p2 + "\n");
                                ++this.numEdges;
                                return null;
                            }
                            /**
                             *
                             * @param {java.lang.Object[]} vertices
                             * @return {*}
                             */
                            addFace(vertices) {
                                return null;
                            }
                            /**
                             *
                             * @param {com.vzome.core.algebra.AlgebraicVector} gv
                             * @return {*}
                             */
                            addVertex(gv) {
                                gv.getVectorExpression$java_lang_StringBuffer$int(this.vefVertices, com.vzome.core.algebra.AlgebraicField.VEF_FORMAT);
                                this.vefVertices.append("\n");
                                return this.numVertices++;
                            }
                            print(out) {
                                out.println$java_lang_Object("vZome VEF 5");
                                out.println$java_lang_Object(this.numVertices);
                                out.println$java_lang_Object(this.vefVertices.toString());
                                out.println$java_lang_Object(this.numEdges);
                                out.println$java_lang_Object(this.vefEdges.toString());
                                out.close();
                            }
                        }
                        WythoffConstruction.VefPrinter = VefPrinter;
                        VefPrinter["__class"] = "com.vzome.core.math.symmetry.WythoffConstruction.VefPrinter";
                        VefPrinter["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];
                    })(WythoffConstruction = symmetry.WythoffConstruction || (symmetry.WythoffConstruction = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class D4Group {
                        constructor(field) {
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            this.ROOTS = [null, null, null, null];
                            this.WEIGHTS = [null, null, null, null];
                            this.field = field;
                            const neg_one = field['createRational$long'](-1);
                            this.ROOTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.ROOTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_one);
                            this.ROOTS[1] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
                            this.ROOTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_one);
                            this.ROOTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
                            this.ROOTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_one);
                            this.ROOTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
                            this.ROOTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, field.one());
                            const y = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
                            const half = field['createRational$long$long'](1, 2);
                            const neg_half = field['createRational$long$long'](-1, 2);
                            this.WEIGHTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.WEIGHTS[1] = this.WEIGHTS[0].plus(y);
                            this.WEIGHTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_half);
                            this.WEIGHTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, half);
                        }
                        static D4_PERMS_$LI$() { if (D4Group.D4_PERMS == null) {
                            D4Group.D4_PERMS = [[0, 1, 2, 3], [2, 3, 0, 1], [1, 0, 3, 2], [3, 2, 1, 0], [2, 1, 3, 0], [3, 0, 2, 1], [1, 2, 0, 3], [0, 3, 1, 2], [0, 2, 3, 1], [3, 1, 0, 2], [2, 0, 1, 3], [1, 3, 2, 0], [1, 0, 2, 3], [2, 3, 1, 0], [0, 1, 3, 2], [3, 2, 0, 1], [0, 2, 1, 3], [1, 3, 0, 2], [2, 0, 3, 1], [3, 1, 2, 0], [2, 1, 0, 3], [0, 3, 2, 1], [1, 2, 3, 0], [3, 0, 1, 2]];
                        } return D4Group.D4_PERMS; }
                        /**
                         *
                         * @return {number}
                         */
                        getOrder() {
                            return 24 * 8;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        groupAction(model, element) {
                            const result = this.field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            const perm = (element / 8 | 0);
                            let signs = element % 8;
                            let even = true;
                            for (let c = 0; c < 4; c++) {
                                {
                                    let source = model.getComponent((D4Group.D4_PERMS_$LI$()[perm][c] + 1) % 4);
                                    if (c === 3 && !even) {
                                        source = source.negate();
                                    }
                                    else if (signs % 2 !== 0) {
                                        even = !even;
                                        source = source.negate();
                                    }
                                    result.setComponent((c + 1) % 4, source);
                                    signs = signs >> 1;
                                }
                                ;
                            }
                            return result;
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getOrigin() {
                            return this.field.origin(4);
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getWeight(i) {
                            return this.WEIGHTS[i];
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getSimpleRoot(i) {
                            return this.ROOTS[i];
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getField() {
                            return this.field;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        chiralSubgroupAction(model, element) {
                            const result = this.field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            const perm = (element / 8 | 0);
                            if (perm >= 12)
                                return null;
                            let signs = element % 8;
                            let even = true;
                            for (let c = 0; c < 4; c++) {
                                {
                                    let source = model.getComponent((D4Group.D4_PERMS_$LI$()[perm][c] + 1) % 4);
                                    if (c === 3 && !even) {
                                        source = source.negate();
                                    }
                                    else if (signs % 2 !== 0) {
                                        even = !even;
                                        source = source.negate();
                                    }
                                    result.setComponent((c + 1) % 4, source);
                                    signs = signs >> 1;
                                }
                                ;
                            }
                            return result;
                        }
                    }
                    symmetry.D4Group = D4Group;
                    D4Group["__class"] = "com.vzome.core.math.symmetry.D4Group";
                    D4Group["__interfaces"] = ["com.vzome.core.math.symmetry.CoxeterGroup"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    let SpecialOrbit;
                    (function (SpecialOrbit) {
                        SpecialOrbit[SpecialOrbit["BLUE"] = 0] = "BLUE";
                        SpecialOrbit[SpecialOrbit["RED"] = 1] = "RED";
                        SpecialOrbit[SpecialOrbit["YELLOW"] = 2] = "YELLOW";
                        SpecialOrbit[SpecialOrbit["BLACK"] = 3] = "BLACK";
                    })(SpecialOrbit = symmetry.SpecialOrbit || (symmetry.SpecialOrbit = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class Permutation {
                        constructor(group, map) {
                            if (this.m_map === undefined) {
                                this.m_map = null;
                            }
                            this.m_order = 1;
                            if (this.mSymmetryGroup === undefined) {
                                this.mSymmetryGroup = null;
                            }
                            this.mSymmetryGroup = group;
                            if (map == null) {
                                const numUnits = group.getChiralOrder();
                                map = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(numUnits);
                                for (let unit = 0; unit < numUnits; unit++) {
                                    map[unit] = unit;
                                }
                            }
                            this.m_map = map;
                            let unit = 0;
                            for (let i = 0; i < this.m_map.length; i++) {
                                {
                                    unit = this.m_map[unit];
                                    if (unit === 0) {
                                        this.m_order = i + 1;
                                        break;
                                    }
                                }
                                ;
                            }
                        }
                        getJsonValue() {
                            return this.m_map;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        toString() {
                            return "permutation #" + this.mapIndex(0);
                        }
                        getOrder() {
                            return this.m_order;
                        }
                        /**
                         * Composition, where p1.compose( p2 ) .permute(axis)  == p1.permute( p2.permute( axis ) )
                         * @param {com.vzome.core.math.symmetry.Permutation} other
                         * @return {com.vzome.core.math.symmetry.Permutation}
                         */
                        compose(other) {
                            return this.mSymmetryGroup.getPermutation(this.m_map[other.m_map[0]]);
                        }
                        inverse() {
                            for (let i = 0; i < this.m_map.length; i++) {
                                if (this.mapIndex(i) === 0)
                                    return this.mSymmetryGroup.getPermutation(i);
                                ;
                            }
                            return null;
                        }
                        power(power) {
                            if (power === 0)
                                return this.mSymmetryGroup.getPermutation(0);
                            let base = this;
                            if (power < 0) {
                                base = this.inverse();
                                power *= -1;
                            }
                            if (power === 1)
                                return base;
                            return base.compose(base.power(power - 1));
                        }
                        mapIndex(i) {
                            if ((i < 0) || (i >= this.m_map.length))
                                return com.vzome.core.math.symmetry.Symmetry.NO_ROTATION;
                            return this.m_map[i];
                        }
                        permute(axis, sense) {
                            let orn = axis.getOrientation();
                            orn = this.mapIndex(orn);
                            return axis.getDirection().getAxis$int$int((sense + axis.getSense()) % 2, orn);
                        }
                    }
                    symmetry.Permutation = Permutation;
                    Permutation["__class"] = "com.vzome.core.math.symmetry.Permutation";
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry_1) {
                    class OrbitDotLocator {
                        constructor(symmetry, worldTriangle) {
                            if (this.worldTrianglePoint === undefined) {
                                this.worldTrianglePoint = null;
                            }
                            if (this.worldTriangleNormal === undefined) {
                                this.worldTriangleNormal = null;
                            }
                            if (this.dotTransform === undefined) {
                                this.dotTransform = null;
                            }
                            if (this.orbitProbe === undefined) {
                                this.orbitProbe = null;
                            }
                            if (this.symmetry === undefined) {
                                this.symmetry = null;
                            }
                            if (this.debugger === undefined) {
                                this.debugger = null;
                            }
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            if (this.vefDebugOutput === undefined) {
                                this.vefDebugOutput = null;
                            }
                            this.symmetry = symmetry;
                            this.field = symmetry.getField();
                            const oldMatrix = new com.vzome.core.algebra.AlgebraicMatrix(worldTriangle);
                            const X = this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                            const Y = this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
                            const Z = this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                            const viewTriangle = [Z, X.plus(Z), Y.plus(Z)];
                            const newMatrix = new com.vzome.core.algebra.AlgebraicMatrix(viewTriangle);
                            this.dotTransform = newMatrix.times(oldMatrix.inverse());
                            const blueVertex = worldTriangle[0];
                            const redVertex = worldTriangle[1];
                            const yellowVertex = worldTriangle[2];
                            this.orbitProbe = redVertex.plus(yellowVertex.plus(blueVertex)).toRealVector();
                            this.worldTrianglePoint = blueVertex;
                            this.worldTriangleNormal = com.vzome.core.algebra.AlgebraicVectors.getNormal$java_util_Collection(java.util.Arrays.asList(worldTriangle));
                            if (this.debugger != null) {
                                this.debugger.exportSegment(this.field.origin(3), redVertex);
                                this.debugger.exportPoint(redVertex);
                                this.debugger.exportSegment(this.field.origin(3), yellowVertex);
                                this.debugger.exportPoint(yellowVertex);
                                this.debugger.exportSegment(this.field.origin(3), blueVertex);
                                this.debugger.exportPoint(blueVertex);
                                this.debugger.exportPolygon(java.util.Arrays.asList(worldTriangle));
                                this.debugger.exportPolygon(java.util.Arrays.asList(viewTriangle));
                                this.debugger.exportSegment(blueVertex, this.worldTriangleNormal);
                            }
                        }
                        enableDebugger() {
                            this.vefDebugOutput = new java.io.StringWriter();
                            this.debugger = new com.vzome.core.algebra.VefVectorExporter(this.vefDebugOutput, this.field);
                        }
                        locateOrbitDot(orbit) {
                            const dotZone = this.symmetry['getAxis$com_vzome_core_math_RealVector$java_util_Collection'](this.orbitProbe, java.util.Collections.singleton(orbit)).normal();
                            const lineStart = this.field.origin(3);
                            const worldDot = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(lineStart, dotZone, this.worldTrianglePoint, this.worldTriangleNormal);
                            const viewDot = this.dotTransform.timesColumn(worldDot);
                            const dotX = viewDot.getComponent(com.vzome.core.algebra.AlgebraicVector.X).evaluate();
                            const dotY = viewDot.getComponent(com.vzome.core.algebra.AlgebraicVector.Y).evaluate();
                            orbit.setDotLocation(dotX, dotY);
                            if (this.debugger != null) {
                                this.debugger.exportSegment(this.field.origin(3), dotZone);
                                this.debugger.exportPoint(worldDot);
                                this.debugger.exportPoint(viewDot);
                            }
                        }
                        getDebuggerOutput() {
                            this.debugger.finishExport();
                            this.debugger = null;
                            return this.vefDebugOutput.toString();
                        }
                    }
                    symmetry_1.OrbitDotLocator = OrbitDotLocator;
                    OrbitDotLocator["__class"] = "com.vzome.core.math.symmetry.OrbitDotLocator";
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * Should be called Zone, an infinite family of parallel lines, one member of an orbit (Direction)
                     * of a Symmetry group.
                     * @class
                     */
                    class Axis {
                        constructor(dir, index, sense, rotation, rotPerm, normal, outbound) {
                            if (((dir != null && dir instanceof com.vzome.core.math.symmetry.Direction) || dir === null) && ((typeof index === 'number') || index === null) && ((typeof sense === 'number') || sense === null) && ((typeof rotation === 'number') || rotation === null) && ((rotPerm != null && rotPerm instanceof com.vzome.core.math.symmetry.Permutation) || rotPerm === null) && ((normal != null && normal instanceof com.vzome.core.algebra.AlgebraicVector) || normal === null) && ((typeof outbound === 'boolean') || outbound === null)) {
                                let __args = arguments;
                                if (this.mDirection === undefined) {
                                    this.mDirection = null;
                                }
                                if (this.orientation === undefined) {
                                    this.orientation = 0;
                                }
                                if (this.mSense === undefined) {
                                    this.mSense = 0;
                                }
                                if (this.mRotationPerm === undefined) {
                                    this.mRotationPerm = null;
                                }
                                if (this.mRotation === undefined) {
                                    this.mRotation = 0;
                                }
                                if (this.__normal === undefined) {
                                    this.__normal = null;
                                }
                                this.outbound = true;
                                this.mDirection = dir;
                                this.mRotation = rotation;
                                this.mRotationPerm = rotPerm;
                                this.orientation = index;
                                this.__normal = normal;
                                this.mSense = sense;
                                this.outbound = outbound;
                            }
                            else if (((dir != null && dir instanceof com.vzome.core.math.symmetry.Direction) || dir === null) && ((typeof index === 'number') || index === null) && ((typeof sense === 'number') || sense === null) && ((typeof rotation === 'number') || rotation === null) && ((rotPerm != null && rotPerm instanceof com.vzome.core.math.symmetry.Permutation) || rotPerm === null) && ((normal != null && normal instanceof com.vzome.core.algebra.AlgebraicVector) || normal === null) && outbound === undefined) {
                                let __args = arguments;
                                {
                                    let __args = arguments;
                                    let outbound = true;
                                    if (this.mDirection === undefined) {
                                        this.mDirection = null;
                                    }
                                    if (this.orientation === undefined) {
                                        this.orientation = 0;
                                    }
                                    if (this.mSense === undefined) {
                                        this.mSense = 0;
                                    }
                                    if (this.mRotationPerm === undefined) {
                                        this.mRotationPerm = null;
                                    }
                                    if (this.mRotation === undefined) {
                                        this.mRotation = 0;
                                    }
                                    if (this.__normal === undefined) {
                                        this.__normal = null;
                                    }
                                    this.outbound = true;
                                    this.mDirection = dir;
                                    this.mRotation = rotation;
                                    this.mRotationPerm = rotPerm;
                                    this.orientation = index;
                                    this.__normal = normal;
                                    this.mSense = sense;
                                    this.outbound = outbound;
                                }
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         * Return the normal vector for this axis.
                         * Note that this vector may not have length=1.0, but it will have length
                         * equal to one "unit" for this axis.
                         * @return {com.vzome.core.algebra.AlgebraicVector} AlgebraicVector
                         */
                        normal() {
                            return this.__normal;
                        }
                        isOutbound() {
                            return this.outbound;
                        }
                        getLength(vector) {
                            return vector.getLength(this.__normal);
                        }
                        /**
                         *
                         * @return {number}
                         */
                        hashCode() {
                            const prime = 31;
                            let result = 1;
                            result = prime * result + ((this.mDirection == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                                return o.hashCode();
                            }
                            else {
                                return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                            } })(this.mDirection));
                            result = prime * result + this.mSense;
                            result = prime * result + ((this.__normal == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                                return o.hashCode();
                            }
                            else {
                                return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                            } })(this.__normal));
                            return result;
                        }
                        /**
                         *
                         * @param {*} obj
                         * @return {boolean}
                         */
                        equals(obj) {
                            if (this === obj)
                                return true;
                            if (obj == null)
                                return false;
                            if (this.constructor !== obj.constructor)
                                return false;
                            const other = obj;
                            if (this.mDirection == null) {
                                if (other.mDirection != null)
                                    return false;
                            }
                            else if (!this.mDirection.equals(other.mDirection))
                                return false;
                            if (this.mSense !== other.mSense)
                                return false;
                            if (this.__normal == null) {
                                if (other.__normal != null)
                                    return false;
                            }
                            else if (!this.__normal.equals(other.__normal))
                                return false;
                            return true;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        toString() {
                            return this.mDirection.toString() + " " + ((this.mSense === com.vzome.core.math.symmetry.Symmetry.PLUS) ? "+" : "-") + this.orientation + (this.outbound ? "" : "i");
                        }
                        getOrbit() {
                            return this.mDirection;
                        }
                        getDirection() {
                            return this.mDirection;
                        }
                        getOrientation() {
                            return this.orientation;
                        }
                        getRotation() {
                            return this.mRotation;
                        }
                        getCorrectRotation() {
                            return (this.mRotationPerm == null) ? com.vzome.core.math.symmetry.Symmetry.NO_ROTATION : this.mRotationPerm.mapIndex(0);
                        }
                        getRotationPermutation() {
                            return this.mRotationPerm;
                        }
                        getSense() {
                            return this.mSense;
                        }
                        /**
                         * @param plus
                         * @param {number} orientation2
                         * @param {boolean} outbound
                         * @param {number} sense
                         */
                        rename(sense, orientation2, outbound) {
                            this.mSense = sense;
                            this.orientation = orientation2;
                            this.outbound = outbound;
                        }
                        getXML(elem) {
                            com.vzome.xml.DomUtils.addAttribute(elem, "symm", this.mDirection.getSymmetry().getName());
                            com.vzome.xml.DomUtils.addAttribute(elem, "dir", this.mDirection.getName());
                            com.vzome.xml.DomUtils.addAttribute(elem, "orbit", this.mDirection.getCanonicalName());
                            com.vzome.xml.DomUtils.addAttribute(elem, "index", /* toString */ ('' + (this.orientation)));
                            if (this.mSense !== com.vzome.core.math.symmetry.Symmetry.PLUS)
                                com.vzome.xml.DomUtils.addAttribute(elem, "sense", "minus");
                        }
                    }
                    Axis.PLUS = 0;
                    Axis.MINUS = 1;
                    symmetry.Axis = Axis;
                    Axis["__class"] = "com.vzome.core.math.symmetry.Axis";
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     * @param {com.vzome.core.math.symmetry.Direction} dir
                     * @param {string} name
                     * @class
                     */
                    class DirectionNaming {
                        constructor(dir, name) {
                            if (this.mName === undefined) {
                                this.mName = null;
                            }
                            if (this.mDirection === undefined) {
                                this.mDirection = null;
                            }
                            this.mName = name;
                            this.mDirection = dir;
                        }
                        static SIGN_$LI$() { if (DirectionNaming.SIGN == null) {
                            DirectionNaming.SIGN = ["+", "-"];
                        } return DirectionNaming.SIGN; }
                        getName$() {
                            return this.mName;
                        }
                        /**
                         * Default behavior.
                         * @param {string} axisName
                         * @return
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getAxis(axisName) {
                            return this.mDirection.getAxis$int$int(this.getSign(axisName), this.getInteger(axisName));
                        }
                        getSign(axisName) {
                            if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "-"))
                                return com.vzome.core.math.symmetry.Symmetry.MINUS;
                            return com.vzome.core.math.symmetry.Symmetry.PLUS;
                        }
                        getInteger(axisName) {
                            if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "-") || /* startsWith */ ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "+"))
                                return javaemul.internal.IntegerHelper.parseInt(axisName.substring(1));
                            return javaemul.internal.IntegerHelper.parseInt(axisName);
                        }
                        getName$com_vzome_core_math_symmetry_Axis(axis) {
                            const sign = DirectionNaming.SIGN_$LI$()[axis.getSense()];
                            return sign + axis.getOrientation();
                        }
                        getName(axis) {
                            if (((axis != null && axis instanceof com.vzome.core.math.symmetry.Axis) || axis === null)) {
                                return this.getName$com_vzome_core_math_symmetry_Axis(axis);
                            }
                            else if (axis === undefined) {
                                return this.getName$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        getFullName(axis) {
                            return this.mName + " " + this.getName$com_vzome_core_math_symmetry_Axis(axis);
                        }
                        getDirection() {
                            return this.mDirection;
                        }
                    }
                    symmetry.DirectionNaming = DirectionNaming;
                    DirectionNaming["__class"] = "com.vzome.core.math.symmetry.DirectionNaming";
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     * @class
                     */
                    class AbstractSymmetry {
                        constructor(order, field, frameColor, principalReflection) {
                            this.mDirectionMap = (new java.util.HashMap());
                            this.mDirectionList = (new java.util.ArrayList());
                            this.orbitSet = new com.vzome.core.math.symmetry.OrbitSet(this);
                            if (this.mOrientations === undefined) {
                                this.mOrientations = null;
                            }
                            if (this.mMatrices === undefined) {
                                this.mMatrices = null;
                            }
                            if (this.mField === undefined) {
                                this.mField = null;
                            }
                            this.principalReflection = null;
                            if (this.dotLocator === undefined) {
                                this.dotLocator = null;
                            }
                            this.mField = field;
                            this.principalReflection = principalReflection;
                            this.mOrientations = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(order);
                            this.mMatrices = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(order);
                            this.createInitialPermutations();
                            let done = false;
                            while ((!done)) {
                                {
                                    done = true;
                                    for (let i = 1; i < order; i++) {
                                        {
                                            const p1 = this.mOrientations[i];
                                            if (p1 == null) {
                                                done = false;
                                                continue;
                                            }
                                            done = true;
                                            for (let j = 1; j < order; j++) {
                                                {
                                                    const p2 = this.mOrientations[j];
                                                    if (p2 == null) {
                                                        done = false;
                                                        continue;
                                                    }
                                                    const result = p1.mapIndex(p2.mapIndex(0));
                                                    if (this.mOrientations[result] != null)
                                                        continue;
                                                    const map = (s => { let a = []; while (s-- > 0)
                                                        a.push(0); return a; })(order);
                                                    for (let k = 0; k < order; k++) {
                                                        map[k] = p1.mapIndex(p2.mapIndex(k));
                                                    }
                                                    this.mOrientations[result] = new com.vzome.core.math.symmetry.Permutation(this, map);
                                                }
                                                ;
                                            }
                                            if (done)
                                                break;
                                        }
                                        ;
                                    }
                                }
                            }
                            ;
                            this.createFrameOrbit(frameColor);
                            this.createOtherOrbits();
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getField() {
                            return this.mField;
                        }
                        /**
                         *
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getPreferredAxis() {
                            return null;
                        }
                        createZoneOrbit$java_lang_String$int$int$int_A_A(name, prototype, rotatedPrototype, norm) {
                            const aNorm = this.mField.createVector(norm);
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(name, prototype, rotatedPrototype, aNorm, false);
                        }
                        createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector(name, prototype, rotatedPrototype, norm) {
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(name, prototype, rotatedPrototype, norm, false);
                        }
                        createZoneOrbit$java_lang_String$int$int$int_A_A$boolean(name, prototype, rotatedPrototype, norm, standard) {
                            const aNorm = this.mField.createVector(norm);
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean(name, prototype, rotatedPrototype, aNorm, standard, false);
                        }
                        createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(name, prototype, rotatedPrototype, norm, standard) {
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, false);
                        }
                        createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, halfSizes) {
                            const aNorm = this.mField.createVector(norm);
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, aNorm, standard, false, null);
                        }
                        createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, halfSizes) {
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, false, this.mField.one());
                        }
                        createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, halfSizes, unitLength) {
                            const aNorm = this.mField.createVector(norm);
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, aNorm, standard, halfSizes, unitLength);
                        }
                        createZoneOrbit(name, prototype, rotatedPrototype, norm, standard, halfSizes, unitLength) {
                            if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof Array && (norm.length == 0 || norm[0] == null || norm[0] instanceof Array)) || norm === null) && ((typeof standard === 'boolean') || standard === null) && ((typeof halfSizes === 'boolean') || halfSizes === null) && ((unitLength != null && (unitLength.constructor != null && unitLength.constructor["__interfaces"] != null && unitLength.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || unitLength === null)) {
                                return this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, halfSizes, unitLength);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof com.vzome.core.algebra.AlgebraicVector) || norm === null) && ((typeof standard === 'boolean') || standard === null) && ((typeof halfSizes === 'boolean') || halfSizes === null) && ((unitLength != null && (unitLength.constructor != null && unitLength.constructor["__interfaces"] != null && unitLength.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || unitLength === null)) {
                                return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, halfSizes, unitLength);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof Array && (norm.length == 0 || norm[0] == null || norm[0] instanceof Array)) || norm === null) && ((typeof standard === 'boolean') || standard === null) && ((typeof halfSizes === 'boolean') || halfSizes === null) && unitLength === undefined) {
                                return this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, halfSizes);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof com.vzome.core.algebra.AlgebraicVector) || norm === null) && ((typeof standard === 'boolean') || standard === null) && ((typeof halfSizes === 'boolean') || halfSizes === null) && unitLength === undefined) {
                                return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, halfSizes);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof Array && (norm.length == 0 || norm[0] == null || norm[0] instanceof Array)) || norm === null) && ((typeof standard === 'boolean') || standard === null) && halfSizes === undefined && unitLength === undefined) {
                                return this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean(name, prototype, rotatedPrototype, norm, standard);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof com.vzome.core.algebra.AlgebraicVector) || norm === null) && ((typeof standard === 'boolean') || standard === null) && halfSizes === undefined && unitLength === undefined) {
                                return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(name, prototype, rotatedPrototype, norm, standard);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof Array && (norm.length == 0 || norm[0] == null || norm[0] instanceof Array)) || norm === null) && standard === undefined && halfSizes === undefined && unitLength === undefined) {
                                return this.createZoneOrbit$java_lang_String$int$int$int_A_A(name, prototype, rotatedPrototype, norm);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof com.vzome.core.algebra.AlgebraicVector) || norm === null) && standard === undefined && halfSizes === undefined && unitLength === undefined) {
                                return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector(name, prototype, rotatedPrototype, norm);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, halfSizes, unitLength) {
                            const existingDir = this.mDirectionMap.get(name);
                            if (existingDir != null) {
                                this.mDirectionMap.remove(name);
                                this.orbitSet.remove(existingDir);
                                this.mDirectionList.remove(existingDir);
                            }
                            const orbit = new com.vzome.core.math.symmetry.Direction(name, this, prototype, rotatedPrototype, norm, standard);
                            if (halfSizes)
                                orbit.setHalfSizes(true);
                            orbit.setUnitLength(unitLength);
                            this.mDirectionMap.put(orbit.getName(), orbit);
                            this.mDirectionList.add(orbit);
                            this.orbitSet.add(orbit);
                            if (this.dotLocator != null)
                                this.dotLocator.locateOrbitDot(orbit);
                            return orbit;
                        }
                        /**
                         *
                         * @param {string} name
                         * @param {number} prototype
                         * @param {number} rotatedPrototype
                         * @param {com.vzome.core.algebra.AlgebraicVector} norm
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        createNewZoneOrbit(name, prototype, rotatedPrototype, norm) {
                            const orbit = new com.vzome.core.math.symmetry.Direction(name, this, prototype, rotatedPrototype, norm, false).withCorrection();
                            if (this.dotLocator == null)
                                this.dotLocator = new com.vzome.core.math.symmetry.OrbitDotLocator(this, this.getOrbitTriangle());
                            this.dotLocator.locateOrbitDot(orbit);
                            return orbit;
                        }
                        /**
                         *
                         * @return {com.vzome.core.math.symmetry.OrbitSet}
                         */
                        getOrbitSet() {
                            return this.orbitSet;
                        }
                        /**
                         * @param unit
                         * @param rot
                         * @return
                         * @param {number} from
                         * @param {number} to
                         * @return {number}
                         */
                        getMapping(from, to) {
                            if (to === com.vzome.core.math.symmetry.Symmetry.NO_ROTATION)
                                return com.vzome.core.math.symmetry.Symmetry.NO_ROTATION;
                            for (let p = 0; p < this.mOrientations.length; p++) {
                                if (this.mOrientations[p].mapIndex(from) === to)
                                    return p;
                                ;
                            }
                            return com.vzome.core.math.symmetry.Symmetry.NO_ROTATION;
                        }
                        mapAxis(from, to) {
                            return this.mapAxes([from], [to]);
                        }
                        mapAxes(from, to) {
                            if (from.length !== to.length)
                                throw new AbstractSymmetry.MismatchedAxes("must map to equal number of axes");
                            if (from.length > 3)
                                throw new AbstractSymmetry.MismatchedAxes("must map three or fewer axes");
                            for (let i = 0; i < from.length; i++) {
                                if (from[i].getDirection().equals(to[i].getDirection()))
                                    throw new AbstractSymmetry.MismatchedAxes("must map between same color axes");
                                ;
                            }
                            const result = [null];
                            return result[0];
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getDirections() {
                            return this.mDirectionList;
                        }
                        getAxis$com_vzome_core_algebra_AlgebraicVector(vector) {
                            return this.getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet(vector, this.orbitSet);
                        }
                        getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet(vector, orbits) {
                            if (vector.isOrigin()) {
                                return null;
                            }
                            const canonicalOrbit = this.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.BLACK);
                            if (canonicalOrbit == null)
                                for (let index = orbits.getDirections().iterator(); index.hasNext();) {
                                    let dir = index.next();
                                    {
                                        const candidate = dir.getAxis$com_vzome_core_algebra_AlgebraicVector(vector);
                                        if (candidate != null) {
                                            return candidate;
                                        }
                                    }
                                }
                            else {
                                const zone = canonicalOrbit.getAxis$com_vzome_core_math_RealVector(vector.toRealVector());
                                const orientation = zone.getOrientation();
                                const sense = zone.getSense();
                                for (let index = orbits.getDirections().iterator(); index.hasNext();) {
                                    let orbit = index.next();
                                    {
                                        const candidate = orbit.getCanonicalAxis(sense, orientation);
                                        if (com.vzome.core.algebra.AlgebraicVectors.areParallel(candidate.normal(), vector)) {
                                            return candidate;
                                        }
                                    }
                                }
                            }
                            return null;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @param {com.vzome.core.math.symmetry.OrbitSet} orbits
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getAxis(vector, orbits) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((orbits != null && orbits instanceof com.vzome.core.math.symmetry.OrbitSet) || orbits === null)) {
                                return this.getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet(vector, orbits);
                            }
                            else if (((vector != null && vector instanceof com.vzome.core.math.RealVector) || vector === null) && ((orbits != null && (orbits.constructor != null && orbits.constructor["__interfaces"] != null && orbits.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || orbits === null)) {
                                return this.getAxis$com_vzome_core_math_RealVector$java_util_Collection(vector, orbits);
                            }
                            else if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && orbits === undefined) {
                                return this.getAxis$com_vzome_core_algebra_AlgebraicVector(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        getAxis$com_vzome_core_math_RealVector$java_util_Collection(vector, dirMask) {
                            if (com.vzome.core.math.RealVector.ORIGIN_$LI$().equals(vector)) {
                                return null;
                            }
                            let maxCosine = -1.0;
                            let closest = null;
                            let orientation = -1;
                            let sense = -1;
                            const chiralOrbit = this.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.BLACK);
                            if (chiralOrbit != null) {
                                const closestChiralAxis = chiralOrbit.getChiralAxis(vector);
                                orientation = closestChiralAxis.getOrientation();
                                sense = closestChiralAxis.getSense();
                            }
                            const dirs = dirMask == null ? this.orbitSet.getDirections() : dirMask;
                            for (let index = dirs.iterator(); index.hasNext();) {
                                let dir = index.next();
                                {
                                    const axis = (orientation >= 0) ? dir.getCanonicalAxis(sense, orientation) : dir.getAxisBruteForce(vector);
                                    const axisV = axis.normal().toRealVector();
                                    const cosine = vector.dot(axisV) / (vector.length() * axisV.length());
                                    if (cosine > maxCosine) {
                                        maxCosine = cosine;
                                        closest = axis;
                                    }
                                }
                            }
                            return closest;
                        }
                        /**
                         *
                         * @return {number}
                         */
                        getChiralOrder() {
                            return this.mOrientations.length;
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.math.symmetry.Permutation}
                         */
                        getPermutation(i) {
                            if ((i < 0) || (i > this.mOrientations.length))
                                return null;
                            return this.mOrientations[i];
                        }
                        getPermutations() {
                            return this.mOrientations;
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicMatrix}
                         */
                        getMatrix(i) {
                            return this.mMatrices[i];
                        }
                        getMatrices() {
                            return this.mMatrices;
                        }
                        /**
                         *
                         * @param {number} orientation
                         * @return {number}
                         */
                        inverse(orientation) {
                            if ((orientation < 0) || (orientation > this.mOrientations.length))
                                return com.vzome.core.math.symmetry.Symmetry.NO_ROTATION;
                            return this.mOrientations[orientation].inverse().mapIndex(0);
                        }
                        /**
                         *
                         * @param {string} color
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getDirection(color) {
                            return this.mDirectionMap.get(color);
                        }
                        /**
                         *
                         * @return {java.lang.String[]}
                         */
                        getDirectionNames() {
                            const list = (new java.util.ArrayList());
                            for (let index = this.mDirectionList.iterator(); index.hasNext();) {
                                let dir = index.next();
                                {
                                    if (!dir.isAutomatic())
                                        list.add(dir.getName());
                                }
                            }
                            return list.toArray([]);
                        }
                        /**
                         *
                         * @param {int[]} perms
                         * @return {int[]}
                         */
                        closure(perms) {
                            const newPerms = (new java.util.ArrayList());
                            const knownPerms = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(this.mOrientations.length);
                            let closureSize = 0;
                            for (let i = 0; i < perms.length; i++) {
                                {
                                    const perm = this.mOrientations[perms[i]];
                                    knownPerms[perms[i]] = perm;
                                    newPerms.add(perm);
                                    ++closureSize;
                                }
                                ;
                            }
                            while ((!newPerms.isEmpty())) {
                                {
                                    const perm = newPerms.remove(0);
                                    for (let index = 0; index < knownPerms.length; index++) {
                                        let knownPerm = knownPerms[index];
                                        {
                                            if (knownPerm != null) {
                                                let composition = perm.compose(knownPerm);
                                                let j = composition.mapIndex(0);
                                                if (knownPerms[j] == null) {
                                                    newPerms.add(composition);
                                                    knownPerms[j] = composition;
                                                    ++closureSize;
                                                }
                                                composition = knownPerm.compose(perm);
                                                j = composition.mapIndex(0);
                                                if (knownPerms[j] == null) {
                                                    newPerms.add(composition);
                                                    knownPerms[j] = composition;
                                                    ++closureSize;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            ;
                            const result = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(closureSize);
                            let j = 0;
                            for (let i = 0; i < knownPerms.length; i++) {
                                {
                                    if (knownPerms[i] != null) {
                                        result[j++] = i;
                                    }
                                }
                                ;
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {number} orientation
                         * @return {int[]}
                         */
                        getIncidentOrientations(orientation) {
                            return null;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} v
                         * @return {com.vzome.core.math.RealVector}
                         */
                        embedInR3(v) {
                            return v.toRealVector();
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} v
                         * @return {double[]}
                         */
                        embedInR3Double(v) {
                            return v.to3dDoubleVector();
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isTrivial() {
                            return true;
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.AlgebraicMatrix}
                         */
                        getPrincipalReflection() {
                            return this.principalReflection;
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.AlgebraicVector[]}
                         */
                        getOrbitTriangle() {
                            const blueVertex = this.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.BLUE).getPrototype();
                            const redVertex = this.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.RED).getPrototype();
                            const yellowVertex = this.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.YELLOW).getPrototype();
                            return [blueVertex, redVertex, yellowVertex];
                        }
                        /**
                         *
                         * @return {string}
                         */
                        computeOrbitDots() {
                            if (this.dotLocator == null)
                                this.dotLocator = new com.vzome.core.math.symmetry.OrbitDotLocator(this, this.getOrbitTriangle());
                            for (let index = this.mDirectionList.iterator(); index.hasNext();) {
                                let orbit = index.next();
                                {
                                    this.dotLocator.locateOrbitDot(orbit);
                                }
                            }
                            return null;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        reverseOrbitTriangle() {
                            return false;
                        }
                    }
                    symmetry.AbstractSymmetry = AbstractSymmetry;
                    AbstractSymmetry["__class"] = "com.vzome.core.math.symmetry.AbstractSymmetry";
                    AbstractSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "com.vzome.core.math.symmetry.Embedding"];
                    (function (AbstractSymmetry) {
                        class MismatchedAxes extends java.lang.RuntimeException {
                            constructor(message) {
                                super(message);
                                Object.setPrototypeOf(this, MismatchedAxes.prototype);
                            }
                        }
                        MismatchedAxes.serialVersionUID = 2610579323321804987;
                        AbstractSymmetry.MismatchedAxes = MismatchedAxes;
                        MismatchedAxes["__class"] = "com.vzome.core.math.symmetry.AbstractSymmetry.MismatchedAxes";
                        MismatchedAxes["__interfaces"] = ["java.io.Serializable"];
                    })(AbstractSymmetry = symmetry.AbstractSymmetry || (symmetry.AbstractSymmetry = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    let Embedding;
                    (function (Embedding) {
                        class Trivial {
                            /**
                             *
                             * @param {com.vzome.core.algebra.AlgebraicVector} v
                             * @return {com.vzome.core.math.RealVector}
                             */
                            embedInR3(v) {
                                return v.toRealVector();
                            }
                            /**
                             *
                             * @param {com.vzome.core.algebra.AlgebraicVector} v
                             * @return {double[]}
                             */
                            embedInR3Double(v) {
                                return v.to3dDoubleVector();
                            }
                            /**
                             *
                             * @return {boolean}
                             */
                            isTrivial() {
                                return true;
                            }
                            constructor() {
                            }
                        }
                        Embedding.Trivial = Trivial;
                        Trivial["__class"] = "com.vzome.core.math.symmetry.Embedding.Trivial";
                        Trivial["__interfaces"] = ["com.vzome.core.math.symmetry.Embedding"];
                    })(Embedding = symmetry.Embedding || (symmetry.Embedding = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry_2) {
                    class OrbitSet {
                        constructor(symmetry) {
                            this.contents = (new java.util.HashMap());
                            if (this.symmetry === undefined) {
                                this.symmetry = null;
                            }
                            this.lastAdded = null;
                            this.symmetry = symmetry;
                        }
                        getSymmetry() {
                            return this.symmetry;
                        }
                        getAxis(vector) {
                            return this.symmetry['getAxis$com_vzome_core_math_RealVector$java_util_Collection'](vector, this.contents.values());
                        }
                        getDirection(name) {
                            for (let index = this.getDirections().iterator(); index.hasNext();) {
                                let dir = index.next();
                                {
                                    if (dir.getCanonicalName() === name)
                                        return dir;
                                    if (dir.getName() === name)
                                        return dir;
                                }
                            }
                            return null;
                        }
                        getDirections() {
                            return this.contents.values();
                        }
                        remove(orbit) {
                            const key = orbit.toString();
                            const hadOne = this.contents.containsKey(key);
                            this.contents.remove(orbit.toString());
                            return hadOne;
                        }
                        add(orbit) {
                            const key = orbit.toString();
                            const hadOne = this.contents.containsKey(key);
                            this.contents.put(orbit.toString(), orbit);
                            if (!hadOne)
                                this.lastAdded = orbit;
                            return !hadOne;
                        }
                        contains(orbit) {
                            return this.contents.containsKey(orbit.toString());
                        }
                        size() {
                            return this.contents.size();
                        }
                        clear() {
                            this.contents.clear();
                        }
                        addAll(orbits) {
                            this.contents.putAll(orbits.contents);
                        }
                        retainAll(allOrbits) {
                            const badKeys = (new java.util.ArrayList());
                            for (let index = this.contents.keySet().iterator(); index.hasNext();) {
                                let key = index.next();
                                {
                                    if (!allOrbits.contents.containsKey(key))
                                        badKeys.add(key);
                                }
                            }
                            for (let index = badKeys.iterator(); index.hasNext();) {
                                let key = index.next();
                                {
                                    this.contents.remove(key);
                                }
                            }
                        }
                        isEmpty() {
                            return this.contents.isEmpty();
                        }
                        last() {
                            return this.lastAdded;
                        }
                    }
                    symmetry_2.OrbitSet = OrbitSet;
                    OrbitSet["__class"] = "com.vzome.core.math.symmetry.OrbitSet";
                    (function (OrbitSet) {
                        class OrbitComparator {
                            constructor(__parent) {
                                this.__parent = __parent;
                                this.names = this.__parent.getSymmetry().getDirectionNames();
                            }
                            /**
                             *
                             * @param {com.vzome.core.math.symmetry.Direction} dir1
                             * @param {com.vzome.core.math.symmetry.Direction} dir2
                             * @return {number}
                             */
                            compare(dir1, dir2) {
                                const name1 = dir1.getName();
                                const name2 = dir2.getName();
                                let i1 = -1;
                                let i2 = -1;
                                for (let i = 0; i < this.names.length; i++) {
                                    {
                                        if (name1 === (this.names[i]))
                                            i1 = i;
                                        else if (name2 === (this.names[i]))
                                            i2 = i;
                                    }
                                    ;
                                }
                                return i2 - i1;
                            }
                        }
                        OrbitSet.OrbitComparator = OrbitComparator;
                        OrbitComparator["__class"] = "com.vzome.core.math.symmetry.OrbitSet.OrbitComparator";
                        OrbitComparator["__interfaces"] = ["java.util.Comparator"];
                    })(OrbitSet = symmetry_2.OrbitSet || (symmetry_2.OrbitSet = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     * @class
                     */
                    class NamingConvention {
                        constructor() {
                            this.mNamings = (new java.util.HashMap());
                        }
                        addDirectionNaming(naming) {
                            this.mNamings.put(naming.getName$(), naming);
                        }
                        getAxis(color, name) {
                            const naming = this.mNamings.get(color);
                            if (naming == null)
                                return null;
                            return naming.getAxis(name);
                        }
                        getName(axis) {
                            for (let index = this.mNamings.values().iterator(); index.hasNext();) {
                                let naming = index.next();
                                {
                                    if (naming.getDirection().equals(axis.getDirection()))
                                        return naming.getName$com_vzome_core_math_symmetry_Axis(axis);
                                }
                            }
                            return NamingConvention.UNKNOWN_AXIS;
                        }
                    }
                    NamingConvention.UNKNOWN_AXIS = "UNKNOWN AXIS";
                    symmetry.NamingConvention = NamingConvention;
                    NamingConvention["__class"] = "com.vzome.core.math.symmetry.NamingConvention";
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    let Symmetry;
                    (function (Symmetry) {
                        Symmetry.PLUS = 0;
                        Symmetry.MINUS = 1;
                        Symmetry.NO_ROTATION = -1;
                        Symmetry.TETRAHEDRAL = "tetrahedral";
                        Symmetry.PYRITOHEDRAL = "pyritohedral";
                    })(Symmetry = symmetry.Symmetry || (symmetry.Symmetry = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * A single orbit in a Symmetry group.
                     * Consists of a collection of zones (Axis), each of which is an infinite family of parallel lines.
                     * There is a prototype zone (Axis) which has index==0; ideally, that zone should
                     * have normal vector =~ (1,e,e), for 0 < e << 1, but this is not true, historically.
                     *
                     * The orbit is represented by a single "dot" on the fundamental region triangle, and typically
                     * struts in the orbit are rendered with a shape and color unique from all other orbits.
                     *
                     * @author Scott Vorthmann
                     * @param {string} name
                     * @param {*} group
                     * @param {number} prototype
                     * @param {number} rotatedPrototype
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector
                     * @param {boolean} isStd
                     * @class
                     */
                    class Direction {
                        constructor(name, group, prototype, rotatedPrototype, vector, isStd) {
                            if (this.mName === undefined) {
                                this.mName = null;
                            }
                            if (this.canonicalName === undefined) {
                                this.canonicalName = null;
                            }
                            if (this.zoneNames === undefined) {
                                this.zoneNames = null;
                            }
                            this.zoneVectors = (new java.util.HashMap());
                            if (this.mSymmetryGroup === undefined) {
                                this.mSymmetryGroup = null;
                            }
                            if (this.mPrototype === undefined) {
                                this.mPrototype = null;
                            }
                            if (this.mStandard === undefined) {
                                this.mStandard = false;
                            }
                            if (this.mAutomatic === undefined) {
                                this.mAutomatic = false;
                            }
                            if (this.__hasHalfSizes === undefined) {
                                this.__hasHalfSizes = false;
                            }
                            this.scaleNames = ["shorter", "short", "medium", "long"];
                            this.scales = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(this.scaleNames.length);
                            if (this.unitLength === undefined) {
                                this.unitLength = null;
                            }
                            if (this.unitLengthReciprocal === undefined) {
                                this.unitLengthReciprocal = null;
                            }
                            this.dotX = -999.0;
                            this.dotY = -999.0;
                            if (this.index === undefined) {
                                this.index = 0;
                            }
                            if (this.prototype === undefined) {
                                this.prototype = 0;
                            }
                            if (this.rotatedPrototype === undefined) {
                                this.rotatedPrototype = 0;
                            }
                            this.canonicalize = 0;
                            this.needsCanonicalization = false;
                            this.prototype = prototype;
                            this.rotatedPrototype = rotatedPrototype;
                            this.index = Direction.globalIndex++;
                            this.mStandard = isStd;
                            this.mName = name;
                            this.canonicalName = null;
                            this.mSymmetryGroup = group;
                            for (let i = 0; i < this.scales.length; i++) {
                                {
                                    this.scales[i] = this.mSymmetryGroup.getField()['createPower$int'](i - 1);
                                }
                                ;
                            }
                            this.mPrototype = vector;
                            const order = group.getChiralOrder();
                            this.zoneNames = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                                return null;
                            }
                            else {
                                let array = [];
                                for (let i = 0; i < dims[0]; i++) {
                                    array.push(allocate(dims.slice(1)));
                                }
                                return array;
                            } }; return allocate(dims); })([2, 2, order]);
                        }
                        /**
                         *
                         * @return {number}
                         */
                        hashCode() {
                            const prime = 31;
                            let result = 1;
                            result = prime * result + this.index;
                            result = prime * result + ((this.mPrototype == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                                return o.hashCode();
                            }
                            else {
                                return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                            } })(this.mPrototype));
                            result = prime * result + ((this.mSymmetryGroup == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                                return o.hashCode();
                            }
                            else {
                                return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                            } })(this.mSymmetryGroup));
                            return result;
                        }
                        /**
                         *
                         * @param {*} obj
                         * @return {boolean}
                         */
                        equals(obj) {
                            if (this === obj) {
                                return true;
                            }
                            if (obj == null) {
                                return false;
                            }
                            if (this.constructor !== obj.constructor) {
                                return false;
                            }
                            const other = obj;
                            if (this.index !== other.index) {
                                return false;
                            }
                            if (this.mPrototype == null) {
                                if (other.mPrototype != null) {
                                    return false;
                                }
                            }
                            else if (!this.mPrototype.equals(other.mPrototype)) {
                                return false;
                            }
                            if (this.mSymmetryGroup == null) {
                                if (other.mSymmetryGroup != null) {
                                    return false;
                                }
                            }
                            else if (!((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(this.mSymmetryGroup, other.mSymmetryGroup)) {
                                return false;
                            }
                            return true;
                        }
                        static logger_$LI$() { if (Direction.logger == null) {
                            Direction.logger = java.util.logging.Logger.getLogger("com.vzome.core.math.symmetry.Orbit");
                        } return Direction.logger; }
                        setAutomatic(auto) {
                            this.mAutomatic = auto;
                        }
                        isAutomatic() {
                            return this.mAutomatic;
                        }
                        isStandard() {
                            return this.mStandard;
                        }
                        /*private*/ getZoneVectors() {
                            if (this.zoneVectors.isEmpty()) {
                                if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                                    Direction.logger_$LI$().finer("creating zone vectors: " + this.toString());
                                for (let i = 0; i < this.mSymmetryGroup.getChiralOrder(); i++) {
                                    {
                                        const transform = this.mSymmetryGroup.getMatrix(i);
                                        const perm = this.mSymmetryGroup.getPermutation(i);
                                        const j = perm.mapIndex(this.prototype);
                                        const rotated = perm.mapIndex(this.rotatedPrototype);
                                        const normal = transform.timesColumn(this.mPrototype);
                                        const rot = this.mSymmetryGroup.getMapping(j, rotated);
                                        this.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(j, rot, normal);
                                    }
                                    ;
                                }
                            }
                            return this.zoneVectors;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        toString() {
                            return this.mSymmetryGroup.getName() + " " + this.mName;
                        }
                        getPrototype() {
                            return this.mPrototype;
                        }
                        /**
                         *
                         * @return {*}
                         */
                        iterator() {
                            return this.getZoneVectors().values().iterator();
                        }
                        getSymmetry() {
                            return this.mSymmetryGroup;
                        }
                        getName() {
                            return this.mName;
                        }
                        getCanonicalName() {
                            if (this.canonicalName == null) {
                                const canonicalAxis = this.getCanonicalAxis(0, 0);
                                const vector = canonicalAxis.normal();
                                const x = vector.getComponent(0);
                                let y = vector.getComponent(1);
                                let z = vector.getComponent(2).negate();
                                if (x.isZero()) {
                                    this.canonicalName = this.mName;
                                }
                                else {
                                    y = y.dividedBy(x);
                                    z = z.dividedBy(x);
                                    this.canonicalName = "[" + /* replace */ java.util.Arrays.toString(y.toTrailingDivisor()).split(" ").join("") + "," + /* replace */ java.util.Arrays.toString(z.toTrailingDivisor()).split(" ").join("") + "]";
                                }
                            }
                            return this.canonicalName;
                        }
                        getAxis$com_vzome_core_algebra_AlgebraicVector(vector) {
                            for (let index = this.getZoneVectors().values().iterator(); index.hasNext();) {
                                let axis = index.next();
                                {
                                    const normal = axis.normal();
                                    if (com.vzome.core.algebra.AlgebraicVectors.areParallel(normal, vector)) {
                                        const dotProd = normal.dot(vector);
                                        if (dotProd.evaluate() > 0) {
                                            return axis;
                                        }
                                        else {
                                            const principalReflection = this.mSymmetryGroup.getPrincipalReflection();
                                            if (principalReflection == null) {
                                                const opp = (axis.getSense() + 1) % 2;
                                                return this.getAxis$int$int(opp, axis.getOrientation());
                                            }
                                            else {
                                                return this.getAxis$int$int$boolean(axis.getSense(), axis.getOrientation(), !axis.isOutbound());
                                            }
                                        }
                                    }
                                }
                            }
                            return null;
                        }
                        getAxis$com_vzome_core_math_RealVector(vector) {
                            return this.getSymmetry()['getAxis$com_vzome_core_math_RealVector$java_util_Collection'](vector, java.util.Collections.singleton(this));
                        }
                        getChiralAxis(vector) {
                            if (com.vzome.core.math.RealVector.ORIGIN_$LI$().equals(vector)) {
                                return null;
                            }
                            const vectorLength = vector.length();
                            const checked = (new java.util.HashSet());
                            let closestOrientation = 0;
                            let closestSense = com.vzome.core.math.symmetry.Symmetry.PLUS;
                            let closestAxis = this.getCanonicalAxis(com.vzome.core.math.symmetry.Symmetry.PLUS, 0);
                            checked.add(closestAxis);
                            let axisV = closestAxis.normal().toRealVector();
                            let maxCosine = vector.dot(axisV) / (vectorLength * axisV.length());
                            if (maxCosine < 0) {
                                closestAxis = this.getCanonicalAxis(com.vzome.core.math.symmetry.Symmetry.MINUS, 0);
                                closestSense = com.vzome.core.math.symmetry.Symmetry.MINUS;
                                checked.add(closestAxis);
                                axisV = closestAxis.normal().toRealVector();
                                maxCosine = vector.dot(axisV) / (vectorLength * axisV.length());
                            }
                            const finished = false;
                            while ((!finished)) {
                                {
                                    const incidentOrientations = this.getSymmetry().getIncidentOrientations(closestOrientation);
                                    if (incidentOrientations == null) {
                                        break;
                                    }
                                    const reverseSense = (closestSense + 1) % 2;
                                    for (let index = 0; index < incidentOrientations.length; index++) {
                                        let i = incidentOrientations[index];
                                        {
                                            const neighbor = this.getCanonicalAxis(reverseSense, i);
                                            if (checked.contains(neighbor))
                                                continue;
                                            checked.add(neighbor);
                                            axisV = neighbor.normal().toRealVector();
                                            const cosine = vector.dot(axisV) / (vectorLength * axisV.length());
                                            if (cosine > maxCosine) {
                                                maxCosine = cosine;
                                                closestAxis = neighbor;
                                                closestOrientation = i;
                                                closestSense = reverseSense;
                                            }
                                        }
                                    }
                                    if (reverseSense !== closestSense) {
                                        return closestAxis;
                                    }
                                }
                            }
                            ;
                            return this.getAxisBruteForce(vector);
                        }
                        getAxisBruteForce(vector) {
                            let closestAxis = null;
                            let maxCosine = -1.0;
                            for (let index = this.iterator(); index.hasNext();) {
                                let axis = index.next();
                                {
                                    const axisV = axis.normal().toRealVector();
                                    const cosine = vector.dot(axisV) / (vector.length() * axisV.length());
                                    if (cosine > maxCosine) {
                                        maxCosine = cosine;
                                        closestAxis = axis;
                                    }
                                }
                            }
                            return closestAxis;
                        }
                        zoneInitialized(sense, unit) {
                            return this.zoneNames[1][sense][unit] != null;
                        }
                        getAxis$int$int(sense, index) {
                            return this.getAxis$int$int$boolean(sense, index, true);
                        }
                        getAxis$int$int$boolean(sense, index, outbound) {
                            this.getZoneVectors();
                            return this.zoneNames[outbound ? 1 : 0][sense][index];
                        }
                        getAxis(sense, index, outbound) {
                            if (((typeof sense === 'number') || sense === null) && ((typeof index === 'number') || index === null) && ((typeof outbound === 'boolean') || outbound === null)) {
                                return this.getAxis$int$int$boolean(sense, index, outbound);
                            }
                            else if (((typeof sense === 'number') || sense === null) && ((typeof index === 'number') || index === null) && outbound === undefined) {
                                return this.getAxis$int$int(sense, index);
                            }
                            else if (((sense != null && sense instanceof com.vzome.core.algebra.AlgebraicVector) || sense === null) && index === undefined && outbound === undefined) {
                                return this.getAxis$com_vzome_core_algebra_AlgebraicVector(sense);
                            }
                            else if (((sense != null && sense instanceof com.vzome.core.math.RealVector) || sense === null) && index === undefined && outbound === undefined) {
                                return this.getAxis$com_vzome_core_math_RealVector(sense);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        withCorrection() {
                            this.needsCanonicalization = true;
                            return this;
                        }
                        /**
                         * Get the axis that protrudes from the canonical direction on the zome ball.
                         * Many Directions (orbits) are created without regard to whether "axis 0" actually sticks out
                         * of the ball in the fundamental domain with index 0.
                         * @param {number} sense
                         * @param {number} index
                         * @return
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getCanonicalAxis(sense, index) {
                            if (this.needsCanonicalization) {
                                const treatedAs0 = this.getAxisBruteForce(com.vzome.core.math.RealVector.DIRECTION_0_$LI$());
                                this.canonicalize = treatedAs0.getOrientation();
                                if (treatedAs0.getSense() === com.vzome.core.math.symmetry.Symmetry.MINUS)
                                    this.canonicalize *= -1;
                                this.needsCanonicalization = false;
                            }
                            if (this.canonicalize !== 0) {
                                if (this.canonicalize < 0)
                                    sense = (sense + 1) % 2;
                                const target = this.mSymmetryGroup.getPermutation(index);
                                index = target.mapIndex(Math.abs(this.canonicalize));
                            }
                            return this.getAxis$int$int(sense, index);
                        }
                        createAxis$int$int$int_A_A(orientation, rotation, norm) {
                            const aNorm = this.mSymmetryGroup.getField().createVector(norm);
                            this.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(orientation, rotation, aNorm);
                        }
                        createAxis(orientation, rotation, norm) {
                            if (((typeof orientation === 'number') || orientation === null) && ((typeof rotation === 'number') || rotation === null) && ((norm != null && norm instanceof Array && (norm.length == 0 || norm[0] == null || norm[0] instanceof Array)) || norm === null)) {
                                return this.createAxis$int$int$int_A_A(orientation, rotation, norm);
                            }
                            else if (((typeof orientation === 'number') || orientation === null) && ((typeof rotation === 'number') || rotation === null) && ((norm != null && norm instanceof com.vzome.core.algebra.AlgebraicVector) || norm === null)) {
                                return this.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(orientation, rotation, norm);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(orientation, rotation, norm) {
                            let perm = this.mSymmetryGroup.getPermutation(rotation);
                            this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.PLUS, rotation, perm, norm, true);
                            const inversion = this.mSymmetryGroup.getPrincipalReflection();
                            if (inversion == null) {
                                if (perm != null)
                                    perm = perm.inverse();
                                this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.MINUS, rotation, perm, norm.negate(), true);
                            }
                            else {
                                let reverseRotation = rotation;
                                let reversePerm = perm;
                                if (perm != null) {
                                    reversePerm = perm.inverse();
                                    reverseRotation = perm.mapIndex(0);
                                }
                                this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.PLUS, reverseRotation, reversePerm, norm.negate(), false);
                                let reflectedNorm = inversion.timesColumn(norm);
                                this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.MINUS, reverseRotation, reversePerm, reflectedNorm, true);
                                reflectedNorm = reflectedNorm.negate();
                                this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.MINUS, rotation, perm, reflectedNorm, false);
                            }
                        }
                        /*private*/ recordZone(dir, orientation, sense, rotation, rotPerm, normal, outbound) {
                            let zone = this.zoneVectors.get(normal.toString());
                            if (zone == null) {
                                zone = new com.vzome.core.math.symmetry.Axis(this, orientation, sense, rotation, rotPerm, normal, outbound);
                                this.zoneVectors.put(normal.toString(), zone);
                                if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                                    Direction.logger_$LI$().finer("creating zone " + zone.toString() + " " + normal.toString());
                            }
                            else {
                                if (outbound && !zone.isOutbound()) {
                                    const oldName = zone.toString();
                                    zone.rename(sense, orientation, true);
                                    if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                                        Direction.logger_$LI$().finer("zone " + oldName + " upgraded to " + zone.toString());
                                }
                                else if (zone.isOutbound() && !outbound) {
                                    if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))
                                        Direction.logger_$LI$().finest("zone " + zone.toString() + " aliased as " + ((sense === com.vzome.core.math.symmetry.Axis.MINUS) ? "-" : "") + orientation + (outbound ? "" : "i"));
                                }
                                else if (sense === com.vzome.core.math.symmetry.Axis.PLUS && (zone.getSense() === com.vzome.core.math.symmetry.Axis.MINUS)) {
                                    const oldName = zone.toString();
                                    zone.rename(sense, orientation, outbound);
                                    if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                                        Direction.logger_$LI$().finer("zone " + oldName + " upgraded to " + zone.toString());
                                }
                                else {
                                    if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))
                                        Direction.logger_$LI$().finest("zone " + zone.toString() + " aliased as " + ((sense === com.vzome.core.math.symmetry.Axis.MINUS) ? "-" : "") + orientation + (outbound ? "" : "i"));
                                }
                            }
                            this.zoneNames[outbound ? 1 : 0][sense][orientation] = zone;
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.Direction} other
                         * @return {number}
                         */
                        compareTo(other) {
                            return this.index - other.index;
                        }
                        setHalfSizes(value) {
                            this.__hasHalfSizes = value;
                        }
                        hasHalfSizes() {
                            return this.__hasHalfSizes;
                        }
                        setScaleNames(names) {
                            for (let i = 0; i < names.length; i++) {
                                {
                                    this.scaleNames[i] = names[i];
                                }
                                ;
                            }
                        }
                        getScaleName(scale) {
                            if (scale < this.scaleNames.length && scale >= 0)
                                return this.scaleNames[scale];
                            else
                                return "scale " + (scale - 1);
                        }
                        setUnitLength(unitLength) {
                            this.unitLength = unitLength;
                            this.unitLengthReciprocal = unitLength.reciprocal();
                        }
                        getUnitLength() {
                            if (this.unitLength == null)
                                return this.mSymmetryGroup.getField().one();
                            else
                                return this.unitLength;
                        }
                        getLengthInUnits(rawLength) {
                            const field = this.mSymmetryGroup.getField();
                            const scaledLength = rawLength['times$com_vzome_core_algebra_AlgebraicNumber'](field['createPower$int'](-Direction.USER_SCALE));
                            if (this.unitLength == null)
                                return scaledLength;
                            else
                                return scaledLength['times$com_vzome_core_algebra_AlgebraicNumber'](this.unitLengthReciprocal);
                        }
                        getLengthName(length) {
                            for (let i = 0; i < this.scales.length; i++) {
                                {
                                    if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                        return o1.equals(o2);
                                    }
                                    else {
                                        return o1 === o2;
                                    } })(this.scales[i], length)) {
                                        return this.scaleNames[i];
                                    }
                                }
                                ;
                            }
                            return "";
                        }
                        getLengthExpression(buf, length) {
                            const bufLen = buf.length();
                            buf.append(this.getLengthName(length));
                            if (buf.length() === bufLen) {
                                buf.append(" ");
                            }
                            buf.append(":");
                            length.getNumberExpression(buf, com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT);
                        }
                        getDotX() {
                            return this.dotX;
                        }
                        getDotY() {
                            return this.dotY;
                        }
                        setDotLocation(x, y) {
                            this.dotX = x;
                            this.dotY = y;
                        }
                    }
                    Direction.globalIndex = 0;
                    Direction.USER_SCALE = 3;
                    symmetry.Direction = Direction;
                    Direction["__class"] = "com.vzome.core.math.symmetry.Direction";
                    Direction["__interfaces"] = ["java.lang.Comparable", "java.lang.Iterable"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class B4Group {
                        constructor(field) {
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            this.ROOTS = [null, null, null, null];
                            this.WEIGHTS = [null, null, null, null];
                            this.field = field;
                            const neg_one = field['createRational$long'](-1);
                            this.ROOTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.ROOTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_one);
                            this.ROOTS[1] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
                            this.ROOTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_one);
                            this.ROOTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
                            this.ROOTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_one);
                            this.ROOTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.W4);
                            const y = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
                            const z = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
                            this.WEIGHTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.WEIGHTS[1] = this.WEIGHTS[0].plus(y);
                            this.WEIGHTS[2] = this.WEIGHTS[1].plus(z);
                            this.WEIGHTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            const half = field['createRational$long$long'](1, 2);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, half);
                            if (field.scale4dRoots()) {
                                const scale = field['createPower$int'](1);
                                this.ROOTS[3] = this.ROOTS[3].scale(scale);
                                this.WEIGHTS[3] = this.WEIGHTS[3].scale(scale);
                            }
                        }
                        static B4_PERMS_$LI$() { if (B4Group.B4_PERMS == null) {
                            B4Group.B4_PERMS = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 2, 3, 1], [0, 3, 2, 1], [0, 3, 1, 2], [1, 0, 2, 3], [1, 0, 3, 2], [1, 2, 0, 3], [1, 2, 3, 0], [1, 3, 2, 0], [1, 3, 0, 2], [2, 1, 0, 3], [2, 1, 3, 0], [2, 0, 1, 3], [2, 0, 3, 1], [2, 3, 0, 1], [2, 3, 1, 0], [3, 1, 2, 0], [3, 1, 0, 2], [3, 2, 1, 0], [3, 2, 0, 1], [3, 0, 2, 1], [3, 0, 1, 2]];
                        } return B4Group.B4_PERMS; }
                        /**
                         *
                         * @return {number}
                         */
                        getOrder() {
                            return 24 * 16;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        groupAction(model, element) {
                            const result = this.field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            const perm = (element / 16 | 0);
                            let signs = element % 16;
                            for (let c = 0; c < 4; c++) {
                                {
                                    let source = model.getComponent((B4Group.B4_PERMS_$LI$()[perm][c] + 1) % 4);
                                    if (signs % 2 !== 0)
                                        source = source.negate();
                                    result.setComponent((c + 1) % 4, source);
                                    signs = signs >> 1;
                                }
                                ;
                            }
                            return result;
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getOrigin() {
                            return this.field.origin(4);
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getWeight(i) {
                            return this.WEIGHTS[i];
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getSimpleRoot(i) {
                            return this.ROOTS[i];
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getField() {
                            return this.field;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        chiralSubgroupAction(model, element) {
                            const result = this.field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            const perm = (element / 16 | 0);
                            let signs = element % 16;
                            let even = true;
                            for (let c = 0; c < 4; c++) {
                                {
                                    let source = model.getComponent((B4Group.B4_PERMS_$LI$()[perm][c] + 1) % 4);
                                    if (signs % 2 !== 0) {
                                        even = !even;
                                        source = source.negate();
                                    }
                                    result.setComponent((c + 1) % 4, source);
                                    signs = signs >> 1;
                                }
                                ;
                            }
                            return even ? result : null;
                        }
                    }
                    symmetry.B4Group = B4Group;
                    B4Group["__class"] = "com.vzome.core.math.symmetry.B4Group";
                    B4Group["__interfaces"] = ["com.vzome.core.math.symmetry.CoxeterGroup"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    let Constants;
                    (function (Constants) {
                        Constants.RED = 0;
                        Constants.YELLOW = 1;
                        Constants.BLUE = 2;
                        Constants.GREEN = 3;
                        Constants.ORANGE = 4;
                        Constants.PURPLE = 5;
                        Constants.BLACK = 6;
                        Constants.NO_AXIS = 7;
                        /**
                         * Blue axes of basis.
                         */
                        Constants.X = 2;
                        /**
                         * Blue axes of basis.
                         */
                        Constants.Y = 5;
                        /**
                         * Blue axes of basis.
                         */
                        Constants.Z = 13;
                        Constants.SHORT = 3;
                        Constants.MEDIUM = 4;
                        Constants.LONG = 5;
                        Constants.JUST_RED = 1 << Constants.RED;
                        Constants.JUST_YELLOW = 1 << Constants.YELLOW;
                        Constants.JUST_BLUE = 1 << Constants.BLUE;
                        Constants.JUST_GREEN = 1 << Constants.GREEN;
                        Constants.JUST_ORANGE = 1 << Constants.ORANGE;
                        Constants.JUST_PURPLE = 1 << Constants.PURPLE;
                        Constants.JUST_BLACK = 1 << Constants.BLACK;
                        Constants.ORIGINAL_STRUTS = Constants.JUST_RED | Constants.JUST_YELLOW | Constants.JUST_BLUE;
                        Constants.ALL_STRUTS = Constants.ORIGINAL_STRUTS | Constants.JUST_GREEN | Constants.JUST_ORANGE | Constants.JUST_PURPLE | Constants.JUST_BLACK;
                        Constants.RED_AXIS_YELLOW_NEIGHBORS = [[0, 1, 2, 3, 4], [1, 0, 5, -8, 6], [2, 1, 6, -9, 7], [3, 2, 7, -5, 8], [4, 3, 8, -6, 9], [0, 4, 9, -7, 5]];
                        Constants.AXIS_SYMMETRY = [5, 3, 2, 1, 1, 1, 1];
                    })(Constants = symmetry.Constants || (symmetry.Constants = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                class VefParser {
                    constructor() {
                        this.mVersion = 0;
                        this.dimension = 4;
                        this.__isRational = false;
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        if (this.parsedOffset === undefined) {
                            this.parsedOffset = null;
                        }
                    }
                    endVertices() {
                    }
                    endEdges() {
                    }
                    endFaces() {
                    }
                    endBalls() {
                    }
                    getVersion() {
                        return this.mVersion;
                    }
                    getField() {
                        return this.field;
                    }
                    isRational() {
                        return this.__isRational;
                    }
                    wFirst() {
                        return this.mVersion >= VefParser.VERSION_W_FIRST;
                    }
                    parseVEF(vefData, field) {
                        this.field = field;
                        const tokens = new java.util.StringTokenizer(vefData);
                        let token = null;
                        try {
                            token = tokens.nextToken();
                        }
                        catch (e1) {
                            throw new java.lang.IllegalStateException("VEF format error: no tokens in file data: \"" + vefData + "\"");
                        }
                        this.mVersion = 0;
                        this.__isRational = false;
                        if (token === ("vZome")) {
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e1) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"vZome\"");
                            }
                            if (!("VEF" === token))
                                throw new java.lang.IllegalStateException("VEF format error: token after \"vZome\" (\"" + token + "\" should be \"VEF\"");
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e1) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"VEF\"");
                            }
                            try {
                                this.mVersion = javaemul.internal.IntegerHelper.parseInt(token);
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException("VEF format error: VEF version number (\"" + token + "\") must be an integer", e);
                            }
                            token = tokens.nextToken();
                        }
                        if (token === ("field")) {
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e1) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"field\"");
                            }
                            if (token === ("rational")) {
                                this.__isRational = true;
                                token = field.getName();
                            }
                            if (!field.supportsSubfield(token)) {
                                throw new java.lang.IllegalStateException("VEF field mismatch error: VEF field name (\"" + token + "\") does not match current model field name (\"" + field.getName() + "\").");
                            }
                            token = tokens.nextToken();
                        }
                        if (token === ("actual")) {
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e1) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"actual\"");
                            }
                        }
                        if (token === ("dimension")) {
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e1) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"dimension\"");
                            }
                            try {
                                this.dimension = javaemul.internal.IntegerHelper.parseInt(token);
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException("VEF format error: dimension number (\"" + token + "\") must be an integer", e);
                            }
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"dimension\"");
                            }
                        }
                        const scaleVector = new com.vzome.core.algebra.AlgebraicVector(field, this.dimension);
                        if (token === ("scale")) {
                            try {
                                token = tokens.nextToken();
                                if (token === ("vector")) {
                                    try {
                                        for (let tokNum = 0; tokNum < this.dimension; tokNum++) {
                                            {
                                                token = tokens.nextToken();
                                                const coord = this.field.parseVefNumber(token, this.__isRational);
                                                scaleVector.setComponent(tokNum, coord);
                                            }
                                            ;
                                        }
                                    }
                                    catch (e) {
                                        throw new java.lang.IllegalStateException("VEF format error: scale vector requires " + this.dimension + " coordinates");
                                    }
                                }
                                else {
                                    const scale = this.field.parseVefNumber(token, this.__isRational);
                                    for (let i = 0; i < this.dimension; i++) {
                                        {
                                            scaleVector.setComponent(i, scale);
                                        }
                                        ;
                                    }
                                }
                                token = tokens.nextToken();
                            }
                            catch (e) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"scale\"");
                            }
                        }
                        else {
                            for (let i = 0; i < this.dimension; i++) {
                                {
                                    scaleVector.setComponent(i, field.one());
                                }
                                ;
                            }
                        }
                        this.parsedOffset = new com.vzome.core.algebra.AlgebraicVector(field, this.dimension);
                        if (token === ("offset")) {
                            try {
                                for (let tokNum = 0; tokNum < this.dimension; tokNum++) {
                                    {
                                        token = tokens.nextToken();
                                        const coord = this.field.parseVefNumber(token, this.__isRational);
                                        this.parsedOffset.setComponent(tokNum, coord);
                                    }
                                    ;
                                }
                            }
                            catch (e) {
                                throw new java.lang.IllegalStateException("VEF format error: offset vector requires " + this.dimension + " coordinates");
                            }
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"offset\"");
                            }
                        }
                        let numVertices;
                        try {
                            numVertices = javaemul.internal.IntegerHelper.parseInt(token);
                        }
                        catch (e) {
                            throw new java.lang.RuntimeException("VEF format error: number of vertices (\"" + token + "\") must be an integer", e);
                        }
                        this.startVertices(numVertices);
                        const hasOffset = !this.parsedOffset.isOrigin();
                        for (let i = 0; i < numVertices; i++) {
                            {
                                let v = field.origin(this.dimension);
                                for (let tokNum = 0; tokNum < this.dimension; tokNum++) {
                                    {
                                        try {
                                            token = tokens.nextToken();
                                        }
                                        catch (e1) {
                                            throw new java.lang.IllegalStateException("VEF format error: not enough vertices in list");
                                        }
                                        const coord = this.field.parseVefNumber(token, this.__isRational)['times$com_vzome_core_algebra_AlgebraicNumber'](scaleVector.getComponent(tokNum));
                                        v.setComponent(tokNum, coord);
                                    }
                                    ;
                                }
                                if (hasOffset) {
                                    v = v.plus(this.parsedOffset);
                                }
                                this.addVertex(i, v);
                            }
                            ;
                        }
                        this.endVertices();
                        if (tokens.hasMoreTokens()) {
                            token = tokens.nextToken();
                            let numEdges;
                            try {
                                numEdges = javaemul.internal.IntegerHelper.parseInt(token);
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException("VEF format error: number of edges (\"" + token + "\") must be an integer", e);
                            }
                            this.startEdges(numEdges);
                            for (let i = 0; i < numEdges; i++) {
                                {
                                    try {
                                        token = tokens.nextToken();
                                    }
                                    catch (e1) {
                                        throw new java.lang.IllegalStateException("VEF format error: not enough edges in list");
                                    }
                                    const v1 = javaemul.internal.IntegerHelper.parseInt(token);
                                    try {
                                        token = tokens.nextToken();
                                    }
                                    catch (e1) {
                                        throw new java.lang.IllegalStateException("VEF format error: 2nd vertex index of last edge is missing");
                                    }
                                    const v2 = javaemul.internal.IntegerHelper.parseInt(token);
                                    this.addEdge(i, v1, v2);
                                }
                                ;
                            }
                            this.endEdges();
                        }
                        if (tokens.hasMoreTokens()) {
                            token = tokens.nextToken();
                            let numFaces;
                            try {
                                numFaces = javaemul.internal.IntegerHelper.parseInt(token);
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException("VEF format error: number of faces (\"" + token + "\") must be an integer", e);
                            }
                            this.startFaces(numFaces);
                            for (let i = 0; i < numFaces; i++) {
                                {
                                    try {
                                        token = tokens.nextToken();
                                    }
                                    catch (e1) {
                                        throw new java.lang.IllegalStateException("VEF format error: not enough faces in list");
                                    }
                                    const order = javaemul.internal.IntegerHelper.parseInt(token);
                                    const verts = (s => { let a = []; while (s-- > 0)
                                        a.push(0); return a; })(order);
                                    for (let j = 0; j < order; j++) {
                                        {
                                            try {
                                                token = tokens.nextToken();
                                            }
                                            catch (e1) {
                                                throw new java.lang.IllegalStateException("VEF format error: not enough vertices in last face");
                                            }
                                            verts[j] = javaemul.internal.IntegerHelper.parseInt(token);
                                        }
                                        ;
                                    }
                                    this.addFace(i, verts);
                                }
                                ;
                            }
                            this.endFaces();
                        }
                        if (tokens.hasMoreTokens()) {
                            token = tokens.nextToken();
                            let numBalls;
                            try {
                                numBalls = javaemul.internal.IntegerHelper.parseInt(token);
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException("VEF format error: number of balls (\"" + token + "\") must be an integer", e);
                            }
                            this.startBalls(numBalls);
                            for (let i = 0; i < numBalls; i++) {
                                {
                                    try {
                                        token = tokens.nextToken();
                                    }
                                    catch (e1) {
                                        throw new java.lang.IllegalStateException("VEF format error: not enough balls in list");
                                    }
                                    const v1 = javaemul.internal.IntegerHelper.parseInt(token);
                                    this.addBall(i, v1);
                                }
                                ;
                            }
                            this.endBalls();
                        }
                        this.endFile(tokens);
                    }
                    endFile(tokens) {
                    }
                }
                VefParser.VERSION_EXPLICIT_OFFSET = 10;
                VefParser.VERSION_EXPLICIT_DIMENSION = 9;
                VefParser.VERSION_SCALE_VECTOR = 8;
                VefParser.VERSION_RATIONAL_ACTUAL_SCALE = 7;
                VefParser.VERSION_EXPLICIT_BALLS = 6;
                VefParser.VERSION_ANY_FIELD = 5;
                VefParser.VERSION_W_FIRST = 4;
                math.VefParser = VefParser;
                VefParser["__class"] = "com.vzome.core.math.VefParser";
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                /**
                 * @param {*} field
                 * @param {com.vzome.core.algebra.AlgebraicVector} leftQuat
                 * @param {com.vzome.core.algebra.AlgebraicVector} rightQuat
                 * @class
                 */
                class QuaternionProjection {
                    constructor(field, leftQuat, rightQuat) {
                        this.quaternions = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return null;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([2, 2]);
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        this.field = field;
                        this.setQuaternion(leftQuat, QuaternionProjection.LEFT);
                        this.setQuaternion(rightQuat, QuaternionProjection.RIGHT);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} source
                     * @param {boolean} wFirst
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    projectImage(source, wFirst) {
                        let result = source;
                        const leftQuat = this.getQuaternion(QuaternionProjection.LEFT, wFirst);
                        const rightQuat = this.getQuaternion(QuaternionProjection.RIGHT, wFirst);
                        if (rightQuat != null) {
                            if (leftQuat != null) {
                                result = leftQuat.rightMultiply(result);
                                console.info("left mult: " + result.toString());
                            }
                            result = rightQuat.leftMultiply(result);
                        }
                        else {
                            result = leftQuat.rightMultiply(result);
                        }
                        return this.field.projectTo3d(result, wFirst);
                    }
                    /*private*/ setQuaternion(quatVector, hand) {
                        this.quaternions[hand][QuaternionProjection.WFIRST] = quatVector == null ? null : new com.vzome.core.algebra.Quaternion(this.field, quatVector.inflateTo4d$boolean(true));
                        this.quaternions[hand][QuaternionProjection.WLAST] = quatVector == null ? null : new com.vzome.core.algebra.Quaternion(this.field, quatVector.inflateTo4d$boolean(false));
                    }
                    /*private*/ getQuaternion(hand, wFirst) {
                        return this.quaternions[hand][wFirst ? QuaternionProjection.WFIRST : QuaternionProjection.WLAST];
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        const leftQuat = this.getQuaternion(QuaternionProjection.LEFT, true);
                        const rightQuat = this.getQuaternion(QuaternionProjection.RIGHT, true);
                        if (leftQuat != null) {
                            com.vzome.xml.DomUtils.addAttribute(element, QuaternionProjection.LEFT_QUATERNION_ATTRIBUTENAME, leftQuat.getVector().toParsableString());
                        }
                        if (rightQuat != null) {
                            com.vzome.xml.DomUtils.addAttribute(element, QuaternionProjection.RIGHT_QUATERNION_ATTRIBUTENAME, rightQuat.getVector().toParsableString());
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    setXmlAttributes(xml) {
                        this.setQuaternion(this.parseRationalVector(xml, QuaternionProjection.LEFT_QUATERNION_ATTRIBUTENAME), QuaternionProjection.LEFT);
                        this.setQuaternion(this.parseRationalVector(xml, QuaternionProjection.RIGHT_QUATERNION_ATTRIBUTENAME), QuaternionProjection.RIGHT);
                    }
                    /*private*/ parseRationalVector(xml, attrName) {
                        const nums = xml.getAttribute(attrName);
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return null;
                        const loc = this.field.parseVector(nums);
                        return loc;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getProjectionName() {
                        return "Quaternion";
                    }
                }
                QuaternionProjection.LEFT = 0;
                QuaternionProjection.RIGHT = 1;
                QuaternionProjection.WFIRST = 0;
                QuaternionProjection.WLAST = 1;
                QuaternionProjection.RIGHT_QUATERNION_ATTRIBUTENAME = "quaternion";
                QuaternionProjection.LEFT_QUATERNION_ATTRIBUTENAME = "leftQuaternion";
                math.QuaternionProjection = QuaternionProjection;
                QuaternionProjection["__class"] = "com.vzome.core.math.QuaternionProjection";
                QuaternionProjection["__interfaces"] = ["com.vzome.core.math.Projection"];
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                let Projection;
                (function (Projection) {
                    class Default {
                        constructor(field) {
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            this.field = field;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} source
                         * @param {boolean} wFirst
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        projectImage(source, wFirst) {
                            return this.field.projectTo3d(source, wFirst);
                        }
                        /**
                         *
                         * @param {*} element
                         */
                        getXmlAttributes(element) {
                        }
                        /**
                         *
                         * @param {*} xml
                         */
                        setXmlAttributes(xml) {
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getProjectionName() {
                            return "";
                        }
                    }
                    Projection.Default = Default;
                    Default["__class"] = "com.vzome.core.math.Projection.Default";
                    Default["__interfaces"] = ["com.vzome.core.math.Projection"];
                })(Projection = math.Projection || (math.Projection = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                class PerspectiveProjection {
                    constructor(field, cameraDist) {
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        if (this.cameraDist === undefined) {
                            this.cameraDist = null;
                        }
                        if (this.minDenom === undefined) {
                            this.minDenom = null;
                        }
                        if (this.minDenomValue === undefined) {
                            this.minDenomValue = 0;
                        }
                        this.field = field;
                        this.cameraDist = cameraDist;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} source
                     * @param {boolean} wFirst
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    projectImage(source, wFirst) {
                        const result = this.field.origin(4);
                        const w = source.getComponent(0);
                        let denom = this.cameraDist['minus$com_vzome_core_algebra_AlgebraicNumber'](w);
                        if (this.minDenom == null) {
                            this.minDenom = this.field['createPower$int'](-5);
                            this.minDenomValue = this.minDenom.evaluate();
                        }
                        const denomValue = denom.evaluate();
                        if (denomValue < this.minDenomValue) {
                            denom = this.minDenom;
                        }
                        const numerator = denom.reciprocal();
                        result.setComponent(0, this.field.one());
                        result.setComponent(1, source.getComponent(1)['times$com_vzome_core_algebra_AlgebraicNumber'](numerator));
                        result.setComponent(2, source.getComponent(2)['times$com_vzome_core_algebra_AlgebraicNumber'](numerator));
                        result.setComponent(3, source.getComponent(3)['times$com_vzome_core_algebra_AlgebraicNumber'](numerator));
                        return result;
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.cameraDist != null) {
                            com.vzome.xml.DomUtils.addAttribute(element, "cameraDist", this.cameraDist.toString(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    setXmlAttributes(xml) {
                        const nums = xml.getAttribute("cameraDist");
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return;
                        this.cameraDist = this.field.parseNumber(nums);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getProjectionName() {
                        return "Perspective";
                    }
                }
                math.PerspectiveProjection = PerspectiveProjection;
                PerspectiveProjection["__class"] = "com.vzome.core.math.PerspectiveProjection";
                PerspectiveProjection["__interfaces"] = ["com.vzome.core.math.Projection"];
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                class Line {
                    constructor(origin, direction) {
                        if (this.origin === undefined) {
                            this.origin = null;
                        }
                        if (this.direction === undefined) {
                            this.direction = null;
                        }
                        this.direction = direction;
                        this.origin = origin;
                    }
                    getOrigin() {
                        return this.origin;
                    }
                    getDirection() {
                        return this.direction;
                    }
                }
                math.Line = Line;
                Line["__class"] = "com.vzome.core.math.Line";
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var model;
            (function (model) {
                class Group extends java.util.ArrayList {
                    constructor() {
                        super();
                        if (this.mContainer === undefined) {
                            this.mContainer = null;
                        }
                    }
                    getContainer() {
                        return this.mContainer;
                    }
                    /**
                     *
                     * @param {com.vzome.core.model.Group} container
                     */
                    setContainer(container) {
                        this.mContainer = container;
                    }
                }
                model.Group = Group;
                Group["__class"] = "com.vzome.core.model.Group";
                Group["__interfaces"] = ["java.util.RandomAccess", "com.vzome.core.model.GroupElement", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
            })(model = core.model || (core.model = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var model;
            (function (model) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} field
                 * @param {*} projection
                 * @class
                 */
                class RealizedModelImpl {
                    constructor(field, projection) {
                        this.mListeners = (new java.util.ArrayList(1));
                        this.mManifestations = (new java.util.LinkedHashMap(1000));
                        if (this.mProjection === undefined) {
                            this.mProjection = null;
                        }
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        this.doingBatch = false;
                        this.additions = (new java.util.HashSet());
                        this.removals = (new java.util.HashSet());
                        if (this.mManifestedNow === undefined) {
                            this.mManifestedNow = null;
                        }
                        this.field = field;
                        this.mProjection = projection;
                    }
                    moreVisibleThan(other) {
                        const result = (new java.util.HashSet());
                        for (let index = this.mManifestations.values().iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man.isHidden())
                                    continue;
                                const doppel = other.mManifestations.get(man.toConstruction().getSignature());
                                if (doppel == null || doppel.isHidden())
                                    result.add(man);
                            }
                        }
                        return result;
                    }
                    addListener(l) {
                        this.mListeners.add(l);
                    }
                    removeListener(l) {
                        this.mListeners.remove(l);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    iterator() {
                        return this.mManifestations.values().iterator();
                    }
                    manifest(c) {
                        let m = null;
                        if (c != null && c instanceof com.vzome.core.construction.Point) {
                            const p = c;
                            m = new com.vzome.core.model.ConnectorImpl(this.mProjection.projectImage(p.getLocation(), true));
                        }
                        else if (c != null && c instanceof com.vzome.core.construction.Segment) {
                            const s = c;
                            const start = this.mProjection.projectImage(s.getStart(), true);
                            const end = this.mProjection.projectImage(s.getEnd(), true);
                            if (!start.equals(end)) {
                                m = new com.vzome.core.model.StrutImpl(start, end);
                            }
                        }
                        else if (c != null && c instanceof com.vzome.core.construction.Polygon) {
                            const p = c;
                            const vertices = (new java.util.ArrayList());
                            for (let i = 0; i < p.getVertexCount(); i++) {
                                {
                                    vertices.add(this.mProjection.projectImage(p.getVertex(i), true));
                                }
                                ;
                            }
                            m = new com.vzome.core.model.PanelImpl(vertices);
                        }
                        return m;
                    }
                    static logger_$LI$() { if (RealizedModelImpl.logger == null) {
                        RealizedModelImpl.logger = java.util.logging.Logger.getLogger("com.vzome.core.model");
                    } return RealizedModelImpl.logger; }
                    /**
                     *
                     * @param {*} m
                     */
                    add(m) {
                        const key = m.toConstruction().getSignature();
                        this.mManifestations.put(key, m);
                        if (RealizedModelImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                            RealizedModelImpl.logger_$LI$().finer("add manifestation: " + m.toString());
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    remove(m) {
                        const key = m.toConstruction().getSignature();
                        this.mManifestations.remove(key);
                        if (RealizedModelImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                            RealizedModelImpl.logger_$LI$().finer("remove manifestation: " + m.toString());
                    }
                    refresh(on, unused) {
                        for (let index = this.mManifestations.values().iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (!man.isHidden()) {
                                    if (on)
                                        this.show(man);
                                    else
                                        this.hide(man);
                                }
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    show(m) {
                        if (this.doingBatch) {
                            if (this.removals.contains(m))
                                this.removals.remove(m);
                            else
                                this.additions.add(m);
                        }
                        else
                            this.privateShow(m);
                    }
                    /*private*/ privateShow(m) {
                        if (!m.isRendered()) {
                            for (let index = this.mListeners.iterator(); index.hasNext();) {
                                let next = index.next();
                                {
                                    next.manifestationAdded(m);
                                }
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    hide(m) {
                        if (this.doingBatch) {
                            if (this.additions.contains(m))
                                this.additions.remove(m);
                            else
                                this.removals.add(m);
                        }
                        else
                            this.privateHide(m);
                    }
                    /*private*/ privateHide(m) {
                        if (m.isRendered()) {
                            for (let index = this.mListeners.iterator(); index.hasNext();) {
                                let next = index.next();
                                {
                                    next.manifestationRemoved(m);
                                }
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} m
                     * @param {com.vzome.core.construction.Color} color
                     */
                    setColor(m, color) {
                        m.setColor(color);
                        if (m.isRendered()) {
                            for (let index = this.mListeners.iterator(); index.hasNext();) {
                                let next = index.next();
                                {
                                    next.manifestationColored(m, color);
                                }
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} m
                     * @param {string} label
                     */
                    setLabel(m, label) {
                        m.setLabel(label);
                        if (m.isRendered()) {
                            for (let index = this.mListeners.iterator(); index.hasNext();) {
                                let next = index.next();
                                {
                                    next.manifestationLabeled(m, label);
                                }
                            }
                        }
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.Construction} c
                     * @return {*}
                     */
                    findConstruction(c) {
                        let actualMan = this.mManifestations.get(c.getSignature());
                        if (actualMan == null)
                            actualMan = this.manifest(c);
                        return actualMan;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.Construction} c
                     * @return {*}
                     */
                    removeConstruction(c) {
                        const actualMan = this.mManifestations.get(c.getSignature());
                        if (actualMan == null)
                            return null;
                        return this.manifest(c);
                    }
                    /**
                     * @param {com.vzome.core.construction.Construction} c
                     * @return
                     * @return {*}
                     */
                    getManifestation(c) {
                        return this.mManifestations.get(c.getSignature());
                    }
                    /**
                     *
                     * @return {number}
                     */
                    size() {
                        return this.mManifestations.size();
                    }
                    /**
                     *
                     * @param {*} object
                     * @return {boolean}
                     */
                    equals(object) {
                        if (object == null) {
                            return false;
                        }
                        if (object === this) {
                            return true;
                        }
                        if (!(object != null && object instanceof com.vzome.core.model.RealizedModelImpl))
                            return false;
                        const that = object;
                        if (this.size() !== that.size())
                            return false;
                        for (let index = this.mManifestations.values().iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (!that.mManifestations.values().contains(man)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        return this.size();
                    }
                    startBatch() {
                        this.additions.clear();
                        this.removals.clear();
                        this.doingBatch = true;
                    }
                    endBatch() {
                        for (let index = this.removals.iterator(); index.hasNext();) {
                            let m = index.next();
                            {
                                this.privateHide(m);
                            }
                        }
                        for (let index = this.additions.iterator(); index.hasNext();) {
                            let m = index.next();
                            {
                                this.privateShow(m);
                            }
                        }
                        this.additions.clear();
                        this.removals.clear();
                        this.doingBatch = false;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getField() {
                        return this.field;
                    }
                    /**
                     *
                     * @param {string} signature
                     * @return {*}
                     */
                    findPerEditManifestation(signature) {
                        return this.mManifestedNow.get(signature);
                    }
                    /**
                     *
                     * @param {string} signature
                     * @param {*} m
                     */
                    addPerEditManifestation(signature, m) {
                        this.mManifestedNow.put(signature, m);
                    }
                    /**
                     *
                     */
                    clearPerEditManifestations() {
                        this.mManifestedNow = (new java.util.HashMap());
                    }
                }
                model.RealizedModelImpl = RealizedModelImpl;
                RealizedModelImpl["__class"] = "com.vzome.core.model.RealizedModelImpl";
                RealizedModelImpl["__interfaces"] = ["com.vzome.core.model.RealizedModel", "java.lang.Iterable"];
            })(model = core.model || (core.model = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var model;
            (function (model) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 */
                class ManifestationImpl {
                    constructor() {
                        this.mManifests = (new java.util.ArrayList());
                        this.mRendered = null;
                        this.hidden = false;
                        this.mId = ManifestationImpl.NO_ID;
                        if (this.color === undefined) {
                            this.color = null;
                        }
                        if (this.mContainer === undefined) {
                            this.mContainer = null;
                        }
                    }
                    resetId() {
                        ManifestationImpl.NEXT_ID = 0;
                        this.mId = ManifestationImpl.NO_ID;
                    }
                    getId() {
                        if (this.mId === ManifestationImpl.NO_ID)
                            this.mId = ManifestationImpl.NEXT_ID++;
                        return this.mId;
                    }
                    addConstruction(c) {
                        this.mManifests.add(c);
                    }
                    removeConstruction(c) {
                        this.mManifests.remove(c);
                    }
                    getConstructions() {
                        return this.mManifests.iterator();
                    }
                    /**
                     * This is different from toConstruction, because we must support
                     * the legacy behavior, which used the iterator.
                     * @return
                     * @return {com.vzome.core.construction.Construction}
                     */
                    getFirstConstruction() {
                        if (this.mManifests.isEmpty())
                            return null;
                        return this.mManifests.iterator().next();
                    }
                    isUnnecessary() {
                        return this.mManifests.isEmpty();
                    }
                    getColor() {
                        if (this.color == null && this.mRendered != null) {
                            this.color = this.mRendered.getColor();
                        }
                        return this.color;
                    }
                    setColor(color) {
                        this.color = color;
                    }
                    setRenderedObject(obj) {
                        this.mRendered = obj;
                        if (this.mRendered != null)
                            this.color = this.mRendered.getColor();
                    }
                    getRenderedObject() {
                        return this.mRendered;
                    }
                    isHidden() {
                        return this.hidden;
                    }
                    getContainer() {
                        return this.mContainer;
                    }
                    /**
                     *
                     * @param {com.vzome.core.model.Group} container
                     */
                    setContainer(container) {
                        this.mContainer = container;
                    }
                    setHidden(hidden) {
                        this.hidden = hidden;
                    }
                    isRendered() {
                        return this.mRendered != null;
                    }
                    getXml(doc) {
                        return this.toConstruction().getXml(doc);
                    }
                }
                ManifestationImpl.NO_ID = -1;
                ManifestationImpl.NEXT_ID = 0;
                model.ManifestationImpl = ManifestationImpl;
                ManifestationImpl["__class"] = "com.vzome.core.model.ManifestationImpl";
                ManifestationImpl["__interfaces"] = ["com.vzome.core.model.HasRenderedObject", "com.vzome.core.model.GroupElement", "com.vzome.core.model.Manifestation"];
            })(model = core.model || (core.model = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var parts;
            (function (parts) {
                /**
                 * @author Scott Vorthmann
                 *
                 * Since every field allows octahedral symmetry, we want the richest triangular
                 * tiling of that symmetry, which means we want the fundamental triangles of
                 * the reflection group, by definition.  Rather than rely on any symmetry orbits,
                 * we can simply hard-code the vertices of a disdyakis dodecahedron, all
                 * reflections and permutations of (8,0,0), (4,4,4), and (5,5,0).
                 * (This is a simple approximation with integers.)
                 * These vertices correspond to blue-like, yellow-like, and green-like axes,
                 * in the usual Zome coloring.
                 * @param {com.vzome.core.math.symmetry.Direction} dir
                 * @class
                 */
                class FastDefaultStrutGeometry {
                    constructor(dir) {
                        if (this.g2_vector === undefined) {
                            this.g2_vector = null;
                        }
                        if (this.b2_vector === undefined) {
                            this.b2_vector = null;
                        }
                        if (this.y2_vector === undefined) {
                            this.y2_vector = null;
                        }
                        if (this.g2n_vector === undefined) {
                            this.g2n_vector = null;
                        }
                        if (this.y2n_vector === undefined) {
                            this.y2n_vector = null;
                        }
                        if (this.mAxis === undefined) {
                            this.mAxis = null;
                        }
                        this.mAxis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0);
                        const v = this.mAxis.normal();
                        let x = v.getComponent(com.vzome.core.algebra.AlgebraicVector.X).evaluate();
                        let y = v.getComponent(com.vzome.core.algebra.AlgebraicVector.Y).evaluate();
                        let z = v.getComponent(com.vzome.core.algebra.AlgebraicVector.Z).evaluate();
                        let evenParity = true;
                        const xNeg = x < 0.0;
                        if (xNeg) {
                            x = -x;
                            evenParity = !evenParity;
                        }
                        const yNeg = y < 0.0;
                        if (yNeg) {
                            y = -y;
                            evenParity = !evenParity;
                        }
                        const zNeg = z < 0.0;
                        if (zNeg) {
                            z = -z;
                            evenParity = !evenParity;
                        }
                        let first;
                        let second;
                        let third;
                        let firstNeg;
                        let secondNeg;
                        let thirdNeg;
                        if (x >= y) {
                            if (y >= z) {
                                first = com.vzome.core.algebra.AlgebraicVector.X;
                                firstNeg = xNeg;
                                second = com.vzome.core.algebra.AlgebraicVector.Y;
                                secondNeg = yNeg;
                                third = com.vzome.core.algebra.AlgebraicVector.Z;
                                thirdNeg = zNeg;
                            }
                            else if (x >= z) {
                                first = com.vzome.core.algebra.AlgebraicVector.X;
                                firstNeg = xNeg;
                                second = com.vzome.core.algebra.AlgebraicVector.Z;
                                secondNeg = zNeg;
                                third = com.vzome.core.algebra.AlgebraicVector.Y;
                                thirdNeg = yNeg;
                                evenParity = !evenParity;
                            }
                            else {
                                first = com.vzome.core.algebra.AlgebraicVector.Z;
                                firstNeg = zNeg;
                                second = com.vzome.core.algebra.AlgebraicVector.X;
                                secondNeg = xNeg;
                                third = com.vzome.core.algebra.AlgebraicVector.Y;
                                thirdNeg = yNeg;
                            }
                        }
                        else {
                            if (x >= z) {
                                first = com.vzome.core.algebra.AlgebraicVector.Y;
                                firstNeg = yNeg;
                                second = com.vzome.core.algebra.AlgebraicVector.X;
                                secondNeg = xNeg;
                                third = com.vzome.core.algebra.AlgebraicVector.Z;
                                thirdNeg = zNeg;
                                evenParity = !evenParity;
                            }
                            else if (y >= z) {
                                first = com.vzome.core.algebra.AlgebraicVector.Y;
                                firstNeg = yNeg;
                                second = com.vzome.core.algebra.AlgebraicVector.Z;
                                secondNeg = zNeg;
                                third = com.vzome.core.algebra.AlgebraicVector.X;
                                thirdNeg = xNeg;
                            }
                            else {
                                first = com.vzome.core.algebra.AlgebraicVector.Z;
                                firstNeg = zNeg;
                                second = com.vzome.core.algebra.AlgebraicVector.Y;
                                secondNeg = yNeg;
                                third = com.vzome.core.algebra.AlgebraicVector.X;
                                thirdNeg = xNeg;
                                evenParity = !evenParity;
                            }
                        }
                        const field = v.getField();
                        const eight = field['createRational$long$long'](8, 10);
                        this.b2_vector = field.origin(3);
                        this.b2_vector.setComponent(first, firstNeg ? eight.negate() : eight);
                        const five = field['createRational$long$long'](5, 10);
                        this.g2_vector = field.origin(3);
                        this.g2_vector.setComponent(first, firstNeg ? five.negate() : five);
                        this.g2_vector.setComponent(second, secondNeg ? five.negate() : five);
                        const four = field['createRational$long$long'](4, 10);
                        this.y2_vector = field.origin(3);
                        this.y2_vector.setComponent(first, firstNeg ? four.negate() : four);
                        this.y2_vector.setComponent(second, secondNeg ? four.negate() : four);
                        this.y2_vector.setComponent(third, thirdNeg ? four.negate() : four);
                        if (!evenParity) {
                            const swap = this.y2_vector;
                            this.y2_vector = this.g2_vector;
                            this.g2_vector = swap;
                        }
                        const centroid = com.vzome.core.algebra.AlgebraicVectors.getCentroid([this.b2_vector, this.g2_vector, this.y2_vector]);
                        const b2g2 = this.g2_vector.minus(this.b2_vector);
                        const y2g2 = this.g2_vector.minus(this.y2_vector);
                        const normal = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(b2g2, y2g2);
                        const intersection = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(field.origin(3), v, this.g2_vector, normal);
                        const g2_offset = this.g2_vector.minus(centroid);
                        const y2_offset = this.y2_vector.minus(centroid);
                        this.g2_vector = intersection.plus(g2_offset);
                        this.y2_vector = intersection.plus(y2_offset);
                        this.g2n_vector = intersection.minus(g2_offset);
                        this.y2n_vector = intersection.minus(y2_offset);
                    }
                    getFast() {
                        return true;
                    }
                    /**
                     *
                     * @param {*} length
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    getStrutPolyhedron(length) {
                        const field = this.mAxis.getDirection().getSymmetry().getField();
                        const poly = new com.vzome.core.math.Polyhedron(field);
                        const strutVector = this.mAxis.normal().scale(length);
                        const g1_vector = this.g2_vector.negate().plus(strutVector);
                        const y1_vector = this.y2_vector.negate().plus(strutVector);
                        const g1n_vector = this.g2n_vector.negate().plus(strutVector);
                        const y1n_vector = this.y2n_vector.negate().plus(strutVector);
                        poly.addVertex(y1_vector);
                        const y1 = 0;
                        poly.addVertex(g1_vector);
                        const g1 = 1;
                        poly.addVertex(this.y2_vector);
                        const y2 = 2;
                        poly.addVertex(this.g2_vector);
                        const g2 = 3;
                        poly.addVertex(y1n_vector);
                        const y1n = 4;
                        poly.addVertex(g1n_vector);
                        const g1n = 5;
                        poly.addVertex(this.y2n_vector);
                        const y2n = 6;
                        poly.addVertex(this.g2n_vector);
                        const g2n = 7;
                        let face = poly.newFace();
                        face.add(g2);
                        face.add(y2);
                        face.add(y1n);
                        face.add(g1n);
                        poly.addFace(face);
                        face = poly.newFace();
                        face.add(g2);
                        face.add(g1n);
                        face.add(y1);
                        face.add(y2n);
                        poly.addFace(face);
                        face = poly.newFace();
                        face.add(g2n);
                        face.add(y2n);
                        face.add(y1);
                        face.add(g1);
                        poly.addFace(face);
                        face = poly.newFace();
                        face.add(g2n);
                        face.add(g1);
                        face.add(y1n);
                        face.add(y2);
                        poly.addFace(face);
                        face = poly.newFace();
                        face.add(y2);
                        face.add(g2);
                        face.add(y2n);
                        face.add(g2n);
                        poly.addFace(face);
                        face = poly.newFace();
                        face.add(g1);
                        face.add(y1);
                        face.add(g1n);
                        face.add(y1n);
                        poly.addFace(face);
                        return poly;
                    }
                }
                parts.FastDefaultStrutGeometry = FastDefaultStrutGeometry;
                FastDefaultStrutGeometry["__class"] = "com.vzome.core.parts.FastDefaultStrutGeometry";
                FastDefaultStrutGeometry["__interfaces"] = ["com.vzome.core.parts.StrutGeometry"];
            })(parts = core.parts || (core.parts = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 */
                class Construction {
                    constructor(field) {
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        this.mImpossible = false;
                        this.mIndex = -1;
                        this.__failed = false;
                        if (this.color === undefined) {
                            this.color = null;
                        }
                        this.field = field;
                    }
                    getField() {
                        return this.field;
                    }
                    setIndex(index) {
                        this.mIndex = index;
                    }
                    getIndex() {
                        return this.mIndex;
                    }
                    isImpossible() {
                        return this.mImpossible;
                    }
                    setImpossible(value) {
                        this.mImpossible = value;
                    }
                    setFailed() {
                        this.__failed = true;
                    }
                    failed() {
                        return this.__failed;
                    }
                    setColor(color) {
                        this.color = color;
                    }
                    getColor() {
                        return this.color;
                    }
                    getSignature() {
                        return "";
                    }
                }
                construction.Construction = Construction;
                Construction["__class"] = "com.vzome.core.construction.Construction";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * A selection in the model.
                 * @class
                 * @extends java.util.ArrayList
                 */
                class ConstructionList extends java.util.ArrayList {
                    addConstruction(ball) {
                        this.add(ball);
                        return this;
                    }
                    removeConstruction(ball) {
                        this.remove(ball);
                        return this;
                    }
                    getConstructions() {
                        return this.toArray((s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.size()));
                    }
                    constructor() {
                        super();
                    }
                }
                construction.ConstructionList = ConstructionList;
                ConstructionList["__class"] = "com.vzome.core.construction.ConstructionList";
                ConstructionList["__interfaces"] = ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {number} r
                 * @param {number} g
                 * @param {number} b
                 * @param {number} a
                 * @class
                 */
                class Color {
                    constructor(r, g, b, a) {
                        if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && ((typeof a === 'number') || a === null)) {
                            let __args = arguments;
                            if (this.red === undefined) {
                                this.red = 0;
                            }
                            if (this.green === undefined) {
                                this.green = 0;
                            }
                            if (this.blue === undefined) {
                                this.blue = 0;
                            }
                            if (this.alpha === undefined) {
                                this.alpha = 0;
                            }
                            this.red = r > 255 ? 255 : (r < 0 ? 0 : r);
                            this.green = g > 255 ? 255 : (g < 0 ? 0 : g);
                            this.blue = b > 255 ? 255 : (b < 0 ? 0 : b);
                            this.alpha = a > 255 ? 255 : (a < 0 ? 0 : a);
                        }
                        else if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && a === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let a = 255;
                                if (this.red === undefined) {
                                    this.red = 0;
                                }
                                if (this.green === undefined) {
                                    this.green = 0;
                                }
                                if (this.blue === undefined) {
                                    this.blue = 0;
                                }
                                if (this.alpha === undefined) {
                                    this.alpha = 0;
                                }
                                this.red = r > 255 ? 255 : (r < 0 ? 0 : r);
                                this.green = g > 255 ? 255 : (g < 0 ? 0 : g);
                                this.blue = b > 255 ? 255 : (b < 0 ? 0 : b);
                                this.alpha = a > 255 ? 255 : (a < 0 ? 0 : a);
                            }
                        }
                        else if (((typeof r === 'string') || r === null) && g === undefined && b === undefined && a === undefined) {
                            let __args = arguments;
                            let rgbaHex = __args[0];
                            if (this.red === undefined) {
                                this.red = 0;
                            }
                            if (this.green === undefined) {
                                this.green = 0;
                            }
                            if (this.blue === undefined) {
                                this.blue = 0;
                            }
                            if (this.alpha === undefined) {
                                this.alpha = 0;
                            }
                            const padded = "00000000" + rgbaHex;
                            rgbaHex = padded.substring(padded.length - 8);
                            const r = javaemul.internal.IntegerHelper.parseInt(rgbaHex.substring(0, 2), 16);
                            const g = javaemul.internal.IntegerHelper.parseInt(rgbaHex.substring(2, 4), 16);
                            const b = javaemul.internal.IntegerHelper.parseInt(rgbaHex.substring(4, 6), 16);
                            const a = javaemul.internal.IntegerHelper.parseInt(rgbaHex.substring(6, 8), 16);
                            this.red = r > 255 ? 255 : (r < 0 ? 0 : r);
                            this.green = g > 255 ? 255 : (g < 0 ? 0 : g);
                            this.blue = b > 255 ? 255 : (b < 0 ? 0 : b);
                            this.alpha = a > 255 ? 255 : (a < 0 ? 0 : a);
                        }
                        else if (((typeof r === 'number') || r === null) && g === undefined && b === undefined && a === undefined) {
                            let __args = arguments;
                            let rgb = __args[0];
                            {
                                let __args = arguments;
                                let r = (rgb >> 16) & 255;
                                let g = (rgb >> 8) & 255;
                                let b = rgb & 255;
                                {
                                    let __args = arguments;
                                    let a = 255;
                                    if (this.red === undefined) {
                                        this.red = 0;
                                    }
                                    if (this.green === undefined) {
                                        this.green = 0;
                                    }
                                    if (this.blue === undefined) {
                                        this.blue = 0;
                                    }
                                    if (this.alpha === undefined) {
                                        this.alpha = 0;
                                    }
                                    this.red = r > 255 ? 255 : (r < 0 ? 0 : r);
                                    this.green = g > 255 ? 255 : (g < 0 ? 0 : g);
                                    this.blue = b > 255 ? 255 : (b < 0 ? 0 : b);
                                    this.alpha = a > 255 ? 255 : (a < 0 ? 0 : a);
                                }
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static BLACK_$LI$() { if (Color.BLACK == null) {
                        Color.BLACK = new Color(0, 0, 0);
                    } return Color.BLACK; }
                    static WHITE_$LI$() { if (Color.WHITE == null) {
                        Color.WHITE = new Color(255, 255, 255);
                    } return Color.WHITE; }
                    static GREY_TRANSPARENT_$LI$() { if (Color.GREY_TRANSPARENT == null) {
                        Color.GREY_TRANSPARENT = new Color(25, 25, 25, 50);
                    } return Color.GREY_TRANSPARENT; }
                    getRGBColorComponents(rgb) {
                        const len = rgb.length;
                        if (len < 3 || len > 4) {
                            throw new java.lang.IllegalArgumentException("Expected rgb.length to be 3 or 4. Found " + len + ".");
                        }
                        rgb[0] = Math.fround(this.red / 255.0);
                        rgb[1] = Math.fround(this.green / 255.0);
                        rgb[2] = Math.fround(this.blue / 255.0);
                        if (len === 4) {
                            rgb[3] = Math.fround(this.alpha / 255.0);
                        }
                        return rgb;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        return this.getRGBA();
                    }
                    /**
                     *
                     * @param {*} other
                     * @return {boolean}
                     */
                    equals(other) {
                        if (this === other)
                            return true;
                        if (other == null)
                            return true;
                        if (!(other != null && other instanceof com.vzome.core.construction.Color))
                            return false;
                        const c = other;
                        return this.red === c.red && this.green === c.green && this.blue === c.blue && this.alpha === c.alpha;
                    }
                    getPastel() {
                        const r = this.red + ((255 - this.red) / 2 | 0);
                        const g = this.green + ((255 - this.green) / 2 | 0);
                        const b = this.blue + ((255 - this.blue) / 2 | 0);
                        return new Color(r, g, b, this.alpha);
                    }
                    /**
                     * @return
                     * @return {number}
                     */
                    getRGBA() {
                        return this.red * 16777216 + this.green * 65536 + this.blue * 256 + this.alpha;
                    }
                    getRGB() {
                        return this.red * 65536 + this.green * 256 + this.blue;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return this.red + "," + this.green + "," + this.blue + ((this.alpha < 255) ? "," + this.alpha : "");
                    }
                    toWebString() {
                        return javaemul.internal.StringHelper.format("#%02X%02X%02X", this.red, this.green, this.blue);
                    }
                    static parseColor(str) {
                        const toks = new java.util.StringTokenizer(str, ",");
                        const red = toks.nextToken();
                        const green = toks.nextToken();
                        const blue = toks.nextToken();
                        return new Color(javaemul.internal.IntegerHelper.parseInt(red), javaemul.internal.IntegerHelper.parseInt(green), javaemul.internal.IntegerHelper.parseInt(blue));
                    }
                    static parseWebColor(colorStr) {
                        return new Color(/* intValue */ (javaemul.internal.IntegerHelper.valueOf(colorStr.substring(1, 3), 16) | 0), /* intValue */ (javaemul.internal.IntegerHelper.valueOf(colorStr.substring(3, 5), 16) | 0), /* intValue */ (javaemul.internal.IntegerHelper.valueOf(colorStr.substring(5, 7), 16) | 0));
                    }
                    getRed() {
                        return this.red;
                    }
                    getGreen() {
                        return this.green;
                    }
                    getBlue() {
                        return this.blue;
                    }
                    getAlpha() {
                        return this.alpha;
                    }
                    static getComplement(color) {
                        return (color == null) ? null : new Color((128 + color.red) % 256, (128 + color.green) % 256, (128 + color.blue) % 256, color.alpha);
                    }
                    static getInverted(color) {
                        return (color == null) ? null : new Color(255 - color.red, 255 - color.green, 255 - color.blue, color.alpha);
                    }
                    /**
                     * @param {com.vzome.core.construction.Color} color color to be modified.
                     * @param {number} scale0to1 is adjusted internally to be between 0 and 1.
                     * @return {com.vzome.core.construction.Color} The original color maximized then having each component
                     * multiplied by the specified scale (between 0 and 1).
                     * Multiplying by 0 returns BLACK.
                     * Multiplying by 1 returns the maximized color.
                     */
                    static getScaledTo(color, scale0to1) {
                        if (color == null) {
                            return null;
                        }
                        const maxColor = Color.getMaximum(color);
                        const scale = Math.min(Math.max(0.0, scale0to1), 1.0);
                        if (scale === 0.0)
                            return Color.BLACK_$LI$();
                        if (scale === 1.0)
                            return maxColor;
                        const red = maxColor.getRed() * scale;
                        const green = maxColor.getGreen() * scale;
                        const blue = maxColor.getBlue() * scale;
                        return new Color(/* intValue */ (red | 0), /* intValue */ (green | 0), /* intValue */ (blue | 0), color.getAlpha());
                    }
                    /**
                     * @param {com.vzome.core.construction.Color} color
                     * @return {com.vzome.core.construction.Color} A new color where each of the RGB components are proportional to the parameter
                     * but scaled so that the component with the highest value becomes 0xFF.
                     * Other components are scaled proportionally. The alpha component is unchanged.
                     * If the color is null or BLACK (0,0,0) or if one or more elements are already at 0xFF
                     * then the original value is returned unchanged.
                     */
                    static getMaximum(color) {
                        if (color == null) {
                            return null;
                        }
                        const most = Math.max(Math.max(color.red, color.green), color.blue);
                        return (most === 0 || most === 255) ? color : new Color((255 * color.red / most | 0), (255 * color.green / most | 0), (255 * color.blue / most | 0), color.alpha);
                    }
                    static getPastel(color) {
                        return (color == null) ? null : color.getPastel();
                    }
                }
                construction.Color = Color;
                Color["__class"] = "com.vzome.core.construction.Color";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var generic;
            (function (generic) {
                /**
                 * @author David Hall
                 * @class
                 */
                class ArrayComparator {
                    getContentFirstArrayComparator() {
                        return (new ArrayComparator.ContentFirstArrayComparator());
                    }
                    getLengthFirstArrayComparator() {
                        return (new ArrayComparator.LengthFirstArrayComparator());
                    }
                }
                generic.ArrayComparator = ArrayComparator;
                ArrayComparator["__class"] = "com.vzome.core.generic.ArrayComparator";
                (function (ArrayComparator) {
                    class ContentFirstArrayComparator {
                        /**
                         *
                         * @param {T[]} array1
                         * @param {T[]} array2
                         * @return {number}
                         */
                        compare(array1, array2) {
                            const len1 = array1.length;
                            const len2 = array2.length;
                            const smaller = len1 < len2 ? len1 : len2;
                            for (let i = 0; i < smaller; i++) {
                                {
                                    const element1 = array1[i];
                                    const element2 = array2[i];
                                    const comparison = element1.compareTo(element2);
                                    if (comparison !== 0) {
                                        return comparison;
                                    }
                                }
                                ;
                            }
                            return /* compareTo */ ((o1, o2) => { if (o1 && o1.compareTo) {
                                return o1.compareTo(o2);
                            }
                            else {
                                return o1 < o2 ? -1 : o2 < o1 ? 1 : 0;
                            } })(len1, len2);
                        }
                        constructor() {
                        }
                    }
                    ArrayComparator.ContentFirstArrayComparator = ContentFirstArrayComparator;
                    ContentFirstArrayComparator["__class"] = "com.vzome.core.generic.ArrayComparator.ContentFirstArrayComparator";
                    ContentFirstArrayComparator["__interfaces"] = ["java.util.Comparator"];
                    class LengthFirstArrayComparator {
                        /**
                         *
                         * @param {T[]} array1
                         * @param {T[]} array2
                         * @return {number}
                         */
                        compare(array1, array2) {
                            const len1 = array1.length;
                            const len2 = array2.length;
                            let comparison = ((o1, o2) => { if (o1 && o1.compareTo) {
                                return o1.compareTo(o2);
                            }
                            else {
                                return o1 < o2 ? -1 : o2 < o1 ? 1 : 0;
                            } })(len1, len2);
                            if (comparison !== 0) {
                                return comparison;
                            }
                            for (let i = 0; i < len1; i++) {
                                {
                                    const element1 = array1[i];
                                    const element2 = array2[i];
                                    comparison = element1.compareTo(element2);
                                    if (comparison !== 0) {
                                        return comparison;
                                    }
                                }
                                ;
                            }
                            return comparison;
                        }
                        constructor() {
                        }
                    }
                    ArrayComparator.LengthFirstArrayComparator = LengthFirstArrayComparator;
                    LengthFirstArrayComparator["__class"] = "com.vzome.core.generic.ArrayComparator.LengthFirstArrayComparator";
                    LengthFirstArrayComparator["__interfaces"] = ["java.util.Comparator"];
                })(ArrayComparator = generic.ArrayComparator || (generic.ArrayComparator = {}));
            })(generic = core.generic || (core.generic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var generic;
            (function (generic) {
                /**
                 * @author David Hall
                 * Based on http://stackoverflow.com/questions/5474893/how-to-implement-this-filteringiterator
                 * @class
                 */
                class FilteredIterator {
                    constructor(preTest, iterable, postTest) {
                        if (this.wrappedIterator === undefined) {
                            this.wrappedIterator = null;
                        }
                        if (this.__preFilter === undefined) {
                            this.__preFilter = null;
                        }
                        if (this.__postFilter === undefined) {
                            this.__postFilter = null;
                        }
                        this.nextElement = null;
                        this.__hasNext = null;
                        this.wrappedIterator = iterable.iterator();
                        this.__preFilter = (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                            return funcInst;
                        } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(preTest));
                        this.__postFilter = (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                            return funcInst;
                        } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postTest));
                    }
                    /**
                     * Elements must match this filter before conversion
                     * @param {*} element
                     * @return {boolean}
                     */
                    preFilter(element) {
                        return this.__preFilter == null ? true : (target => (typeof target === 'function') ? target(element) : target.test(element))(this.__preFilter);
                    }
                    /**
                     * Elements must match this filter after conversion
                     * @param {*} element
                     * @return {boolean}
                     */
                    postFilter(element) {
                        return this.__postFilter == null ? true : (target => (typeof target === 'function') ? target(element) : target.test(element))(this.__postFilter);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    iterator() {
                        return this;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        if (this.__hasNext == null) {
                            this.nextMatch();
                        }
                        return this.__hasNext;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    next() {
                        if (this.__hasNext == null) {
                            this.nextMatch();
                        }
                        if (!this.__hasNext) {
                            throw new java.util.NoSuchElementException();
                        }
                        return this.nextMatch();
                    }
                    nextMatch() {
                        const lastMatch = this.nextElement;
                        while ((this.wrappedIterator.hasNext())) {
                            {
                                const next = this.wrappedIterator.next();
                                if (this.preFilter(next)) {
                                    const converted = this.apply(next);
                                    if (this.postFilter(converted)) {
                                        this.nextElement = converted;
                                        this.__hasNext = true;
                                        return lastMatch;
                                    }
                                }
                            }
                        }
                        ;
                        this.__hasNext = false;
                        return lastMatch;
                    }
                    /**
                     *
                     */
                    remove() {
                        this.wrappedIterator.remove();
                    }
                }
                generic.FilteredIterator = FilteredIterator;
                FilteredIterator["__class"] = "com.vzome.core.generic.FilteredIterator";
                FilteredIterator["__interfaces"] = ["java.util.Iterator", "java.lang.Iterable"];
                (function (FilteredIterator) {
                    class Filters {
                        constructor() {
                        }
                        /**
                         * A static convenience function that may be passed as a preFilter parameter
                         * @param <T>
                         * @param {*} element
                         * @return {boolean} {@code true} if element is not null
                         */
                        static elementNotNull(element) {
                            return element != null;
                        }
                        /**
                         * A static convenience function that may be passed as a postFilter parameter
                         * @param <R>
                         * @param {*} result
                         * @return {boolean} {@code true} if result is not null
                         */
                        static resultNotNull(result) {
                            return result != null;
                        }
                        /**
                         * A static convenience function that may be used with another predicate
                         * to be passed as a preFilter or postFilter parameter
                         * @param <B>
                         * @param {*} predicate The predicate to be negated.
                         * @param {*} arg The parameter to be passed to the predicate.
                         * @return {boolean} The opposite of what the predicate returns.
                         */
                        static not(predicate, arg) {
                            return (target => (typeof target === 'function') ? target(arg) : target.test(arg))((target => (typeof target === 'function') ? target() : target.negate())(predicate));
                        }
                        /**
                         * A static convenience function that may be used to combine two other predicates
                         * to be passed as a preFilter or postFilter parameter
                         * @param <B>
                         * @param {*} check1 The 1st predicate to be evaluated.
                         * @param {*} check2 The 2nd predicate to be evaluated.
                         * @param {*} arg The parameter to be passed to the predicates.
                         * @return {boolean} {@code true} only if both predicates are true.
                         */
                        static and(check1, check2, arg) {
                            return (target => (typeof target === 'function') ? target(arg) : target.test(arg))((target => (typeof target === 'function') ? target(check2) : target.and(check2))(check1));
                        }
                        /**
                         * A static convenience function that may be used to combine two other predicates
                         * to be passed as a preFilter or postFilter parameter
                         * @param <B>
                         * @param {*} check1 The 1st predicate to be evaluated.
                         * @param {*} check2 The 2nd predicate to be evaluated.
                         * @param {*} arg The parameter to be passed to the predicates.
                         * @return {boolean} {@code true} if either predicate is true.
                         */
                        static or(check1, check2, arg) {
                            return (target => (typeof target === 'function') ? target(arg) : target.test(arg))((target => (typeof target === 'function') ? target(check2) : target.or(check2))(check1));
                        }
                    }
                    FilteredIterator.Filters = Filters;
                    Filters["__class"] = "com.vzome.core.generic.FilteredIterator.Filters";
                })(FilteredIterator = generic.FilteredIterator || (generic.FilteredIterator = {}));
            })(generic = core.generic || (core.generic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class XmlSaveFormat {
                    constructor(version, capabilities) {
                        if (this.mProject4d === undefined) {
                            this.mProject4d = false;
                        }
                        if (this.mSelectionNotSaved === undefined) {
                            this.mSelectionNotSaved = false;
                        }
                        if (this.mRationalVectors === undefined) {
                            this.mRationalVectors = false;
                        }
                        if (this.mGroupingInSelection === undefined) {
                            this.mGroupingInSelection = false;
                        }
                        if (this.mField === undefined) {
                            this.mField = null;
                        }
                        if (this.mScale === undefined) {
                            this.mScale = 0;
                        }
                        if (this.mMultiplier === undefined) {
                            this.mMultiplier = null;
                        }
                        if (this.writerVersion === undefined) {
                            this.writerVersion = null;
                        }
                        if (this.version === undefined) {
                            this.version = null;
                        }
                        this.capabilities = (new java.util.HashSet());
                        if (this.properties === undefined) {
                            this.properties = null;
                        }
                        this.version = version;
                        this.capabilities.addAll(java.util.Arrays.asList(capabilities));
                        this.mProject4d = this.capabilities.contains(XmlSaveFormat.PROJECT_4D);
                        this.mSelectionNotSaved = this.capabilities.contains(XmlSaveFormat.SELECTION_NOT_SAVED);
                        this.mRationalVectors = this.capabilities.contains(XmlSaveFormat.RATIONAL_VECTORS);
                        this.mGroupingInSelection = this.capabilities.contains(XmlSaveFormat.GROUPING_IN_SELECTION);
                        XmlSaveFormat.FORMATS_$LI$().put(version, this);
                    }
                    static FORMATS_$LI$() { if (XmlSaveFormat.FORMATS == null) {
                        XmlSaveFormat.FORMATS = (new java.util.HashMap());
                    } return XmlSaveFormat.FORMATS; }
                    static logger_$LI$() { if (XmlSaveFormat.logger == null) {
                        XmlSaveFormat.logger = java.util.logging.Logger.getLogger("com.vzome.core.commands.XmlSaveFormat");
                    } return XmlSaveFormat.logger; }
                    /**
                     * Initialize.
                     *
                     * If you're tempted to add another parameter, see if you can make it a property instead.
                     *
                     * Shouldn't we just replace all the parameters with one Controller object?
                     *
                     * @param root
                     * @param {*} field
                     * @param symms
                     * @param {number} scale
                     * @param {string} writerVersion
                     * @param {java.util.Properties} props
                     */
                    initialize(field, scale, writerVersion, props) {
                        this.properties = props;
                        this.writerVersion = writerVersion;
                        if ((writerVersion == null) || /* isEmpty */ (writerVersion.length === 0))
                            this.writerVersion = "before 2.1 Beta 7";
                        this.mField = field;
                        this.mScale = scale;
                        if (scale === 0)
                            this.mMultiplier = null;
                        else
                            this.mMultiplier = field['createPower$int'](scale);
                    }
                    getVersion() {
                        return this.version;
                    }
                    isMigration() {
                        return !this.multipleDesigns();
                    }
                    selectionsNotSaved() {
                        return this.mSelectionNotSaved;
                    }
                    rationalVectors() {
                        return this.mRationalVectors;
                    }
                    actionHistory() {
                        return false;
                    }
                    commandEditsCompacted() {
                        return this.capabilities.contains(XmlSaveFormat.COMPACTED_COMMAND_EDITS);
                    }
                    multipleDesigns() {
                        return this.capabilities.contains(XmlSaveFormat.MULTIPLE_DESIGNS);
                    }
                    groupingDoneInSelection() {
                        return this.mGroupingInSelection && !("2.1.3" === this.writerVersion);
                    }
                    groupingRecursive() {
                        return !this.groupingDoneInSelection() || ("2.1.2" === this.writerVersion);
                    }
                    interim210format() {
                        return this.capabilities.contains(XmlSaveFormat.FORMAT_2_1_0);
                    }
                    parseAlgebraicVector(elem) {
                        let val = elem.getAttribute("x");
                        const x = (val == null || /* isEmpty */ (val.length === 0)) ? this.mField.zero() : this.mField.parseLegacyNumber(val);
                        val = elem.getAttribute("y");
                        const y = (val == null || /* isEmpty */ (val.length === 0)) ? this.mField.zero() : this.mField.parseLegacyNumber(val);
                        val = elem.getAttribute("z");
                        const z = (val == null || /* isEmpty */ (val.length === 0)) ? this.mField.zero() : this.mField.parseLegacyNumber(val);
                        val = elem.getAttribute("w");
                        const threeD = val == null || /* isEmpty */ (val.length === 0);
                        let w = null;
                        if (!threeD)
                            w = this.mField.parseLegacyNumber(val);
                        let value = threeD ? new com.vzome.core.algebra.AlgebraicVector(x, y, z) : new com.vzome.core.algebra.AlgebraicVector(w, x, y, z);
                        if (this.mProject4d && !threeD) {
                            if (!w.isZero() && XmlSaveFormat.logger_$LI$().isLoggable(java.util.logging.Level.WARNING))
                                XmlSaveFormat.logger_$LI$().warning("stripping non-zero W component from " + value.toString());
                            value = this.mField.projectTo3d(value, true);
                        }
                        if (this.mMultiplier != null)
                            value = value.scale(this.mMultiplier);
                        return value;
                    }
                    static NOT_AN_ATTRIBUTE_$LI$() { if (XmlSaveFormat.NOT_AN_ATTRIBUTE == null) {
                        XmlSaveFormat.NOT_AN_ATTRIBUTE = new Object();
                    } return XmlSaveFormat.NOT_AN_ATTRIBUTE; }
                    parseAlgebraicObject(valName, val) {
                        let value = XmlSaveFormat.NOT_AN_ATTRIBUTE_$LI$();
                        if (valName === ("Null"))
                            value = null;
                        else if (valName === ("RationalVector")) {
                            const nums = val.getAttribute("nums");
                            if (nums == null || /* isEmpty */ (nums.length === 0))
                                return this.mField.origin(3);
                            const denoms = val.getAttribute("denoms");
                            let tokens = new java.util.StringTokenizer(nums);
                            const result = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1];
                            for (let i = 0; i < this.mField.getOrder(); i++) {
                                {
                                    const token = tokens.nextToken();
                                    if (token == null)
                                        throw new java.lang.IllegalStateException("RationalVector nums too short for field " + this.mField.getName());
                                    result[i * 2] = javaemul.internal.IntegerHelper.parseInt(token);
                                }
                                ;
                            }
                            if (denoms != null && !(denoms.length === 0)) {
                                tokens = new java.util.StringTokenizer(denoms);
                                for (let i = 0; i < this.mField.getOrder(); i++) {
                                    {
                                        const token = tokens.nextToken();
                                        if (token == null)
                                            throw new java.lang.IllegalStateException("RationalVector denoms too short for field " + this.mField.getName());
                                        result[i * 2 + 1] = javaemul.internal.IntegerHelper.parseInt(token);
                                    }
                                    ;
                                }
                            }
                            const oneThirdLen = (result.length / 3 | 0);
                            const twoThirdLen = oneThirdLen * 2;
                            const result3d = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                                return 0;
                            }
                            else {
                                let array = [];
                                for (let i = 0; i < dims[0]; i++) {
                                    array.push(allocate(dims.slice(1)));
                                }
                                return array;
                            } }; return allocate(dims); })([3, oneThirdLen]);
                            for (let i = 0; i < oneThirdLen; i++) {
                                {
                                    result3d[0][i] = result[i];
                                    result3d[1][i] = result[i + oneThirdLen];
                                    result3d[2][i] = result[i + twoThirdLen];
                                }
                                ;
                            }
                            value = this.mField.createVector(result3d);
                        }
                        else if (valName === ("GoldenVector"))
                            value = this.parseAlgebraicVector(val);
                        else if (valName === ("Boolean")) {
                            const gnum = val.getAttribute("value");
                            value = javaemul.internal.BooleanHelper.parseBoolean(gnum);
                        }
                        else if (valName === ("Integer")) {
                            const gnum = val.getAttribute("value");
                            value = javaemul.internal.IntegerHelper.parseInt(gnum);
                        }
                        else if ((valName === ("GoldenNumber")) || (valName === ("IntegralNumber"))) {
                            const gnum = val.getAttribute("value");
                            value = this.mField.parseLegacyNumber(gnum);
                            if (this.mMultiplier != null)
                                value = value['times$com_vzome_core_algebra_AlgebraicNumber'](this.mMultiplier);
                        }
                        else if (valName === ("String"))
                            value = val.getTextContent();
                        return value;
                    }
                    parseConstruction$java_lang_String$org_w3c_dom_Element(apName, attrOrParam) {
                        return this.parseConstruction$java_lang_String$org_w3c_dom_Element$boolean(apName, attrOrParam, false);
                    }
                    parseConstruction$java_lang_String$org_w3c_dom_Element$boolean(apName, attrOrParam, projectTo3d) {
                        let c = null;
                        if (apName === ("point")) {
                            let loc = this.parseAlgebraicVector(attrOrParam);
                            if (projectTo3d)
                                loc = loc.projectTo3d(true);
                            c = new com.vzome.core.construction.FreePoint(loc);
                        }
                        else if (apName === ("segment")) {
                            const start = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element$java_lang_String(attrOrParam, "start");
                            const end = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element$java_lang_String(attrOrParam, "end");
                            let sloc = this.parseAlgebraicVector(start);
                            let eloc = this.parseAlgebraicVector(end);
                            if (projectTo3d) {
                                sloc = sloc.projectTo3d(true);
                                eloc = eloc.projectTo3d(true);
                            }
                            c = new com.vzome.core.construction.SegmentJoiningPoints(new com.vzome.core.construction.FreePoint(sloc), new com.vzome.core.construction.FreePoint(eloc));
                        }
                        else if (apName === ("polygon")) {
                            const kids = attrOrParam.getElementsByTagName("vertex");
                            const pts = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(kids.getLength());
                            for (let k = 0; k < kids.getLength(); k++) {
                                {
                                    let loc = this.parseAlgebraicVector(kids.item(k));
                                    if (projectTo3d)
                                        loc = loc.projectTo3d(true);
                                    pts[k] = new com.vzome.core.construction.FreePoint(loc);
                                }
                                ;
                            }
                            c = new com.vzome.core.construction.PolygonFromVertices(pts);
                        }
                        return c;
                    }
                    /**
                     * this is for the old format (before rationalVectors)
                     * @param {string} apName
                     * @param {*} attrOrParam
                     * @param {boolean} projectTo3d
                     * @return {com.vzome.core.construction.Construction}
                     */
                    parseConstruction(apName, attrOrParam, projectTo3d) {
                        if (((typeof apName === 'string') || apName === null) && ((attrOrParam != null && (attrOrParam.constructor != null && attrOrParam.constructor["__interfaces"] != null && attrOrParam.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || attrOrParam === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                            return this.parseConstruction$java_lang_String$org_w3c_dom_Element$boolean(apName, attrOrParam, projectTo3d);
                        }
                        else if (((typeof apName === 'string') || apName === null) && ((attrOrParam != null && (attrOrParam.constructor != null && attrOrParam.constructor["__interfaces"] != null && attrOrParam.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || attrOrParam === null) && projectTo3d === undefined) {
                            return this.parseConstruction$java_lang_String$org_w3c_dom_Element(apName, attrOrParam);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    loadCommandAttributes$org_w3c_dom_Element(editElem) {
                        return this.loadCommandAttributes$org_w3c_dom_Element$boolean(editElem, false);
                    }
                    loadCommandAttributes$org_w3c_dom_Element$boolean(editElem, projectTo3d) {
                        const attrs = new com.vzome.core.commands.AttributeMap();
                        const kids = editElem.getChildNodes();
                        for (let j = 0; j < kids.getLength(); j++) {
                            {
                                const node = kids.item(j);
                                if (!(node != null && (node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)))
                                    continue;
                                let attrElem = node;
                                let elemName = attrElem.getLocalName();
                                let attrName = attrElem.getAttribute("attrName");
                                if (this.interim210format()) {
                                    attrName = attrElem.getAttribute("name");
                                    const elemKid = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element(attrElem);
                                    if (elemKid != null) {
                                        attrElem = elemKid;
                                        elemName = attrElem.getLocalName();
                                    }
                                }
                                let value = this.parseAlgebraicObject(elemName, attrElem);
                                if (value === XmlSaveFormat.NOT_AN_ATTRIBUTE_$LI$())
                                    if (this.rationalVectors()) {
                                        if (elemName === ("point"))
                                            value = this.parsePoint$org_w3c_dom_Element$java_lang_String$boolean(attrElem, "at", projectTo3d);
                                        else if (elemName === ("segment"))
                                            value = this.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String$boolean(attrElem, "start", "end", projectTo3d);
                                        else if (elemName === ("polygon"))
                                            value = this.parsePolygon$org_w3c_dom_Element$java_lang_String$boolean(attrElem, "vertex", projectTo3d);
                                        else
                                            throw new java.lang.IllegalStateException("unknown parameter construction: " + elemName);
                                    }
                                    else
                                        value = this.parseConstruction$java_lang_String$org_w3c_dom_Element$boolean(elemName, attrElem, projectTo3d);
                                attrs.put(attrName, value);
                            }
                            ;
                        }
                        return attrs;
                    }
                    loadCommandAttributes(editElem, projectTo3d) {
                        if (((editElem != null && (editElem.constructor != null && editElem.constructor["__interfaces"] != null && editElem.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || editElem === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                            return this.loadCommandAttributes$org_w3c_dom_Element$boolean(editElem, projectTo3d);
                        }
                        else if (((editElem != null && (editElem.constructor != null && editElem.constructor["__interfaces"] != null && editElem.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || editElem === null) && projectTo3d === undefined) {
                            return this.loadCommandAttributes$org_w3c_dom_Element(editElem);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getField() {
                        return this.mField;
                    }
                    getScale() {
                        return this.mScale;
                    }
                    static serializeNumber(xml, attrName, number) {
                        com.vzome.xml.DomUtils.addAttribute(xml, attrName, number.toString(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                    }
                    static serializePoint(xml, attrName, point) {
                        com.vzome.xml.DomUtils.addAttribute(xml, attrName, point.getLocation().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                    }
                    static serializeSegment(xml, startAttrName, endAttrName, segment) {
                        com.vzome.xml.DomUtils.addAttribute(xml, startAttrName, segment.getStart().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                        com.vzome.xml.DomUtils.addAttribute(xml, endAttrName, segment.getEnd().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                    }
                    static serializePolygon(xml, vertexChildName, polygon) {
                        polygon.getXml$org_w3c_dom_Element$java_lang_String(xml, vertexChildName);
                    }
                    parseRationalVector(xml, attrName) {
                        const nums = xml.getAttribute(attrName);
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return null;
                        const loc = this.mField.parseVector(nums);
                        return loc;
                    }
                    parseRationalNumber(xml, attrName) {
                        const nums = xml.getAttribute(attrName);
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return null;
                        const loc = this.mField.parseNumber(nums);
                        return loc;
                    }
                    parsePoint$org_w3c_dom_Element$java_lang_String(xml, attrName) {
                        return this.parsePoint$org_w3c_dom_Element$java_lang_String$boolean(xml, attrName, false);
                    }
                    parsePoint$org_w3c_dom_Element$java_lang_String$boolean(xml, attrName, projectTo3d) {
                        const nums = xml.getAttribute(attrName);
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return null;
                        let loc = this.mField.parseVector(nums);
                        if (projectTo3d)
                            loc = loc.projectTo3d(true);
                        return new com.vzome.core.construction.FreePoint(loc);
                    }
                    parsePoint(xml, attrName, projectTo3d) {
                        if (((xml != null && (xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof attrName === 'string') || attrName === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                            return this.parsePoint$org_w3c_dom_Element$java_lang_String$boolean(xml, attrName, projectTo3d);
                        }
                        else if (((xml != null && (xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof attrName === 'string') || attrName === null) && projectTo3d === undefined) {
                            return this.parsePoint$org_w3c_dom_Element$java_lang_String(xml, attrName);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, startAttrName, endAttrName) {
                        return this.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String$boolean(xml, startAttrName, endAttrName, false);
                    }
                    parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String$boolean(xml, startAttrName, endAttrName, projectTo3d) {
                        let nums = xml.getAttribute(endAttrName);
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return null;
                        let eloc = this.mField.parseVector(nums);
                        nums = xml.getAttribute(startAttrName);
                        let sloc = (nums == null || /* isEmpty */ (nums.length === 0)) ? this.mField.origin(eloc.dimension()) : this.mField.parseVector(nums);
                        if (projectTo3d) {
                            sloc = sloc.projectTo3d(true);
                            eloc = eloc.projectTo3d(true);
                        }
                        return new com.vzome.core.construction.SegmentJoiningPoints(new com.vzome.core.construction.FreePoint(sloc), new com.vzome.core.construction.FreePoint(eloc));
                    }
                    parseSegment(xml, startAttrName, endAttrName, projectTo3d) {
                        if (((xml != null && (xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof startAttrName === 'string') || startAttrName === null) && ((typeof endAttrName === 'string') || endAttrName === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                            return this.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String$boolean(xml, startAttrName, endAttrName, projectTo3d);
                        }
                        else if (((xml != null && (xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof startAttrName === 'string') || startAttrName === null) && ((typeof endAttrName === 'string') || endAttrName === null) && projectTo3d === undefined) {
                            return this.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, startAttrName, endAttrName);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    parsePolygon$org_w3c_dom_Element$java_lang_String(xml, vertexChildName) {
                        return this.parsePolygon$org_w3c_dom_Element$java_lang_String$boolean(xml, vertexChildName, false);
                    }
                    parsePolygon$org_w3c_dom_Element$java_lang_String$boolean(xml, vertexChildName, projectTo3d) {
                        const kids = xml.getElementsByTagName(vertexChildName);
                        const pts = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(kids.getLength());
                        for (let k = 0; k < kids.getLength(); k++) {
                            {
                                const nums = kids.item(k).getAttribute("at");
                                let loc = this.mField.parseVector(nums);
                                if (projectTo3d)
                                    loc = loc.projectTo3d(true);
                                pts[k] = new com.vzome.core.construction.FreePoint(loc);
                            }
                            ;
                        }
                        return new com.vzome.core.construction.PolygonFromVertices(pts);
                    }
                    parsePolygon(xml, vertexChildName, projectTo3d) {
                        if (((xml != null && (xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof vertexChildName === 'string') || vertexChildName === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                            return this.parsePolygon$org_w3c_dom_Element$java_lang_String$boolean(xml, vertexChildName, projectTo3d);
                        }
                        else if (((xml != null && (xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof vertexChildName === 'string') || vertexChildName === null) && projectTo3d === undefined) {
                            return this.parsePolygon$org_w3c_dom_Element$java_lang_String(xml, vertexChildName);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    parsePolygonReversed(xml, vertexChildName) {
                        const kids = xml.getElementsByTagName(vertexChildName);
                        const pts = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(kids.getLength());
                        const kmax = kids.getLength() - 1;
                        for (let k = 0; k < kids.getLength(); k++) {
                            {
                                const nums = kids.item(k).getAttribute("at");
                                const loc = this.mField.parseVector(nums);
                                pts[kmax - k] = new com.vzome.core.construction.FreePoint(loc);
                            }
                            ;
                        }
                        return new com.vzome.core.construction.PolygonFromVertices(pts);
                    }
                    parseNumber(xml, attrName) {
                        const nums = xml.getAttribute(attrName);
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return null;
                        return this.mField.parseNumber(nums);
                    }
                    static escapeNewlines(input) {
                        const buf = new java.lang.StringBuffer();
                        const br = new java.io.BufferedReader(new java.io.StringReader(input));
                        let line = null;
                        try {
                            while (((line = br.readLine()) != null)) {
                                {
                                    const comment = line.indexOf("//");
                                    if (comment >= 0) {
                                        line = line.substring(0, comment);
                                    }
                                    buf.append(line + "\n");
                                }
                            }
                            ;
                        }
                        catch (e) {
                        }
                        return buf.toString();
                    }
                    loadToRender() {
                        return !("true" === this.properties.getProperty("no.rendering"));
                    }
                    getToolVersion(element) {
                        let fileEdition = element.getAttribute("edition");
                        if (fileEdition == null || /* isEmpty */ (fileEdition.length === 0))
                            fileEdition = "vZome";
                        return fileEdition + " " + this.writerVersion;
                    }
                }
                XmlSaveFormat.CURRENT_FORMAT = "http://xml.vzome.com/vZome/4.0.0/";
                XmlSaveFormat.PROJECT_4D = "project-4D-to-3D";
                XmlSaveFormat.SELECTION_NOT_SAVED = "selection-not-saved";
                XmlSaveFormat.FORMAT_2_1_0 = "interim-210-format";
                XmlSaveFormat.GROUPING_IN_SELECTION = "grouping-in-selection";
                XmlSaveFormat.RATIONAL_VECTORS = "rational-vectors";
                XmlSaveFormat.COMPACTED_COMMAND_EDITS = "compacted-command-edits";
                XmlSaveFormat.MULTIPLE_DESIGNS = "multiple-designs";
                XmlSaveFormat.UNKNOWN_COMMAND = "unknown.command";
                commands.XmlSaveFormat = XmlSaveFormat;
                XmlSaveFormat["__class"] = "com.vzome.core.commands.XmlSaveFormat";
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author David Hall
                 * This class doesn't add anything to the TreeMap,
                 * but there were so many places that were using Map<String, Object>,
                 * that I decided to use this class to clarify which ones were using it
                 * for managing attributes. It also avoids cluttering the code
                 * with Map<String, Object> which is just needed for type safety,
                 * but which does nothing for describing the intended use of the variables.
                 *
                 * Note that in XmlSaveFormat, AttributeMap replaces TreeMap<>,
                 * but in other places (such as CommandEdit), it replaces HashMap<>.
                 * XmlSaveFormat requires the Map<> to be ordered, but I assume
                 * that other places can safely use any implementation of Map<>.
                 * Therefore, I have used TreeMap<> rather than HashMap<> as the basis
                 * for AttributeMap across the board.
                 * @class
                 * @extends java.util.TreeMap
                 */
                class AttributeMap extends java.util.TreeMap {
                    constructor() {
                        super();
                    }
                }
                AttributeMap.__com_vzome_core_commands_AttributeMap_serialVersionUID = 1;
                commands.AttributeMap = AttributeMap;
                AttributeMap["__class"] = "com.vzome.core.commands.AttributeMap";
                AttributeMap["__interfaces"] = ["java.lang.Cloneable", "java.util.Map", "java.util.NavigableMap", "java.util.SortedMap", "java.io.Serializable"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class AbstractCommand {
                    /**
                     * This default behavior deserializes in the old way, before XmlSaveFormat .COMPACTED_COMMAND_EDITS
                     * @param attributes
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @return
                     * @return {com.vzome.core.commands.AttributeMap}
                     */
                    setXml(xml, format) {
                        const attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                        this.setFixedAttributes(attrs, format);
                        return attrs;
                    }
                    setFixedAttributes(attributes, format) {
                        attributes.put(com.vzome.core.commands.Command.FIELD_ATTR_NAME, format.getField());
                    }
                    /**
                     * This default behavior serializes in the old way, before XmlSaveFormat .COMPACTED_COMMAND_EDITS
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @return
                     * @param {*} result
                     */
                    getXml(result, attributes) {
                        if (attributes == null)
                            return;
                        for (let index = attributes.keySet().iterator(); index.hasNext();) {
                            let key = index.next();
                            {
                                if (key === com.vzome.core.commands.Command.FIELD_ATTR_NAME)
                                    continue;
                                if (key === com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME)
                                    continue;
                                if (key === com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME)
                                    continue;
                                if (key === com.vzome.core.commands.CommandImportVEFData.FIELD_ATTR_NAME)
                                    continue;
                                const value = attributes.get(key);
                                if (value != null && value instanceof com.vzome.core.math.symmetry.IcosahedralSymmetry)
                                    continue;
                                AbstractCommand.saveCommandAttribute(result, key, value);
                            }
                        }
                    }
                    static saveCommandAttribute(command, attrName, value) {
                        const doc = command.getOwnerDocument();
                        let valElem = null;
                        if (value != null && value instanceof Array && (value.length == 0 || value[0] == null || typeof value[0] === 'number')) {
                            const v = value;
                            valElem = command.getOwnerDocument().createElement("RationalVector");
                            let allOnes = true;
                            let allZeros = true;
                            for (let i = 0; i < (v.length / 2 | 0); i++) {
                                {
                                    allZeros = allZeros && (v[2 * i] === 0);
                                    allOnes = allOnes && (v[2 * i + 1] === 1);
                                }
                                ;
                            }
                            if (!allZeros) {
                                const numerators = new java.lang.StringBuffer();
                                for (let i = 0; i < (v.length / 2 | 0); i++) {
                                    {
                                        if (i > 0)
                                            numerators.append(" ");
                                        numerators.append(v[2 * i]);
                                    }
                                    ;
                                }
                                com.vzome.xml.DomUtils.addAttribute(valElem, "nums", numerators.toString());
                                if (!allOnes) {
                                    const denominators = new java.lang.StringBuffer();
                                    for (let i = 0; i < (v.length / 2 | 0); i++) {
                                        {
                                            if (i > 0)
                                                denominators.append(" ");
                                            denominators.append(v[2 * i + 1]);
                                        }
                                        ;
                                    }
                                    com.vzome.xml.DomUtils.addAttribute(valElem, "denoms", denominators.toString());
                                }
                            }
                        }
                        else if (value != null && value instanceof com.vzome.core.math.symmetry.Axis) {
                            valElem = doc.createElement("Axis");
                            value.getXML(valElem);
                        }
                        else if (typeof value === 'boolean') {
                            valElem = doc.createElement("Boolean");
                            com.vzome.xml.DomUtils.addAttribute(valElem, "value", value.toString());
                        }
                        else if (typeof value === 'number') {
                            valElem = doc.createElement("Integer");
                            com.vzome.xml.DomUtils.addAttribute(valElem, "value", value.toString());
                        }
                        else if (value != null && value instanceof com.vzome.core.construction.Construction) {
                            valElem = value.getXml(command.getOwnerDocument());
                        }
                        else if (typeof value === 'string') {
                            valElem = doc.createElement("String");
                            const str = com.vzome.core.commands.XmlSaveFormat.escapeNewlines(value);
                            valElem.appendChild(doc.createTextNode(str));
                        }
                        else if (value != null && value instanceof com.vzome.core.math.symmetry.QuaternionicSymmetry) {
                            valElem = doc.createElement("QuaternionicSymmetry");
                            com.vzome.xml.DomUtils.addAttribute(valElem, "name", value.getName());
                        }
                        else if (value != null && (value.constructor != null && value.constructor["__interfaces"] != null && value.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) {
                            valElem = doc.createElement("Symmetry");
                            com.vzome.xml.DomUtils.addAttribute(valElem, "name", value.getName());
                        }
                        else if (value == null) {
                            valElem = doc.createElement("Null");
                        }
                        else {
                            throw new java.lang.IllegalStateException("unable to save " + /* getName */ (c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])(value.constructor));
                        }
                        com.vzome.xml.DomUtils.addAttribute(valElem, "attrName", attrName);
                        command.appendChild(valElem);
                    }
                    attributeIs3D(attrName) {
                        return true;
                    }
                    setQuaternion(offset) {
                    }
                    ordersSelection() {
                        return false;
                    }
                    constructor() {
                    }
                }
                commands.AbstractCommand = AbstractCommand;
                AbstractCommand["__class"] = "com.vzome.core.commands.AbstractCommand";
                AbstractCommand["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                let Command;
                (function (Command) {
                    Command.LOADING_FROM_FILE = "org.vorthmann.zome.editor.Command.LOADING_FROM_FILE";
                    Command.FIELD_ATTR_NAME = "org.vorthmann.zome.commands.Command.ALGEBRAIC_FIELD";
                    Command.GENERIC_PARAM_NAME = "org.vorthmann.zome.editor.Command.GENERIC_PARAM";
                })(Command = commands.Command || (commands.Command = {}));
                (function (Command) {
                    /**
                     * @param {string} message
                     * @param {java.lang.Throwable} cause
                     * @class
                     * @extends java.lang.Exception
                     */
                    class Failure extends Error {
                        constructor(message, cause) {
                            if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                                let __args = arguments;
                                super(message);
                                this.message = message;
                                Failure.logger_$LI$().log(java.util.logging.Level.INFO, "command failure: " + message, cause);
                            }
                            else if (((typeof message === 'string') || message === null) && cause === undefined) {
                                let __args = arguments;
                                super(message);
                                this.message = message;
                                if (Failure.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                    Failure.logger_$LI$().log(java.util.logging.Level.FINE, "command failure: " + message);
                            }
                            else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                                let __args = arguments;
                                let cause = __args[0];
                                super(cause);
                                this.message = cause;
                                Failure.logger_$LI$().log(java.util.logging.Level.INFO, "command failure", cause);
                            }
                            else if (message === undefined && cause === undefined) {
                                let __args = arguments;
                                super();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static logger_$LI$() { if (Failure.logger == null) {
                            Failure.logger = java.util.logging.Logger.getLogger("org.vorthmann.zome.commands");
                        } return Failure.logger; }
                    }
                    Command.Failure = Failure;
                    Failure["__class"] = "com.vzome.core.commands.Command.Failure";
                    Failure["__interfaces"] = ["java.io.Serializable"];
                })(Command = commands.Command || (commands.Command = {}));
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters2d;
            (function (exporters2d) {
                class QuartzXMLExporter {
                    constructor(snapshot) {
                        if (this.output === undefined) {
                            this.output = null;
                        }
                        if (this.mSnapshot === undefined) {
                            this.mSnapshot = null;
                        }
                        if (this.height === undefined) {
                            this.height = 0;
                        }
                        this.mSnapshot = snapshot;
                    }
                    exportQuartzXML(writer) {
                        this.output = new java.io.PrintWriter(writer);
                        this.height = Math.fround(this.mSnapshot.getRect().getHeight());
                        const width = Math.fround(this.mSnapshot.getRect().getWidth());
                        this.output.println$java_lang_Object("<?xml version=\'1.0\'?>");
                        this.output.println$java_lang_Object("<quartz>");
                        this.output.println$();
                        this.output.println$java_lang_Object("  <beginPage height=\'" + this.height + "\' width=\'" + width + "\'/>");
                        let rgb = this.mSnapshot.getBackgroundColor().getRGBColorComponents(null);
                        this.setRGBFillColor(rgb[0], rgb[1], rgb[2]);
                        this.beginPath();
                        this.output.println$java_lang_Object("    <addRect x=\'0\' y=\'0\' width=\'" + width + "\' height=\'" + this.height + "\'/>");
                        this.closePath();
                        this.fillPath();
                        this.output.println$();
                        this.output.println$java_lang_Object("    <setLineWidth width=\'" + this.mSnapshot.getStrokeWidth() + "\'/>");
                        for (let index = this.mSnapshot.getPolygons().iterator(); index.hasNext();) {
                            let polygon = index.next();
                            {
                                this.renderPath(polygon.getPath());
                                rgb = polygon.getColor().getRGBColorComponents(null);
                                this.setRGBFillColor(rgb[0], rgb[1], rgb[2]);
                                this.fillPath();
                                this.renderPath(polygon.getPath());
                                this.strokePath();
                            }
                        }
                        this.output.println$();
                        this.output.println$java_lang_Object("  <endPage/>");
                        this.output.println$java_lang_Object("</quartz>");
                        this.output.flush();
                        this.output.close();
                    }
                    renderPath(path) {
                        this.beginPath();
                        const segments = path.getPathIterator(null);
                        while ((!segments.isDone())) {
                            {
                                const coords = [0, 0, 0, 0, 0, 0];
                                const step = segments.currentSegment(coords);
                                switch ((step)) {
                                    case java.awt.geom.PathIterator.SEG_MOVETO:
                                        this.moveToPoint(coords[0], Math.fround(this.height - coords[1]));
                                        break;
                                    case java.awt.geom.PathIterator.SEG_LINETO:
                                        this.addLineToPoint(coords[0], Math.fround(this.height - coords[1]));
                                        break;
                                    case java.awt.geom.PathIterator.SEG_CLOSE:
                                        this.closePath();
                                        break;
                                    default:
                                        break;
                                }
                                segments.next();
                            }
                        }
                        ;
                    }
                    /*private*/ setRGBFillColor(r, g, b) {
                        this.output.println$();
                        this.output.println$();
                        this.output.print("    <setRGBFillColor r=\"");
                        this.output.print(r + "\" g=\"");
                        this.output.print(g + "\" b=\"");
                        this.output.println$java_lang_Object(b + "\"/>");
                    }
                    /*private*/ beginPath() {
                        this.output.println$java_lang_Object("    <beginPath/>");
                    }
                    /*private*/ moveToPoint(x, y) {
                        this.output.print("        <moveToPoint ");
                        this.output.println$java_lang_Object(" x=\"" + x + "\" y=\"" + y + "\"/>");
                    }
                    /*private*/ addLineToPoint(x, y) {
                        this.output.print("        <addLineToPoint ");
                        this.output.println$java_lang_Object(" x=\"" + x + "\" y=\"" + y + "\"/>");
                    }
                    /*private*/ closePath() {
                        this.output.println$java_lang_Object("    <closePath/>");
                    }
                    /*private*/ fillPath() {
                        this.output.println$java_lang_Object("    <fillPath/>");
                    }
                    /*private*/ strokePath() {
                        this.output.println$java_lang_Object("    <strokePath/>");
                    }
                }
                exporters2d.QuartzXMLExporter = QuartzXMLExporter;
                QuartzXMLExporter["__class"] = "com.vzome.core.exporters2d.QuartzXMLExporter";
            })(exporters2d = core.exporters2d || (core.exporters2d = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters2d;
            (function (exporters2d) {
                class Java2dSnapshot {
                    constructor() {
                        this.polygons = (new java.util.ArrayList());
                        this.lines = (new java.util.ArrayList());
                        if (this.mRect === undefined) {
                            this.mRect = null;
                        }
                        if (this.strokeWidth === undefined) {
                            this.strokeWidth = 0;
                        }
                        if (this.backgroundColor === undefined) {
                            this.backgroundColor = null;
                        }
                    }
                    getBackgroundColor() {
                        return this.backgroundColor;
                    }
                    isLineDrawing() {
                        return !this.lines.isEmpty();
                    }
                    addPolygon(polygon) {
                        this.polygons.add(polygon);
                    }
                    addLineSegment(color, start, end) {
                        this.lines.add(new Java2dSnapshot.LineSegment(color, start, end));
                    }
                    depthSort() {
                        if (this.isLineDrawing())
                            java.util.Collections.sort(this.lines);
                        else
                            java.util.Collections.sort(this.polygons);
                    }
                    setRect(rect) {
                        this.mRect = rect;
                    }
                    setStrokeWidth(strokeWidth) {
                        this.strokeWidth = strokeWidth;
                    }
                    getRect() {
                        return this.mRect;
                    }
                    getStrokeWidth() {
                        return this.strokeWidth;
                    }
                    getDimension() {
                        return new java.awt.Dimension((this.mRect.getWidth() | 0), (this.mRect.getHeight() | 0));
                    }
                    getLines() {
                        return this.lines;
                    }
                    getPolygons() {
                        return this.polygons;
                    }
                    clear() {
                        this.lines.clear();
                        this.polygons.clear();
                    }
                    setBackgroundColor(backgroundColor) {
                        this.backgroundColor = backgroundColor;
                    }
                }
                exporters2d.Java2dSnapshot = Java2dSnapshot;
                Java2dSnapshot["__class"] = "com.vzome.core.exporters2d.Java2dSnapshot";
                (function (Java2dSnapshot) {
                    class LineSegment {
                        constructor(color, start, end) {
                            if (this.mPath === undefined) {
                                this.mPath = null;
                            }
                            if (this.mDepth === undefined) {
                                this.mDepth = 0;
                            }
                            if (this.mPolyColor === undefined) {
                                this.mPolyColor = null;
                            }
                            this.mPolyColor = color;
                            this.mPath = new java.awt.geom.GeneralPath();
                            this.mPath.moveTo(start.x, start.y);
                            this.mPath.lineTo(end.x, end.y);
                            this.mDepth = Math.fround((Math.fround(start.z + end.z)) / 2.0);
                        }
                        getPath() {
                            return this.mPath;
                        }
                        getColor() {
                            return this.mPolyColor;
                        }
                        /**
                         *
                         * @param {com.vzome.core.exporters2d.Java2dSnapshot.LineSegment} other
                         * @return {number}
                         */
                        compareTo(other) {
                            const otherZ = other.mDepth;
                            if (this.mDepth > otherZ)
                                return 1;
                            if (this.mDepth < otherZ)
                                return -1;
                            return 0;
                        }
                    }
                    Java2dSnapshot.LineSegment = LineSegment;
                    LineSegment["__class"] = "com.vzome.core.exporters2d.Java2dSnapshot.LineSegment";
                    LineSegment["__interfaces"] = ["java.lang.Comparable"];
                    class Polygon {
                        constructor(color) {
                            if (this.mPath === undefined) {
                                this.mPath = null;
                            }
                            if (this.mDepth === undefined) {
                                this.mDepth = 0;
                            }
                            this.mSize = 0;
                            if (this.mPolyColor === undefined) {
                                this.mPolyColor = null;
                            }
                            this.mPolyColor = color;
                            this.mPath = new java.awt.geom.GeneralPath();
                        }
                        getPath() {
                            return this.mPath;
                        }
                        size() {
                            return this.mSize;
                        }
                        addVertex(vertex) {
                            ++this.mSize;
                            if (this.mSize === 1) {
                                this.mPath.moveTo(vertex.x, vertex.y);
                                this.mDepth = vertex.z;
                            }
                            else {
                                this.mPath.lineTo(vertex.x, vertex.y);
                                this.mDepth += vertex.z;
                            }
                        }
                        close() {
                            this.mDepth /= this.mSize;
                            this.mPath.closePath();
                        }
                        getColor() {
                            return this.mPolyColor;
                        }
                        /**
                         *
                         * @param {com.vzome.core.exporters2d.Java2dSnapshot.Polygon} other
                         * @return {number}
                         */
                        compareTo(other) {
                            const otherZ = other.mDepth;
                            if (this.mDepth > otherZ)
                                return 1;
                            if (this.mDepth < otherZ)
                                return -1;
                            return 0;
                        }
                        applyLighting(normal, lightDirs, lightColors, ambient) {
                            let redIntensity = Math.fround(ambient.getRed() / 255.0);
                            let greenIntensity = Math.fround(ambient.getGreen() / 255.0);
                            let blueIntensity = Math.fround(ambient.getBlue() / 255.0);
                            for (let i = 0; i < lightColors.length; i++) {
                                {
                                    const intensity = Math.max(normal.dot(lightDirs[i]), 0.0);
                                    redIntensity += intensity * (Math.fround(lightColors[i].getRed() / 255.0));
                                    greenIntensity += intensity * (Math.fround(lightColors[i].getGreen() / 255.0));
                                    blueIntensity += intensity * (Math.fround(lightColors[i].getBlue() / 255.0));
                                }
                                ;
                            }
                            const red = ((Math.fround(this.mPolyColor.getRed() * Math.min(redIntensity, 1.0))) | 0);
                            const green = ((Math.fround(this.mPolyColor.getGreen() * Math.min(greenIntensity, 1.0))) | 0);
                            const blue = ((Math.fround(this.mPolyColor.getBlue() * Math.min(blueIntensity, 1.0))) | 0);
                            this.mPolyColor = new java.awt.Color(red, green, blue);
                        }
                    }
                    Java2dSnapshot.Polygon = Polygon;
                    Polygon["__class"] = "com.vzome.core.exporters2d.Java2dSnapshot.Polygon";
                    Polygon["__interfaces"] = ["java.lang.Comparable"];
                })(Java2dSnapshot = exporters2d.Java2dSnapshot || (exporters2d.Java2dSnapshot = {}));
            })(exporters2d = core.exporters2d || (core.exporters2d = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters2d;
            (function (exporters2d) {
                /**
                 * Builds a Java2dSnapshot, for use in rendering to a Snapshot2dPanel
                 * or exporting via a SnapshotExporter.
                 * @author vorth
                 * @class
                 */
                class Java2dExporter {
                    constructor() {
                        if (this.viewTransform === undefined) {
                            this.viewTransform = null;
                        }
                        if (this.eyeTrans === undefined) {
                            this.eyeTrans = null;
                        }
                    }
                    render2d(model, viewTransform, eyeTransform, lights, height, width, drawLines, doLighting) {
                        this.viewTransform = viewTransform;
                        this.eyeTrans = eyeTransform;
                        const lightDirs = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(lights.size());
                        const lightColors = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(lights.size());
                        let ambientLight;
                        let background;
                        const snapshot = new com.vzome.core.exporters2d.Java2dSnapshot();
                        for (let i = 0; i < lightDirs.length; i++) {
                            {
                                lightDirs[i] = lights.getDirectionalLightVector(i).normalize().negate();
                                lightColors[i] = new java.awt.Color(lights.getDirectionalLightColor(i).getRGB());
                            }
                            ;
                        }
                        ambientLight = new java.awt.Color(lights.getAmbientColor().getRGB());
                        background = new java.awt.Color(lights.getBackgroundColor().getRGB());
                        snapshot.setStrokeWidth(0.5);
                        snapshot.setRect(new java.awt.geom.Rectangle2D.Float(0.0, 0.0, width, height));
                        snapshot.setBackgroundColor(background);
                        const mappedVertices = (new java.util.ArrayList(60));
                        for (let index = model.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const shape = rm.getShape();
                                const c = rm.getColor();
                                const color = (c == null) ? java.awt.Color.WHITE_$LI$() : new java.awt.Color(c.getRGB());
                                if (drawLines) {
                                    const m = rm.getManifestation();
                                    if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                        const start = m.getLocation();
                                        const end = m.getEnd();
                                        const v0 = this.mapCoordinates(model.renderVector(start), height, width);
                                        const v1 = this.mapCoordinates(model.renderVector(end), height, width);
                                        snapshot.addLineSegment(color, v0, v1);
                                    }
                                    continue;
                                }
                                const vertices = shape.getVertexList();
                                const partOrientation = rm.getOrientation();
                                const location = rm.getLocation();
                                if (location == null)
                                    continue;
                                mappedVertices.clear();
                                for (let i = 0; i < vertices.size(); i++) {
                                    {
                                        let gv = vertices.get(i);
                                        gv = partOrientation.timesColumn(gv);
                                        const rv = location.plus(model.renderVector(gv));
                                        const v = this.mapCoordinates(rv, height, width);
                                        mappedVertices.add(v);
                                    }
                                    ;
                                }
                                for (let index = shape.getFaceSet().iterator(); index.hasNext();) {
                                    let face = index.next();
                                    {
                                        const arity = face.size();
                                        const path = new com.vzome.core.exporters2d.Java2dSnapshot.Polygon(color);
                                        let backFacing = false;
                                        let v1 = null;
                                        let v2 = null;
                                        for (let j = 0; j < arity; j++) {
                                            {
                                                const index = face.get(j);
                                                const v = mappedVertices.get(index);
                                                path.addVertex(v);
                                                switch ((path.size())) {
                                                    case 1:
                                                        v1 = ((o) => { if (o.clone != undefined) {
                                                            return o.clone();
                                                        }
                                                        else {
                                                            let clone = Object.create(o);
                                                            for (let p in o) {
                                                                if (o.hasOwnProperty(p))
                                                                    clone[p] = o[p];
                                                            }
                                                            return clone;
                                                        } })(v);
                                                        break;
                                                    case 2:
                                                        v2 = ((o) => { if (o.clone != undefined) {
                                                            return o.clone();
                                                        }
                                                        else {
                                                            let clone = Object.create(o);
                                                            for (let p in o) {
                                                                if (o.hasOwnProperty(p))
                                                                    clone[p] = o[p];
                                                            }
                                                            return clone;
                                                        } })(v);
                                                        break;
                                                    case 3:
                                                        let v3 = ((o) => { if (o.clone != undefined) {
                                                            return o.clone();
                                                        }
                                                        else {
                                                            let clone = Object.create(o);
                                                            for (let p in o) {
                                                                if (o.hasOwnProperty(p))
                                                                    clone[p] = o[p];
                                                            }
                                                            return clone;
                                                        } })(v);
                                                        v3 = v3.minus(v2);
                                                        v2 = v2.minus(v1);
                                                        const normal = v2.cross(v3);
                                                        backFacing = normal.z > 0;
                                                        break;
                                                    default:
                                                        break;
                                                }
                                            }
                                            ;
                                        }
                                        path.close();
                                        if (!backFacing) {
                                            if (doLighting) {
                                                const faceNormal = partOrientation.timesColumn(face.getNormal(vertices));
                                                const normal = model.renderVector(faceNormal).normalize();
                                                let normalV = new com.vzome.core.math.RealVector(normal.x, normal.y, normal.z);
                                                normalV = this.viewTransform.transform3dVec(normalV);
                                                path.applyLighting(normalV, lightDirs, lightColors, ambientLight);
                                            }
                                            snapshot.addPolygon(path);
                                        }
                                    }
                                }
                            }
                        }
                        snapshot.depthSort();
                        return snapshot;
                    }
                    /*private*/ mapCoordinates(rv, height, width) {
                        const xscale = Math.fround(width / 2.0);
                        rv = this.viewTransform.transform3dPt(rv);
                        let p4 = [rv.x, rv.y, rv.z, 1.0];
                        p4 = this.eyeTrans.transform4d(p4);
                        let x = Math.fround(p4[0] / p4[3]);
                        let y = Math.fround(p4[1] / p4[3]);
                        const z = Math.fround(p4[2] / p4[3]);
                        x = Math.fround(xscale * (Math.fround(x + 1.0)));
                        y = Math.fround((Math.fround(height - (Math.fround(width * y)))) / 2.0);
                        return new com.vzome.core.math.RealVector(x, y, z);
                    }
                }
                exporters2d.Java2dExporter = Java2dExporter;
                Java2dExporter["__class"] = "com.vzome.core.exporters2d.Java2dExporter";
            })(exporters2d = core.exporters2d || (core.exporters2d = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * @class
                 */
                class ManifestationColorMappers {
                    static __static_initialize() { if (!ManifestationColorMappers.__static_initialized) {
                        ManifestationColorMappers.__static_initialized = true;
                        ManifestationColorMappers.__static_initializer_0();
                    } }
                    static colorMappers_$LI$() { ManifestationColorMappers.__static_initialize(); if (ManifestationColorMappers.colorMappers == null) {
                        ManifestationColorMappers.colorMappers = (new java.util.HashMap());
                    } return ManifestationColorMappers.colorMappers; }
                    static __static_initializer_0() {
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.RadialCentroidColorMap());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.RadialStandardBasisColorMap());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.CanonicalOrientationColorMap());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.NormalPolarityColorMap());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.CentroidByOctantAndDirectionColorMap());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.CoordinatePlaneColorMap());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.Identity());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.ColorComplementor());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.ColorInverter());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.ColorMaximizer());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.ColorSoftener());
                    }
                    static RegisterMapper(mapper) {
                        if (mapper != null) {
                            ManifestationColorMappers.colorMappers_$LI$().put(mapper.getName(), mapper);
                            if (mapper.getName() === ("ColorComplementor"))
                                ManifestationColorMappers.colorMappers_$LI$().put("ColorComplimentor", mapper);
                        }
                    }
                    static getColorMapper$java_lang_String(mapperName) {
                        const strTransparency = "TransparencyMapper@";
                        if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(mapperName, strTransparency)) {
                            const strAlpha = mapperName.substring(strTransparency.length);
                            const alpha = javaemul.internal.IntegerHelper.parseInt(strAlpha);
                            return new ManifestationColorMappers.TransparencyMapper(alpha);
                        }
                        switch ((mapperName)) {
                            case "TransparencyMapper":
                                return new ManifestationColorMappers.TransparencyMapper(255);
                            case "DarkenWithDistance":
                                return new ManifestationColorMappers.DarkenWithDistance();
                            case "DarkenNearOrigin":
                                return new ManifestationColorMappers.DarkenNearOrigin();
                            case "CopyLastSelectedColor":
                                return new ManifestationColorMappers.CopyLastSelectedColor();
                        }
                        return ManifestationColorMappers.colorMappers_$LI$().get(mapperName);
                    }
                    static getColorMapper$java_lang_String$com_vzome_core_editor_api_OrbitSource(mapperName, symmetry) {
                        let colorMapper = mapperName === ("SystemColorMap") ? new ManifestationColorMappers.SystemColorMap(symmetry) : mapperName === ("SystemCentroidColorMap") ? new ManifestationColorMappers.SystemCentroidColorMap(symmetry) : mapperName === ("NearestSpecialOrbitColorMap") ? new ManifestationColorMappers.NearestSpecialOrbitColorMap(symmetry) : mapperName === ("CentroidNearestSpecialOrbitColorMap") ? new ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap(symmetry) : mapperName === ("NearestPredefinedOrbitColorMap") ? new ManifestationColorMappers.NearestPredefinedOrbitColorMap(symmetry) : mapperName === ("CentroidNearestPredefinedOrbitColorMap") ? new ManifestationColorMappers.CentroidNearestPredefinedOrbitColorMap(symmetry) : ManifestationColorMappers.getColorMapper$java_lang_String(mapperName);
                        if (colorMapper == null) {
                            colorMapper = new ManifestationColorMappers.Identity();
                        }
                        return colorMapper;
                    }
                    static getColorMapper(mapperName, symmetry) {
                        if (((typeof mapperName === 'string') || mapperName === null) && ((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.OrbitSource") >= 0)) || symmetry === null)) {
                            return com.vzome.core.edits.ManifestationColorMappers.getColorMapper$java_lang_String$com_vzome_core_editor_api_OrbitSource(mapperName, symmetry);
                        }
                        else if (((typeof mapperName === 'string') || mapperName === null) && symmetry === undefined) {
                            return com.vzome.core.edits.ManifestationColorMappers.getColorMapper$java_lang_String(mapperName);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static mapPolarity(vector, alpha) {
                        const polarity = vector.compareTo(vector.negate());
                        const mid = 128;
                        const diff = 64;
                        const shade = polarity < 0 ? mid - diff : polarity > 0 ? mid + diff : mid;
                        return new com.vzome.core.construction.Color(shade, shade, shade, alpha);
                    }
                    /**
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector could be midpoint, start, end, normal, or any basis for mapping to a color
                     * @param {number} alpha the transparency component of the resulting color.
                     * @return
                     * @return {com.vzome.core.construction.Color}
                     */
                    static mapRadially(vector, alpha) {
                        const midPoint = 127;
                        const rgb = [midPoint, midPoint, midPoint];
                        const parts = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(rgb.length);
                        const dimensions = Math.min(rgb.length, vector.dimension());
                        let whole = 0.0;
                        for (let i = 0; i < dimensions; i++) {
                            {
                                const component = vector.getComponent(i);
                                parts[i] = component.evaluate();
                                whole += Math.abs(parts[i]);
                            }
                            ;
                        }
                        if (whole !== 0.0) {
                            for (let i = 0; i < parts.length; i++) {
                                {
                                    const part = (parts[i] / whole);
                                    const contribution = part * midPoint;
                                    rgb[i] = /* intValue */ (contribution | 0) + midPoint;
                                    rgb[i] = Math.min(255, rgb[i]);
                                    rgb[i] = Math.max(0, rgb[i]);
                                }
                                ;
                            }
                        }
                        return new com.vzome.core.construction.Color(rgb[0], rgb[1], rgb[2], alpha);
                    }
                    /**
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector could be midpoint, start, end, normal, or any basis for mapping to a color
                     * @param {number} alpha the transparency component of the resulting color.
                     * @param {number} neg the R, G or B level of vectors with a negative value in the corresponding X, Y, or Z dimension.
                     * @param {number} zero the R, G or B level of vectors with a zero value in the corresponding X, Y, or Z dimension.
                     * @param {number} pos the R, G or B level of vectors with a positive value in the corresponding X, Y, or Z dimension.
                     * @return
                     * @return {com.vzome.core.construction.Color}
                     */
                    static mapToOctant(vector, alpha, neg, zero, pos) {
                        const src = [neg, zero, pos];
                        const rgb = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(src.length);
                        const dimensions = Math.min(rgb.length, vector.dimension());
                        for (let i = 0; i < dimensions; i++) {
                            {
                                const component = vector.getComponent(i);
                                const dir = (f => { if (f > 0) {
                                    return 1;
                                }
                                else if (f < 0) {
                                    return -1;
                                }
                                else {
                                    return 0;
                                } })(component.evaluate());
                                const index = (dir | 0) + 1;
                                rgb[i] = src[index];
                            }
                            ;
                        }
                        return new com.vzome.core.construction.Color(rgb[0], rgb[1], rgb[2], alpha);
                    }
                    static mapToMagnitude(vector, offset, fullScaleSquared, initialColor) {
                        if (vector == null || initialColor == null) {
                            return initialColor;
                        }
                        const magnitudeSquared = com.vzome.core.algebra.AlgebraicVectors.getMagnitudeSquared(vector).evaluate();
                        const denominator = (fullScaleSquared === 0.0) ? 1.0E-4 : fullScaleSquared;
                        const scale = Math.abs(offset - magnitudeSquared) / denominator;
                        return com.vzome.core.construction.Color.getScaledTo(initialColor, scale);
                    }
                }
                ManifestationColorMappers.__static_initialized = false;
                edits.ManifestationColorMappers = ManifestationColorMappers;
                ManifestationColorMappers["__class"] = "com.vzome.core.edits.ManifestationColorMappers";
                (function (ManifestationColorMappers) {
                    /**
                     * Common abstract base class adds xml persistence
                     * and late loading of criteria based on selection and/or model
                     * @class
                     */
                    class ManifestationColorMapper {
                        /* Default method injected from com.vzome.core.edits.ColorMappers.ColorMapper */
                        requiresOrderedSelection() {
                            return false;
                        }
                        constructor() {
                        }
                        /**
                         * Optional opportunity to initialize parameters that were not available at time of the constructor
                         * but are determined based on the selection or model iterator
                         * just before apply is called on each individual manifestation.
                         * @param selection
                         * @param model
                         * @param {com.vzome.core.editor.api.Manifestations.ManifestationIterator} manifestations
                         */
                        initialize(manifestations) {
                        }
                        apply$com_vzome_core_model_Manifestation(man) {
                            return (man == null || !man.isRendered()) ? null : this.applyTo(man);
                        }
                        /**
                         *
                         * @param {*} man
                         * @return {com.vzome.core.construction.Color}
                         */
                        apply(man) {
                            if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null)) {
                                return this.apply$com_vzome_core_model_Manifestation(man);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        applyTo(manifestation) {
                            let color = manifestation.getColor();
                            if (color == null) {
                                color = com.vzome.core.construction.Color.WHITE_$LI$();
                            }
                            return color;
                        }
                        /**
                         * subclasses should call {@code result.setAttribute()} if they have any parameters to persist
                         * @param {*} result
                         */
                        getXmlAttributes(result) {
                        }
                        /**
                         * subclasses should call {@code xml.getAttribute()} to retrieve any persisted parameters
                         * @param {*} xml
                         */
                        setXmlAttributes(xml) {
                        }
                    }
                    ManifestationColorMappers.ManifestationColorMapper = ManifestationColorMapper;
                    ManifestationColorMapper["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper";
                    ManifestationColorMapper["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * returns current color
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class Identity extends ManifestationColorMappers.ManifestationColorMapper {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "Identity";
                        }
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            return rendered.getColor();
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.Identity = Identity;
                    Identity["__class"] = "com.vzome.core.edits.ManifestationColorMappers.Identity";
                    Identity["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * returns complementary color
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class ColorComplementor extends ManifestationColorMappers.ManifestationColorMapper {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "ColorComplementor";
                        }
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            return com.vzome.core.construction.Color.getComplement(super.applyTo(rendered));
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.ColorComplementor = ColorComplementor;
                    ColorComplementor["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ColorComplementor";
                    ColorComplementor["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * returns inverted color
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class ColorInverter extends ManifestationColorMappers.ManifestationColorMapper {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "ColorInverter";
                        }
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            return com.vzome.core.construction.Color.getInverted(super.applyTo(rendered));
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.ColorInverter = ColorInverter;
                    ColorInverter["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ColorInverter";
                    ColorInverter["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * returns maximized color
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class ColorMaximizer extends ManifestationColorMappers.ManifestationColorMapper {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "ColorMaximizer";
                        }
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            return com.vzome.core.construction.Color.getMaximum(super.applyTo(rendered));
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.ColorMaximizer = ColorMaximizer;
                    ColorMaximizer["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ColorMaximizer";
                    ColorMaximizer["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * returns pastel of current color
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class ColorSoftener extends ManifestationColorMappers.ManifestationColorMapper {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "ColorSoftener";
                        }
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            return com.vzome.core.construction.Color.getPastel(super.applyTo(rendered));
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.ColorSoftener = ColorSoftener;
                    ColorSoftener["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ColorSoftener";
                    ColorSoftener["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    class TransparencyMapper extends ManifestationColorMappers.ManifestationColorMapper {
                        constructor(alpha) {
                            super();
                            if (this.alpha === undefined) {
                                this.alpha = 0;
                            }
                            this.setAlpha(alpha);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "TransparencyMapper";
                        }
                        setAlpha(value) {
                            this.alpha = Math.min(255, Math.max(1, value));
                        }
                        /**
                         *
                         * @param {*} xml
                         */
                        setXmlAttributes(xml) {
                            this.alpha = javaemul.internal.IntegerHelper.parseInt(xml.getAttribute(TransparencyMapper.ALPHA_ATTR_NAME));
                        }
                        /**
                         *
                         * @param {*} result
                         */
                        getXmlAttributes(result) {
                            result.setAttribute(TransparencyMapper.ALPHA_ATTR_NAME, /* toString */ ('' + (this.alpha)));
                        }
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            const color = super.applyTo(rendered);
                            return new com.vzome.core.construction.Color(color.getRed(), color.getGreen(), color.getBlue(), this.alpha);
                        }
                    }
                    TransparencyMapper.ALPHA_ATTR_NAME = "alpha";
                    ManifestationColorMappers.TransparencyMapper = TransparencyMapper;
                    TransparencyMapper["__class"] = "com.vzome.core.edits.ManifestationColorMappers.TransparencyMapper";
                    TransparencyMapper["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    class CopyLastSelectedColor extends ManifestationColorMappers.ManifestationColorMapper {
                        constructor() {
                            super();
                            if (this.color === undefined) {
                                this.color = null;
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "CopyLastSelectedColor";
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        requiresOrderedSelection() {
                            return true;
                        }
                        /**
                         *
                         * @param {com.vzome.core.editor.api.Manifestations.ManifestationIterator} selection
                         */
                        initialize(selection) {
                            if (this.color == null) {
                                let last = null;
                                for (let index = selection.iterator(); index.hasNext();) {
                                    let man = index.next();
                                    {
                                        if (man != null && man.isRendered()) {
                                            last = man;
                                        }
                                    }
                                }
                                if (last != null) {
                                    this.color = last.getColor();
                                }
                            }
                            if (this.color == null) {
                                throw new com.vzome.core.commands.Command.Failure("select a ball, strut or panel as the color to be copied.");
                            }
                        }
                        /**
                         *
                         * @param {*} xml
                         */
                        setXmlAttributes(xml) {
                            const red = xml.getAttribute("red");
                            const green = xml.getAttribute("green");
                            const blue = xml.getAttribute("blue");
                            const alphaStr = xml.getAttribute("alpha");
                            const alpha = (alphaStr == null || /* isEmpty */ (alphaStr.length === 0)) ? 255 : javaemul.internal.IntegerHelper.parseInt(alphaStr);
                            this.color = new com.vzome.core.construction.Color(javaemul.internal.IntegerHelper.parseInt(red), javaemul.internal.IntegerHelper.parseInt(green), javaemul.internal.IntegerHelper.parseInt(blue), alpha);
                        }
                        /**
                         *
                         * @param {*} result
                         */
                        getXmlAttributes(result) {
                            result.setAttribute("red", "" + this.color.getRed());
                            result.setAttribute("green", "" + this.color.getGreen());
                            result.setAttribute("blue", "" + this.color.getBlue());
                            const alpha = this.color.getAlpha();
                            if (alpha < 255)
                                result.setAttribute("alpha", "" + alpha);
                        }
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            return this.color;
                        }
                    }
                    ManifestationColorMappers.CopyLastSelectedColor = CopyLastSelectedColor;
                    CopyLastSelectedColor["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CopyLastSelectedColor";
                    CopyLastSelectedColor["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Handles getting the centroid and calling overloaded methods to map the subClass specific AlgebraicVector
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     * @class
                     */
                    class CentroidColorMapper extends ManifestationColorMappers.ManifestationColorMapper {
                        constructor() {
                            super();
                        }
                        applyTo$com_vzome_core_model_Manifestation(rendered) {
                            const color = rendered.getColor();
                            const alpha = color == null ? 255 : color.getAlpha();
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(rendered.getCentroid(), alpha);
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
                        applyTo(centroid, alpha) {
                            if (((centroid != null && centroid instanceof com.vzome.core.algebra.AlgebraicVector) || centroid === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha);
                            }
                            else if (((centroid != null && (centroid.constructor != null && centroid.constructor["__interfaces"] != null && centroid.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || centroid === null) && alpha === undefined) {
                                return this.applyTo$com_vzome_core_model_Manifestation(centroid);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                    }
                    ManifestationColorMappers.CentroidColorMapper = CentroidColorMapper;
                    CentroidColorMapper["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper";
                    CentroidColorMapper["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Scales the intensity of the current color of each Manifestation
                     * based on the distance of its centroid from the origin.
                     * A position ranging from the origin to the fullScale vector position
                     * adjusts the intensity of the current color from darkest to lightest.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class DarkenNearOrigin extends ManifestationColorMappers.ManifestationColorMapper {
                        constructor() {
                            super();
                            this.offset = 0;
                            this.fullScaleSquared = 0;
                            this.FULLSCALESQUARED_ATTR_NAME = "fullScaleSquared";
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "DarkenNearOrigin";
                        }
                        /**
                         *
                         * @param {com.vzome.core.editor.api.Manifestations.ManifestationIterator} manifestations
                         */
                        initialize(manifestations) {
                            if (this.fullScaleSquared === 0) {
                                const fullScale = DarkenNearOrigin.getMostDistantPoint(manifestations);
                                if (fullScale == null) {
                                    throw new com.vzome.core.commands.Command.Failure("unable to determine most distant point");
                                }
                                if (fullScale.isOrigin()) {
                                    throw new com.vzome.core.commands.Command.Failure("select at least one point other than the origin");
                                }
                                this.fullScaleSquared = com.vzome.core.algebra.AlgebraicVectors.getMagnitudeSquared(fullScale).evaluate();
                            }
                        }
                        static getMostDistantPoint(manifestations) {
                            const centroids = (new java.util.ArrayList());
                            for (let index = manifestations.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    centroids.add(man.getCentroid());
                                }
                            }
                            if (centroids.isEmpty()) {
                                return null;
                            }
                            const mostDistant = com.vzome.core.algebra.AlgebraicVectors.getMostDistantFromOrigin(centroids);
                            return mostDistant.isEmpty() ? null : mostDistant.first();
                        }
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            const centroid = rendered.getCentroid();
                            const initialColor = super.applyTo(rendered);
                            return ManifestationColorMappers.mapToMagnitude(centroid, this.offset, this.fullScaleSquared, initialColor);
                        }
                        /**
                         *
                         * @param {*} result
                         */
                        getXmlAttributes(result) {
                            result.setAttribute(this.FULLSCALESQUARED_ATTR_NAME, /* toString */ ('' + (this.fullScaleSquared)));
                        }
                        /**
                         *
                         * @param {*} xml
                         */
                        setXmlAttributes(xml) {
                            const attr = xml.getAttribute(this.FULLSCALESQUARED_ATTR_NAME);
                            this.fullScaleSquared = javaemul.internal.DoubleHelper.parseDouble(attr);
                        }
                    }
                    ManifestationColorMappers.DarkenNearOrigin = DarkenNearOrigin;
                    DarkenNearOrigin["__class"] = "com.vzome.core.edits.ManifestationColorMappers.DarkenNearOrigin";
                    DarkenNearOrigin["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Abstract base class which calls subclass specific abstract overloads for all known subtypes.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class ManifestationSubclassColorMapper extends ManifestationColorMappers.ManifestationColorMapper {
                        /**
                         *
                         * @param {*} man
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(man) {
                            const color = man.getColor();
                            const alpha = color == null ? 255 : color.getAlpha();
                            if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                return this.applyToBall(man, alpha);
                            }
                            else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                return this.applyToStrut(man, alpha);
                            }
                            else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                return this.applyToPanel(man, alpha);
                            }
                            return null;
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.ManifestationSubclassColorMapper = ManifestationSubclassColorMapper;
                    ManifestationSubclassColorMapper["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ManifestationSubclassColorMapper";
                    ManifestationSubclassColorMapper["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Maps vector XYZ components to RGB
                     * such that each RGB component is weighted by the contribution
                     * of the corresponding XYZ component
                     * and offset by half of the color range so that a
                     * + directions map between 0x7F and 0xFF color element
                     * 0 direction maps to a midrange    0x7F color element
                     * - directions map between 0x00 and 0x7F color element
                     *
                     * Polarity info IS retained by this mapping.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper
                     */
                    class RadialCentroidColorMap extends ManifestationColorMappers.CentroidColorMapper {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "RadialCentroidColorMap";
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha) {
                            return ManifestationColorMappers.mapRadially(centroid, alpha);
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} centroid
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(centroid, alpha) {
                            if (((centroid != null && centroid instanceof com.vzome.core.algebra.AlgebraicVector) || centroid === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha);
                            }
                            else if (((centroid != null && (centroid.constructor != null && centroid.constructor["__interfaces"] != null && centroid.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || centroid === null) && alpha === undefined) {
                                return this.applyTo$com_vzome_core_model_Manifestation(centroid);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.RadialCentroidColorMap = RadialCentroidColorMap;
                    RadialCentroidColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.RadialCentroidColorMap";
                    RadialCentroidColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Maps vector XYZ components to RGB by Octant
                     *
                     * Polarity info IS retained by this mapping.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper
                     */
                    class CentroidByOctantAndDirectionColorMap extends ManifestationColorMappers.CentroidColorMapper {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "CentroidByOctantAndDirectionColorMap";
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha) {
                            return com.vzome.core.construction.Color.getMaximum(ManifestationColorMappers.mapToOctant(vector, alpha, 0, 127, 255));
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(vector, alpha) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                            }
                            else if (((vector != null && (vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                                return this.applyTo$com_vzome_core_model_Manifestation(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.CentroidByOctantAndDirectionColorMap = CentroidByOctantAndDirectionColorMap;
                    CentroidByOctantAndDirectionColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CentroidByOctantAndDirectionColorMap";
                    CentroidByOctantAndDirectionColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Maps vector XYZ components to RGB
                     * corresponding to the X, Y or Z coordinate plane.
                     *
                     * Polarity info IS NOT retained by this mapping.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper
                     */
                    class CoordinatePlaneColorMap extends ManifestationColorMappers.CentroidColorMapper {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "CoordinatePlaneColorMap";
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha) {
                            return com.vzome.core.construction.Color.getInverted(ManifestationColorMappers.mapToOctant(vector, alpha, 0, 255, 0));
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(vector, alpha) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                            }
                            else if (((vector != null && (vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                                return this.applyTo$com_vzome_core_model_Manifestation(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.CoordinatePlaneColorMap = CoordinatePlaneColorMap;
                    CoordinatePlaneColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CoordinatePlaneColorMap";
                    CoordinatePlaneColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Maps standard SymmetrySystem colors
                     * to the Manifestation's Centroid instead of the normal vector
                     * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper
                     * @class
                     */
                    class SystemCentroidColorMap extends ManifestationColorMappers.CentroidColorMapper {
                        constructor(symmetry) {
                            super();
                            if (this.symmetrySystem === undefined) {
                                this.symmetrySystem = null;
                            }
                            this.symmetrySystem = symmetry;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "SystemCentroidColorMap";
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha) {
                            return this.symmetrySystem.getVectorColor(centroid);
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} centroid
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(centroid, alpha) {
                            if (((centroid != null && centroid instanceof com.vzome.core.algebra.AlgebraicVector) || centroid === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha);
                            }
                            else if (((centroid != null && (centroid.constructor != null && centroid.constructor["__interfaces"] != null && centroid.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || centroid === null) && alpha === undefined) {
                                return this.applyTo$com_vzome_core_model_Manifestation(centroid);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         *
                         * @param {*} element
                         */
                        getXmlAttributes(element) {
                            if (this.symmetrySystem != null) {
                                com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetrySystem.getName());
                            }
                        }
                    }
                    ManifestationColorMappers.SystemCentroidColorMap = SystemCentroidColorMap;
                    SystemCentroidColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.SystemCentroidColorMap";
                    SystemCentroidColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Same as {@code DarkenNearOrigin} except that
                     * the color mapping is reversed from lightest to darkest
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.DarkenNearOrigin
                     */
                    class DarkenWithDistance extends ManifestationColorMappers.DarkenNearOrigin {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "DarkenWithDistance";
                        }
                        /**
                         *
                         * @param {com.vzome.core.editor.api.Manifestations.ManifestationIterator} manifestations
                         */
                        initialize(manifestations) {
                            super.initialize(manifestations);
                            this.offset = this.fullScaleSquared;
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.DarkenWithDistance = DarkenWithDistance;
                    DarkenWithDistance["__class"] = "com.vzome.core.edits.ManifestationColorMappers.DarkenWithDistance";
                    DarkenWithDistance["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Polarity info is retained by this mapping
                     * so that inverted struts and panels will be mapped to inverted colors.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationSubclassColorMapper
                     */
                    class RadialStandardBasisColorMap extends ManifestationColorMappers.ManifestationSubclassColorMapper {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "RadialStandardBasisColorMap";
                        }
                        /**
                         *
                         * @param {*} ball
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToBall(ball, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(ball.getLocation(), alpha);
                        }
                        /**
                         *
                         * @param {*} strut
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToStrut(strut, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(strut.getOffset(), alpha);
                        }
                        /**
                         *
                         * @param {*} panel
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToPanel(panel, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(panel['getNormal$'](), alpha);
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha) {
                            return ManifestationColorMappers.mapRadially(vector, alpha);
                        }
                        applyTo(vector, alpha) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                            }
                            else if (((vector != null && (vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                                return super.applyTo(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.RadialStandardBasisColorMap = RadialStandardBasisColorMap;
                    RadialStandardBasisColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.RadialStandardBasisColorMap";
                    RadialStandardBasisColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Gets standard color mapping from the OrbitSource
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationSubclassColorMapper
                     * @class
                     */
                    class SystemColorMap extends ManifestationColorMappers.ManifestationSubclassColorMapper {
                        constructor(symmetry) {
                            super();
                            if (this.symmetrySystem === undefined) {
                                this.symmetrySystem = null;
                            }
                            this.symmetrySystem = symmetry;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "SystemColorMap";
                        }
                        /**
                         *
                         * @param {*} ball
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToBall(ball, alpha) {
                            return this.symmetrySystem.getVectorColor(null);
                        }
                        /**
                         *
                         * @param {*} strut
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToStrut(strut, alpha) {
                            return this.applyToVector(strut.getOffset());
                        }
                        /**
                         *
                         * @param {*} panel
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToPanel(panel, alpha) {
                            return this.applyToVector(panel['getNormal$']()).getPastel();
                        }
                        applyToVector(vector) {
                            return this.symmetrySystem.getVectorColor(vector);
                        }
                        /**
                         *
                         * @param {*} element
                         */
                        getXmlAttributes(element) {
                            if (this.symmetrySystem != null) {
                                com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetrySystem.getName());
                            }
                        }
                    }
                    ManifestationColorMappers.SystemColorMap = SystemColorMap;
                    SystemColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.SystemColorMap";
                    SystemColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Polarity info is intentionally removed by this mapping for struts and panels, but not balls
                     * so that parallel struts and the panels normal to them will be the same color.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.RadialStandardBasisColorMap
                     */
                    class CanonicalOrientationColorMap extends ManifestationColorMappers.RadialStandardBasisColorMap {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "CanonicalOrientationColorMap";
                        }
                        /**
                         *
                         * @param {*} ball
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToBall(ball, alpha) {
                            return super.applyToBall(ball, alpha);
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha) {
                            return super.applyTo$com_vzome_core_algebra_AlgebraicVector$int(com.vzome.core.algebra.AlgebraicVectors.getCanonicalOrientation(vector), alpha);
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(vector, alpha) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                            }
                            else if (((vector != null && (vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                                return super.applyTo(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.CanonicalOrientationColorMap = CanonicalOrientationColorMap;
                    CanonicalOrientationColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CanonicalOrientationColorMap";
                    CanonicalOrientationColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Polarity info is the ONLY basis for this mapping
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.RadialStandardBasisColorMap
                     */
                    class NormalPolarityColorMap extends ManifestationColorMappers.RadialStandardBasisColorMap {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "NormalPolarityColorMap";
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha) {
                            return ManifestationColorMappers.mapPolarity(vector, alpha);
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(vector, alpha) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                            }
                            else if (((vector != null && (vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                                return super.applyTo(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.NormalPolarityColorMap = NormalPolarityColorMap;
                    NormalPolarityColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.NormalPolarityColorMap";
                    NormalPolarityColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Gets standard color of the nearest special orbit using the standard color basis
                     * @extends com.vzome.core.edits.ManifestationColorMappers.SystemColorMap
                     * @class
                     */
                    class NearestSpecialOrbitColorMap extends ManifestationColorMappers.SystemColorMap {
                        constructor(symm) {
                            super(symm);
                            this.specialOrbits = (new java.util.LinkedHashSet());
                            this.specialOrbits.add(symm.getSymmetry().getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.BLUE));
                            this.specialOrbits.add(symm.getSymmetry().getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.YELLOW));
                            this.specialOrbits.add(symm.getSymmetry().getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.RED));
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "NearestSpecialOrbitColorMap";
                        }
                        /**
                         *
                         * @param {*} ball
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToBall(ball, alpha) {
                            return this.applyToVector(ball.getLocation());
                        }
                        /**
                         *
                         * @param {*} strut
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToStrut(strut, alpha) {
                            return this.applyToVector(strut.getOffset());
                        }
                        /**
                         *
                         * @param {*} panel
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToPanel(panel, alpha) {
                            return this.applyToVector(panel['getNormal$']()).getPastel();
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToVector(vector) {
                            if (vector.isOrigin()) {
                                return this.symmetrySystem.getVectorColor(null);
                            }
                            const nearestSpecialOrbit = this.symmetrySystem.getSymmetry()['getAxis$com_vzome_core_math_RealVector$java_util_Collection'](vector.toRealVector(), this.specialOrbits);
                            const normal = nearestSpecialOrbit.normal();
                            return this.symmetrySystem.getVectorColor(normal);
                        }
                    }
                    ManifestationColorMappers.NearestSpecialOrbitColorMap = NearestSpecialOrbitColorMap;
                    NearestSpecialOrbitColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.NearestSpecialOrbitColorMap";
                    NearestSpecialOrbitColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Gets standard color of the nearest special orbit based on the Centroid
                     * @extends com.vzome.core.edits.ManifestationColorMappers.NearestSpecialOrbitColorMap
                     * @class
                     */
                    class CentroidNearestSpecialOrbitColorMap extends ManifestationColorMappers.NearestSpecialOrbitColorMap {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "CentroidNearestSpecialOrbitColorMap";
                        }
                        constructor(symm) {
                            super(symm);
                        }
                        /**
                         *
                         * @param {*} ball
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToBall(ball, alpha) {
                            return this.applyToVector(ball.getCentroid());
                        }
                        /**
                         *
                         * @param {*} strut
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToStrut(strut, alpha) {
                            return this.applyToVector(strut.getCentroid());
                        }
                        /**
                         *
                         * @param {*} panel
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToPanel(panel, alpha) {
                            return this.applyToVector(panel.getCentroid()).getPastel();
                        }
                    }
                    ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap = CentroidNearestSpecialOrbitColorMap;
                    CentroidNearestSpecialOrbitColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap";
                    CentroidNearestSpecialOrbitColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Gets standard color of the nearest predefined orbit using the symmetry's standard color scheme
                     * @extends com.vzome.core.edits.ManifestationColorMappers.NearestSpecialOrbitColorMap
                     * @class
                     */
                    class NearestPredefinedOrbitColorMap extends ManifestationColorMappers.NearestSpecialOrbitColorMap {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "NearestPredefinedOrbitColorMap";
                        }
                        constructor(symm) {
                            super(symm);
                            this.specialOrbits = null;
                        }
                    }
                    ManifestationColorMappers.NearestPredefinedOrbitColorMap = NearestPredefinedOrbitColorMap;
                    NearestPredefinedOrbitColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.NearestPredefinedOrbitColorMap";
                    NearestPredefinedOrbitColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Gets standard color of the nearest predefined orbit based on the centroid of each manifestation
                     * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap
                     * @class
                     */
                    class CentroidNearestPredefinedOrbitColorMap extends ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap {
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "CentroidNearestPredefinedOrbitColorMap";
                        }
                        constructor(symm) {
                            super(symm);
                            this.specialOrbits = null;
                        }
                    }
                    ManifestationColorMappers.CentroidNearestPredefinedOrbitColorMap = CentroidNearestPredefinedOrbitColorMap;
                    CentroidNearestPredefinedOrbitColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CentroidNearestPredefinedOrbitColorMap";
                    CentroidNearestPredefinedOrbitColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                })(ManifestationColorMappers = edits.ManifestationColorMappers || (edits.ManifestationColorMappers = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * @class
                 */
                class ColorMappers {
                }
                edits.ColorMappers = ColorMappers;
                ColorMappers["__class"] = "com.vzome.core.edits.ColorMappers";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 */
                class SelectionImpl {
                    constructor() {
                        this.mManifestations = (new java.util.LinkedHashSet());
                        this.mListeners = (new java.util.ArrayList());
                        this.mSelectedGroup = null;
                    }
                    static logger_$LI$() { if (SelectionImpl.logger == null) {
                        SelectionImpl.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor.selection");
                    } return SelectionImpl.logger; }
                    /**
                     *
                     * @param {*} target
                     */
                    copy(target) {
                        target.addAll(this.mManifestations);
                    }
                    addListener(listener) {
                        this.mListeners.add(listener);
                    }
                    removeListener(listener) {
                        this.mListeners.remove(listener);
                    }
                    /**
                     *
                     * @param {*} m
                     * @return {boolean}
                     */
                    manifestationSelected(m) {
                        return this.mManifestations.contains(m);
                    }
                    isEmpty() {
                        return this.mManifestations.isEmpty();
                    }
                    /**
                     *
                     * @return {*}
                     */
                    iterator() {
                        return this.mManifestations.iterator();
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    select(m) {
                        if (this.mManifestations.contains(m))
                            return;
                        this.mManifestations.add(m);
                        if (SelectionImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                            SelectionImpl.logger_$LI$().finer("  select: " + m.toString());
                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                            let mc = index.next();
                            {
                                mc.manifestationAdded(m);
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    unselect(m) {
                        if (this.mManifestations.remove(m)) {
                            if (SelectionImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                                SelectionImpl.logger_$LI$().finer("deselect: " + m.toString());
                            for (let index = this.mListeners.iterator(); index.hasNext();) {
                                let mc = index.next();
                                {
                                    mc.manifestationRemoved(m);
                                }
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    selectWithGrouping(m) {
                        if (this.mManifestations.contains(m))
                            return;
                        if (m == null)
                            return;
                        const group = com.vzome.core.editor.api.Selection.biggestGroup(m);
                        if (group == null)
                            this.add(m);
                        else
                            this.selectGroup(group);
                        this.mSelectedGroup = group;
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    unselectWithGrouping(m) {
                        if (this.mManifestations.contains(m)) {
                            const group = com.vzome.core.editor.api.Selection.biggestGroup(m);
                            if (group == null)
                                this.remove(m);
                            else
                                this.unselectGroup(group);
                            this.mSelectedGroup = null;
                        }
                    }
                    /*private*/ add(m) {
                        this.mManifestations.add(m);
                        if (SelectionImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                            SelectionImpl.logger_$LI$().finer("  select: " + m.toString());
                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                            let mc = index.next();
                            {
                                mc.manifestationAdded(m);
                            }
                        }
                    }
                    /*private*/ remove(m) {
                        if (this.mManifestations.remove(m)) {
                            if (SelectionImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                                SelectionImpl.logger_$LI$().finer("deselect: " + m.toString());
                            for (let index = this.mListeners.iterator(); index.hasNext();) {
                                let mc = index.next();
                                {
                                    mc.manifestationRemoved(m);
                                }
                            }
                        }
                    }
                    /*private*/ selectGroup(group) {
                        for (let index = group.iterator(); index.hasNext();) {
                            let next = index.next();
                            {
                                if (next != null && next instanceof com.vzome.core.model.Group)
                                    this.selectGroup(next);
                                else
                                    this.add(next);
                            }
                        }
                    }
                    /*private*/ unselectGroup(group) {
                        for (let index = group.iterator(); index.hasNext();) {
                            let next = index.next();
                            {
                                if (next != null && next instanceof com.vzome.core.model.Group)
                                    this.unselectGroup(next);
                                else
                                    this.remove(next);
                            }
                        }
                    }
                    /**
                     *
                     * @param {java.lang.Class} kind
                     * @return {*}
                     */
                    getSingleSelection(kind) {
                        let count = 0;
                        let result = null;
                        for (let index = this.mManifestations.iterator(); index.hasNext();) {
                            let next = index.next();
                            {
                                if ((kind === "com.vzome.core.model.Connector" && (next != null && (next.constructor != null && next.constructor["__interfaces"] != null && next.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))) || (kind === "com.vzome.core.model.Strut" && (next != null && (next.constructor != null && next.constructor["__interfaces"] != null && next.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))) || (kind === "com.vzome.core.model.Panel" && (next != null && (next.constructor != null && next.constructor["__interfaces"] != null && next.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)))) {
                                    ++count;
                                    result = next;
                                }
                            }
                        }
                        if (count === 1)
                            return result;
                        else
                            return null;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSelectionAGroup() {
                        return this.getSelectedGroup(false) != null;
                    }
                    /*private*/ getSelectedGroup(onlyOne) {
                        let selectedGroup = null;
                        for (let index = this.mManifestations.iterator(); index.hasNext();) {
                            let m = index.next();
                            {
                                if (onlyOne && (selectedGroup != null))
                                    return selectedGroup;
                                const group = com.vzome.core.editor.api.Selection.biggestGroup(m);
                                if (group == null)
                                    return null;
                                else if (selectedGroup == null)
                                    selectedGroup = group;
                                else if (group !== selectedGroup)
                                    return null;
                            }
                        }
                        return selectedGroup;
                    }
                    /**
                     *
                     */
                    gatherGroup() {
                        const newGroup = new com.vzome.core.model.Group();
                        for (let index = this.mManifestations.iterator(); index.hasNext();) {
                            let m = index.next();
                            {
                                const group = com.vzome.core.editor.api.Selection.biggestGroup(m);
                                if (group === newGroup)
                                    ;
                                else if (group == null) {
                                    newGroup.add(m);
                                    m.setContainer(newGroup);
                                }
                                else {
                                    newGroup.add(group);
                                    group.setContainer(newGroup);
                                }
                            }
                        }
                    }
                    /**
                     *
                     */
                    scatterGroup() {
                        const selectedGroup = this.getSelectedGroup(true);
                        if (selectedGroup == null)
                            return;
                        for (const ms = selectedGroup.iterator(); ms.hasNext();) {
                            {
                                const next = ms.next();
                                ms.remove();
                                next.setContainer(null);
                            }
                            ;
                        }
                    }
                    /**
                     *
                     */
                    gatherGroup211() {
                        if (this.mSelectedGroup != null)
                            return;
                        this.mSelectedGroup = new com.vzome.core.model.Group();
                        for (let index = this.mManifestations.iterator(); index.hasNext();) {
                            let m = index.next();
                            {
                                const group = com.vzome.core.editor.api.Selection.biggestGroup(m);
                                if (group == null) {
                                    this.mSelectedGroup.add(m);
                                }
                                else {
                                    this.mSelectedGroup.add(group);
                                }
                            }
                        }
                        for (let index = this.mSelectedGroup.iterator(); index.hasNext();) {
                            let next = index.next();
                            {
                                next.setContainer(this.mSelectedGroup);
                            }
                        }
                    }
                    /**
                     *
                     */
                    scatterGroup211() {
                        if (this.mSelectedGroup == null)
                            return;
                        for (const ms = this.mSelectedGroup.iterator(); ms.hasNext();) {
                            {
                                const next = ms.next();
                                ms.remove();
                                next.setContainer(null);
                            }
                            ;
                        }
                    }
                    refresh(on, otherSelection) {
                        for (let index = this.mManifestations.iterator(); index.hasNext();) {
                            let m = index.next();
                            {
                                if (otherSelection == null || !otherSelection.mManifestations.contains(m)) {
                                    if (on) {
                                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                                            let mc = index.next();
                                            {
                                                mc.manifestationAdded(m);
                                            }
                                        }
                                    }
                                    else {
                                        for (let index = this.mListeners.iterator(); index.hasNext();) {
                                            let mc = index.next();
                                            {
                                                mc.manifestationRemoved(m);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    /**
                     *
                     * @return {number}
                     */
                    size() {
                        return this.mManifestations.size();
                    }
                    /**
                     *
                     */
                    clear() {
                        if (!this.mManifestations.isEmpty()) {
                            if (SelectionImpl.logger_$LI$().isLoggable(java.util.logging.Level.FINER)) {
                                SelectionImpl.logger_$LI$().finer("clearing selection");
                            }
                            const temp = (new java.util.LinkedHashSet(this.mManifestations));
                            for (let index = temp.iterator(); index.hasNext();) {
                                let m = index.next();
                                {
                                    this.unselect(m);
                                }
                            }
                        }
                    }
                }
                editor.SelectionImpl = SelectionImpl;
                SelectionImpl["__class"] = "com.vzome.core.editor.SelectionImpl";
                SelectionImpl["__interfaces"] = ["com.vzome.core.editor.api.Selection", "java.lang.Iterable"];
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor_1) {
                class ToolsModel extends java.util.TreeMap {
                    constructor(context, originPoint) {
                        super();
                        if (this.editor === undefined) {
                            this.editor = null;
                        }
                        this.lastId = 0;
                        this.pcs = new java.beans.PropertyChangeSupport(this);
                        if (this.context === undefined) {
                            this.context = null;
                        }
                        if (this.originPoint === undefined) {
                            this.originPoint = null;
                        }
                        this.toolLabels = (new java.util.HashMap());
                        this.toolDeleteInputs = (new java.util.HashMap());
                        this.toolSelectInputs = (new java.util.HashMap());
                        this.toolCopyColors = (new java.util.HashMap());
                        this.hiddenTools = (new java.util.HashSet());
                        this.customTools = (new java.util.ArrayList());
                        this.customBookmarks = (new java.util.ArrayList());
                        this.context = context;
                        this.originPoint = originPoint;
                    }
                    reserveId() {
                        return this.lastId++;
                    }
                    /**
                     * Only called during load of a document, before any new tool creations with reserveId.
                     * @param {number} id
                     */
                    setMaxId(id) {
                        if (id >= this.lastId)
                            this.lastId = id + 1;
                    }
                    /**
                     *
                     * @param {string} key
                     * @param {com.vzome.core.editor.Tool} tool
                     * @return {com.vzome.core.editor.Tool}
                     */
                    put(key, tool) {
                        const result = super.put(key, tool);
                        this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("tool.instances", null, tool);
                        if (!tool.isPredefined() && !tool.isHidden()) {
                            if (tool.getCategory() === com.vzome.core.tools.BookmarkTool.ID) {
                                this.customBookmarks.add(key);
                                this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("customBookmarks", null, this.getToolIDs(true));
                            }
                            else {
                                this.customTools.add(key);
                                this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("customTools", null, this.getToolIDs(false));
                            }
                        }
                        return result;
                    }
                    getToolIDs(bookmarks) {
                        return bookmarks ? this.customBookmarks.toArray([]) : this.customTools.toArray([]);
                    }
                    createEdit(className) {
                        switch ((className)) {
                            case "ToolApplied":
                                return new com.vzome.core.editor.ApplyTool(this, null, false, false, false, false, false, true);
                            case "ApplyTool":
                                return new com.vzome.core.editor.ApplyTool(this, null, false, false, false, false, true, true);
                            case "SelectToolParameters":
                                return new com.vzome.core.editor.SelectToolParameters(this, null);
                            default:
                                return null;
                        }
                    }
                    applyTool(tool, selectInputs, deleteInputs, createOutputs, selectOutputs, copyColors) {
                        const edit = new com.vzome.core.editor.ApplyTool(this, tool, selectInputs, deleteInputs, createOutputs, selectOutputs, true, copyColors);
                        this.getContext().performAndRecord(edit);
                    }
                    selectToolParameters(tool) {
                        const edit = new com.vzome.core.editor.SelectToolParameters(this, tool);
                        this.getContext().performAndRecord(edit);
                    }
                    addPropertyListener(listener) {
                        this.pcs.addPropertyChangeListener$java_beans_PropertyChangeListener(listener);
                    }
                    removePropertyListener(listener) {
                        this.pcs.removePropertyChangeListener$java_beans_PropertyChangeListener(listener);
                    }
                    setEditorModel(editor) {
                        this.editor = editor;
                    }
                    getEditorModel() {
                        return this.editor;
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    getPredefinedTool(id) {
                        return this.get(id);
                    }
                    getContext() {
                        return this.context;
                    }
                    getOriginPoint() {
                        return this.originPoint;
                    }
                    getXml(doc) {
                        const result = doc.createElement("Tools");
                        for (let index = this.values().iterator(); index.hasNext();) {
                            let tool = index.next();
                            if (!tool.isPredefined()) {
                                const toolElem = doc.createElement("Tool");
                                com.vzome.xml.DomUtils.addAttribute(toolElem, "id", tool.getId());
                                com.vzome.xml.DomUtils.addAttribute(toolElem, "label", tool.getLabel());
                                if (tool.isHidden())
                                    com.vzome.xml.DomUtils.addAttribute(toolElem, "hidden", "true");
                                toolElem.setAttribute("selectInputs", javaemul.internal.BooleanHelper.toString(tool.isSelectInputs()));
                                toolElem.setAttribute("deleteInputs", javaemul.internal.BooleanHelper.toString(tool.isDeleteInputs()));
                                toolElem.setAttribute("copyColors", javaemul.internal.BooleanHelper.toString(tool.isCopyColors()));
                                result.appendChild(toolElem);
                            }
                        }
                        return result;
                    }
                    loadFromXml(xml) {
                        const nodes = xml.getChildNodes();
                        for (let i = 0; i < nodes.getLength(); i++) {
                            {
                                const node = nodes.item(i);
                                if (node != null && (node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) {
                                    const toolElem = node;
                                    const id = toolElem.getAttribute("id");
                                    const label = toolElem.getAttribute("label");
                                    this.toolLabels.put(id, label);
                                    let value = toolElem.getAttribute("selectInputs");
                                    if (value != null && !(value === ("")))
                                        this.toolSelectInputs.put(id, javaemul.internal.BooleanHelper.parseBoolean(value));
                                    value = toolElem.getAttribute("deleteInputs");
                                    if (value != null && !(value === ("")))
                                        this.toolDeleteInputs.put(id, javaemul.internal.BooleanHelper.parseBoolean(value));
                                    value = toolElem.getAttribute("copyColors");
                                    if (value != null && !(value === ("")))
                                        this.toolCopyColors.put(id, javaemul.internal.BooleanHelper.parseBoolean(value));
                                    const hiddenStr = toolElem.getAttribute("hidden");
                                    if (hiddenStr != null && (hiddenStr === ("true")))
                                        this.hiddenTools.add(id);
                                }
                            }
                            ;
                        }
                    }
                    setConfiguration(tool) {
                        const id = tool.getId();
                        const label = this.toolLabels.get(id);
                        if (label != null)
                            tool.setLabel(label);
                        if (this.toolDeleteInputs.containsKey(id) || this.toolSelectInputs.containsKey(id)) {
                            const deleteInputs = this.toolDeleteInputs.containsKey(id) ? this.toolDeleteInputs.get(id) : true;
                            const selectInputs = this.toolSelectInputs.containsKey(id) ? this.toolSelectInputs.get(id) : false;
                            tool.setInputBehaviors(selectInputs, deleteInputs);
                        }
                        if (this.toolCopyColors.containsKey(id)) {
                            tool.setCopyColors(this.toolCopyColors.get(id));
                        }
                        tool.setHidden(this.hiddenTools.contains(id));
                    }
                    hideTool(tool) {
                        this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("tool.instances", tool, null);
                        if (tool.getCategory() === com.vzome.core.tools.BookmarkTool.ID) {
                            this.customBookmarks.remove(tool.getId());
                            this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("customBookmarks", null, this.getToolIDs(true));
                        }
                        else {
                            this.customTools.remove(tool.getId());
                            this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("customTools", null, this.getToolIDs(false));
                        }
                    }
                }
                editor_1.ToolsModel = ToolsModel;
                ToolsModel["__class"] = "com.vzome.core.editor.ToolsModel";
                ToolsModel["__interfaces"] = ["java.lang.Cloneable", "com.vzome.api.Tool.Source", "java.util.Map", "java.util.NavigableMap", "java.util.SortedMap", "java.io.Serializable"];
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class Duplicator {
                    constructor(edit, offset) {
                        this.vertexData = (new java.util.HashMap());
                        if (this.edit === undefined) {
                            this.edit = null;
                        }
                        if (this.offset === undefined) {
                            this.offset = null;
                        }
                        this.edit = edit;
                        this.offset = offset;
                    }
                    duplicateManifestation(man) {
                        const constr = this.duplicateConstruction(man);
                        this.edit.manifestConstruction(constr);
                    }
                    duplicateConstruction(man) {
                        if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                            const vector = man.getLocation();
                            return this.getVertex(vector);
                        }
                        else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                            const strut = man;
                            const p1 = this.getVertex(strut.getLocation());
                            const p2 = this.getVertex(strut.getEnd());
                            return new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                        }
                        else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                            const vs = (new java.util.ArrayList());
                            for (let index = man.iterator(); index.hasNext();) {
                                let v = index.next();
                                {
                                    vs.add(this.getVertex(v));
                                }
                            }
                            return new com.vzome.core.construction.PolygonFromVertices(vs.toArray([]));
                        }
                        return null;
                    }
                    getVertex(vertexVector) {
                        let result = this.vertexData.get(vertexVector);
                        if (result == null) {
                            const key = vertexVector;
                            if (this.offset != null)
                                vertexVector = vertexVector.plus(this.offset);
                            result = new com.vzome.core.construction.FreePoint(vertexVector);
                            this.vertexData.put(key, result);
                        }
                        return result;
                    }
                }
                editor.Duplicator = Duplicator;
                Duplicator["__class"] = "com.vzome.core.editor.Duplicator";
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class SelectionSummary {
                    constructor(selection) {
                        this.balls = 0;
                        this.struts = 0;
                        this.panels = 0;
                        this.listeners = (new java.util.ArrayList());
                        if (this.selection === undefined) {
                            this.selection = null;
                        }
                        this.selection = selection;
                    }
                    static LOGGER_$LI$() { if (SelectionSummary.LOGGER == null) {
                        SelectionSummary.LOGGER = java.util.logging.Logger.getLogger("com.vzome.core.editor.SelectionSummary");
                    } return SelectionSummary.LOGGER; }
                    notifyListeners() {
                        for (let index = this.listeners.iterator(); index.hasNext();) {
                            let listener = index.next();
                            {
                                listener.selectionChanged(this.selection.size(), this.balls, this.struts, this.panels);
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    manifestationAdded(m) {
                        if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))
                            ++this.balls;
                        else if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))
                            ++this.struts;
                        else if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))
                            ++this.panels;
                        this.verifyCounts();
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    manifestationRemoved(m) {
                        if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))
                            --this.balls;
                        else if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))
                            --this.struts;
                        else if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))
                            --this.panels;
                        this.verifyCounts();
                    }
                    verifyCounts() {
                        if (this.balls + this.struts + this.panels !== this.selection.size()) {
                            if (SelectionSummary.LOGGER_$LI$().isLoggable(java.util.logging.Level.WARNING)) {
                                SelectionSummary.LOGGER_$LI$().warning("Incorrect total for balls, struts and panels: " + this.balls + " + " + this.struts + " + " + this.panels + " != " + this.selection.size());
                            }
                            this.balls = this.struts = this.panels = 0;
                            for (let index = this.selection.iterator(); index.hasNext();) {
                                let m = index.next();
                                {
                                    if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))
                                        ++this.balls;
                                    else if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))
                                        ++this.struts;
                                    else if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))
                                        ++this.panels;
                                }
                            }
                            if (SelectionSummary.LOGGER_$LI$().isLoggable(java.util.logging.Level.WARNING)) {
                                SelectionSummary.LOGGER_$LI$().warning("SelectionSummary resynced on thread: " + java.lang.Thread.currentThread() + ". " + this.balls + " + " + this.struts + " + " + this.panels + " = " + this.selection.size());
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} m
                     * @param {com.vzome.core.construction.Color} color
                     */
                    manifestationColored(m, color) {
                    }
                    /**
                     *
                     * @param {*} m
                     * @param {string} label
                     */
                    manifestationLabeled(m, label) {
                    }
                    addListener(listener) {
                        this.listeners.add(listener);
                    }
                }
                editor.SelectionSummary = SelectionSummary;
                SelectionSummary["__class"] = "com.vzome.core.editor.SelectionSummary";
                SelectionSummary["__interfaces"] = ["com.vzome.core.model.ManifestationChanges"];
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    class UndoableEdit {
                        constructor() {
                            this.__com_vzome_core_editor_EditHistory_DeferredEdit_hasBreakpoint = false;
                            this.lineNumber = -1;
                        }
                        hasBreakpoint() {
                            return this.__com_vzome_core_editor_EditHistory_DeferredEdit_hasBreakpoint;
                        }
                        setBreakpoint(value) {
                            this.__com_vzome_core_editor_EditHistory_DeferredEdit_hasBreakpoint = value;
                        }
                        getLineNumber() {
                            return this.lineNumber;
                        }
                        setLineNumber(lineNumber) {
                            this.lineNumber = lineNumber;
                        }
                    }
                    api.UndoableEdit = UndoableEdit;
                    UndoableEdit["__class"] = "com.vzome.core.editor.api.UndoableEdit";
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    class ManifestConstructions extends java.util.ArrayList {
                        constructor(edit) {
                            super();
                            if (this.edit === undefined) {
                                this.edit = null;
                            }
                            this.edit = edit;
                        }
                        constructionAdded$com_vzome_core_construction_Construction(c) {
                            this.edit.manifestConstruction(c);
                            this.edit.redo();
                        }
                        constructionAdded$com_vzome_core_construction_Construction$com_vzome_core_construction_Color(c, color) {
                            const manifestation = this.edit.manifestConstruction(c);
                            if (color != null)
                                this.edit.colorManifestation(manifestation, color);
                            this.edit.select$com_vzome_core_model_Manifestation(manifestation);
                            this.edit.redo();
                        }
                        /**
                         *
                         * @param {com.vzome.core.construction.Construction} c
                         * @param {com.vzome.core.construction.Color} color
                         */
                        constructionAdded(c, color) {
                            if (((c != null && c instanceof com.vzome.core.construction.Construction) || c === null) && ((color != null && color instanceof com.vzome.core.construction.Color) || color === null)) {
                                return this.constructionAdded$com_vzome_core_construction_Construction$com_vzome_core_construction_Color(c, color);
                            }
                            else if (((c != null && c instanceof com.vzome.core.construction.Construction) || c === null) && color === undefined) {
                                return this.constructionAdded$com_vzome_core_construction_Construction(c);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                    }
                    api.ManifestConstructions = ManifestConstructions;
                    ManifestConstructions["__class"] = "com.vzome.core.editor.api.ManifestConstructions";
                    ManifestConstructions["__interfaces"] = ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "com.vzome.core.construction.ConstructionChanges", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    let Selection;
                    (function (Selection) {
                        function biggestGroup(m) {
                            let parent = m.getContainer();
                            let group = parent;
                            while ((parent != null)) {
                                {
                                    parent = group.getContainer();
                                    if (parent == null)
                                        break;
                                    group = parent;
                                }
                            }
                            ;
                            return group;
                        }
                        Selection.biggestGroup = biggestGroup;
                    })(Selection = api.Selection || (api.Selection = {}));
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    let ActionEnum;
                    (function (ActionEnum) {
                        ActionEnum[ActionEnum["IGNORE"] = 0] = "IGNORE";
                        ActionEnum[ActionEnum["SELECT"] = 1] = "SELECT";
                        ActionEnum[ActionEnum["DESELECT"] = 2] = "DESELECT";
                    })(ActionEnum = api.ActionEnum || (api.ActionEnum = {}));
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class AbstractToolFactory {
                    constructor(tools, symmetry, id, label, tooltip) {
                        this.enabled = false;
                        if (this.pcs === undefined) {
                            this.pcs = null;
                        }
                        if (this.tools === undefined) {
                            this.tools = null;
                        }
                        if (this.label === undefined) {
                            this.label = null;
                        }
                        if (this.tooltip === undefined) {
                            this.tooltip = null;
                        }
                        if (this.id === undefined) {
                            this.id = null;
                        }
                        if (this.symmetry === undefined) {
                            this.symmetry = null;
                        }
                        this.tools = tools;
                        this.symmetry = symmetry;
                        this.id = id;
                        this.label = label;
                        this.tooltip = tooltip;
                        this.pcs = new java.beans.PropertyChangeSupport(this);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     */
                    selectionChanged(total, balls, struts, panels) {
                        const wasEnabled = this.enabled;
                        if (this.countsAreValid(total, balls, struts, panels))
                            this.enabled = this.bindParameters(this.getSelection());
                        else
                            this.enabled = false;
                        if (wasEnabled !== this.enabled)
                            this.pcs.firePropertyChange$java_lang_String$boolean$boolean("enabled", wasEnabled, this.enabled);
                    }
                    getSymmetry() {
                        return this.symmetry;
                    }
                    getId() {
                        return this.id;
                    }
                    getLabel() {
                        return this.label;
                    }
                    getToolTip() {
                        return this.tooltip;
                    }
                    getToolsModel() {
                        return this.tools;
                    }
                    getEditorModel() {
                        return this.tools.getEditorModel();
                    }
                    getSelection() {
                        return this.getEditorModel().getSelection();
                    }
                    getModel() {
                        return this.getEditorModel().getRealizedModel();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isEnabled() {
                        return this.enabled;
                    }
                    addListener(listener) {
                        this.pcs.addPropertyChangeListener$java_beans_PropertyChangeListener(listener);
                    }
                    /**
                     *
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createTool() {
                        const index = this.tools.reserveId();
                        const tool = this.createToolInternal(AbstractToolFactory.NEW_PREFIX + index);
                        tool.setCategory(this.getId());
                        tool.setLabel(this.getId() + " " + index);
                        if (tool != null && tool instanceof com.vzome.core.editor.api.UndoableEdit)
                            this.tools.getContext().performAndRecord(tool);
                        else
                            this.tools.put(tool.getId(), tool);
                        return tool;
                    }
                    createPredefinedTool(label) {
                        const tool = this.createToolInternal(this.getId() + ".builtin/" + label);
                        tool.setLabel(label);
                        tool.setCategory(this.getId());
                        tool.setPredefined(true);
                        tool.checkSelection(true);
                        this.tools.put(tool.getId(), tool);
                        return tool;
                    }
                    deserializeTool(id) {
                        const tool = this.createToolInternal(id);
                        if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(id, AbstractToolFactory.NEW_PREFIX)) {
                            const num = javaemul.internal.IntegerHelper.parseInt(id.substring(AbstractToolFactory.NEW_PREFIX.length));
                            this.tools.setMaxId(num);
                        }
                        const nextDot = id.indexOf(".");
                        if (nextDot > 0) {
                            tool.setCategory(id.substring(0, nextDot));
                        }
                        else {
                            tool.setCategory(this.getId());
                        }
                        this.tools.setConfiguration(tool);
                        return tool;
                    }
                }
                AbstractToolFactory.NEW_PREFIX = "tool-";
                editor.AbstractToolFactory = AbstractToolFactory;
                AbstractToolFactory["__class"] = "com.vzome.core.editor.AbstractToolFactory";
                AbstractToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor_2) {
                class SymmetrySystem {
                    constructor(symmXml, symmetryPerspective, context, colors, allowNonstandard) {
                        this.nextNewAxis = 0;
                        if (this.symmetry === undefined) {
                            this.symmetry = null;
                        }
                        if (this.orbits === undefined) {
                            this.orbits = null;
                        }
                        this.orbitColors = (new java.util.HashMap());
                        if (this.shapes === undefined) {
                            this.shapes = null;
                        }
                        this.vectorToAxis = (new java.util.HashMap());
                        this.noKnownDirections = false;
                        if (this.symmetryPerspective === undefined) {
                            this.symmetryPerspective = null;
                        }
                        this.toolFactoryLists = (new java.util.HashMap());
                        this.toolLists = (new java.util.HashMap());
                        if (this.context === undefined) {
                            this.context = null;
                        }
                        if (this.editor === undefined) {
                            this.editor = null;
                        }
                        if (this.colors === undefined) {
                            this.colors = null;
                        }
                        this.symmetryPerspective = symmetryPerspective;
                        this.context = context;
                        this.colors = colors;
                        this.symmetry = symmetryPerspective.getSymmetry();
                        let styleName = symmetryPerspective.getDefaultGeometry().getName();
                        this.orbits = new com.vzome.core.math.symmetry.OrbitSet(this.symmetry);
                        if (symmXml == null) {
                            for (let index = this.symmetry.getOrbitSet().getDirections().iterator(); index.hasNext();) {
                                let orbit = index.next();
                                {
                                    if (symmetryPerspective.orbitIsStandard(orbit) || allowNonstandard)
                                        this.orbits.add(orbit);
                                    const color = colors.getColor(com.vzome.core.render.Colors.DIRECTION_$LI$() + orbit.getName());
                                    this.orbitColors.put(orbit.getName(), color);
                                }
                            }
                        }
                        else {
                            styleName = symmXml.getAttribute("renderingStyle");
                            const nodes = symmXml.getChildNodes();
                            for (let i = 0; i < nodes.getLength(); i++) {
                                {
                                    const node = nodes.item(i);
                                    if (node != null && (node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) {
                                        const dirElem = node;
                                        const name = dirElem.getAttribute("name");
                                        let orbit = null;
                                        const nums = dirElem.getAttribute("prototype");
                                        if (nums != null && !(nums.length === 0)) {
                                            try {
                                                const prototype = this.symmetry.getField().parseVector(nums);
                                                orbit = this.symmetry.createNewZoneOrbit(name, 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, prototype);
                                            }
                                            catch (e) {
                                                console.error("Integer overflow happened while creating orbit: " + name);
                                                continue;
                                            }
                                            orbit.setAutomatic(true);
                                            try {
                                                const autoNum = javaemul.internal.IntegerHelper.parseInt(name);
                                                this.nextNewAxis = Math.max(this.nextNewAxis, autoNum + 1);
                                            }
                                            catch (e) {
                                                console.error(e.message);
                                            }
                                        }
                                        else {
                                            orbit = this.symmetry.getDirection(name);
                                            if (orbit == null)
                                                continue;
                                        }
                                        this.orbits.add(orbit);
                                        let color = colors.getColor(com.vzome.core.render.Colors.DIRECTION_$LI$() + orbit.getCanonicalName());
                                        const str = dirElem.getAttribute("color");
                                        if (str != null && !(str.length === 0) && !(str === ("255,255,255"))) {
                                            color = com.vzome.core.construction.Color.parseColor(str);
                                        }
                                        this.orbitColors.put(orbit.getName(), color);
                                        this.orbitColors.put(orbit.getCanonicalName(), color);
                                    }
                                }
                                ;
                            }
                            for (let index = this.symmetry.getOrbitSet().getDirections().iterator(); index.hasNext();) {
                                let orbit = index.next();
                                {
                                    if (this.orbits.contains(orbit))
                                        continue;
                                    if (orbit.isStandard() || allowNonstandard)
                                        this.orbits.add(orbit);
                                    const color = colors.getColor(com.vzome.core.render.Colors.DIRECTION_$LI$() + orbit.getCanonicalName());
                                    this.orbitColors.put(orbit.getName(), color);
                                    this.orbitColors.put(orbit.getCanonicalName(), color);
                                }
                            }
                        }
                        this.setStyle(styleName);
                    }
                    /* Default method injected from com.vzome.core.editor.api.OrbitSource */
                    getOrientations$() {
                        return this.getOrientations(false);
                    }
                    /* Default method injected from com.vzome.core.editor.api.OrbitSource */
                    getEmbedding() {
                        const symmetry = this.getSymmetry();
                        const field = symmetry.getField();
                        const embedding = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(16);
                        for (let i = 0; i < 3; i++) {
                            {
                                const columnSelect = field.basisVector(3, i);
                                const colRV = symmetry.embedInR3(columnSelect);
                                embedding[i * 4 + 0] = colRV.x;
                                embedding[i * 4 + 1] = colRV.y;
                                embedding[i * 4 + 2] = colRV.z;
                                embedding[i * 4 + 3] = 0.0;
                            }
                            ;
                        }
                        embedding[12] = 0.0;
                        embedding[13] = 0.0;
                        embedding[14] = 0.0;
                        embedding[15] = 1.0;
                        return embedding;
                    }
                    /* Default method injected from com.vzome.core.editor.api.OrbitSource */
                    getZone(orbit, orientation) {
                        return this.getSymmetry().getDirection(orbit).getAxis(com.vzome.core.math.symmetry.Symmetry.PLUS, orientation);
                    }
                    /* Default method injected from com.vzome.core.editor.api.OrbitSource */
                    getOrientations(rowMajor) {
                        if (((typeof rowMajor === 'boolean') || rowMajor === null)) {
                            let __args = arguments;
                            if (this.symmetry === undefined) {
                                this.symmetry = null;
                            }
                            if (this.orbits === undefined) {
                                this.orbits = null;
                            }
                            if (this.shapes === undefined) {
                                this.shapes = null;
                            }
                            if (this.symmetryPerspective === undefined) {
                                this.symmetryPerspective = null;
                            }
                            if (this.context === undefined) {
                                this.context = null;
                            }
                            if (this.editor === undefined) {
                                this.editor = null;
                            }
                            if (this.colors === undefined) {
                                this.colors = null;
                            }
                            this.nextNewAxis = 0;
                            this.orbitColors = (new java.util.HashMap());
                            this.vectorToAxis = (new java.util.HashMap());
                            this.noKnownDirections = false;
                            this.toolFactoryLists = (new java.util.HashMap());
                            this.toolLists = (new java.util.HashMap());
                            return (() => {
                                const symmetry = this.getSymmetry();
                                const field = symmetry.getField();
                                const order = symmetry.getChiralOrder();
                                const orientations = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(order);
                                for (let orientation = 0; orientation < order; orientation++) {
                                    {
                                        if (rowMajor) {
                                            orientations[orientation] = symmetry.getMatrix(orientation).getRowMajorRealElements();
                                            continue;
                                        }
                                        const asFloats = (s => { let a = []; while (s-- > 0)
                                            a.push(0); return a; })(16);
                                        const transform = symmetry.getMatrix(orientation);
                                        for (let i = 0; i < 3; i++) {
                                            {
                                                const columnSelect = field.basisVector(3, i);
                                                const columnI = transform.timesColumn(columnSelect);
                                                const colRV = columnI.toRealVector();
                                                asFloats[i * 4 + 0] = colRV.x;
                                                asFloats[i * 4 + 1] = colRV.y;
                                                asFloats[i * 4 + 2] = colRV.z;
                                                asFloats[i * 4 + 3] = 0.0;
                                            }
                                            ;
                                        }
                                        asFloats[12] = 0.0;
                                        asFloats[13] = 0.0;
                                        asFloats[14] = 0.0;
                                        asFloats[15] = 1.0;
                                        orientations[orientation] = asFloats;
                                    }
                                    ;
                                }
                                return orientations;
                            })();
                        }
                        else if (rowMajor === undefined) {
                            return this.getOrientations$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static logger_$LI$() { if (SymmetrySystem.logger == null) {
                        SymmetrySystem.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor");
                    } return SymmetrySystem.logger; }
                    setEditorModel(editor) {
                        this.editor = editor;
                    }
                    createToolFactories(tools) {
                        {
                            let array = /* Enum.values */ function () { let result = []; for (let val in com.vzome.api.Tool.Kind) {
                                if (!isNaN(val)) {
                                    result.push(parseInt(val, 10));
                                }
                            } return result; }();
                            for (let index = 0; index < array.length; index++) {
                                let kind = array[index];
                                {
                                    const list = this.symmetryPerspective.createToolFactories(kind, tools);
                                    this.toolFactoryLists.put(kind, list);
                                    const toolList = this.symmetryPerspective.predefineTools(kind, tools);
                                    this.toolLists.put(kind, toolList);
                                }
                            }
                        }
                    }
                    getName() {
                        return this.symmetry.getName();
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector
                     * @return {com.vzome.core.math.symmetry.Axis}
                     */
                    getAxis(vector) {
                        if (vector.isOrigin()) {
                            return null;
                        }
                        let line = this.vectorToAxis.get(vector.toString());
                        if (line != null)
                            return line;
                        if (!this.noKnownDirections) {
                            line = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet'](vector, this.orbits);
                            if (line != null) {
                                this.vectorToAxis.put(vector.toString(), line);
                                return line;
                            }
                        }
                        const dir = this.createAnonymousOrbit(vector);
                        line = dir.getAxis$com_vzome_core_algebra_AlgebraicVector(vector);
                        this.vectorToAxis.put(vector.toString(), line);
                        return line;
                    }
                    createAnonymousOrbit(vector) {
                        const symm = this.orbits.getSymmetry();
                        const field = symm.getField();
                        const longer = field['createPower$int'](1);
                        const shorter = field['createPower$int'](-1);
                        const rv = vector.toRealVector();
                        let longVector = vector;
                        let shortVector = vector;
                        let longLen = 2.0;
                        let shortLen = 2.0;
                        const len = rv.length();
                        if (len > 2.0) {
                            longLen = len;
                            longVector = vector;
                            while ((longLen > 2.0)) {
                                {
                                    shortVector = longVector.scale(shorter);
                                    shortLen = shortVector.toRealVector().length();
                                    if (shortLen <= 2.0)
                                        break;
                                    longLen = shortLen;
                                    longVector = shortVector;
                                }
                            }
                            ;
                        }
                        else {
                            shortLen = len;
                            shortVector = vector;
                            while ((shortLen <= 2.0)) {
                                {
                                    longVector = shortVector.scale(longer);
                                    longLen = longVector.toRealVector().length();
                                    if (longLen > 2.0)
                                        break;
                                    shortLen = longLen;
                                    shortVector = longVector;
                                }
                            }
                            ;
                        }
                        if ((2.0 / shortLen) > longLen)
                            vector = longVector;
                        else
                            vector = shortVector;
                        const colorName = "" + this.nextNewAxis++;
                        const orbit = symm.createNewZoneOrbit(colorName, 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vector);
                        orbit.setAutomatic(true);
                        this.orbits.add(orbit);
                        let color = this.colors.getColor(com.vzome.core.render.Colors.DIRECTION_$LI$() + orbit.getCanonicalName());
                        if (color == null)
                            color = com.vzome.core.construction.Color.WHITE_$LI$();
                        this.orbitColors.put(orbit.getName(), color);
                        this.orbitColors.put(orbit.getCanonicalName(), color);
                        return orbit;
                    }
                    getVectorColor(vector) {
                        if (vector == null || vector.isOrigin()) {
                            return this.colors.getColor(com.vzome.core.render.Colors.CONNECTOR_$LI$());
                        }
                        let line = this.vectorToAxis.get(vector.toString());
                        if (line == null) {
                            line = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet'](vector, this.orbits);
                        }
                        return (line == null) ? com.vzome.core.construction.Color.WHITE_$LI$() : this.getColor(line.getDirection());
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} orbit
                     * @return {com.vzome.core.construction.Color}
                     */
                    getColor(orbit) {
                        if (orbit == null)
                            return this.colors.getColor(com.vzome.core.render.Colors.CONNECTOR_$LI$());
                        let shapeColor = this.shapes.getColor(orbit);
                        if (shapeColor == null)
                            shapeColor = this.orbitColors.get(orbit.getName());
                        if (shapeColor == null)
                            return com.vzome.core.construction.Color.WHITE_$LI$();
                        return shapeColor;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetry() {
                        return this.symmetry;
                    }
                    /**
                     *
                     * @return {com.vzome.core.math.symmetry.OrbitSet}
                     */
                    getOrbits() {
                        return this.orbits;
                    }
                    disableKnownDirection() {
                        this.noKnownDirections = true;
                    }
                    getRenderingStyle() {
                        return this.shapes;
                    }
                    getXml(doc) {
                        const result = doc.createElement("SymmetrySystem");
                        com.vzome.xml.DomUtils.addAttribute(result, "name", this.getSymmetry().getName());
                        com.vzome.xml.DomUtils.addAttribute(result, "renderingStyle", this.shapes.getName());
                        for (let index = this.orbits.getDirections().iterator(); index.hasNext();) {
                            let dir = index.next();
                            {
                                const dirElem = doc.createElement("Direction");
                                if (dir.isAutomatic())
                                    com.vzome.xml.DomUtils.addAttribute(dirElem, "prototype", dir.getPrototype().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                                com.vzome.xml.DomUtils.addAttribute(dirElem, "name", dir.getName());
                                com.vzome.xml.DomUtils.addAttribute(dirElem, "orbit", dir.getCanonicalName());
                                {
                                    const color = this.getColor(dir);
                                    if (color != null)
                                        com.vzome.xml.DomUtils.addAttribute(dirElem, "color", color.toString());
                                }
                                ;
                                result.appendChild(dirElem);
                            }
                        }
                        return result;
                    }
                    getStyle$java_lang_String(styleName) {
                        const found = this.symmetryPerspective.getGeometries().stream().filter((e) => (styleName === e.getName()) || (styleName === e.getAlias()) || (styleName === e.getPackage())).findFirst();
                        if (found.isPresent())
                            return found.get();
                        else
                            return null;
                    }
                    getStyle(styleName) {
                        if (((typeof styleName === 'string') || styleName === null)) {
                            return this.getStyle$java_lang_String(styleName);
                        }
                        else if (styleName === undefined) {
                            return this.getStyle$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    setStyle(styleName) {
                        const result = this.getStyle$java_lang_String(styleName);
                        if (result != null)
                            this.shapes = result;
                        else {
                            SymmetrySystem.logger_$LI$().warning("UNKNOWN STYLE NAME: " + styleName);
                            this.shapes = this.symmetryPerspective.getDefaultGeometry();
                        }
                    }
                    getStyleNames() {
                        return this.symmetryPerspective.getGeometries().stream().map((e) => e.getName()).toArray((arg0) => { return new Array(arg0); });
                    }
                    getStyle$() {
                        return this.shapes;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getShapes() {
                        return this.shapes;
                    }
                    getShape$com_vzome_core_algebra_AlgebraicVector(offset) {
                        return this.getShape$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_editor_api_Shapes(offset, this.shapes);
                    }
                    getShape$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_editor_api_Shapes(offset, shapes) {
                        if (offset == null)
                            return shapes.getConnectorShape();
                        else {
                            if (offset.isOrigin())
                                return null;
                            const axis = this.getAxis(offset);
                            if (axis == null)
                                return null;
                            const orbit = axis.getDirection();
                            const len = axis.getLength(offset);
                            return shapes.getStrutShape(orbit, len);
                        }
                    }
                    getShape(offset, shapes) {
                        if (((offset != null && offset instanceof com.vzome.core.algebra.AlgebraicVector) || offset === null) && ((shapes != null && (shapes.constructor != null && shapes.constructor["__interfaces"] != null && shapes.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.Shapes") >= 0)) || shapes === null)) {
                            return this.getShape$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_editor_api_Shapes(offset, shapes);
                        }
                        else if (((offset != null && offset instanceof com.vzome.core.algebra.AlgebraicVector) || offset === null) && shapes === undefined) {
                            return this.getShape$com_vzome_core_algebra_AlgebraicVector(offset);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getToolFactories(kind) {
                        return this.toolFactoryLists.get(kind);
                    }
                    getPredefinedTools(kind) {
                        return this.toolLists.get(kind);
                    }
                    doAction(action) {
                        const command = this.symmetryPerspective.getLegacyCommand(action);
                        if (command != null) {
                            const edit = new com.vzome.core.editor.CommandEdit(command, this.editor);
                            this.context.performAndRecord(edit);
                            return true;
                        }
                        return false;
                    }
                    getModelResourcePath() {
                        return this.symmetryPerspective.getModelResourcePath();
                    }
                    orbitIsStandard(orbit) {
                        return this.symmetryPerspective.orbitIsStandard(orbit);
                    }
                    orbitIsBuildDefault(orbit) {
                        return this.symmetryPerspective.orbitIsBuildDefault(orbit);
                    }
                    getOrbitUnitLength(orbit) {
                        return this.symmetryPerspective.getOrbitUnitLength(orbit);
                    }
                    resetColors() {
                        for (let index = this.symmetry.getOrbitSet().getDirections().iterator(); index.hasNext();) {
                            let orbit = index.next();
                            {
                                const color = this.colors.getColor(com.vzome.core.render.Colors.DIRECTION_$LI$() + orbit.getName());
                                this.orbitColors.put(orbit.getName(), color);
                            }
                        }
                    }
                }
                editor_2.SymmetrySystem = SymmetrySystem;
                SymmetrySystem["__class"] = "com.vzome.core.editor.SymmetrySystem";
                SymmetrySystem["__interfaces"] = ["com.vzome.core.editor.api.OrbitSource"];
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Vector3dHomogeneous {
                    constructor(e1, e2, e3, e0, field) {
                        if (((e1 != null && (e1.constructor != null && e1.constructor["__interfaces"] != null && e1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e1 === null) && ((e2 != null && (e2.constructor != null && e2.constructor["__interfaces"] != null && e2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e2 === null) && ((e3 != null && (e3.constructor != null && e3.constructor["__interfaces"] != null && e3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e3 === null) && ((e0 != null && (e0.constructor != null && e0.constructor["__interfaces"] != null && e0.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e0 === null) && ((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null)) {
                            let __args = arguments;
                            if (this.e1 === undefined) {
                                this.e1 = null;
                            }
                            if (this.e2 === undefined) {
                                this.e2 = null;
                            }
                            if (this.e3 === undefined) {
                                this.e3 = null;
                            }
                            if (this.e0 === undefined) {
                                this.e0 = null;
                            }
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            this.e1 = e1;
                            this.e2 = e2;
                            this.e3 = e3;
                            this.e0 = e0;
                            this.field = field;
                        }
                        else if (((e1 != null && (e1.constructor != null && e1.constructor["__interfaces"] != null && e1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e1 === null) && ((e2 != null && (e2.constructor != null && e2.constructor["__interfaces"] != null && e2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e2 === null) && ((e3 != null && (e3.constructor != null && e3.constructor["__interfaces"] != null && e3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e3 === null) && ((e0 != null && (e0.constructor != null && e0.constructor["__interfaces"] != null && e0.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || e0 === null) && field === undefined) {
                            let __args = arguments;
                            let field = __args[3];
                            {
                                let __args = arguments;
                                let e2 = __args[0];
                                let e3 = __args[0];
                                let e0 = __args[4].one();
                                if (this.e1 === undefined) {
                                    this.e1 = null;
                                }
                                if (this.e2 === undefined) {
                                    this.e2 = null;
                                }
                                if (this.e3 === undefined) {
                                    this.e3 = null;
                                }
                                if (this.e0 === undefined) {
                                    this.e0 = null;
                                }
                                if (this.field === undefined) {
                                    this.field = null;
                                }
                                this.e1 = e1;
                                this.e2 = e2;
                                this.e3 = e3;
                                this.e0 = e0;
                                this.field = field;
                            }
                        }
                        else if (((e1 != null && e1 instanceof com.vzome.core.algebra.AlgebraicVector) || e1 === null) && ((e2 != null && (e2.constructor != null && e2.constructor["__interfaces"] != null && e2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || e2 === null) && e3 === undefined && e0 === undefined && field === undefined) {
                            let __args = arguments;
                            let v = __args[0];
                            let field = __args[1];
                            {
                                let __args = arguments;
                                let e1 = v.getComponent(0);
                                let e2 = v.getComponent(1);
                                let e3 = v.getComponent(2);
                                {
                                    let __args = arguments;
                                    let e2 = __args[0];
                                    let e3 = __args[0];
                                    let e0 = __args[4].one();
                                    if (this.e1 === undefined) {
                                        this.e1 = null;
                                    }
                                    if (this.e2 === undefined) {
                                        this.e2 = null;
                                    }
                                    if (this.e3 === undefined) {
                                        this.e3 = null;
                                    }
                                    if (this.e0 === undefined) {
                                        this.e0 = null;
                                    }
                                    if (this.field === undefined) {
                                        this.field = null;
                                    }
                                    this.e1 = e1;
                                    this.e2 = e2;
                                    this.e3 = e3;
                                    this.e0 = e0;
                                    this.field = field;
                                }
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    outer(that) {
                        const e12 = this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1));
                        const e23 = this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2));
                        const e31 = this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3));
                        const e10 = this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1));
                        const e20 = this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2));
                        const e30 = this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3));
                        return new com.vzome.core.algebra.Bivector3dHomogeneous(e12, e23, e31, e10, e20, e30, this.field);
                    }
                    getVector() {
                        return new com.vzome.core.algebra.AlgebraicVector(this.e1.dividedBy(this.e0), this.e2.dividedBy(this.e0), this.e3.dividedBy(this.e0));
                    }
                    dot(v) {
                        const e1 = this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](v.e31)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](v.e12))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](v.e10));
                        const e2 = this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](v.e12)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](v.e23))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](v.e20));
                        const e3 = this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](v.e23)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](v.e31))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](v.e30));
                        const e0 = this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](v.e10)['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](v.e20))['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](v.e30));
                        return new Vector3dHomogeneous(e1, e2, e3, e0, this.field);
                    }
                    exists() {
                        return !this.e0.isZero();
                    }
                }
                algebra.Vector3dHomogeneous = Vector3dHomogeneous;
                Vector3dHomogeneous["__class"] = "com.vzome.core.algebra.Vector3dHomogeneous";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Bivector3dHomogeneous {
                    constructor(e12, e23, e31, e10, e20, e30, field) {
                        if (this.e12 === undefined) {
                            this.e12 = null;
                        }
                        if (this.e23 === undefined) {
                            this.e23 = null;
                        }
                        if (this.e31 === undefined) {
                            this.e31 = null;
                        }
                        if (this.e10 === undefined) {
                            this.e10 = null;
                        }
                        if (this.e20 === undefined) {
                            this.e20 = null;
                        }
                        if (this.e30 === undefined) {
                            this.e30 = null;
                        }
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        this.e12 = e12;
                        this.e23 = e23;
                        this.e31 = e31;
                        this.e10 = e10;
                        this.e20 = e20;
                        this.e30 = e30;
                        this.field = field;
                    }
                    outer(that) {
                        const e123 = this.e12['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3)['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e23['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1))['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e31['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2));
                        const e310 = this.e10['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3)['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e31['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e30['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1));
                        const e320 = this.e20['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e30['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e23['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0));
                        const e120 = this.e12['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0)['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e20['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e10['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2));
                        return new com.vzome.core.algebra.Trivector3dHomogeneous(e123, e310, e320, e120, this.field);
                    }
                }
                algebra.Bivector3dHomogeneous = Bivector3dHomogeneous;
                Bivector3dHomogeneous["__class"] = "com.vzome.core.algebra.Bivector3dHomogeneous";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class AlgebraicMatrix {
                    constructor(x, y, z, w) {
                        if (((x != null && x instanceof com.vzome.core.algebra.AlgebraicVector) || x === null) && ((y != null && y instanceof com.vzome.core.algebra.AlgebraicVector) || y === null) && ((z != null && z instanceof com.vzome.core.algebra.AlgebraicVector) || z === null) && ((w != null && w instanceof com.vzome.core.algebra.AlgebraicVector) || w === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let columns = [x, y, z, w];
                                if (this.matrix === undefined) {
                                    this.matrix = null;
                                }
                                const rows = columns[0].dimension();
                                const cols = columns.length;
                                this.matrix = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                                    return null;
                                }
                                else {
                                    let array = [];
                                    for (let i = 0; i < dims[0]; i++) {
                                        array.push(allocate(dims.slice(1)));
                                    }
                                    return array;
                                } }; return allocate(dims); })([rows, cols]);
                                for (let i = 0; i < rows; i++) {
                                    {
                                        for (let j = 0; j < cols; j++) {
                                            {
                                                this.matrix[i][j] = columns[j].getComponent(i);
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                        }
                        else if (((x != null && x instanceof com.vzome.core.algebra.AlgebraicVector) || x === null) && ((y != null && y instanceof com.vzome.core.algebra.AlgebraicVector) || y === null) && ((z != null && z instanceof com.vzome.core.algebra.AlgebraicVector) || z === null) && w === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let columns = [x, y, z];
                                if (this.matrix === undefined) {
                                    this.matrix = null;
                                }
                                const rows = columns[0].dimension();
                                const cols = columns.length;
                                this.matrix = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                                    return null;
                                }
                                else {
                                    let array = [];
                                    for (let i = 0; i < dims[0]; i++) {
                                        array.push(allocate(dims.slice(1)));
                                    }
                                    return array;
                                } }; return allocate(dims); })([rows, cols]);
                                for (let i = 0; i < rows; i++) {
                                    {
                                        for (let j = 0; j < cols; j++) {
                                            {
                                                this.matrix[i][j] = columns[j].getComponent(i);
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                        }
                        else if (((x != null && (x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null) && w === undefined) {
                            let __args = arguments;
                            let field = __args[0];
                            let rows = __args[1];
                            let cols = __args[2];
                            if (this.matrix === undefined) {
                                this.matrix = null;
                            }
                            this.matrix = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                                return null;
                            }
                            else {
                                let array = [];
                                for (let i = 0; i < dims[0]; i++) {
                                    array.push(allocate(dims.slice(1)));
                                }
                                return array;
                            } }; return allocate(dims); })([rows, cols]);
                            for (let i = 0; i < rows; i++) {
                                {
                                    for (let j = 0; j < cols; j++) {
                                        {
                                            this.matrix[i][j] = field.zero();
                                        }
                                        ;
                                    }
                                }
                                ;
                            }
                        }
                        else if (((x != null && x instanceof com.vzome.core.algebra.AlgebraicVector) || x === null) && ((y != null && y instanceof com.vzome.core.algebra.AlgebraicVector) || y === null) && z === undefined && w === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let columns = [x, y];
                                if (this.matrix === undefined) {
                                    this.matrix = null;
                                }
                                const rows = columns[0].dimension();
                                const cols = columns.length;
                                this.matrix = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                                    return null;
                                }
                                else {
                                    let array = [];
                                    for (let i = 0; i < dims[0]; i++) {
                                        array.push(allocate(dims.slice(1)));
                                    }
                                    return array;
                                } }; return allocate(dims); })([rows, cols]);
                                for (let i = 0; i < rows; i++) {
                                    {
                                        for (let j = 0; j < cols; j++) {
                                            {
                                                this.matrix[i][j] = columns[j].getComponent(i);
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                        }
                        else if (((x != null && (x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || x === null) && ((typeof y === 'number') || y === null) && z === undefined && w === undefined) {
                            let __args = arguments;
                            let field = __args[0];
                            let dim = __args[1];
                            if (this.matrix === undefined) {
                                this.matrix = null;
                            }
                            this.matrix = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                                return null;
                            }
                            else {
                                let array = [];
                                for (let i = 0; i < dims[0]; i++) {
                                    array.push(allocate(dims.slice(1)));
                                }
                                return array;
                            } }; return allocate(dims); })([dim, dim]);
                            for (let i = 0; i < dim; i++) {
                                {
                                    for (let j = 0; j < dim; j++) {
                                        {
                                            if (i === j)
                                                this.matrix[i][j] = field.one();
                                            else
                                                this.matrix[i][j] = field.zero();
                                        }
                                        ;
                                    }
                                }
                                ;
                            }
                        }
                        else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (x[0] != null && x[0] instanceof com.vzome.core.algebra.AlgebraicVector))) || x === null) && y === undefined && z === undefined && w === undefined) {
                            let __args = arguments;
                            let columns = __args[0];
                            if (this.matrix === undefined) {
                                this.matrix = null;
                            }
                            const rows = columns[0].dimension();
                            const cols = columns.length;
                            this.matrix = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                                return null;
                            }
                            else {
                                let array = [];
                                for (let i = 0; i < dims[0]; i++) {
                                    array.push(allocate(dims.slice(1)));
                                }
                                return array;
                            } }; return allocate(dims); })([rows, cols]);
                            for (let i = 0; i < rows; i++) {
                                {
                                    for (let j = 0; j < cols; j++) {
                                        {
                                            this.matrix[i][j] = columns[j].getComponent(i);
                                        }
                                        ;
                                    }
                                }
                                ;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        const prime = 31;
                        let result = 1;
                        for (let index = 0; index < this.matrix.length; index++) {
                            let m = this.matrix[index];
                            {
                                result = prime * result + java.util.Arrays.hashCode(m);
                            }
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj)
                            return true;
                        if (obj == null)
                            return false;
                        if (this.constructor !== obj.constructor)
                            return false;
                        const other = obj;
                        return java.util.Arrays.deepEquals(this.matrix, other.matrix);
                    }
                    getMatrix() {
                        return this.matrix;
                    }
                    getRowMajorRealElements() {
                        const result = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                        for (let i = 0; i < 3; i++) {
                            {
                                for (let j = 0; j < 3; j++) {
                                    {
                                        result[i * 4 + j] = Math.fround(this.getElement(i, j).evaluate());
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return result;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const buf = new java.lang.StringBuilder();
                        for (let index = 0; index < this.matrix.length; index++) {
                            let m = this.matrix[index];
                            {
                                buf.append(java.util.Arrays.toString(m));
                                buf.append(", ");
                            }
                        }
                        return "[ " + buf.toString() + " ]";
                    }
                    negate() {
                        const field = this.matrix[0][0].getField();
                        const result = new AlgebraicMatrix(field, this.matrix.length);
                        for (let i = 0; i < this.matrix.length; i++) {
                            {
                                for (let j = 0; j < this.matrix[i].length; j++) {
                                    {
                                        result.matrix[i][j] = this.matrix[i][j].negate();
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return result;
                    }
                    inverse() {
                        if (!this.isSquare()) {
                            throw new java.lang.IllegalArgumentException("matrix is not square");
                        }
                        const field = this.matrix[0][0].getField();
                        const result = new AlgebraicMatrix(field, this.matrix.length);
                        const rank = com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(this.matrix, result.matrix);
                        if (rank !== this.matrix.length) {
                            const message = "AlgebraicMatrix inverse expects matrix rank to be " + this.matrix.length + ", but it is " + rank + ".";
                            console.error(message);
                        }
                        return result;
                    }
                    transpose() {
                        const field = this.matrix[0][0].getField();
                        const result = new AlgebraicMatrix(field, this.matrix[0].length, this.matrix.length);
                        for (let i = 0; i < result.matrix.length; i++) {
                            {
                                for (let j = 0; j < this.matrix.length; j++) {
                                    {
                                        result.matrix[i][j] = this.matrix[j][i];
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return result;
                    }
                    times(that) {
                        const field = this.matrix[0][0].getField();
                        const result = new AlgebraicMatrix(field, this.matrix.length, that.matrix[0].length);
                        com.vzome.core.algebra.Fields.matrixMultiplication(this.matrix, that.matrix, result.matrix);
                        return result;
                    }
                    timesRow(rowVector) {
                        const colLength = rowVector.dimension();
                        if (this.matrix.length !== colLength)
                            throw new java.lang.IllegalArgumentException("vector length incorrect for this matrix: " + rowVector);
                        const rowLength = this.matrix[0].length;
                        const resultComponents = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(rowLength);
                        const field = this.matrix[0][0].getField();
                        for (let j = 0; j < rowLength; j++) {
                            {
                                resultComponents[j] = field.zero();
                                for (let i = 0; i < colLength; i++) {
                                    {
                                        const product = rowVector.getComponent(i)['times$com_vzome_core_algebra_AlgebraicNumber'](this.matrix[i][j]);
                                        resultComponents[j] = resultComponents[j]['plus$com_vzome_core_algebra_AlgebraicNumber'](product);
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return new com.vzome.core.algebra.AlgebraicVector(resultComponents);
                    }
                    timesColumn(columnVector) {
                        const rowLength = columnVector.dimension();
                        if (this.matrix[0].length !== rowLength)
                            throw new java.lang.IllegalArgumentException("vector length incorrect for this matrix: " + columnVector);
                        const colLength = this.matrix.length;
                        const resultComponents = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(colLength);
                        const field = this.matrix[0][0].getField();
                        for (let i = 0; i < colLength; i++) {
                            {
                                resultComponents[i] = field.zero();
                                for (let j = 0; j < rowLength; j++) {
                                    {
                                        const product = columnVector.getComponent(j)['times$com_vzome_core_algebra_AlgebraicNumber'](this.matrix[i][j]);
                                        resultComponents[i] = resultComponents[i]['plus$com_vzome_core_algebra_AlgebraicNumber'](product);
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return new com.vzome.core.algebra.AlgebraicVector(resultComponents);
                    }
                    timesScalar(scalar) {
                        const result = new AlgebraicMatrix(scalar.getField(), this.matrix.length);
                        for (let i = 0; i < this.matrix.length; i++) {
                            {
                                for (let j = 0; j < this.matrix[i].length; j++) {
                                    {
                                        result.matrix[i][j] = this.matrix[i][j]['times$com_vzome_core_algebra_AlgebraicNumber'](scalar);
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return result;
                    }
                    isSquare() {
                        return this.matrix.length === this.matrix[0].length;
                    }
                    trace() {
                        if (!this.isSquare()) {
                            throw new java.lang.IllegalArgumentException("matrix is not square");
                        }
                        let trace = this.matrix[0][0].getField().zero();
                        for (let i = 0; i < this.matrix.length; i++) {
                            {
                                trace = trace['plus$com_vzome_core_algebra_AlgebraicNumber'](this.matrix[i][i]);
                            }
                            ;
                        }
                        return trace;
                    }
                    determinant() {
                        return AlgebraicMatrix.laplaceDeterminant(this.matrix);
                    }
                    static laplaceDeterminant(matrix) {
                        if (matrix.length !== matrix[0].length) {
                            throw new java.lang.IllegalArgumentException("matrix is not square");
                        }
                        let determinant = null;
                        switch ((matrix.length)) {
                            case 3:
                                determinant = (matrix[0][0]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][1])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][2]))['plus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][1]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][2])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][0]))['plus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][2]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][0])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][1]))['minus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][2]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][1])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][0]))['minus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][0]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][2])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][1]))['minus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][1]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][0])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][2]));
                                break;
                            case 2:
                                determinant = (matrix[0][0]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][1]))['minus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][1]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][0]));
                                break;
                            case 1:
                                determinant = matrix[0][0];
                                break;
                            default:
                                determinant = matrix[0][0].getField().zero();
                                const auxLength = matrix.length - 1;
                                let sign = matrix[0][0].getField().one();
                                for (let i = 0; i < matrix.length; i++) {
                                    {
                                        if (!matrix[0][i].isZero()) {
                                            const aux = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                                                return null;
                                            }
                                            else {
                                                let array = [];
                                                for (let i = 0; i < dims[0]; i++) {
                                                    array.push(allocate(dims.slice(1)));
                                                }
                                                return array;
                                            } }; return allocate(dims); })([auxLength, auxLength]);
                                            let iAux = 0;
                                            let jAux = 0;
                                            for (let row = 1; row < matrix.length; row++) {
                                                {
                                                    for (let col = 0; col < matrix.length; col++) {
                                                        {
                                                            if (col !== i) {
                                                                aux[iAux][jAux] = matrix[row][col];
                                                                jAux++;
                                                            }
                                                        }
                                                        ;
                                                    }
                                                    iAux++;
                                                    jAux = 0;
                                                }
                                                ;
                                            }
                                            determinant = determinant['plus$com_vzome_core_algebra_AlgebraicNumber'](sign['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][i])['times$com_vzome_core_algebra_AlgebraicNumber'](AlgebraicMatrix.laplaceDeterminant(aux)));
                                        }
                                        sign = sign.negate();
                                    }
                                    ;
                                }
                        }
                        return determinant;
                    }
                    setElement(i, j, value) {
                        this.matrix[i][j] = value;
                        return this;
                    }
                    getElement(i, j) {
                        return this.matrix[i][j];
                    }
                }
                algebra.AlgebraicMatrix = AlgebraicMatrix;
                AlgebraicMatrix["__class"] = "com.vzome.core.algebra.AlgebraicMatrix";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                /**
                 * A collection of static helper methods for the AlgebraicVector class
                 * @class
                 */
                class AlgebraicVectors {
                    constructor() {
                    }
                    static getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v1, v2) {
                        return v1.cross(v2);
                    }
                    static getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2) {
                        return AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v1.minus(v0), v2.minus(v0));
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v0
                     * @param {com.vzome.core.algebra.AlgebraicVector} v1
                     * @param {com.vzome.core.algebra.AlgebraicVector} v2
                     * @return {com.vzome.core.algebra.AlgebraicVector} normal to vectors v1 and v2,
                     * with both v1 and v2 positioned at v0
                     * using the righthand rule.
                     */
                    static getNormal(v0, v1, v2) {
                        if (((v0 != null && v0 instanceof com.vzome.core.algebra.AlgebraicVector) || v0 === null) && ((v1 != null && v1 instanceof com.vzome.core.algebra.AlgebraicVector) || v1 === null) && ((v2 != null && v2 instanceof com.vzome.core.algebra.AlgebraicVector) || v2 === null)) {
                            return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
                        }
                        else if (((v0 != null && v0 instanceof com.vzome.core.algebra.AlgebraicVector) || v0 === null) && ((v1 != null && v1 instanceof com.vzome.core.algebra.AlgebraicVector) || v1 === null) && v2 === undefined) {
                            return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1);
                        }
                        else if (((v0 != null && (v0.constructor != null && v0.constructor["__interfaces"] != null && v0.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || v0 === null) && v1 === undefined && v2 === undefined) {
                            return com.vzome.core.algebra.AlgebraicVectors.getNormal$java_util_Collection(v0);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v1
                     * @param {com.vzome.core.algebra.AlgebraicVector} v2
                     * @return {boolean} true if vectors v1 and v2 are parallel, otherwise false.
                     * Considered as position vectors, this is the same as testing if they are collinear with the origin.
                     */
                    static areParallel(v1, v2) {
                        return AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v1, v2).isOrigin();
                    }
                    static getNormal$java_util_Collection(vectors) {
                        if (vectors.size() < 3) {
                            throw new java.lang.IllegalArgumentException("Three vertices are required to calculate a normal. Found " + vectors.size());
                        }
                        let v0 = null;
                        let v1 = null;
                        let normal = null;
                        for (let index = vectors.iterator(); index.hasNext();) {
                            let vector = index.next();
                            {
                                if (v0 == null) {
                                    v0 = vector;
                                }
                                else if (v1 == null) {
                                    if (vector !== v0) {
                                        v1 = vector;
                                    }
                                }
                                else {
                                    normal = AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, vector);
                                    if (!normal.isOrigin()) {
                                        return normal;
                                    }
                                }
                            }
                        }
                        return normal;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector
                     * @return {number} index of the vector component having the greatest absolute value.
                     * If more than one component has the same absolute value,
                     * the greatest index will be returned.
                     */
                    static getMaxComponentIndex(vector) {
                        let maxIndex = 0;
                        let maxSq = vector.getField().zero();
                        for (let i = 0; i < vector.dimension(); i++) {
                            {
                                const n = vector.getComponent(i);
                                const sq = n['times$com_vzome_core_algebra_AlgebraicNumber'](n);
                                if (!sq.lessThan(maxSq)) {
                                    maxIndex = i;
                                    maxSq = sq;
                                }
                            }
                            ;
                        }
                        return maxIndex;
                    }
                    static areCoplanar(vectors) {
                        if (vectors.size() < 4) {
                            return true;
                        }
                        const normal = AlgebraicVectors.getNormal$java_util_Collection(vectors);
                        if (normal.isOrigin() || normal.dimension() < 3) {
                            return true;
                        }
                        return AlgebraicVectors.areOrthogonalTo(normal, vectors);
                    }
                    static areOrthogonalTo(normal, vectors) {
                        if (normal.isOrigin()) {
                            throw new java.lang.IllegalArgumentException("Normal vector cannot be the origin");
                        }
                        let v0 = null;
                        for (let index = vectors.iterator(); index.hasNext();) {
                            let vector = index.next();
                            {
                                if (v0 == null) {
                                    v0 = vector;
                                }
                                else if (!vector.minus(v0).dot(normal).isZero()) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    static areCollinear$java_util_Collection(vectors) {
                        return (vectors.size() < 3) ? true : AlgebraicVectors.getNormal$java_util_Collection(vectors).isOrigin();
                    }
                    static areCollinear$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2) {
                        return AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2).isOrigin();
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v0
                     * @param {com.vzome.core.algebra.AlgebraicVector} v1
                     * @param {com.vzome.core.algebra.AlgebraicVector} v2
                     * @return {boolean} true if position vectors v0, v1 and v2 are collinear, otherwise false.
                     */
                    static areCollinear(v0, v1, v2) {
                        if (((v0 != null && v0 instanceof com.vzome.core.algebra.AlgebraicVector) || v0 === null) && ((v1 != null && v1 instanceof com.vzome.core.algebra.AlgebraicVector) || v1 === null) && ((v2 != null && v2 instanceof com.vzome.core.algebra.AlgebraicVector) || v2 === null)) {
                            return com.vzome.core.algebra.AlgebraicVectors.areCollinear$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
                        }
                        else if (((v0 != null && (v0.constructor != null && v0.constructor["__interfaces"] != null && v0.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || v0 === null) && v1 === undefined && v2 === undefined) {
                            return com.vzome.core.algebra.AlgebraicVectors.areCollinear$java_util_Collection(v0);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static getLinePlaneIntersection(lineStart, lineDirection, planeCenter, planeNormal) {
                        const denom = planeNormal.dot(lineDirection);
                        if (denom.isZero())
                            return null;
                        const p1p3 = planeCenter.minus(lineStart);
                        const numerator = planeNormal.dot(p1p3);
                        const u = numerator.dividedBy(denom);
                        return lineStart.plus(lineDirection.scale(u));
                    }
                    static calculateCentroid(vectors) {
                        return AlgebraicVectors.getCentroid(vectors.toArray((s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(vectors.size())));
                    }
                    static getCentroid(vectors) {
                        const field = vectors[0].getField();
                        let sum = new com.vzome.core.algebra.AlgebraicVector(field, vectors[0].dimension());
                        for (let index = 0; index < vectors.length; index++) {
                            let vector = vectors[index];
                            {
                                sum = sum.plus(vector);
                            }
                        }
                        return sum.scale(field['createRational$long$long'](1, vectors.length));
                    }
                    static getMagnitudeSquared(v) {
                        return v.dot(v);
                    }
                    /**
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector
                     * @return {com.vzome.core.algebra.AlgebraicVector} the greater of {@code vector} and its inverse.
                     * The comparison is based on a canonical (not mathematical) comparison as implemented in {@code AlgebraicVector.compareTo()}.
                     * There is no reasonable mathematical sense of ordering vectors,
                     * but this provides a way to map a vector and its inverse to a common vector for such purposes as sorting and color mapping.
                     */
                    static getCanonicalOrientation(vector) {
                        const negate = vector.negate();
                        return vector.compareTo(negate) > 0 ? vector : negate;
                    }
                    /**
                     * getMostDistantFromOrigin() is is used by a few ColorMapper classes, but I think it can eventually be useful elsewhere as well, for example, a zoom-to-fit command or in deriving a convex hull. I've made it a static method of the AlgebraicVector class to encourage such reuse.
                     *
                     * @param {*} vectors A collection of vectors to be evaluated.
                     * @return {java.util.TreeSet} A canonically sorted subset (maybe all) of the {@code vectors} collection. All of the returned vectors will be the same distance from the origin. That distance will be the maximum distance from the origin of any of the vectors in the original collection. If the original collection contains only the origin then so will the result.
                     */
                    static getMostDistantFromOrigin(vectors) {
                        const mostDistant = (new java.util.TreeSet());
                        let maxDistanceSquared = 0.0;
                        for (let index = vectors.iterator(); index.hasNext();) {
                            let vector = index.next();
                            {
                                const magnitudeSquared = AlgebraicVectors.getMagnitudeSquared(vector).evaluate();
                                if (magnitudeSquared >= maxDistanceSquared) {
                                    if (magnitudeSquared > maxDistanceSquared) {
                                        mostDistant.clear();
                                    }
                                    maxDistanceSquared = magnitudeSquared;
                                    mostDistant.add(vector);
                                }
                            }
                        }
                        return mostDistant;
                    }
                }
                algebra.AlgebraicVectors = AlgebraicVectors;
                AlgebraicVectors["__class"] = "com.vzome.core.algebra.AlgebraicVectors";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class AlgebraicSeries {
                    constructor(field, power) {
                        if (this.series === undefined) {
                            this.series = null;
                        }
                        let sequence = (new java.util.ArrayList());
                        sequence.add(0);
                        let divisor = field.getUnitTerm(1);
                        divisor = divisor['times$com_vzome_core_algebra_AlgebraicNumber'](divisor);
                        for (let i = 0; i < power + 2; i++) {
                            {
                                sequence = field.recurrence(sequence);
                            }
                            ;
                        }
                        this.series = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(sequence.size() + 1);
                        this.series[0] = field.zero();
                        let prevIndex = 0;
                        for (let index = sequence.iterator(); index.hasNext();) {
                            let integer = index.next();
                            {
                                const prev = this.series[prevIndex++];
                                const step = field.getUnitTerm(integer).dividedBy(divisor);
                                this.series[prevIndex] = prev['plus$com_vzome_core_algebra_AlgebraicNumber'](step);
                            }
                        }
                    }
                    nearestAlgebraicNumber(target) {
                        const negative = target < 0.0;
                        if (negative)
                            target = -target;
                        const positive = this.checkRange(0, this.series.length - 1, target);
                        if (negative)
                            return positive.negate();
                        else
                            return positive;
                    }
                    /*private*/ checkRange(minIndex, maxIndex, target) {
                        if (minIndex >= maxIndex)
                            return this.series[maxIndex];
                        else {
                            const lowDiff = target - this.series[minIndex].evaluate();
                            const highDiff = this.series[maxIndex].evaluate() - target;
                            if (maxIndex === minIndex + 1) {
                                return (highDiff < lowDiff) ? this.series[maxIndex] : this.series[minIndex];
                            }
                            else {
                                const midIndex = (Math.floor(((maxIndex + minIndex) / 2 | 0)) | 0);
                                return (highDiff < lowDiff) ? this.checkRange(midIndex, maxIndex, target) : this.checkRange(minIndex, midIndex, target);
                            }
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        let result = "";
                        for (let index = 0; index < this.series.length; index++) {
                            let algebraicNumber = this.series[index];
                            {
                                result += algebraicNumber.toString() + ", ";
                            }
                        }
                        return result;
                    }
                }
                algebra.AlgebraicSeries = AlgebraicSeries;
                AlgebraicSeries["__class"] = "com.vzome.core.algebra.AlgebraicSeries";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                /**
                 * @author vorth
                 * @param {*} n1
                 * @param {*} n2
                 * @param {*} n3
                 * @param {*} n4
                 * @param {*} n5
                 * @class
                 */
                class AlgebraicVector {
                    constructor(n1, n2, n3, n4, n5) {
                        if (((n1 != null && (n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && ((n2 != null && (n2.constructor != null && n2.constructor["__interfaces"] != null && n2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n2 === null) && ((n3 != null && (n3.constructor != null && n3.constructor["__interfaces"] != null && n3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n3 === null) && ((n4 != null && (n4.constructor != null && n4.constructor["__interfaces"] != null && n4.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n4 === null) && ((n5 != null && (n5.constructor != null && n5.constructor["__interfaces"] != null && n5.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n5 === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let field = n1.getField();
                                let dims = 5;
                                if (this.coordinates === undefined) {
                                    this.coordinates = null;
                                }
                                if (this.field === undefined) {
                                    this.field = null;
                                }
                                this.coordinates = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(dims);
                                for (let i = 0; i < dims; i++) {
                                    {
                                        this.coordinates[i] = field.zero();
                                    }
                                    ;
                                }
                                this.field = field;
                            }
                            (() => {
                                this.coordinates[0] = n1;
                                this.coordinates[1] = n2;
                                this.coordinates[2] = n3;
                                this.coordinates[3] = n4;
                                this.coordinates[4] = n5;
                            })();
                        }
                        else if (((n1 != null && (n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && ((n2 != null && (n2.constructor != null && n2.constructor["__interfaces"] != null && n2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n2 === null) && ((n3 != null && (n3.constructor != null && n3.constructor["__interfaces"] != null && n3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n3 === null) && ((n4 != null && (n4.constructor != null && n4.constructor["__interfaces"] != null && n4.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n4 === null) && n5 === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let field = n1.getField();
                                let dims = 4;
                                if (this.coordinates === undefined) {
                                    this.coordinates = null;
                                }
                                if (this.field === undefined) {
                                    this.field = null;
                                }
                                this.coordinates = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(dims);
                                for (let i = 0; i < dims; i++) {
                                    {
                                        this.coordinates[i] = field.zero();
                                    }
                                    ;
                                }
                                this.field = field;
                            }
                            (() => {
                                this.coordinates[0] = n1;
                                this.coordinates[1] = n2;
                                this.coordinates[2] = n3;
                                this.coordinates[3] = n4;
                            })();
                        }
                        else if (((n1 != null && (n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && ((n2 != null && (n2.constructor != null && n2.constructor["__interfaces"] != null && n2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n2 === null) && ((n3 != null && (n3.constructor != null && n3.constructor["__interfaces"] != null && n3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n3 === null) && n4 === undefined && n5 === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let field = n1.getField();
                                let dims = 3;
                                if (this.coordinates === undefined) {
                                    this.coordinates = null;
                                }
                                if (this.field === undefined) {
                                    this.field = null;
                                }
                                this.coordinates = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(dims);
                                for (let i = 0; i < dims; i++) {
                                    {
                                        this.coordinates[i] = field.zero();
                                    }
                                    ;
                                }
                                this.field = field;
                            }
                            (() => {
                                this.coordinates[0] = n1;
                                this.coordinates[1] = n2;
                                this.coordinates[2] = n3;
                            })();
                        }
                        else if (((n1 != null && (n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && ((n2 != null && (n2.constructor != null && n2.constructor["__interfaces"] != null && n2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n2 === null) && n3 === undefined && n4 === undefined && n5 === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let field = n1.getField();
                                let dims = 2;
                                if (this.coordinates === undefined) {
                                    this.coordinates = null;
                                }
                                if (this.field === undefined) {
                                    this.field = null;
                                }
                                this.coordinates = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(dims);
                                for (let i = 0; i < dims; i++) {
                                    {
                                        this.coordinates[i] = field.zero();
                                    }
                                    ;
                                }
                                this.field = field;
                            }
                            (() => {
                                this.coordinates[0] = n1;
                                this.coordinates[1] = n2;
                            })();
                        }
                        else if (((n1 != null && (n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || n1 === null) && ((typeof n2 === 'number') || n2 === null) && n3 === undefined && n4 === undefined && n5 === undefined) {
                            let __args = arguments;
                            let field = __args[0];
                            let dims = __args[1];
                            if (this.coordinates === undefined) {
                                this.coordinates = null;
                            }
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            this.coordinates = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(dims);
                            for (let i = 0; i < dims; i++) {
                                {
                                    this.coordinates[i] = field.zero();
                                }
                                ;
                            }
                            this.field = field;
                        }
                        else if (((n1 != null && n1 instanceof Array && (n1.length == 0 || n1[0] == null || (n1[0] != null && (n1[0].constructor != null && n1[0].constructor["__interfaces"] != null && n1[0].constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)))) || n1 === null) && n2 === undefined && n3 === undefined && n4 === undefined && n5 === undefined) {
                            let __args = arguments;
                            let n = __args[0];
                            if (this.coordinates === undefined) {
                                this.coordinates = null;
                            }
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            this.coordinates = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(n.length);
                            java.lang.System.arraycopy(n, 0, this.coordinates, 0, n.length);
                            this.field = n[0].getField();
                        }
                        else if (((n1 != null && (n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && n2 === undefined && n3 === undefined && n4 === undefined && n5 === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let field = n1.getField();
                                let dims = 1;
                                if (this.coordinates === undefined) {
                                    this.coordinates = null;
                                }
                                if (this.field === undefined) {
                                    this.field = null;
                                }
                                this.coordinates = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(dims);
                                for (let i = 0; i < dims; i++) {
                                    {
                                        this.coordinates[i] = field.zero();
                                    }
                                    ;
                                }
                                this.field = field;
                            }
                            (() => {
                                this.coordinates[0] = n1;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        const prime = 31;
                        let result = 1;
                        result = prime * result + java.util.Arrays.hashCode(this.coordinates);
                        return result;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj)
                            return true;
                        if (obj == null)
                            return false;
                        if (this.constructor !== obj.constructor)
                            return false;
                        const other = obj;
                        if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.field, other.field)) {
                            const reason = "Invalid comparison of " + /* getSimpleName */ (c => typeof c === 'string' ? c.substring(c.lastIndexOf('.') + 1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))(this.constructor) + "swith different fields: " + this.field.getName() + " and " + other.field.getName();
                            throw new java.lang.IllegalStateException(reason);
                        }
                        return java.util.Arrays.equals(this.coordinates, other.coordinates);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} other
                     * @return {number}
                     */
                    compareTo(other) {
                        if (this === other) {
                            return 0;
                        }
                        if (other.equals(this)) {
                            return 0;
                        }
                        let comparison = (this.coordinates.length - other.coordinates.length);
                        if (comparison !== 0) {
                            return comparison;
                        }
                        for (let i = 0; i < this.coordinates.length; i++) {
                            {
                                const n1 = this.coordinates[i];
                                const n2 = other.coordinates[i];
                                comparison = n1.compareTo(n2);
                                if (comparison !== 0) {
                                    return comparison;
                                }
                            }
                            ;
                        }
                        return comparison;
                    }
                    toRealVector() {
                        return new com.vzome.core.math.RealVector(this.coordinates[0].evaluate(), this.coordinates[1].evaluate(), this.coordinates[2].evaluate());
                    }
                    to3dDoubleVector() {
                        return [this.coordinates[0].evaluate(), this.coordinates[1].evaluate(), this.coordinates[2].evaluate()];
                    }
                    /**
                     * @return {string} A String with no extended characters so it's suitable for writing
                     * to an 8 bit stream such as System.out or an ASCII text log file in Windows.
                     * Contrast this with {@link toString()} which contains extended characters (e.g.  (phi))
                     */
                    toASCIIString() {
                        return this.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT);
                    }
                    /**
                     * @return {string} A String representation that can be persisted to XML and parsed by XmlSaveFormat.parseRationalVector().
                     */
                    toParsableString() {
                        return this.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT);
                    }
                    toString(format = com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT) {
                        return this.getVectorExpression$int(format);
                    }
                    getComponent(i) {
                        return this.coordinates[i];
                    }
                    getComponents() {
                        return this.coordinates;
                    }
                    setComponent(component, coord) {
                        this.coordinates[component] = coord;
                        return this;
                    }
                    negate() {
                        const result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.coordinates.length);
                        for (let i = 0; i < result.length; i++) {
                            {
                                result[i] = this.coordinates[i].negate();
                            }
                            ;
                        }
                        return new AlgebraicVector(result);
                    }
                    scale(scale) {
                        const result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.coordinates.length);
                        for (let i = 0; i < result.length; i++) {
                            {
                                result[i] = this.coordinates[i]['times$com_vzome_core_algebra_AlgebraicNumber'](scale);
                            }
                            ;
                        }
                        return new AlgebraicVector(result);
                    }
                    isOrigin() {
                        for (let index = 0; index < this.coordinates.length; index++) {
                            let coordinate = this.coordinates[index];
                            {
                                if (!coordinate.isZero()) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    plus(that) {
                        const result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.coordinates.length);
                        for (let i = 0; i < result.length; i++) {
                            {
                                result[i] = this.coordinates[i]['plus$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[i]);
                            }
                            ;
                        }
                        return new AlgebraicVector(result);
                    }
                    minus(that) {
                        const result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.coordinates.length);
                        for (let i = 0; i < result.length; i++) {
                            {
                                result[i] = this.coordinates[i]['minus$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[i]);
                            }
                            ;
                        }
                        return new AlgebraicVector(result);
                    }
                    dimension() {
                        return this.coordinates.length;
                    }
                    cross(that) {
                        const result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.coordinates.length);
                        for (let i = 0; i < result.length; i++) {
                            {
                                const j = (i + 1) % 3;
                                const k = (i + 2) % 3;
                                result[i] = this.coordinates[j]['times$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[k])['minus$com_vzome_core_algebra_AlgebraicNumber'](this.coordinates[k]['times$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[j]));
                            }
                            ;
                        }
                        return new AlgebraicVector(result);
                    }
                    inflateTo4d$() {
                        return this.inflateTo4d$boolean(true);
                    }
                    inflateTo4d$boolean(wFirst) {
                        if (this.coordinates.length === 4) {
                            if (wFirst)
                                return this;
                            else
                                return new AlgebraicVector([this.coordinates[1], this.coordinates[2], this.coordinates[3], this.coordinates[0]]);
                        }
                        if (wFirst)
                            return new AlgebraicVector([this.field.zero(), this.coordinates[0], this.coordinates[1], this.coordinates[2]]);
                        else
                            return new AlgebraicVector([this.coordinates[0], this.coordinates[1], this.coordinates[2], this.field.zero()]);
                    }
                    inflateTo4d(wFirst) {
                        if (((typeof wFirst === 'boolean') || wFirst === null)) {
                            return this.inflateTo4d$boolean(wFirst);
                        }
                        else if (wFirst === undefined) {
                            return this.inflateTo4d$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    projectTo3d(wFirst) {
                        if (this.dimension() === 3)
                            return this;
                        if (wFirst)
                            return new AlgebraicVector([this.coordinates[1], this.coordinates[2], this.coordinates[3]]);
                        else
                            return new AlgebraicVector([this.coordinates[0], this.coordinates[1], this.coordinates[2]]);
                    }
                    getVectorExpression$java_lang_StringBuffer$int(buf, format) {
                        if (format === com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT)
                            buf.append("(");
                        for (let i = 0; i < this.coordinates.length; i++) {
                            {
                                if (i > 0)
                                    if (format === com.vzome.core.algebra.AlgebraicField.VEF_FORMAT || format === com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT)
                                        buf.append(" ");
                                    else
                                        buf.append(", ");
                                this.coordinates[i].getNumberExpression(buf, format);
                            }
                            ;
                        }
                        if (format === com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT)
                            buf.append(")");
                    }
                    /**
                     *
                     * @param {java.lang.StringBuffer} buf a StringBuffer to which the formatted vector will be appended.
                     * @param {number} format may be any of the following:
                     * {@code AlgebraicField.DEFAULT_FORMAT = 0; // 4 + 3}
                     * {@code AlgebraicField.EXPRESSION_FORMAT = 1; // 4 +3*phi}
                     * {@code AlgebraicField.ZOMIC_FORMAT = 2; // 4 3}
                     * {@code AlgebraicField.VEF_FORMAT = 3; // (3,4)}
                     */
                    getVectorExpression(buf, format) {
                        if (((buf != null && buf instanceof java.lang.StringBuffer) || buf === null) && ((typeof format === 'number') || format === null)) {
                            return this.getVectorExpression$java_lang_StringBuffer$int(buf, format);
                        }
                        else if (((typeof buf === 'number') || buf === null) && format === undefined) {
                            return this.getVectorExpression$int(buf);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getVectorExpression$int(format) {
                        const buf = new java.lang.StringBuffer();
                        this.getVectorExpression$java_lang_StringBuffer$int(buf, format);
                        return buf.toString();
                    }
                    dot(that) {
                        let result = this.field.zero();
                        for (let i = 0; i < that.dimension(); i++) {
                            {
                                result = result['plus$com_vzome_core_algebra_AlgebraicNumber'](this.coordinates[i]['times$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[i]));
                            }
                            ;
                        }
                        return result;
                    }
                    getLength(unit) {
                        for (let i = 0; i < this.coordinates.length; i++) {
                            {
                                if (this.coordinates[i].isZero())
                                    continue;
                                return this.coordinates[i].dividedBy(unit.coordinates[i]);
                            }
                            ;
                        }
                        throw new java.lang.IllegalStateException("vector is the origin!");
                    }
                    getField() {
                        return this.field;
                    }
                }
                AlgebraicVector.X = 0;
                AlgebraicVector.Y = 1;
                AlgebraicVector.Z = 2;
                AlgebraicVector.W4 = 0;
                AlgebraicVector.X4 = 1;
                AlgebraicVector.Y4 = 2;
                AlgebraicVector.Z4 = 3;
                algebra.AlgebraicVector = AlgebraicVector;
                AlgebraicVector["__class"] = "com.vzome.core.algebra.AlgebraicVector";
                AlgebraicVector["__interfaces"] = ["java.lang.Comparable"];
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class AbstractAlgebraicField {
                    constructor(name, order, factory) {
                        if (this.name === undefined) {
                            this.name = null;
                        }
                        if (this.order === undefined) {
                            this.order = 0;
                        }
                        if (this.__hashCode === undefined) {
                            this.__hashCode = null;
                        }
                        if (this.__one === undefined) {
                            this.__one = null;
                        }
                        if (this.__zero === undefined) {
                            this.__zero = null;
                        }
                        if (this.positivePowers === undefined) {
                            this.positivePowers = null;
                        }
                        if (this.negativePowers === undefined) {
                            this.negativePowers = null;
                        }
                        if (this.smallSeries === undefined) {
                            this.smallSeries = null;
                        }
                        if (this.numberFactory === undefined) {
                            this.numberFactory = null;
                        }
                        this.name = name;
                        this.order = order;
                        this.numberFactory = factory;
                        this.__zero = this.numberFactory.createRational(this, 0, 1);
                        this.__one = this.numberFactory.createRational(this, 1, 1);
                        this.positivePowers = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(order - 1);
                        this.negativePowers = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(order - 1);
                    }
                    /* Default method injected from com.vzome.core.algebra.AlgebraicField */
                    supportsSubfield(fieldName) {
                        if (fieldName === this.getName())
                            return true;
                        return (fieldName === ("golden")) && this.getGoldenRatio() != null;
                    }
                    /**
                     * The integers should be the same indices used by getUnitTerm().
                     * Subclasses must override to usefully participate in the generation
                     * of AlgebraicSeries.
                     * @param {*} input
                     * @return
                     * @return {*}
                     */
                    recurrence(input) {
                        return input;
                    }
                    normalize(factors) {
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getOrder() {
                        return this.order;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getNumIrrationals() {
                        return this.order - 1;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    scale4dRoots() {
                        return false;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    doubleFrameVectors() {
                        return false;
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {*}
                     */
                    getNumberByName(name) {
                        switch ((name)) {
                            case "zero":
                                return this.zero();
                            case "one":
                                return this.one();
                            case "phi":
                            case "\u03c6":
                                return this.getGoldenRatio();
                            case "\u221a5":
                            case "root5":
                            case "sqrt5":
                                {
                                    const n = this.getGoldenRatio();
                                    return n == null ? null : n['plus$com_vzome_core_algebra_AlgebraicNumber'](n)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.one());
                                }
                                ;
                            case "\u221a8":
                            case "root8":
                            case "sqrt8":
                                {
                                    const n = this.getNumberByName("sqrt2");
                                    return n == null ? null : n['times$com_vzome_core_algebra_AlgebraicNumber'](this.createRational$long(2));
                                }
                                ;
                            default:
                                for (let format = AbstractAlgebraicField.DEFAULT_FORMAT; format <= AbstractAlgebraicField.EXPRESSION_FORMAT; format++) {
                                    {
                                        for (let i = 1; i < this.getOrder(); i++) {
                                            {
                                                if (this['getIrrational$int$int'](i, format) === name) {
                                                    return this.getUnitTerm(i);
                                                }
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                        }
                        return null;
                    }
                    getIrrational$int(i) {
                        return this['getIrrational$int$int'](i, AbstractAlgebraicField.DEFAULT_FORMAT);
                    }
                    /*private*/ initSmallSeries() {
                        if (this.smallSeries == null) {
                            this.smallSeries = this.generateSeries(AbstractAlgebraicField.SMALL_SERIES_THRESHOLD);
                        }
                    }
                    nearestAlgebraicNumber(target) {
                        this.initSmallSeries();
                        return this.smallSeries.nearestAlgebraicNumber(target);
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.RealVector} target
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    nearestAlgebraicVector(target) {
                        this.initSmallSeries();
                        return new com.vzome.core.algebra.AlgebraicVector(this.smallSeries.nearestAlgebraicNumber(target.x), this.smallSeries.nearestAlgebraicNumber(target.y), this.smallSeries.nearestAlgebraicNumber(target.z));
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return this.name;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return this.getName();
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        if (this.__hashCode == null) {
                            const prime = 43;
                            this.__hashCode = 7;
                            const coefficients = this.getCoefficients();
                            for (let i = 0; i < coefficients.length; i++) {
                                {
                                    const coefficient = coefficients[i];
                                    this.__hashCode = prime * this.__hashCode + /* hashCode */ ((o) => { if (o.hashCode) {
                                        return o.hashCode();
                                    }
                                    else {
                                        return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                                    } })(coefficient);
                                }
                                ;
                            }
                        }
                        return this.__hashCode;
                    }
                    /**
                     * With the use of parameterized fields, it's possible for two fields
                     * of different classes to be equal
                     * or for two fields of the same class to not be equal.
                     * For example RootTwoField equals SqrtField(2)
                     * but SqrtField(2) does not equal SqrtField(3).
                     * Similarly, PolygonField(4) equals SqrtField(2)
                     * and PolygonField(6) equals SqrtField(3).
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj) {
                            return true;
                        }
                        if (obj == null) {
                            return false;
                        }
                        if (!(obj != null && obj instanceof com.vzome.core.algebra.AbstractAlgebraicField)) {
                            return false;
                        }
                        const that = obj;
                        if (this.getName() === that.getName()) {
                            return true;
                        }
                        if (this.getOrder() !== that.getOrder()) {
                            return false;
                        }
                        const thisCoefficients = this.getCoefficients();
                        const thatCoefficients = that.getCoefficients();
                        for (let i = 0; i < thisCoefficients.length; i++) {
                            {
                                if (thisCoefficients[i] - thatCoefficients[i] !== 0.0) {
                                    return false;
                                }
                            }
                            ;
                        }
                        return true;
                    }
                    /**
                     * This method is intended to allow subclasses to intercept a 4 element int array
                     * representing the numerators and denominators of a pair of terms (units and phis)
                     * from the golden field and remap them as needed for that field.
                     * Otherwise, the terms are returned unchanged.
                     * @param terms
                     * @return
                     * @param {long[]} pairs
                     * @return {long[]}
                     */
                    convertGoldenNumberPairs(pairs) {
                        if (pairs.length === 2 * this.order)
                            return pairs;
                        else {
                            const newPairs = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(2 * this.order);
                            for (let i = 0; i < this.order; i++) {
                                {
                                    newPairs[2 * i + 0] = (i >= 2) ? 0 : pairs[2 * i + 0];
                                    newPairs[2 * i + 1] = (i >= 2) ? 1 : pairs[2 * i + 1];
                                }
                                ;
                            }
                            return newPairs;
                        }
                    }
                    createAlgebraicNumber$int_A(terms) {
                        return this.numberFactory.createAlgebraicNumber(this, terms, 1);
                    }
                    /**
                     * Generates an AlgebraicNumber from a "trailing divisor" int array representation.
                     * @param {int[]} trailingDivisorForm numerators trailed by a common denominator for all numerators
                     * @return
                     * @return {*}
                     */
                    createAlgebraicNumberFromTD(trailingDivisorForm) {
                        let terms = trailingDivisorForm.length - 1;
                        if (terms === 2 && this.getOrder() > 2) {
                            let pairs = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(2 * terms);
                            const divisor = trailingDivisorForm[terms];
                            for (let i = 0; i < terms; i++) {
                                {
                                    pairs[2 * i + 0] = trailingDivisorForm[i];
                                    pairs[2 * i + 1] = divisor;
                                }
                                ;
                            }
                            pairs = this.convertGoldenNumberPairs(pairs);
                            terms = (pairs.length / 2 | 0);
                            trailingDivisorForm = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(terms + 1);
                            trailingDivisorForm[terms] = (pairs[1] | 0);
                            for (let i = 0; i < (pairs.length / 2 | 0); i++) {
                                {
                                    trailingDivisorForm[i] = (pairs[2 * i] | 0);
                                }
                                ;
                            }
                        }
                        return this.numberFactory.createAlgebraicNumberFromTD(this, trailingDivisorForm);
                    }
                    createAlgebraicNumber$int_A$int(numerators, denominator) {
                        return this.numberFactory.createAlgebraicNumber(this, numerators, denominator);
                    }
                    createAlgebraicNumber$int$int$int$int(ones, irrat, denominator, scalePower) {
                        const factors = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(this.order + 1);
                        factors[0] = ones;
                        factors[1] = irrat;
                        for (let i = 2; i < this.order; i++) {
                            {
                                factors[i] = 0;
                            }
                            ;
                        }
                        factors[this.order] = denominator;
                        const result = this.numberFactory.createAlgebraicNumberFromTD(this, factors);
                        if (scalePower !== 0) {
                            const multiplier = this.createPower$int(scalePower);
                            return result['times$com_vzome_core_algebra_AlgebraicNumber'](multiplier);
                        }
                        else
                            return result;
                    }
                    /**
                     *
                     * @param {number} ones
                     * @param {number} irrat
                     * @param {number} denominator
                     * @param {number} scalePower
                     * @return {*}
                     */
                    createAlgebraicNumber(ones, irrat, denominator, scalePower) {
                        if (((typeof ones === 'number') || ones === null) && ((typeof irrat === 'number') || irrat === null) && ((typeof denominator === 'number') || denominator === null) && ((typeof scalePower === 'number') || scalePower === null)) {
                            return this.createAlgebraicNumber$int$int$int$int(ones, irrat, denominator, scalePower);
                        }
                        else if (((ones != null && ones instanceof Array && (ones.length == 0 || ones[0] == null || (typeof ones[0] === 'number'))) || ones === null) && ((typeof irrat === 'number') || irrat === null) && denominator === undefined && scalePower === undefined) {
                            return this.createAlgebraicNumber$int_A$int(ones, irrat);
                        }
                        else if (((ones != null && ones instanceof Array && (ones.length == 0 || ones[0] == null || (typeof ones[0] === 'number'))) || ones === null) && irrat === undefined && denominator === undefined && scalePower === undefined) {
                            return this.createAlgebraicNumber$int_A(ones);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * The golden ratio (and thus icosahedral symmetry and related tools)
                     * can be generated by some fields even though it's not one of their irrational coefficients.
                     * For example, SqrtField(5) and PolygonField(10) can both generate the golden ratio
                     * so they can support icosa symmetry and related tools.
                     * In some such cases, the resulting AlgebraicNumber
                     * may have multiple terms and/or factors other than one.
                     *
                     * @return {*} An AlgebraicNumber which evaluates to the golden ratio, or null if not possible in this field.
                     */
                    getGoldenRatio() {
                        return null;
                    }
                    createPower$int(power) {
                        return this.createPower$int$int(power, 1);
                    }
                    createPower$int$int(power, irr) {
                        const one = this.one();
                        if (power === 0 || irr === 0)
                            return one;
                        irr -= 1;
                        if (power > 0) {
                            if (this.positivePowers[irr] == null)
                                this.positivePowers[irr] = (new java.util.ArrayList(8));
                            if (power >= this.positivePowers[irr].size()) {
                                if (this.positivePowers[irr].isEmpty()) {
                                    this.positivePowers[irr].add(one);
                                    this.positivePowers[irr].add(this.getUnitTerm(irr + 1));
                                }
                                const size = this.positivePowers[irr].size();
                                const irrat = this.positivePowers[irr].get(1);
                                let last = this.positivePowers[irr].get(size - 1);
                                for (let i = size; i <= power; i++) {
                                    {
                                        const next = last['times$com_vzome_core_algebra_AlgebraicNumber'](irrat);
                                        this.positivePowers[irr].add(next);
                                        last = next;
                                    }
                                    ;
                                }
                            }
                            return this.positivePowers[irr].get(power);
                        }
                        else {
                            power = -power;
                            if (this.negativePowers[irr] == null)
                                this.negativePowers[irr] = (new java.util.ArrayList(8));
                            if (power >= this.negativePowers[irr].size()) {
                                if (this.negativePowers[irr].isEmpty()) {
                                    this.negativePowers[irr].add(one);
                                    this.negativePowers[irr].add(this.getUnitTerm(irr + 1).reciprocal());
                                }
                                const size = this.negativePowers[irr].size();
                                const irrat = this.negativePowers[irr].get(1);
                                let last = this.negativePowers[irr].get(size - 1);
                                for (let i = size; i <= power; i++) {
                                    {
                                        const next = last['times$com_vzome_core_algebra_AlgebraicNumber'](irrat);
                                        this.negativePowers[irr].add(next);
                                        last = next;
                                    }
                                    ;
                                }
                            }
                            return this.negativePowers[irr].get(power);
                        }
                    }
                    /**
                     *
                     * @param {number} power
                     * @param {number} irr
                     * @return {*}
                     */
                    createPower(power, irr) {
                        if (((typeof power === 'number') || power === null) && ((typeof irr === 'number') || irr === null)) {
                            return this.createPower$int$int(power, irr);
                        }
                        else if (((typeof power === 'number') || power === null) && irr === undefined) {
                            return this.createPower$int(power);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    createRational$long(wholeNumber) {
                        return this.numberFactory.createRational(this, wholeNumber, 1);
                    }
                    createRational$long$long(numerator, denominator) {
                        return this.numberFactory.createRational(this, numerator, denominator);
                    }
                    /**
                     * @param {number} numerator
                     * @param {number} denominator
                     * @return {*} AlgebraicNumber
                     */
                    createRational(numerator, denominator) {
                        if (((typeof numerator === 'number') || numerator === null) && ((typeof denominator === 'number') || denominator === null)) {
                            return this.createRational$long$long(numerator, denominator);
                        }
                        else if (((typeof numerator === 'number') || numerator === null) && denominator === undefined) {
                            return this.createRational$long(numerator);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * @return {*} The AlgebraicNumber to be use for the Chord Ratio construction in the given field.
                     * This method can be used to generalize an AffinePolygon tool and a PolygonalAntiprismSymmetry.
                     * This base class returns one, which is the scalar for an affine square and works in any field.
                     * Derived classes should override this method if they can be used to generate any other affine polygon.
                     */
                    getAffineScalar() {
                        return this.__one;
                    }
                    /**
                     * @param {number} n specifies the ordinal of the term in the AlgebraicNumber which will be set to one.
                     * When {@code n == 0}, the result is the same as {@code createRational(1)}.
                     * When {@code n == 1}, the result is the same as {@code createPower(1)}.
                     * When {@code n < 0}, the result will be {@code zero()}.
                     * When {@code n >= getOrder()}, an IndexOutOfBoundsException will be thrown.
                     * @return {*} an AlgebraicNumber with the factor specified by {@code n} set to one.
                     */
                    getUnitTerm(n) {
                        if (n < 0) {
                            return this.zero();
                        }
                        const factors = this.zero().toTrailingDivisor();
                        factors[n] = factors[factors.length - 1];
                        return this.numberFactory.createAlgebraicNumberFromTD(this, factors);
                    }
                    /**
                     * Drop one coordinate from the 4D vector. If wFirst (the usual), then drop
                     * the first coordinate, taking the "imaginary part" of the vector. If
                     * !wFirst (for old VEF import, etc.), drop the last coordinate.
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} source
                     * @param {boolean} wFirst
                     * @return
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    projectTo3d(source, wFirst) {
                        if (source.dimension() === 3)
                            return source;
                        else {
                            const result = this.origin(3);
                            for (let i = 0; i < 3; i++) {
                                result.setComponent(i, source.getComponent(wFirst ? i + 1 : i));
                            }
                            return result;
                        }
                    }
                    /**
                     *
                     * @param {number} dims
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    origin(dims) {
                        return new com.vzome.core.algebra.AlgebraicVector(this, dims);
                    }
                    /**
                     *
                     * @param {number} dims
                     * @param {number} axis
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    basisVector(dims, axis) {
                        const result = this.origin(dims);
                        return result.setComponent(axis, this.one());
                    }
                    reciprocal(fieldElement) {
                        const length = fieldElement.length;
                        const representation = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return null;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([length, length]);
                        let isZero = true;
                        for (let i = 0; i < length; i++) {
                            {
                                isZero = isZero && fieldElement[i].isZero();
                                representation[0][i] = fieldElement[i];
                            }
                            ;
                        }
                        if (isZero)
                            throw new java.lang.RuntimeException("Denominator is zero");
                        for (let j = 1; j < length; j++) {
                            {
                                const column = this.scaleBy(fieldElement, j);
                                java.lang.System.arraycopy(column, 0, representation[j], 0, length);
                            }
                            ;
                        }
                        const reciprocal = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return null;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([length, length]);
                        for (let j = 0; j < length; j++) {
                            {
                                for (let i = 0; i < length; i++) {
                                    {
                                        reciprocal[j][i] = (i === j) ? this.numberFactory.one() : this.numberFactory.zero();
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        const rank = com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(representation, reciprocal);
                        const reciprocalFactors = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(length);
                        java.lang.System.arraycopy(reciprocal[0], 0, reciprocalFactors, 0, length);
                        return (rank === length) ? reciprocalFactors : this.onReciprocalRankDeficient(rank, reciprocal, reciprocalFactors);
                    }
                    /**
                     * Subclasses can overloading this method to handle special cases. (e.g. SqrtField of a perfect square)
                     * @param {number} rank
                     * @param {com.vzome.core.algebra.BigRational[][]} reciprocal
                     * @param {com.vzome.core.algebra.BigRational[]} reciprocalFactors
                     * @throws IllegalStateException
                     * @return {com.vzome.core.algebra.BigRational[]}
                     */
                    onReciprocalRankDeficient(rank, reciprocal, reciprocalFactors) {
                        const msg = this.getName() + " expects reciprocal matrix to be full rank (" + reciprocal.length + "), but it is " + rank + ".";
                        console.error(msg);
                        throw new java.lang.IllegalStateException(msg);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    zero() {
                        return this.__zero;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    one() {
                        return this.__one;
                    }
                    /**
                     *
                     * @param {int[][]} nums is an array of integer arrays: One array of coordinate terms per dimension.
                     * Initially, this is designed to simplify migration of order 2 golden directions
                     * to new fields of higher order having golden subfields as their first two factors.
                     * {@code
                     * field.createVector( new int[]  {  0,1,2,3,   4,5,6,7,   8,9,0,1  } );   // older code like this...
                     * field.createVector( new int[][]{ {0,1,2,3}, {4,5,6,7}, {8,9,0,1} } );   // should be replaced by this.
                     * }
                     * The older code shown in the first example requires an order 2 field.
                     * The second example will work with any field of order 2 or greater.
                     * This new overload has the advantage that the internal arrays representing the individual dimensions are more clearly delineated and controlled.
                     * Inner arrays require an even number of elements since they represent a sequence of numerator/denominator pairs.
                     *
                     * createVector is currently limited to int valued vectors, not long, and definitely not BigInteger
                     * In most cases, this is adequate, but in the case where it's called by XmlSaveFormat.parseAlgebraicObject(),
                     * it seems possible that a value larger than Integer.MAX_VALUE could be saved to the XML which could not subsequently be parsed.
                     * TODO: Consider refactoring createVector to use long[][] instead of int[][] if this becomes an issue.
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector} an AlgebraicVector
                     */
                    createVector(nums) {
                        const dims = nums.length;
                        const coords = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(dims);
                        for (let c = 0; c < coords.length; c++) {
                            {
                                const coordLength = nums[c].length;
                                if (coordLength % 2 !== 0) {
                                    throw new java.lang.IllegalStateException("Vector dimension " + c + " has " + coordLength + " components. An even number is required.");
                                }
                                const nTerms = (coordLength / 2 | 0);
                                if (nTerms > this.getOrder()) {
                                    throw new java.lang.IllegalStateException("Vector dimension " + c + " has " + ((coordLength / 2 | 0)) + " terms. Each dimension of the " + this.getName() + " field is limited to " + this.getOrder() + " terms. Each term consists of a numerator and a denominator.");
                                }
                                let pairs = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(nums[c].length);
                                for (let i = 0; i < pairs.length; i++) {
                                    {
                                        pairs[i] = nums[c][i];
                                    }
                                    ;
                                }
                                if (pairs.length === 4 && this.getOrder() > 2) {
                                    pairs = this.convertGoldenNumberPairs(pairs);
                                }
                                coords[c] = this.numberFactory.createAlgebraicNumberFromPairs(this, pairs);
                            }
                            ;
                        }
                        return new com.vzome.core.algebra.AlgebraicVector(coords);
                    }
                    /**
                     *
                     * @param {int[][]} nums
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    createVectorFromTDs(nums) {
                        const dims = nums.length;
                        const coords = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(dims);
                        for (let c = 0; c < coords.length; c++) {
                            {
                                coords[c] = this.createAlgebraicNumberFromTD(nums[c]);
                            }
                            ;
                        }
                        return new com.vzome.core.algebra.AlgebraicVector(coords);
                    }
                    /**
                     * Generates an AlgebraicVector with all AlgebraicNumber terms being integers (having unit denominators).
                     * Contrast this with {@code createVector(int[][] nums)} which requires all denominators to be specified.
                     * @param {int[][]} nums is a 2 dimensional integer array. The length of nums becomes the number of dimensions in the resulting AlgebraicVector.
                     * For example, {@code (new PentagonField()).createIntegerVector( new int[][]{ {0,-1}, {2,3}, {4,5} } ); }
                     * generates the 3 dimensional vector (-, 2 +3, 4 +5) having all integer terms.
                     * @return {com.vzome.core.algebra.AlgebraicVector} an AlgebraicVector
                     */
                    createIntegerVector(nums) {
                        const dims = nums.length;
                        const result = this.origin(dims);
                        for (let dim = 0; dim < dims; dim++) {
                            {
                                result.setComponent(dim, this.createAlgebraicNumber$int_A(nums[dim]));
                            }
                            ;
                        }
                        return result;
                    }
                    /**
                     * Create a 3x3 square matrix from integer data.
                     * TODO: Generalize this method to create a matrix with dimensions matching the dimensions of the data array
                     * Sample input data for an order-4 field:
                     * {{{7,5,0,1,-4,5,0,1},{-2,5,0,1,4,5,0,1},{0,1,-8,5,0,1,6,5}},
                     * {{-2,5,0,1,4,5,0,1},{7,5,0,1,-4,5,0,1},{0,1,8,5,0,1,-6,5}},
                     * {{0,1,-8,5,0,1,6,5},{0,1,8,5,0,1,-6,5},{-9,5,0,1,8,5,0,1}}}
                     * @param field
                     * @param {int[][][]} data integer coordinates, in row-major order, complete with denominators.
                     * @return
                     * @return {com.vzome.core.algebra.AlgebraicMatrix}
                     */
                    createMatrix(data) {
                        const col1 = this.createVector([data[0][0], data[1][0], data[2][0]]);
                        const col2 = this.createVector([data[0][1], data[1][1], data[2][1]]);
                        const col3 = this.createVector([data[0][2], data[1][2], data[2][2]]);
                        return new com.vzome.core.algebra.AlgebraicMatrix(col1, col2, col3);
                    }
                    /**
                     *
                     * @param {java.lang.StringBuffer} buf
                     * @param {com.vzome.core.algebra.BigRational[]} factors
                     * @param {number} format must be one of the following values.
                     * The result is formatted as follows:
                     * <br>
                     * {@code DEFAULT_FORMAT    // 4 + 3}<br>
                     * {@code EXPRESSION_FORMAT // 4 +3*phi}<br>
                     * {@code ZOMIC_FORMAT      // 4 3}<br>
                     * {@code VEF_FORMAT        // (3,4)}
                     */
                    getNumberExpression(buf, factors, format) {
                        switch ((format)) {
                            case 2 /* ZOMIC_FORMAT */:
                                for (let i = 0; i < factors.length; i++) {
                                    {
                                        if (i > 0)
                                            buf.append(" ");
                                        buf.append(factors[i].toString());
                                    }
                                    ;
                                }
                                break;
                            case 3 /* VEF_FORMAT */:
                                buf.append("(");
                                for (let i = factors.length; i > 0; i--) {
                                    {
                                        buf.append(factors[i - 1].toString());
                                        if (i > 1)
                                            buf.append(",");
                                    }
                                    ;
                                }
                                buf.append(")");
                                break;
                            default:
                                let first = 0;
                                for (let i = 0; i < factors.length; i++) {
                                    {
                                        let factor = factors[i];
                                        if (factor.isZero()) {
                                            ++first;
                                            continue;
                                        }
                                        if (i > first) {
                                            buf.append(" ");
                                        }
                                        if (factor.isNegative()) {
                                            factor = factor.negate();
                                            buf.append("-");
                                        }
                                        else if (i > first) {
                                            buf.append("+");
                                        }
                                        if (i === 0)
                                            buf.append(factor.toString());
                                        else {
                                            if (!factor.isOne()) {
                                                buf.append(factor.toString());
                                                if (format === AbstractAlgebraicField.EXPRESSION_FORMAT)
                                                    buf.append("*");
                                            }
                                            const multiplier = this['getIrrational$int$int'](i, format);
                                            buf.append(multiplier);
                                        }
                                    }
                                    ;
                                }
                                if (first === factors.length)
                                    buf.append("0");
                                break;
                        }
                    }
                    /**
                     *
                     * @param {string} val
                     * @return {*}
                     */
                    parseLegacyNumber(val) {
                        throw new java.lang.IllegalStateException("This field does not support vZome 2.x files.");
                    }
                    /**
                     *
                     * @param {string} string
                     * @param {boolean} isRational
                     * @return {*}
                     */
                    parseVefNumber(string, isRational) {
                        let pairs = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(this.getOrder() * 2);
                        for (let i = 1; i < pairs.length; i += 2) {
                            {
                                pairs[i] = 1;
                            }
                            ;
                        }
                        if ((!isRational) && /* startsWith */ ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "(") && /* endsWith */ ((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(string, ")")) {
                            const tokens = new java.util.StringTokenizer(string.substring(1, string.length - 1), ",");
                            const numStack = (new java.util.Stack());
                            const denomStack = (new java.util.Stack());
                            while ((tokens.hasMoreTokens())) {
                                {
                                    if (numStack.size() >= this.getOrder()) {
                                        throw new java.lang.RuntimeException("VEF format error: \"" + string + "\" has too many factors for " + this.getName() + " field");
                                    }
                                    const parts = tokens.nextToken().split("/");
                                    numStack.push(javaemul.internal.IntegerHelper.parseInt(parts[0]));
                                    denomStack.push((parts.length > 1) ? javaemul.internal.IntegerHelper.parseInt(parts[1]) : 1);
                                }
                            }
                            ;
                            let i = 0;
                            while ((!numStack.empty())) {
                                {
                                    pairs[i++] = numStack.pop();
                                    pairs[i++] = denomStack.pop();
                                }
                            }
                            ;
                            if (i === 4 && this.getOrder() > 2) {
                                pairs = this.convertGoldenNumberPairs([pairs[0], pairs[1], pairs[2], pairs[3]]);
                            }
                        }
                        else {
                            const parts = string.split("/");
                            pairs[0] = javaemul.internal.IntegerHelper.parseInt(parts[0]);
                            pairs[1] = (parts.length > 1) ? javaemul.internal.IntegerHelper.parseInt(parts[1]) : 1;
                        }
                        return this.numberFactory.createAlgebraicNumberFromPairs(this, pairs);
                    }
                    parseNumber$java_lang_String(nums) {
                        const tokens = new java.util.StringTokenizer(nums, " ");
                        return this.parseNumber$java_util_StringTokenizer(tokens);
                    }
                    /**
                     *
                     * @param {string} nums
                     * @return {*}
                     */
                    parseNumber(nums) {
                        if (((typeof nums === 'string') || nums === null)) {
                            return this.parseNumber$java_lang_String(nums);
                        }
                        else if (((nums != null && nums instanceof java.util.StringTokenizer) || nums === null)) {
                            return this.parseNumber$java_util_StringTokenizer(nums);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /*private*/ parseNumber$java_util_StringTokenizer(tokens) {
                        const order = this.getOrder();
                        const pairs = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(order * 2);
                        for (let i = 0; i < order; i++) {
                            {
                                const digit = tokens.nextToken();
                                const parts = digit.split("/");
                                pairs[i * 2] = javaemul.internal.LongHelper.parseLong(parts[0]);
                                if (parts.length > 1)
                                    pairs[i * 2 + 1] = javaemul.internal.LongHelper.parseLong(parts[1]);
                                else
                                    pairs[i * 2 + 1] = 1;
                            }
                            ;
                        }
                        return this.numberFactory.createAlgebraicNumberFromPairs(this, pairs);
                    }
                    /**
                     *
                     * @param {string} nums
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    parseVector(nums) {
                        const tokens = new java.util.StringTokenizer(nums, " ");
                        const numToks = tokens.countTokens();
                        if (numToks % this.getOrder() !== 0)
                            throw new java.lang.IllegalStateException("Field order (" + this.getOrder() + ") does not divide token count: " + numToks + ", for \'" + nums + "\'");
                        const dims = (numToks / this.getOrder() | 0);
                        const coords = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(dims);
                        for (let i = 0; i < dims; i++) {
                            {
                                coords[i] = this.parseNumber$java_util_StringTokenizer(tokens);
                            }
                            ;
                        }
                        return new com.vzome.core.algebra.AlgebraicVector(coords);
                    }
                    /**
                     *
                     * @param {number} dims
                     * @return {com.vzome.core.algebra.AlgebraicMatrix}
                     */
                    identityMatrix(dims) {
                        const columns = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(dims);
                        for (let i = 0; i < columns.length; i++) {
                            {
                                columns[i] = this.basisVector(dims, i);
                            }
                            ;
                        }
                        return new com.vzome.core.algebra.AlgebraicMatrix(columns);
                    }
                    /**
                     * @return {number} the number of independent multipliers in this field.
                     * These are the primitive elements of the field.
                     * The value should be less than or equal to getNumIrrationals.
                     * It will be less whenever the irrationals are dependent.
                     * For example, in the field for sqrt(phi), there is only one
                     * multiplier, since the other irrational is just the square of that one.
                     */
                    getNumMultipliers() {
                        return this.getNumIrrationals();
                    }
                    generateSeries(threshold) {
                        const multiplier = this.createPower$int$int(1, this.getNumIrrationals());
                        let cover = this.one();
                        let power = 0;
                        while ((cover.evaluate() < threshold)) {
                            {
                                cover = cover['times$com_vzome_core_algebra_AlgebraicNumber'](multiplier);
                                ++power;
                            }
                        }
                        ;
                        return new com.vzome.core.algebra.AlgebraicSeries(this, power);
                    }
                    getMathML(factors) {
                        const buf = new java.lang.StringBuffer();
                        let first = 0;
                        for (let i = 0; i < factors.length; i++) {
                            {
                                let factor = factors[i];
                                if (factor.isZero()) {
                                    ++first;
                                    continue;
                                }
                                if (factor.isNegative()) {
                                    factor = factor.negate();
                                    buf.append("<mo>-</mo>");
                                }
                                else if (i > first) {
                                    buf.append("<mo>+</mo>");
                                }
                                if (i === 0)
                                    buf.append(factor.getMathML());
                                else {
                                    if (!factor.isOne()) {
                                        buf.append(factor.getMathML());
                                    }
                                    const multiplier = this['getIrrational$int$int'](i, AbstractAlgebraicField.DEFAULT_FORMAT);
                                    buf.append("<mi>");
                                    buf.append(multiplier);
                                    buf.append("</mi>");
                                }
                            }
                            ;
                        }
                        if (first === factors.length)
                            return "<mn>0</mn>";
                        else if (factors.length - first > 1)
                            return "<mrow>" + buf.toString() + "</mrow>";
                        else
                            return buf.toString();
                    }
                    /**
                     *
                     * @param {string} script
                     * @param {string} language
                     * @param {com.vzome.core.construction.Point} offset
                     * @param {*} symmetry
                     * @param {*} effects
                     */
                    interpretScript(script, language, offset, symmetry, effects) {
                        throw new Error("Scripts are only supported in the golden field.");
                    }
                }
                AbstractAlgebraicField.SMALL_SERIES_THRESHOLD = 30.0;
                AbstractAlgebraicField.DEFAULT_FORMAT = 0;
                AbstractAlgebraicField.EXPRESSION_FORMAT = 1;
                AbstractAlgebraicField.ZOMIC_FORMAT = 2;
                AbstractAlgebraicField.VEF_FORMAT = 3;
                algebra.AbstractAlgebraicField = AbstractAlgebraicField;
                AbstractAlgebraicField["__class"] = "com.vzome.core.algebra.AbstractAlgebraicField";
                AbstractAlgebraicField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class VefVectorExporter {
                    constructor(writer, field, scale, withOffset) {
                        if (((writer != null && writer instanceof java.io.Writer) || writer === null) && ((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((scale != null && (scale.constructor != null && scale.constructor["__interfaces"] != null && scale.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || scale === null) && ((typeof withOffset === 'boolean') || withOffset === null)) {
                            let __args = arguments;
                            if (this.output === undefined) {
                                this.output = null;
                            }
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            if (this.strutEnds === undefined) {
                                this.strutEnds = null;
                            }
                            if (this.panelVertices === undefined) {
                                this.panelVertices = null;
                            }
                            if (this.scale === undefined) {
                                this.scale = null;
                            }
                            if (this.includeOffset === undefined) {
                                this.includeOffset = false;
                            }
                            this.sortedVertexList = null;
                            this.vertices = (new java.util.TreeSet());
                            this.ballLocations = (new java.util.TreeSet());
                            this.exportedOffset = null;
                            this.strTip = "tip";
                            this.strMiddle = "middle";
                            this.includeOffset = withOffset;
                            this.scale = scale;
                            this.output = new java.io.PrintWriter(writer);
                            this.field = field;
                            const arrayComparator = (new com.vzome.core.generic.ArrayComparator());
                            this.strutEnds = (new java.util.TreeSet((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0, arg1) => (funcInst['compare'] ? funcInst['compare'] : funcInst).call(funcInst, arg0, arg1); })(arrayComparator.getContentFirstArrayComparator()))));
                            this.panelVertices = (new java.util.TreeSet((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0, arg1) => (funcInst['compare'] ? funcInst['compare'] : funcInst).call(funcInst, arg0, arg1); })(arrayComparator.getLengthFirstArrayComparator()))));
                        }
                        else if (((writer != null && writer instanceof java.io.Writer) || writer === null) && ((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && scale === undefined && withOffset === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let scale = null;
                                let withOffset = false;
                                if (this.output === undefined) {
                                    this.output = null;
                                }
                                if (this.field === undefined) {
                                    this.field = null;
                                }
                                if (this.strutEnds === undefined) {
                                    this.strutEnds = null;
                                }
                                if (this.panelVertices === undefined) {
                                    this.panelVertices = null;
                                }
                                if (this.scale === undefined) {
                                    this.scale = null;
                                }
                                if (this.includeOffset === undefined) {
                                    this.includeOffset = false;
                                }
                                this.sortedVertexList = null;
                                this.vertices = (new java.util.TreeSet());
                                this.ballLocations = (new java.util.TreeSet());
                                this.exportedOffset = null;
                                this.strTip = "tip";
                                this.strMiddle = "middle";
                                this.includeOffset = withOffset;
                                this.scale = scale;
                                this.output = new java.io.PrintWriter(writer);
                                this.field = field;
                                const arrayComparator = (new com.vzome.core.generic.ArrayComparator());
                                this.strutEnds = (new java.util.TreeSet((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                    return funcInst;
                                } return (arg0, arg1) => (funcInst['compare'] ? funcInst['compare'] : funcInst).call(funcInst, arg0, arg1); })(arrayComparator.getContentFirstArrayComparator()))));
                                this.panelVertices = (new java.util.TreeSet((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                    return funcInst;
                                } return (arg0, arg1) => (funcInst['compare'] ? funcInst['compare'] : funcInst).call(funcInst, arg0, arg1); })(arrayComparator.getLengthFirstArrayComparator()))));
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    exportPoint(pt) {
                        this.vertices.add(pt);
                        this.ballLocations.add(pt);
                        if (this.includeOffset) {
                            this.exportedOffset = pt;
                        }
                    }
                    exportSegment(start, end) {
                        const ends = [start, end];
                        this.vertices.add(ends[0]);
                        this.vertices.add(ends[1]);
                        this.strutEnds.add(ends);
                    }
                    exportPolygon(corners) {
                        this.vertices.addAll(corners);
                        const cornerArray = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(corners.size());
                        corners.toArray(cornerArray);
                        this.panelVertices.add(cornerArray);
                    }
                    /**
                     * @param {java.lang.StringBuffer} buffer = Don't assume that buffer starts out empty. Results will be appended.
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector = Value to be converted to a zero-padded 4D String which will be
                     * prefixed and/or padded with field specific zeroes
                     * depending on the number of dimensions in vector as follows:
                     * 1D : 0 X 0 0
                     * 2D : 0 X Y 0
                     * 3D : 0 X Y Z
                     * 4D : W X Y Z
                     * @param {*} scale
                     */
                    static appendVector(buffer, vector, scale) {
                        const zeroString = vector.getField().zero().toString(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT);
                        const dims = vector.dimension();
                        if (dims < 4) {
                            buffer.append(zeroString);
                            buffer.append(" ");
                        }
                        if (scale != null)
                            vector = vector.scale(scale);
                        vector.getVectorExpression$java_lang_StringBuffer$int(buffer, com.vzome.core.algebra.AlgebraicField.VEF_FORMAT);
                        for (let d = dims + 1; d < 4; d++) {
                            {
                                buffer.append(" ");
                                buffer.append(zeroString);
                            }
                            ;
                        }
                    }
                    static exportPolyhedron(polyhedron) {
                        const out = new java.io.StringWriter();
                        const exporter = new VefVectorExporter(out, polyhedron.getField());
                        const vertexList = polyhedron.getVertexList();
                        for (let index = polyhedron.getFaceSet().iterator(); index.hasNext();) {
                            let face = index.next();
                            {
                                const vertices = (new java.util.ArrayList(face.size()));
                                for (let i = 0; i < face.size(); i++) {
                                    {
                                        const vertexIndex = face.getVertex(i);
                                        vertices.add(vertexList.get(vertexIndex));
                                    }
                                    ;
                                }
                                exporter.exportPolygon(vertices);
                            }
                        }
                        exporter.finishExport();
                        return out.toString();
                    }
                    finishExport() {
                        this.sortedVertexList = (new java.util.ArrayList(this.vertices));
                        this.vertices = null;
                        const version = (this.exportedOffset == null) ? com.vzome.core.math.VefParser.VERSION_EXPLICIT_BALLS : com.vzome.core.math.VefParser.VERSION_EXPLICIT_OFFSET;
                        this.output.println$java_lang_Object("vZome VEF " + version + " field " + this.field.getName());
                        if (this.exportedOffset != null) {
                            const buf = new java.lang.StringBuffer();
                            buf.append("\noffset ");
                            VefVectorExporter.appendVector(buf, this.exportedOffset.negate(), null);
                            buf.append("\n");
                            this.output.println$java_lang_Object(buf.toString());
                        }
                        this.output.println$java_lang_Object("\n" + this.sortedVertexList.size());
                        {
                            const buf = new java.lang.StringBuffer();
                            for (let index = this.sortedVertexList.iterator(); index.hasNext();) {
                                let vector = index.next();
                                {
                                    VefVectorExporter.appendVector(buf, vector, this.scale);
                                    buf.append("\n");
                                }
                            }
                            buf.append("\n");
                            this.output.println$java_lang_Object(buf.toString());
                        }
                        ;
                        this.output.println$java_lang_Object("\n" + this.strutEnds.size());
                        for (let index = this.strutEnds.iterator(); index.hasNext();) {
                            let ends = index.next();
                            {
                                this.output.print(this.sortedVertexList.indexOf(ends[0]) + " ");
                                this.output.println$java_lang_Object(this.sortedVertexList.indexOf(ends[1]));
                            }
                        }
                        this.output.println$java_lang_Object("\n");
                        this.output.println$java_lang_Object("\n" + this.panelVertices.size());
                        for (let index = this.panelVertices.iterator(); index.hasNext();) {
                            let corners = index.next();
                            {
                                this.output.print(corners.length + "  ");
                                for (let index = 0; index < corners.length; index++) {
                                    let corner = corners[index];
                                    {
                                        this.output.print(this.sortedVertexList.indexOf(corner) + " ");
                                    }
                                }
                                this.output.println$();
                            }
                        }
                        this.output.println$java_lang_Object("\n");
                        this.output.println$java_lang_Object("\n" + this.ballLocations.size());
                        let i = 0;
                        for (let index = this.ballLocations.iterator(); index.hasNext();) {
                            let ball = index.next();
                            {
                                this.output.print(this.sortedVertexList.indexOf(ball) + " ");
                                if (++i % 10 === 0) {
                                    this.output.println$();
                                }
                            }
                        }
                        this.output.println$java_lang_Object("\n");
                        this.output.flush();
                    }
                }
                algebra.VefVectorExporter = VefVectorExporter;
                VefVectorExporter["__class"] = "com.vzome.core.algebra.VefVectorExporter";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Fields {
                    static rows(matrix) {
                        return matrix.length;
                    }
                    static columns(matrix) {
                        return matrix[0].length;
                    }
                    static matrixMultiplication(left, right, product) {
                        if (Fields.rows(right) !== Fields.columns(left))
                            throw new java.lang.IllegalArgumentException("matrices cannot be multiplied");
                        if (Fields.rows(product) !== Fields.rows(left))
                            throw new java.lang.IllegalArgumentException("product matrix has wrong number of rows");
                        if (Fields.columns(right) !== Fields.columns(product))
                            throw new java.lang.IllegalArgumentException("product matrix has wrong number of columns");
                        for (let i = 0; i < Fields.rows(product); i++) {
                            {
                                for (let j = 0; j < Fields.columns(product); j++) {
                                    {
                                        let sum = null;
                                        for (let j2 = 0; j2 < Fields.columns(left); j2++) {
                                            {
                                                const prod = left[i][j2].times(right[j2][j]);
                                                if (sum == null)
                                                    sum = prod;
                                                else
                                                    sum = sum.plus(prod);
                                            }
                                            ;
                                        }
                                        product[i][j] = sum;
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                    }
                    static gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A(matrix) {
                        return Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(matrix, matrix);
                    }
                    static gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(immutableMatrix, adjoined) {
                        const nRows = Fields.rows(immutableMatrix);
                        const matrix = Fields.copyOf(immutableMatrix);
                        let rank = 0;
                        for (let col = 0; col < Fields.columns(matrix); col++) {
                            {
                                let pivotRow = -1;
                                for (let row = rank; row < nRows; row++) {
                                    {
                                        const element = matrix[row][col];
                                        if (!element.isZero()) {
                                            pivotRow = row;
                                            break;
                                        }
                                    }
                                    ;
                                }
                                if (pivotRow >= 0) {
                                    if (pivotRow !== rank) {
                                        Fields.swap(matrix, rank, pivotRow);
                                        Fields.swap(adjoined, rank, pivotRow);
                                        pivotRow = rank;
                                    }
                                    let scalar = matrix[pivotRow][col];
                                    if (!scalar.isOne()) {
                                        scalar = scalar.reciprocal();
                                        Fields.scale(matrix[pivotRow], scalar);
                                        Fields.scale(adjoined[pivotRow], scalar);
                                    }
                                    for (let row = 0; row < nRows; row++) {
                                        {
                                            if (row !== pivotRow) {
                                                scalar = matrix[row][col];
                                                if (!scalar.isZero()) {
                                                    scalar = scalar.negate();
                                                    Fields.pivot(matrix, row, scalar, pivotRow);
                                                    Fields.pivot(adjoined, row, scalar, pivotRow);
                                                }
                                            }
                                        }
                                        ;
                                    }
                                    rank++;
                                }
                            }
                            ;
                        }
                        return rank;
                    }
                    static gaussJordanReduction(immutableMatrix, adjoined) {
                        if (((immutableMatrix != null && immutableMatrix instanceof Array && (immutableMatrix.length == 0 || immutableMatrix[0] == null || immutableMatrix[0] instanceof Array)) || immutableMatrix === null) && ((adjoined != null && adjoined instanceof Array && (adjoined.length == 0 || adjoined[0] == null || adjoined[0] instanceof Array)) || adjoined === null)) {
                            return com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(immutableMatrix, adjoined);
                        }
                        else if (((immutableMatrix != null && immutableMatrix instanceof Array && (immutableMatrix.length == 0 || immutableMatrix[0] == null || immutableMatrix[0] instanceof Array)) || immutableMatrix === null) && adjoined === undefined) {
                            return com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A(immutableMatrix);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static copyOf(matrix) {
                        const nRows = Fields.rows(matrix);
                        const nCols = Fields.columns(matrix);
                        const copy = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(nRows);
                        for (let i = 0; i < nRows; i++) {
                            {
                                copy[i] = java.util.Arrays.copyOf(matrix[i], nCols);
                            }
                            ;
                        }
                        return copy;
                    }
                    /**
                     *
                     * @param {java.lang.Object[]} array of elements to be swapped
                     * @param {number} r index of the first element to be swapped
                     * @param {number} s index of the second element to be swapped
                     * <br/>
                     * Note that since Java implements a multi-dimensional array as an array of arrays,
                     * the {@code array} parameter can be an {@code Object[][]} in which case
                     * entire rows are swapped rather than an element at a time.
                     * Besides being more efficient at run time, this also means
                     * that rows of multi-dimensional arrays do not necessarily have to be the same length.
                     * @private
                     */
                    static swap(array, r, s) {
                        const temp = array[r];
                        array[r] = array[s];
                        array[s] = temp;
                    }
                    static scale(array, scalar) {
                        for (let col = 0; col < array.length; col++) {
                            {
                                array[col] = scalar.times(array[col]);
                            }
                            ;
                        }
                    }
                    static pivot(matrix, row, scalar, rank) {
                        for (let col = 0; col < Fields.columns(matrix); col++) {
                            {
                                matrix[row][col] = matrix[row][col].plus(matrix[rank][col].times(scalar));
                            }
                            ;
                        }
                    }
                }
                algebra.Fields = Fields;
                Fields["__class"] = "com.vzome.core.algebra.Fields";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                let AlgebraicField;
                (function (AlgebraicField) {
                    AlgebraicField.DEFAULT_FORMAT = 0;
                    AlgebraicField.EXPRESSION_FORMAT = 1;
                    AlgebraicField.ZOMIC_FORMAT = 2;
                    AlgebraicField.VEF_FORMAT = 3;
                    function getIrrationals(field) {
                        const len = field.getNumIrrationals();
                        const result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(len);
                        for (let i = 0; i < result.length; i++) {
                            {
                                result[i] = field['getIrrational$int'](i + 1);
                            }
                            ;
                        }
                        return result;
                    }
                    AlgebraicField.getIrrationals = getIrrationals;
                    function getMultipliers(field) {
                        const len = field.getNumMultipliers();
                        const result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(len);
                        for (let i = 0; i < result.length; i++) {
                            {
                                result[i] = field['getIrrational$int'](i + 1);
                            }
                            ;
                        }
                        return result;
                    }
                    AlgebraicField.getMultipliers = getMultipliers;
                })(AlgebraicField = algebra.AlgebraicField || (algebra.AlgebraicField = {}));
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Bivector3d {
                    constructor(a, b, c) {
                        if (this.a === undefined) {
                            this.a = null;
                        }
                        if (this.b === undefined) {
                            this.b = null;
                        }
                        if (this.c === undefined) {
                            this.c = null;
                        }
                        this.a = a;
                        this.b = b;
                        this.c = c;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        const prime = 31;
                        let result = 1;
                        result = prime * result + ((this.a == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.a));
                        result = prime * result + ((this.b == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.b));
                        result = prime * result + ((this.c == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.c));
                        return result;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj) {
                            return true;
                        }
                        if (obj == null) {
                            return false;
                        }
                        if (this.constructor !== obj.constructor) {
                            return false;
                        }
                        const other = obj;
                        if (this.a == null) {
                            if (other.a != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.a, other.a)) {
                            return false;
                        }
                        if (this.b == null) {
                            if (other.b != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.b, other.b)) {
                            return false;
                        }
                        if (this.c == null) {
                            if (other.c != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.c, other.c)) {
                            return false;
                        }
                        return true;
                    }
                    /**
                     * The pseudoscalar is implied in the result.
                     * @param {com.vzome.core.algebra.Vector3d} v
                     * @return
                     * @return {*}
                     */
                    outer(v) {
                        const a = this.a['times$com_vzome_core_algebra_AlgebraicNumber'](v.c);
                        const b = this.b['times$com_vzome_core_algebra_AlgebraicNumber'](v.a);
                        const c = this.c['times$com_vzome_core_algebra_AlgebraicNumber'](v.b);
                        return a['plus$com_vzome_core_algebra_AlgebraicNumber'](b)['plus$com_vzome_core_algebra_AlgebraicNumber'](c);
                    }
                }
                algebra.Bivector3d = Bivector3d;
                Bivector3d["__class"] = "com.vzome.core.algebra.Bivector3d";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Trivector3dHomogeneous {
                    constructor(e123, e310, e320, e120, field) {
                        if (this.e123 === undefined) {
                            this.e123 = null;
                        }
                        if (this.e310 === undefined) {
                            this.e310 = null;
                        }
                        if (this.e320 === undefined) {
                            this.e320 = null;
                        }
                        if (this.e120 === undefined) {
                            this.e120 = null;
                        }
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        this.e123 = e123;
                        this.e310 = e310;
                        this.e320 = e320;
                        this.e120 = e120;
                        this.field = field;
                    }
                    dual() {
                        return new com.vzome.core.algebra.Vector3dHomogeneous(this.e320.negate(), this.e310, this.e120, this.e123.negate(), this.field);
                    }
                }
                algebra.Trivector3dHomogeneous = Trivector3dHomogeneous;
                Trivector3dHomogeneous["__class"] = "com.vzome.core.algebra.Trivector3dHomogeneous";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                let AlgebraicNumber;
                (function (AlgebraicNumber) {
                    class Views {
                        constructor() {
                        }
                    }
                    AlgebraicNumber.Views = Views;
                    Views["__class"] = "com.vzome.core.algebra.AlgebraicNumber.Views";
                })(AlgebraicNumber = algebra.AlgebraicNumber || (algebra.AlgebraicNumber = {}));
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Vector3d {
                    constructor(a, b, c) {
                        if (((a != null && (a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || a === null) && ((b != null && (b.constructor != null && b.constructor["__interfaces"] != null && b.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || b === null) && ((c != null && (c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || c === null)) {
                            let __args = arguments;
                            if (this.a === undefined) {
                                this.a = null;
                            }
                            if (this.b === undefined) {
                                this.b = null;
                            }
                            if (this.c === undefined) {
                                this.c = null;
                            }
                            this.a = a;
                            this.b = b;
                            this.c = c;
                        }
                        else if (((a != null && a instanceof com.vzome.core.algebra.AlgebraicVector) || a === null) && b === undefined && c === undefined) {
                            let __args = arguments;
                            let v = __args[0];
                            if (this.a === undefined) {
                                this.a = null;
                            }
                            if (this.b === undefined) {
                                this.b = null;
                            }
                            if (this.c === undefined) {
                                this.c = null;
                            }
                            this.a = v.getComponent(0);
                            this.b = v.getComponent(1);
                            this.c = v.getComponent(2);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    outer(that) {
                        const a = this.a['times$com_vzome_core_algebra_AlgebraicNumber'](that.b)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.b['times$com_vzome_core_algebra_AlgebraicNumber'](that.a));
                        const b = this.b['times$com_vzome_core_algebra_AlgebraicNumber'](that.c)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.c['times$com_vzome_core_algebra_AlgebraicNumber'](that.b));
                        const c = this.c['times$com_vzome_core_algebra_AlgebraicNumber'](that.a)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.a['times$com_vzome_core_algebra_AlgebraicNumber'](that.c));
                        return new com.vzome.core.algebra.Bivector3d(a, b, c);
                    }
                }
                algebra.Vector3d = Vector3d;
                Vector3d["__class"] = "com.vzome.core.algebra.Vector3d";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Quaternion {
                    constructor(field, vector) {
                        if (this.representation === undefined) {
                            this.representation = null;
                        }
                        if (this.transpose === undefined) {
                            this.transpose = null;
                        }
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        if (this.vector === undefined) {
                            this.vector = null;
                        }
                        this.field = field;
                        this.vector = vector;
                        let w_offset = 0;
                        let factor = field['createRational$long'](0);
                        if (vector.dimension() > 3) {
                            factor = vector.getComponent(0);
                            w_offset = 1;
                        }
                        this.representation = field.identityMatrix(4).timesScalar(factor);
                        factor = vector.getComponent(0 + w_offset);
                        this.representation.setElement(1, 0, factor);
                        this.representation.setElement(3, 2, factor);
                        factor = factor.negate();
                        this.representation.setElement(0, 1, factor);
                        this.representation.setElement(2, 3, factor);
                        factor = vector.getComponent(1 + w_offset);
                        this.representation.setElement(1, 3, factor);
                        this.representation.setElement(2, 0, factor);
                        factor = factor.negate();
                        this.representation.setElement(3, 1, factor);
                        this.representation.setElement(0, 2, factor);
                        factor = vector.getComponent(2 + w_offset);
                        this.representation.setElement(3, 0, factor);
                        this.representation.setElement(2, 1, factor);
                        factor = factor.negate();
                        this.representation.setElement(1, 2, factor);
                        this.representation.setElement(0, 3, factor);
                        if (w_offset === 1)
                            factor = vector.getComponent(0);
                        else
                            factor = field['createRational$long'](0);
                        this.transpose = field.identityMatrix(4).timesScalar(factor);
                        factor = vector.getComponent(0 + w_offset);
                        this.transpose.setElement(0, 1, factor);
                        this.transpose.setElement(2, 3, factor);
                        factor = factor.negate();
                        this.transpose.setElement(1, 0, factor);
                        this.transpose.setElement(3, 2, factor);
                        factor = vector.getComponent(1 + w_offset);
                        this.transpose.setElement(3, 1, factor);
                        this.transpose.setElement(0, 2, factor);
                        factor = factor.negate();
                        this.transpose.setElement(1, 3, factor);
                        this.transpose.setElement(2, 0, factor);
                        factor = vector.getComponent(2 + w_offset);
                        this.transpose.setElement(1, 2, factor);
                        this.transpose.setElement(0, 3, factor);
                        factor = factor.negate();
                        this.transpose.setElement(3, 0, factor);
                        this.transpose.setElement(2, 1, factor);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return "Quaternion: " + this.vector.toString();
                    }
                    getVector() {
                        return this.vector;
                    }
                    /*private*/ conjugate(q) {
                        const result = this.field.origin(4);
                        result.setComponent(3, q.getComponent(3).negate());
                        result.setComponent(1, q.getComponent(1).negate());
                        result.setComponent(2, q.getComponent(2).negate());
                        result.setComponent(0, q.getComponent(0));
                        return result;
                    }
                    reflect(v) {
                        let reflection = this.rightMultiply(this.conjugate(v));
                        reflection = this.leftMultiply(reflection);
                        return reflection.negate();
                    }
                    /**
                     * Compute the product this * q.
                     * @param {com.vzome.core.algebra.AlgebraicVector} q
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    rightMultiply(q) {
                        return this.representation.timesColumn(q);
                    }
                    /**
                     * Compute the product q*this.
                     * This is computed using the identities:
                     *
                     * conjugate( q*this ) == conjugate( this ) * conjugate( q )
                     *
                     * q * this == conjugate( conjugate( this ) * conjugate( q ) )
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} q
                     * @return
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    leftMultiply(q) {
                        let result = this.conjugate(q);
                        result = this.transpose.timesColumn(result);
                        return this.conjugate(result);
                    }
                }
                algebra.Quaternion = Quaternion;
                Quaternion["__class"] = "com.vzome.core.algebra.Quaternion";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var xml;
        (function (xml) {
            class DomUtils {
                static addAttribute(elem, name, value) {
                    elem.setAttribute(name, value);
                }
                static getFirstChildElement$org_w3c_dom_Element$java_lang_String(elem, name) {
                    const elems = elem.getElementsByTagName(name);
                    return elems.item(0);
                }
                static getFirstChildElement(elem, name) {
                    if (((elem != null && (elem.constructor != null && elem.constructor["__interfaces"] != null && elem.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || elem === null) && ((typeof name === 'string') || name === null)) {
                        return com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element$java_lang_String(elem, name);
                    }
                    else if (((elem != null && (elem.constructor != null && elem.constructor["__interfaces"] != null && elem.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || elem === null) && name === undefined) {
                        return com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element(elem);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static preserveSpace(contentElem) {
                    contentElem.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
                }
                static getFirstChildElement$org_w3c_dom_Element(parent) {
                    const children = parent.getChildNodes();
                    if (children.getLength() === 0)
                        return null;
                    for (let k = 0; k < children.getLength(); k++) {
                        {
                            const kid = children.item(k);
                            if (kid != null && (kid.constructor != null && kid.constructor["__interfaces"] != null && kid.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) {
                                return kid;
                            }
                        }
                        ;
                    }
                    return null;
                }
                static getChild(parent, i) {
                    const children = parent.getChildNodes();
                    if (children.getLength() === 0)
                        return null;
                    let count = 0;
                    for (let k = 0; k < children.getLength(); k++) {
                        {
                            const kid = children.item(k);
                            if (kid != null && (kid.constructor != null && kid.constructor["__interfaces"] != null && kid.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) {
                                if (count === i)
                                    return kid;
                                else
                                    ++count;
                            }
                        }
                        ;
                    }
                    return null;
                }
                /**
                 * This is required for JSweet, which ignores the radix in Integer.toString( i, 2 )
                 * @param {number} i
                 * @return
                 * @return {string}
                 */
                static byteToBinary(i) {
                    let result = "";
                    result += ((i / 8 | 0) === 1) ? "1" : "0";
                    i = i % 8;
                    result += ((i / 4 | 0) === 1) ? "1" : "0";
                    i = i % 4;
                    result += ((i / 2 | 0) === 1) ? "1" : "0";
                    i = i % 2;
                    result += (i === 1) ? "1" : "0";
                    return result;
                }
            }
            xml.DomUtils = DomUtils;
            DomUtils["__class"] = "com.vzome.xml.DomUtils";
        })(xml = vzome.xml || (vzome.xml = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var xml;
        (function (xml) {
            class LocationData {
                constructor(systemId, startLine, startColumn, endLine, endColumn) {
                    if (this.systemId === undefined) {
                        this.systemId = null;
                    }
                    if (this.startLine === undefined) {
                        this.startLine = 0;
                    }
                    if (this.startColumn === undefined) {
                        this.startColumn = 0;
                    }
                    if (this.endLine === undefined) {
                        this.endLine = 0;
                    }
                    if (this.endColumn === undefined) {
                        this.endColumn = 0;
                    }
                    this.systemId = systemId;
                    this.startLine = startLine;
                    this.startColumn = startColumn;
                    this.endLine = endLine;
                    this.endColumn = endColumn;
                }
                getSystemId() {
                    return this.systemId;
                }
                getStartLine() {
                    return this.startLine;
                }
                getStartColumn() {
                    return this.startColumn;
                }
                getEndLine() {
                    return this.endLine;
                }
                getEndColumn() {
                    return this.endColumn;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return this.getSystemId() + "[line " + this.startLine + ":" + this.startColumn + " to line " + this.endLine + ":" + this.endColumn + "]";
                }
            }
            LocationData.LOCATION_DATA_KEY = "locationDataKey";
            xml.LocationData = LocationData;
            LocationData["__class"] = "com.vzome.xml.LocationData";
        })(xml = vzome.xml || (vzome.xml = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var xml;
        (function (xml) {
            class ResourceLoader {
                static RESOURCE_LOADER_$LI$() { if (ResourceLoader.RESOURCE_LOADER == null) {
                    ResourceLoader.RESOURCE_LOADER = new ResourceLoader();
                } return ResourceLoader.RESOURCE_LOADER; }
                static logger_$LI$() { if (ResourceLoader.logger == null) {
                    ResourceLoader.logger = java.util.logging.Logger.getLogger("com.vzome.xml.ResourceLoader");
                } return ResourceLoader.logger; }
                static setResourceLoader(loader) {
                    ResourceLoader.RESOURCE_LOADER = loader;
                }
                static loadStringResource(path) {
                    return ResourceLoader.RESOURCE_LOADER_$LI$().loadTextResource(path);
                }
                loadTextResource(path) {
                    try {
                        const input = ResourceLoader.getClassLoader().getResourceAsStream(path);
                        if (input == null)
                            return null;
                        const out = new java.io.ByteArrayOutputStream();
                        const buf = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(1024);
                        let num;
                        while (((num = input.read(buf, 0, 1024)) > 0)) {
                            out.write(buf, 0, num);
                        }
                        ;
                        input.close();
                        return new String(out.toByteArray());
                    }
                    catch (e) {
                        if (ResourceLoader.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                            ResourceLoader.logger_$LI$().fine("problem loading resource: " + path);
                        return null;
                    }
                }
            }
            xml.ResourceLoader = ResourceLoader;
            ResourceLoader["__class"] = "com.vzome.xml.ResourceLoader";
        })(xml = vzome.xml || (vzome.xml = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var api;
        (function (api) {
            let Tool;
            (function (Tool) {
                let Kind;
                (function (Kind) {
                    Kind[Kind["SYMMETRY"] = 0] = "SYMMETRY";
                    Kind[Kind["TRANSFORM"] = 1] = "TRANSFORM";
                    Kind[Kind["LINEAR_MAP"] = 2] = "LINEAR_MAP";
                })(Kind = Tool.Kind || (Tool.Kind = {}));
            })(Tool = api.Tool || (api.Tool = {}));
        })(api = vzome.api || (vzome.api = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class SymmetrySnapper {
                    constructor(orbitSet) {
                        if (this.orbitSet === undefined) {
                            this.orbitSet = null;
                        }
                        if (this.embedding === undefined) {
                            this.embedding = null;
                        }
                        this.orbitSet = orbitSet;
                        this.embedding = orbitSet.getSymmetry();
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.RealVector} zIn
                     * @return {com.vzome.core.math.RealVector}
                     */
                    snapZ(zIn) {
                        const lookZone = this.orbitSet.getAxis(zIn);
                        if (lookZone == null)
                            return zIn;
                        return this.embedding.embedInR3(lookZone.normal());
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.RealVector} zOut
                     * @param {com.vzome.core.math.RealVector} yIn
                     * @return {com.vzome.core.math.RealVector}
                     */
                    snapY(zOut, yIn) {
                        const upZone = this.orbitSet.getAxis(yIn);
                        if (upZone == null)
                            return yIn;
                        yIn = this.embedding.embedInR3(upZone.normal());
                        const left = zOut.cross(yIn);
                        return left.cross(zOut);
                    }
                }
                controller.SymmetrySnapper = SymmetrySnapper;
                SymmetrySnapper["__class"] = "com.vzome.desktop.controller.SymmetrySnapper";
                SymmetrySnapper["__interfaces"] = ["com.vzome.desktop.controller.OrbitSnapper"];
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller_1) {
                class DefaultController {
                    constructor() {
                        this.pcs = new java.beans.PropertyChangeSupport(this);
                        if (this.mErrors === undefined) {
                            this.mErrors = null;
                        }
                        if (this.mNextController === undefined) {
                            this.mNextController = null;
                        }
                        this.subcontrollers = (new java.util.HashMap());
                        this.name = "";
                    }
                    static logger_$LI$() { if (DefaultController.logger == null) {
                        DefaultController.logger = java.util.logging.Logger.getLogger("org.vorthmann.zome.controller");
                    } return DefaultController.logger; }
                    properggties() {
                        return this.pcs;
                    }
                    /**
                     *
                     * @param {*} source
                     * @param {string} action
                     */
                    actionPerformed(source, action) {
                        try {
                            if (DefaultController.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                DefaultController.logger_$LI$().fine("ACTION: " + this.getPath() + "||" + action);
                            this.doAction(action);
                        }
                        catch (ex) {
                            console.error(ex.message, ex);
                            this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ERROR_CODE, [ex]);
                        }
                    }
                    /**
                     * This is only overridden or called in Javascript code, in vZome Online.
                     * @param {*} source
                     * @param {string} action
                     * @param {java.util.Properties} params
                     */
                    paramActionPerformed(source, action, params) {
                        try {
                            if (DefaultController.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                DefaultController.logger_$LI$().fine("PARAM ACTION: " + this.getPath() + "||" + action);
                            this.doParamAction(action, params);
                        }
                        catch (ex) {
                            console.error(ex.message, ex);
                            this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ERROR_CODE, [ex]);
                        }
                    }
                    /*private*/ getPath() {
                        if (this.mNextController == null)
                            return this.name;
                        else
                            return this.mNextController.getPath() + "::" + this.name;
                    }
                    /**
                     *
                     * @param {*} listener
                     */
                    addPropertyListener(listener) {
                        this.pcs.addPropertyChangeListener$java_beans_PropertyChangeListener(listener);
                    }
                    /**
                     *
                     * @param {*} listener
                     */
                    removePropertyListener(listener) {
                        this.pcs.removePropertyChangeListener$java_beans_PropertyChangeListener(listener);
                    }
                    doAction(action) {
                        if (this.mNextController != null)
                            this.mNextController.doAction(action);
                        else
                            this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ACTION, [action]);
                    }
                    /**
                     * This is only overridden or called in Javascript code, in vZome Online.
                     * @param source
                     * @param {string} action
                     * @param {java.util.Properties} params
                     */
                    doParamAction(action, params) {
                        if (this.mNextController != null)
                            this.mNextController.doParamAction(action, params);
                        else
                            this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ACTION, [action]);
                    }
                    /**
                     *
                     * @param {string} command
                     * @param {java.io.File} file
                     */
                    doFileAction(command, file) {
                        if (this.mNextController != null)
                            this.mNextController.doFileAction(command, file);
                        else
                            this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ACTION, [command]);
                    }
                    /**
                     *
                     * @param {string} command
                     * @param {string} script
                     */
                    doScriptAction(command, script) {
                        if (this.mNextController != null)
                            this.mNextController.doScriptAction(command, script);
                        else
                            this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ACTION, [command]);
                    }
                    /**
                     *
                     * @param {string} listName
                     * @return {java.lang.String[]}
                     */
                    getCommandList(listName) {
                        if (this.mNextController != null)
                            return this.mNextController.getCommandList(listName);
                        else
                            return [];
                    }
                    /**
                     *
                     * @param {string} string
                     * @return {boolean[]}
                     */
                    getCommandListDefaultStates(string) {
                        return null;
                    }
                    /**
                     *
                     * @param {string} string
                     * @return {string}
                     */
                    getProperty(string) {
                        if (this.mNextController != null)
                            return this.mNextController.getProperty(string);
                        return null;
                    }
                    /**
                     *
                     * @param {string} propName
                     * @return {boolean}
                     */
                    propertyIsTrue(propName) {
                        return "true" === this.getProperty(propName);
                    }
                    /**
                     *
                     * @param {string} name
                     * @param {*} sub
                     */
                    addSubController(name, sub) {
                        sub.name = name;
                        this.subcontrollers.put(name, sub);
                        sub.setNextController(this, name);
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {*}
                     */
                    getSubController(name) {
                        const subc = this.subcontrollers.get(name);
                        if (subc != null)
                            return subc;
                        if (this.mNextController != null)
                            return this.mNextController.getSubController(name);
                        return null;
                    }
                    /**
                     *
                     * @param {*} errors
                     */
                    setErrorChannel(errors) {
                        this.mErrors = errors;
                    }
                    /**
                     *
                     * @param {string} name
                     * @param {*} value
                     */
                    setProperty(name, value) {
                        if (DefaultController.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                            DefaultController.logger_$LI$().fine("SETPROP: " + this.getPath() + "||" + name + "=" + value);
                        this.setModelProperty(name, value);
                    }
                    setModelProperty(name, value) {
                        if (this.mNextController != null)
                            this.mNextController.setProperty(name, value);
                    }
                    /*private*/ setNextController(controller, name) {
                        this.name = name;
                        this.mNextController = controller;
                        this.mNextController.addPropertyListener(new DefaultController.DefaultController$0(this));
                        if (this.mNextController != null && this.mNextController instanceof com.vzome.desktop.controller.DefaultController)
                            this.mErrors = this.mNextController.mErrors;
                    }
                    firePropertyChange$java_beans_PropertyChangeEvent(event) {
                        if (DefaultController.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                            DefaultController.logger_$LI$().fine("CHGEVENT: " + this.getPath() + "||" + event.getPropertyName() + "=" + event.getNewValue());
                        this.pcs.firePropertyChange$java_beans_PropertyChangeEvent(event);
                    }
                    firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propName, oldValue, newValue) {
                        if (DefaultController.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                            DefaultController.logger_$LI$().fine("CHGEVENT: " + this.getPath() + "||" + propName + "=" + newValue);
                        this.pcs.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propName, oldValue, newValue);
                    }
                    firePropertyChange(propName, oldValue, newValue) {
                        if (((typeof propName === 'string') || propName === null) && ((oldValue != null) || oldValue === null) && ((newValue != null) || newValue === null)) {
                            return this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propName, oldValue, newValue);
                        }
                        else if (((propName != null && propName instanceof java.beans.PropertyChangeEvent) || propName === null) && oldValue === undefined && newValue === undefined) {
                            return this.firePropertyChange$java_beans_PropertyChangeEvent(propName);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {string} propName
                     * @return {boolean}
                     */
                    userHasEntitlement(propName) {
                        if (this.mNextController != null)
                            return this.mNextController.userHasEntitlement(propName);
                        return false;
                    }
                    openApplication(file) {
                        if (this.mNextController != null)
                            this.mNextController.openApplication(file);
                    }
                    runScript(script, file) {
                        if (this.mNextController != null)
                            this.mNextController.runScript(script, file);
                    }
                }
                controller_1.DefaultController = DefaultController;
                DefaultController["__class"] = "com.vzome.desktop.controller.DefaultController";
                DefaultController["__interfaces"] = ["com.vzome.desktop.api.Controller"];
                (function (DefaultController) {
                    class DefaultController$0 {
                        constructor(__parent) {
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @param {java.beans.PropertyChangeEvent} event
                         */
                        propertyChange(event) {
                            this.__parent.pcs.firePropertyChange$java_beans_PropertyChangeEvent(event);
                        }
                    }
                    DefaultController.DefaultController$0 = DefaultController$0;
                    DefaultController$0["__interfaces"] = ["java.util.EventListener", "java.beans.PropertyChangeListener"];
                })(DefaultController = controller_1.DefaultController || (controller_1.DefaultController = {}));
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                /**
                 * Transducer: turns trackball roll events into zone (Axis) change events.
                 *
                 * @author Scott Vorthmann
                 * @class
                 */
                class ZoneVectorBall {
                    constructor() {
                        if (this.orbits === undefined) {
                            this.orbits = null;
                        }
                        if (this.zoneVector3d === undefined) {
                            this.zoneVector3d = null;
                        }
                        this.zone = null;
                    }
                    static logger_$LI$() { if (ZoneVectorBall.logger == null) {
                        ZoneVectorBall.logger = java.util.logging.Logger.getLogger("com.vzome.desktop.controller.ZoneVectorBall");
                    } return ZoneVectorBall.logger; }
                    initializeZone(orbits, worldEye) {
                        this.orbits = orbits;
                        this.zoneVector3d = new com.vzome.core.math.RealVector(worldEye.x, worldEye.y, worldEye.z);
                        this.mapVectorToAxis(false);
                        return this.zone;
                    }
                    trackballRolled(rotation) {
                        const x = rotation[0].dot(this.zoneVector3d);
                        const y = rotation[1].dot(this.zoneVector3d);
                        const z = rotation[2].dot(this.zoneVector3d);
                        this.zoneVector3d = new com.vzome.core.math.RealVector(x, y, z);
                        this.mapVectorToAxis(true);
                    }
                    /**
                     * This is used when we're doing some non-trackball drag
                     * to define a new vector, as for the working plane.
                     * @param {com.vzome.core.math.RealVector} vector
                     */
                    setVector(vector) {
                        this.zoneVector3d = vector;
                        this.mapVectorToAxis(true);
                    }
                    /*private*/ mapVectorToAxis(notify) {
                        const vector = new com.vzome.core.math.RealVector(this.zoneVector3d.x, this.zoneVector3d.y, this.zoneVector3d.z);
                        const oldAxis = this.zone;
                        this.zone = this.orbits.getAxis(vector);
                        if (this.zone == null && oldAxis == null) {
                            if (ZoneVectorBall.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                                ZoneVectorBall.logger_$LI$().finer("mapVectorToAxis null zone for " + vector);
                            return;
                        }
                        if (this.zone != null && this.zone.equals(oldAxis)) {
                            if (ZoneVectorBall.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                                ZoneVectorBall.logger_$LI$().finer("mapVectorToAxis  zone " + this.zone + " unchanged for " + vector);
                            return;
                        }
                        if (ZoneVectorBall.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                            ZoneVectorBall.logger_$LI$().finer("preview finished at  " + this.zone + " for " + vector);
                        if (notify)
                            this.zoneChanged(oldAxis, this.zone);
                    }
                }
                controller.ZoneVectorBall = ZoneVectorBall;
                ZoneVectorBall["__class"] = "com.vzome.desktop.controller.ZoneVectorBall";
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var api;
            (function (api) {
                let Controller;
                (function (Controller) {
                    Controller.USER_ERROR_CODE = "user.command.error";
                    Controller.UNKNOWN_ERROR_CODE = "unknown.exception";
                    Controller.UNKNOWN_ACTION = "unknown.action";
                    Controller.UNKNOWN_PROPERTY = "unknown.property";
                })(Controller = api.Controller || (api.Controller = {}));
            })(api = desktop.api || (desktop.api = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters2d;
            (function (exporters2d) {
                /**
                 * Exports a Java2dSnapshot to a character Writer.
                 * Subclassed by SVGExporter and PDFExporter.
                 *
                 * @author Scott Vorthmann
                 * @class
                 */
                class SnapshotExporter {
                    constructor() {
                        if (this.output === undefined) {
                            this.output = null;
                        }
                        if (this.height === undefined) {
                            this.height = 0;
                        }
                        if (this.width === undefined) {
                            this.width = 0;
                        }
                        this.RGB_FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
                        this.XY_FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
                    }
                    includeFile(rsrcName) {
                        const boilerplate = com.vzome.xml.ResourceLoader.loadStringResource(rsrcName);
                        this.output.write$java_lang_String(boilerplate);
                    }
                    export(snapshot, writer, doOutlines, monochrome, showBackground) {
                        this.XY_FORMAT.setGroupingUsed(false);
                        this.XY_FORMAT.setMaximumFractionDigits(2);
                        this.RGB_FORMAT.setMaximumFractionDigits(3);
                        this.output = new SnapshotExporter.CountingPrintWriter(writer);
                        const rect = snapshot.getRect();
                        this.height = Math.fround(rect.getHeight());
                        this.width = Math.fround(rect.getWidth());
                        const lines = snapshot.getLines();
                        let strokeWidth = snapshot.getStrokeWidth();
                        if (!snapshot.isLineDrawing() && !doOutlines)
                            strokeWidth = -1.0;
                        this.outputPrologue(snapshot.getRect(), strokeWidth);
                        const bgColor = snapshot.getBackgroundColor();
                        if (bgColor != null && showBackground)
                            this.outputBackground(bgColor);
                        if (!lines.isEmpty())
                            for (let index = lines.iterator(); index.hasNext();) {
                                let line = index.next();
                                {
                                    this.outputLine(line, monochrome);
                                }
                            }
                        else
                            for (let index = snapshot.getPolygons().iterator(); index.hasNext();) {
                                let polygon = index.next();
                                {
                                    this.outputPolygon(polygon, strokeWidth > 0);
                                }
                            }
                        this.outputPostlogue();
                        this.output.flush();
                        this.output.close();
                    }
                    outputLine(line, monochrome) {
                        this.renderPath(line.getPath());
                        const rgb = line.getColor().getRGBColorComponents(null);
                        if (!monochrome)
                            this.setRGBStrokeColor(rgb[0], rgb[1], rgb[2]);
                        this.strokePath();
                    }
                    outputPolygon(polygon, doOutline) {
                        this.renderPath(polygon.getPath());
                        const rgb = polygon.getColor().getRGBColorComponents(null);
                        this.setRGBFillColor(rgb[0], rgb[1], rgb[2]);
                        this.fillPath();
                        if (doOutline) {
                            this.renderPath(polygon.getPath());
                            this.setBlackStrokeColor();
                            this.strokePath();
                        }
                    }
                    renderPath(path) {
                        this.beginPath();
                        const segments = path.getPathIterator(null);
                        while ((!segments.isDone())) {
                            {
                                const coords = [0, 0, 0, 0, 0, 0];
                                const step = segments.currentSegment(coords);
                                switch ((step)) {
                                    case java.awt.geom.PathIterator.SEG_MOVETO:
                                        this.moveToPoint(coords[0], Math.fround(this.height - coords[1]));
                                        break;
                                    case java.awt.geom.PathIterator.SEG_LINETO:
                                        this.addLineToPoint(coords[0], Math.fround(this.height - coords[1]));
                                        break;
                                    case java.awt.geom.PathIterator.SEG_CLOSE:
                                        this.closePath();
                                        break;
                                    default:
                                        break;
                                }
                                segments.next();
                            }
                        }
                        ;
                    }
                    setBlackStrokeColor() {
                    }
                }
                exporters2d.SnapshotExporter = SnapshotExporter;
                SnapshotExporter["__class"] = "com.vzome.core.exporters2d.SnapshotExporter";
                (function (SnapshotExporter) {
                    class CountingPrintWriter extends java.io.PrintWriter {
                        constructor(writer) {
                            super(writer);
                            this.mTotal = 0;
                        }
                        write$char_A$int$int(buf, offset, len) {
                            super.write$char_A$int$int(buf, offset, len);
                            this.mTotal += len;
                        }
                        /**
                         *
                         * @param {char[]} buf
                         * @param {number} offset
                         * @param {number} len
                         */
                        write(buf, offset, len) {
                            if (((buf != null && buf instanceof Array && (buf.length == 0 || buf[0] == null || (typeof buf[0] === 'string'))) || buf === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                                return this.write$char_A$int$int(buf, offset, len);
                            }
                            else if (((typeof buf === 'string') || buf === null) && offset === undefined && len === undefined) {
                                return this.write$java_lang_String(buf);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        write$java_lang_String(str) {
                            super.write$java_lang_String(str);
                            this.mTotal += str.length;
                        }
                        getBytesTotal() {
                            return this.mTotal;
                        }
                    }
                    SnapshotExporter.CountingPrintWriter = CountingPrintWriter;
                    CountingPrintWriter["__class"] = "com.vzome.core.exporters2d.SnapshotExporter.CountingPrintWriter";
                    CountingPrintWriter["__interfaces"] = ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
                })(SnapshotExporter = exporters2d.SnapshotExporter || (exporters2d.SnapshotExporter = {}));
            })(exporters2d = core.exporters2d || (core.exporters2d = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (java) {
    var beans;
    (function (beans) {
        /**
         * Constructs a new <code>IndexedPropertyChangeEvent</code> object.
         *
         * @param {*} source  The bean that fired the event.
         * @param {string} propertyName  The programmatic name of the property that
         * was changed.
         * @param {*} oldValue      The old value of the property.
         * @param {*} newValue      The new value of the property.
         * @param {number} index index of the property element that was changed.
         * @class
         * @extends java.beans.PropertyChangeEvent
         * @author Mark Davidson
         */
        class IndexedPropertyChangeEvent extends java.beans.PropertyChangeEvent {
            constructor(source, propertyName, oldValue, newValue, index) {
                super(source, propertyName, oldValue, newValue);
                if (this.index === undefined) {
                    this.index = 0;
                }
                this.index = index;
            }
            /**
             * Gets the index of the property that was changed.
             *
             * @return {number} The index specifying the property element that was
             * changed.
             */
            getIndex() {
                return this.index;
            }
            appendTo(sb) {
                sb.append("; index=").append(this.getIndex());
            }
        }
        IndexedPropertyChangeEvent.serialVersionUID = -320227448495806870;
        beans.IndexedPropertyChangeEvent = IndexedPropertyChangeEvent;
        IndexedPropertyChangeEvent["__class"] = "java.beans.IndexedPropertyChangeEvent";
        IndexedPropertyChangeEvent["__interfaces"] = ["java.io.Serializable"];
    })(beans = java.beans || (java.beans = {}));
})(java);
(function (java) {
    var beans;
    (function (beans) {
        class PropertyChangeSupport {
            constructor(sourceBean) {
                this.map = new PropertyChangeSupport.PropertyChangeListenerMap();
                if (this.source === undefined) {
                    this.source = null;
                }
                if (sourceBean == null) {
                    throw new java.lang.NullPointerException();
                }
                this.source = sourceBean;
            }
            addPropertyChangeListener$java_beans_PropertyChangeListener(listener) {
                if (listener == null) {
                    return;
                }
                if (listener != null && listener instanceof java.beans.PropertyChangeListenerProxy) {
                    const proxy = listener;
                    this.addPropertyChangeListener$java_lang_String$java_beans_PropertyChangeListener(proxy.getPropertyName(), proxy.getListener());
                }
                else {
                    this.map.add(null, listener);
                }
            }
            removePropertyChangeListener$java_beans_PropertyChangeListener(listener) {
                if (listener == null) {
                    return;
                }
                if (listener != null && listener instanceof java.beans.PropertyChangeListenerProxy) {
                    const proxy = listener;
                    this.removePropertyChangeListener$java_lang_String$java_beans_PropertyChangeListener(proxy.getPropertyName(), proxy.getListener());
                }
                else {
                    this.map.remove(null, listener);
                }
            }
            getPropertyChangeListeners$() {
                return this.map.getListeners$();
            }
            addPropertyChangeListener$java_lang_String$java_beans_PropertyChangeListener(propertyName, listener) {
                if (listener == null || propertyName == null) {
                    return;
                }
                listener = this.map.extract$java_beans_PropertyChangeListener(listener);
                if (listener != null) {
                    this.map.add(propertyName, listener);
                }
            }
            addPropertyChangeListener(propertyName, listener) {
                if (((typeof propertyName === 'string') || propertyName === null) && ((listener != null && (listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                    return this.addPropertyChangeListener$java_lang_String$java_beans_PropertyChangeListener(propertyName, listener);
                }
                else if (((propertyName != null && (propertyName.constructor != null && propertyName.constructor["__interfaces"] != null && propertyName.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || propertyName === null) && listener === undefined) {
                    return this.addPropertyChangeListener$java_beans_PropertyChangeListener(propertyName);
                }
                else
                    throw new Error('invalid overload');
            }
            removePropertyChangeListener$java_lang_String$java_beans_PropertyChangeListener(propertyName, listener) {
                if (listener == null || propertyName == null) {
                    return;
                }
                listener = this.map.extract$java_beans_PropertyChangeListener(listener);
                if (listener != null) {
                    this.map.remove(propertyName, listener);
                }
            }
            removePropertyChangeListener(propertyName, listener) {
                if (((typeof propertyName === 'string') || propertyName === null) && ((listener != null && (listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                    return this.removePropertyChangeListener$java_lang_String$java_beans_PropertyChangeListener(propertyName, listener);
                }
                else if (((propertyName != null && (propertyName.constructor != null && propertyName.constructor["__interfaces"] != null && propertyName.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || propertyName === null) && listener === undefined) {
                    return this.removePropertyChangeListener$java_beans_PropertyChangeListener(propertyName);
                }
                else
                    throw new Error('invalid overload');
            }
            getPropertyChangeListeners$java_lang_String(propertyName) {
                return this.map.getListeners$java_lang_String(propertyName);
            }
            getPropertyChangeListeners(propertyName) {
                if (((typeof propertyName === 'string') || propertyName === null)) {
                    return this.getPropertyChangeListeners$java_lang_String(propertyName);
                }
                else if (propertyName === undefined) {
                    return this.getPropertyChangeListeners$();
                }
                else
                    throw new Error('invalid overload');
            }
            firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName, oldValue, newValue) {
                if (oldValue == null || newValue == null || !((o1, o2) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(oldValue, newValue)) {
                    this.firePropertyChange$java_beans_PropertyChangeEvent(new java.beans.PropertyChangeEvent(this.source, propertyName, oldValue, newValue));
                }
            }
            firePropertyChange$java_lang_String$int$int(propertyName, oldValue, newValue) {
                if (oldValue !== newValue) {
                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName, javaemul.internal.IntegerHelper.valueOf(oldValue), javaemul.internal.IntegerHelper.valueOf(newValue));
                }
            }
            firePropertyChange(propertyName, oldValue, newValue) {
                if (((typeof propertyName === 'string') || propertyName === null) && ((typeof oldValue === 'number') || oldValue === null) && ((typeof newValue === 'number') || newValue === null)) {
                    return this.firePropertyChange$java_lang_String$int$int(propertyName, oldValue, newValue);
                }
                else if (((typeof propertyName === 'string') || propertyName === null) && ((typeof oldValue === 'boolean') || oldValue === null) && ((typeof newValue === 'boolean') || newValue === null)) {
                    return this.firePropertyChange$java_lang_String$boolean$boolean(propertyName, oldValue, newValue);
                }
                else if (((typeof propertyName === 'string') || propertyName === null) && ((oldValue != null) || oldValue === null) && ((newValue != null) || newValue === null)) {
                    return this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName, oldValue, newValue);
                }
                else if (((propertyName != null && propertyName instanceof java.beans.PropertyChangeEvent) || propertyName === null) && oldValue === undefined && newValue === undefined) {
                    return this.firePropertyChange$java_beans_PropertyChangeEvent(propertyName);
                }
                else
                    throw new Error('invalid overload');
            }
            firePropertyChange$java_lang_String$boolean$boolean(propertyName, oldValue, newValue) {
                if (oldValue !== newValue) {
                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName, javaemul.internal.BooleanHelper.valueOf(oldValue), javaemul.internal.BooleanHelper.valueOf(newValue));
                }
            }
            firePropertyChange$java_beans_PropertyChangeEvent(event) {
                const oldValue = event.getOldValue();
                const newValue = event.getNewValue();
                if (oldValue == null || newValue == null || !((o1, o2) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(oldValue, newValue)) {
                    const name = event.getPropertyName();
                    const common = this.map.get(null);
                    const named = (name != null) ? this.map.get(name) : null;
                    PropertyChangeSupport.fire(common, event);
                    PropertyChangeSupport.fire(named, event);
                }
            }
            static fire(listeners, event) {
                if (listeners != null) {
                    for (let index = 0; index < listeners.length; index++) {
                        let listener = listeners[index];
                        {
                            listener.propertyChange(event);
                        }
                    }
                }
            }
            fireIndexedPropertyChange$java_lang_String$int$java_lang_Object$java_lang_Object(propertyName, index, oldValue, newValue) {
                if (oldValue == null || newValue == null || !((o1, o2) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(oldValue, newValue)) {
                    this.firePropertyChange$java_beans_PropertyChangeEvent(new java.beans.IndexedPropertyChangeEvent(this.source, propertyName, oldValue, newValue, index));
                }
            }
            fireIndexedPropertyChange$java_lang_String$int$int$int(propertyName, index, oldValue, newValue) {
                if (oldValue !== newValue) {
                    this.fireIndexedPropertyChange$java_lang_String$int$java_lang_Object$java_lang_Object(propertyName, index, javaemul.internal.IntegerHelper.valueOf(oldValue), javaemul.internal.IntegerHelper.valueOf(newValue));
                }
            }
            fireIndexedPropertyChange(propertyName, index, oldValue, newValue) {
                if (((typeof propertyName === 'string') || propertyName === null) && ((typeof index === 'number') || index === null) && ((typeof oldValue === 'number') || oldValue === null) && ((typeof newValue === 'number') || newValue === null)) {
                    return this.fireIndexedPropertyChange$java_lang_String$int$int$int(propertyName, index, oldValue, newValue);
                }
                else if (((typeof propertyName === 'string') || propertyName === null) && ((typeof index === 'number') || index === null) && ((typeof oldValue === 'boolean') || oldValue === null) && ((typeof newValue === 'boolean') || newValue === null)) {
                    return this.fireIndexedPropertyChange$java_lang_String$int$boolean$boolean(propertyName, index, oldValue, newValue);
                }
                else if (((typeof propertyName === 'string') || propertyName === null) && ((typeof index === 'number') || index === null) && ((oldValue != null) || oldValue === null) && ((newValue != null) || newValue === null)) {
                    return this.fireIndexedPropertyChange$java_lang_String$int$java_lang_Object$java_lang_Object(propertyName, index, oldValue, newValue);
                }
                else
                    throw new Error('invalid overload');
            }
            fireIndexedPropertyChange$java_lang_String$int$boolean$boolean(propertyName, index, oldValue, newValue) {
                if (oldValue !== newValue) {
                    this.fireIndexedPropertyChange$java_lang_String$int$java_lang_Object$java_lang_Object(propertyName, index, javaemul.internal.BooleanHelper.valueOf(oldValue), javaemul.internal.BooleanHelper.valueOf(newValue));
                }
            }
            hasListeners(propertyName) {
                return this.map.hasListeners(propertyName);
            }
        }
        PropertyChangeSupport.serialVersionUID = 6401253773779951803;
        beans.PropertyChangeSupport = PropertyChangeSupport;
        PropertyChangeSupport["__class"] = "java.beans.PropertyChangeSupport";
        (function (PropertyChangeSupport) {
            class PropertyChangeListenerMap extends java.beans.ChangeListenerMap {
                constructor() {
                    super();
                }
                static EMPTY_$LI$() { if (PropertyChangeListenerMap.EMPTY == null) {
                    PropertyChangeListenerMap.EMPTY = [];
                } return PropertyChangeListenerMap.EMPTY; }
                /**
                 *
                 * @param {number} length
                 * @return {java.beans.PropertyChangeListener[]}
                 */
                newArray(length) {
                    return (0 < length) ? (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(length) : PropertyChangeListenerMap.EMPTY_$LI$();
                }
                newProxy$java_lang_String$java_beans_PropertyChangeListener(name, listener) {
                    return new java.beans.PropertyChangeListenerProxy(name, listener);
                }
                /**
                 *
                 * @param {string} name
                 * @param {*} listener
                 * @return {*}
                 */
                newProxy(name, listener) {
                    if (((typeof name === 'string') || name === null) && ((listener != null && (listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                        return this.newProxy$java_lang_String$java_beans_PropertyChangeListener(name, listener);
                    }
                    else if (((typeof name === 'string') || name === null) && ((listener != null) || listener === null)) {
                        throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)');
                    }
                    else
                        throw new Error('invalid overload');
                }
                extract$java_beans_PropertyChangeListener(listener) {
                    while ((listener != null && listener instanceof java.beans.PropertyChangeListenerProxy)) {
                        {
                            listener = listener.getListener();
                        }
                    }
                    ;
                    return listener;
                }
                extract(listener) {
                    if (((listener != null && (listener.constructor != null && listener.constructor["__interfaces"] != null && listener.constructor["__interfaces"].indexOf("java.beans.PropertyChangeListener") >= 0)) || listener === null)) {
                        return this.extract$java_beans_PropertyChangeListener(listener);
                    }
                    else if (((listener != null) || listener === null)) {
                        throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)');
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            PropertyChangeSupport.PropertyChangeListenerMap = PropertyChangeListenerMap;
            PropertyChangeListenerMap["__class"] = "java.beans.PropertyChangeSupport.PropertyChangeListenerMap";
        })(PropertyChangeSupport = beans.PropertyChangeSupport || (beans.PropertyChangeSupport = {}));
    })(beans = java.beans || (java.beans = {}));
})(java);
(function (java) {
    var text;
    (function (text) {
        class DecimalFormat extends java.text.NumberFormat {
            applyPattern(pattern) {
            }
        }
        text.DecimalFormat = DecimalFormat;
        DecimalFormat["__class"] = "java.text.DecimalFormat";
    })(text = java.text || (java.text = {}));
})(java);
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                /**
                 * Construct a new vector from its coordinate values.
                 * @param {number} x
                 * @param {number} y
                 * @param {number} z
                 * @class
                 */
                class RealVector {
                    constructor(x, y, z) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                            let __args = arguments;
                            if (this.x === undefined) {
                                this.x = 0;
                            }
                            if (this.y === undefined) {
                                this.y = 0;
                            }
                            if (this.z === undefined) {
                                this.z = 0;
                            }
                            this.x = Math.fround(x);
                            this.y = Math.fround(y);
                            this.z = Math.fround(z);
                        }
                        else if (((x != null && x instanceof com.vzome.core.math.RealVector) || x === null) && y === undefined && z === undefined) {
                            let __args = arguments;
                            let that = __args[0];
                            {
                                let __args = arguments;
                                let x = that.x;
                                let y = that.y;
                                let z = that.z;
                                if (this.x === undefined) {
                                    this.x = 0;
                                }
                                if (this.y === undefined) {
                                    this.y = 0;
                                }
                                if (this.z === undefined) {
                                    this.z = 0;
                                }
                                this.x = Math.fround(x);
                                this.y = Math.fround(y);
                                this.z = Math.fround(z);
                            }
                        }
                        else if (x === undefined && y === undefined && z === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let x = 0.0;
                                let y = 0.0;
                                let z = 0.0;
                                if (this.x === undefined) {
                                    this.x = 0;
                                }
                                if (this.y === undefined) {
                                    this.y = 0;
                                }
                                if (this.z === undefined) {
                                    this.z = 0;
                                }
                                this.x = Math.fround(x);
                                this.y = Math.fround(y);
                                this.z = Math.fround(z);
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static __static_initialize() { if (!RealVector.__static_initialized) {
                        RealVector.__static_initialized = true;
                        RealVector.__static_initializer_0();
                    } }
                    static ORIGIN_$LI$() { RealVector.__static_initialize(); if (RealVector.ORIGIN == null) {
                        RealVector.ORIGIN = new RealVector(0.0, 0.0, 0.0);
                    } return RealVector.ORIGIN; }
                    static FORMAT_$LI$() { RealVector.__static_initialize(); if (RealVector.FORMAT == null) {
                        RealVector.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
                    } return RealVector.FORMAT; }
                    static DIRECTION_0_$LI$() { RealVector.__static_initialize(); if (RealVector.DIRECTION_0 == null) {
                        RealVector.DIRECTION_0 = new RealVector(10.0, 0.1, -0.1);
                    } return RealVector.DIRECTION_0; }
                    static __static_initializer_0() {
                        RealVector.FORMAT_$LI$().setMaximumFractionDigits(5);
                        RealVector.FORMAT_$LI$().setMinimumFractionDigits(1);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    clone() {
                        return new RealVector(this);
                    }
                    isZero() {
                        return this.x === 0 && this.y === 0 && this.z === 0;
                    }
                    /**
                     * Return a string representing this vector as XML attribute values.
                     * @return {string}
                     */
                    toXmlAttributes() {
                        return "x=\"" + RealVector.FORMAT_$LI$().format(this.x) + "\" y=\"" + RealVector.FORMAT_$LI$().format(this.y) + "\" z=\"" + RealVector.FORMAT_$LI$().format(this.z) + "\"";
                    }
                    toString$java_text_NumberFormat(format) {
                        return format.format(this.x) + "," + format.format(this.y) + "," + format.format(this.z);
                    }
                    /**
                     * Return a string representing this vector in the form "x,y,z".
                     * @param {java.text.NumberFormat} format
                     * @return {string}
                     */
                    toString(format) {
                        if (((format != null && format instanceof java.text.NumberFormat) || format === null)) {
                            return this.toString$java_text_NumberFormat(format);
                        }
                        else if (format === undefined) {
                            return this.toString$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    toString$() {
                        return RealVector.FORMAT_$LI$().format(this.x) + "," + RealVector.FORMAT_$LI$().format(this.y) + "," + RealVector.FORMAT_$LI$().format(this.z);
                    }
                    /**
                     * Return a string representing this vector in the form "x y z".
                     * @return {string}
                     */
                    spacedString() {
                        const result = RealVector.FORMAT_$LI$().format(this.x) + " " + RealVector.FORMAT_$LI$().format(this.y) + " " + RealVector.FORMAT_$LI$().format(this.z);
                        return result;
                    }
                    /**
                     * Return the sum of this vector plus the vector "other",
                     * as a new Vector3D.
                     * @param {com.vzome.core.math.RealVector} other
                     * @return {com.vzome.core.math.RealVector}
                     */
                    plus(other) {
                        return new RealVector(Math.fround(this.x + other.x), Math.fround(this.y + other.y), Math.fround(this.z + other.z));
                    }
                    /**
                     * Return the difference of this vector minus the vector "other",
                     * as a new Vector3D.
                     * @param {com.vzome.core.math.RealVector} other
                     * @return {com.vzome.core.math.RealVector}
                     */
                    minus(other) {
                        return new RealVector(Math.fround(this.x - other.x), Math.fround(this.y - other.y), Math.fround(this.z - other.z));
                    }
                    negate() {
                        return new RealVector(-this.x, -this.y, -this.z);
                    }
                    /**
                     * Return a new vector equal to this vector scaled by the given factor.
                     * @param {number} factor
                     * @return {com.vzome.core.math.RealVector}
                     */
                    scale(factor) {
                        return new RealVector(this.x * factor, this.y * factor, this.z * factor);
                    }
                    /**
                     * Return the scalar (dot) product with the other vector
                     * @param {com.vzome.core.math.RealVector} other
                     * @return {number}
                     */
                    dot(other) {
                        return Math.fround(Math.fround(Math.fround(this.x * other.x) + Math.fround(this.y * other.y)) + Math.fround(this.z * other.z));
                    }
                    cross(that) {
                        return new RealVector(Math.fround(Math.fround(this.y * that.z) - Math.fround(this.z * that.y)), Math.fround(Math.fround(this.z * that.x) - Math.fround(this.x * that.z)), Math.fround(Math.fround(this.x * that.y) - Math.fround(this.y * that.x)));
                    }
                    /**
                     * Return the length of this vector.
                     * @return {number}
                     */
                    length() {
                        return Math.sqrt(this.dot(this));
                    }
                    normalize() {
                        return this.scale(1.0 / this.length());
                    }
                    write(buf, offset) {
                        buf.put(offset, this.x);
                        buf.put(offset + 1, this.y);
                        buf.put(offset + 2, this.z);
                    }
                    /**
                     *
                     * @param {*} other
                     * @return {boolean}
                     */
                    equals(other) {
                        if (other == null) {
                            return false;
                        }
                        if (other === this) {
                            return true;
                        }
                        if (!(other != null && other instanceof com.vzome.core.math.RealVector))
                            return false;
                        const v = other;
                        return this.x === v.x && this.y === v.y && this.z === v.z;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let hash = 3;
                        hash = 41 * hash + ((javaemul.internal.DoubleHelper.doubleToLongBits(this.x) ^ (javaemul.internal.DoubleHelper.doubleToLongBits(this.x) >>> 32)) | 0);
                        hash = 41 * hash + ((javaemul.internal.DoubleHelper.doubleToLongBits(this.y) ^ (javaemul.internal.DoubleHelper.doubleToLongBits(this.y) >>> 32)) | 0);
                        hash = 41 * hash + ((javaemul.internal.DoubleHelper.doubleToLongBits(this.z) ^ (javaemul.internal.DoubleHelper.doubleToLongBits(this.z) >>> 32)) | 0);
                        return hash;
                    }
                    addTo(addend, sum) {
                        sum[0] = (Math.fround(addend[0] + this.x));
                        sum[1] = (Math.fround(addend[1] + this.y));
                        sum[2] = (Math.fround(addend[2] + this.z));
                    }
                    toArray(output) {
                        output[0] = this.x;
                        output[1] = this.y;
                        output[2] = this.z;
                    }
                }
                RealVector.__static_initialized = false;
                math.RealVector = RealVector;
                RealVector["__class"] = "com.vzome.core.math.RealVector";
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsPanel extends com.vzome.jsweet.JsManifestation {
                constructor(field, adapter, coords) {
                    super(field, adapter, coords);
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Construction}
                 */
                toConstruction() {
                    const projected = (new java.util.ArrayList());
                    for (let i = 0; i < this.vectors.length; i++) {
                        {
                            const pt = this.field.createVectorFromTDs(this.vectors[i]);
                            projected.add(new com.vzome.core.construction.FreePoint(this.field.projectTo3d(pt, true)));
                        }
                        ;
                    }
                    return new com.vzome.core.construction.PolygonFromVertices(projected);
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getLocation() {
                    return null;
                }
                getNormal$() {
                    return this.getZoneVector();
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getZoneVector() {
                    const v0 = this.field.createVectorFromTDs(this.vectors[0]);
                    const v1 = this.field.createVectorFromTDs(this.vectors[1]);
                    const v2 = this.field.createVectorFromTDs(this.vectors[2]);
                    return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return new JsPanel.JsPanel$0(this);
                }
                /**
                 *
                 * @param {com.vzome.core.algebra.AlgebraicVector} vector
                 */
                setZoneVector(vector) {
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getFirstVertex() {
                    return this.field.createVectorFromTDs(this.vectors[0]);
                }
                /**
                 *
                 * @return {number}
                 */
                getVertexCount() {
                    return this.vectors.length;
                }
                /**
                 *
                 * @return {*}
                 */
                getQuadrea() {
                    return this.field.one();
                }
                getNormal$com_vzome_core_math_symmetry_Embedding(embedding) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {*} embedding
                 * @return {com.vzome.core.math.RealVector}
                 */
                getNormal(embedding) {
                    if (((embedding != null && (embedding.constructor != null && embedding.constructor["__interfaces"] != null && embedding.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Embedding") >= 0)) || embedding === null)) {
                        return this.getNormal$com_vzome_core_math_symmetry_Embedding(embedding);
                    }
                    else if (embedding === undefined) {
                        return this.getNormal$();
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            jsweet.JsPanel = JsPanel;
            JsPanel["__class"] = "com.vzome.jsweet.JsPanel";
            JsPanel["__interfaces"] = ["com.vzome.core.model.GroupElement", "com.vzome.core.model.Panel", "com.vzome.core.model.Manifestation", "java.lang.Iterable"];
            (function (JsPanel) {
                class JsPanel$0 {
                    constructor(__parent) {
                        this.__parent = __parent;
                        this.i = 0;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        return this.i < this.__parent.vectors.length;
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    next() {
                        return this.__parent.field.createVectorFromTDs(this.__parent.vectors[this.i++]);
                    }
                }
                JsPanel.JsPanel$0 = JsPanel$0;
                JsPanel$0["__interfaces"] = ["java.util.Iterator"];
            })(JsPanel = jsweet.JsPanel || (jsweet.JsPanel = {}));
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsBall extends com.vzome.jsweet.JsManifestation {
                constructor(field, adapter, coords) {
                    super(field, adapter, coords);
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getLocation() {
                    return this.field.createVectorFromTDs(this.vectors[0]);
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Construction}
                 */
                toConstruction() {
                    return new com.vzome.core.construction.FreePoint(this.getLocation());
                }
                /**
                 *
                 * @param {*} other
                 * @return {number}
                 */
                compareTo(other) {
                    if (this === other) {
                        return 0;
                    }
                    if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(other, this)) {
                        return 0;
                    }
                    return this.getLocation().compareTo(other.getLocation());
                }
            }
            jsweet.JsBall = JsBall;
            JsBall["__class"] = "com.vzome.jsweet.JsBall";
            JsBall["__interfaces"] = ["com.vzome.core.model.GroupElement", "com.vzome.core.model.Connector", "java.lang.Comparable", "com.vzome.core.model.Manifestation"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsStrut extends com.vzome.jsweet.JsManifestation {
                constructor(field, adapter, coords) {
                    super(field, adapter, coords);
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getLocation() {
                    return this.field.createVectorFromTDs(this.vectors[0]);
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Construction}
                 */
                toConstruction() {
                    return new com.vzome.core.construction.SegmentJoiningPoints(new com.vzome.core.construction.FreePoint(this.getLocation()), new com.vzome.core.construction.FreePoint(this.getEnd()));
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getEnd() {
                    return this.field.createVectorFromTDs(this.vectors[1]);
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getOffset() {
                    const start = this.getLocation();
                    const end = this.getEnd();
                    return end.minus(start);
                }
                /**
                 *
                 * @param {com.vzome.core.algebra.AlgebraicVector} vector
                 */
                setZoneVector(vector) {
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getZoneVector() {
                    return this.getOffset();
                }
                /**
                 *
                 * @param {*} other
                 * @return {number}
                 */
                compareTo(other) {
                    if (this === other) {
                        return 0;
                    }
                    if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(other, this)) {
                        return 0;
                    }
                    const thisFirst = this.getCanonicalLesserEnd();
                    const thisLast = this.getCanonicalGreaterEnd();
                    const otherFirst = other.getCanonicalLesserEnd();
                    const otherLast = other.getCanonicalGreaterEnd();
                    const comparison = thisFirst.compareTo(otherFirst);
                    return (comparison === 0) ? thisLast.compareTo(otherLast) : comparison;
                }
                getCanonicalLesserEnd() {
                    const m_end1 = this.getLocation();
                    const m_end2 = this.getEnd();
                    return (m_end1.compareTo(m_end2) < 0) ? m_end1 : m_end2;
                }
                getCanonicalGreaterEnd() {
                    const m_end1 = this.getLocation();
                    const m_end2 = this.getEnd();
                    return (m_end1.compareTo(m_end2) > 0) ? m_end1 : m_end2;
                }
            }
            jsweet.JsStrut = JsStrut;
            JsStrut["__class"] = "com.vzome.jsweet.JsStrut";
            JsStrut["__interfaces"] = ["com.vzome.core.model.GroupElement", "com.vzome.core.model.Strut", "java.lang.Comparable", "com.vzome.core.model.Manifestation"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                class OctahedralSymmetryPerspective extends com.vzome.core.kinds.AbstractSymmetryPerspective {
                    constructor(field) {
                        super(new com.vzome.core.math.symmetry.OctahedralSymmetry(field));
                        this.modelResourcePath = "org/vorthmann/zome/app/octahedral-vef.vZome";
                        this.setDefaultGeometry(new com.vzome.core.viewing.OctahedralShapes("octahedral", "octahedra", this.symmetry));
                    }
                    /**
                     *
                     * @return {com.vzome.core.math.symmetry.OctahedralSymmetry}
                     */
                    getSymmetry() {
                        return this.symmetry;
                    }
                    /**
                     *
                     * @param {com.vzome.api.Tool.Kind} kind
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     * @return {*}
                     */
                    createToolFactories(kind, tools) {
                        const result = (new java.util.ArrayList());
                        switch ((kind)) {
                            case com.vzome.api.Tool.Kind.SYMMETRY:
                                result.add(new com.vzome.core.tools.OctahedralToolFactory(tools, this.symmetry));
                                result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, this.symmetry));
                                result.add(new com.vzome.core.tools.InversionToolFactory(tools));
                                result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                                result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                                result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry));
                                break;
                            case com.vzome.api.Tool.Kind.TRANSFORM:
                                result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry));
                                result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry));
                                result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                                result.add(new com.vzome.core.tools.ProjectionToolFactory(tools));
                                result.add(new com.vzome.core.tools.PerspectiveProjectionToolFactory(tools));
                                break;
                            case com.vzome.api.Tool.Kind.LINEAR_MAP:
                                result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, this.symmetry, false));
                                break;
                            default:
                                break;
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {com.vzome.api.Tool.Kind} kind
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     * @return {*}
                     */
                    predefineTools(kind, tools) {
                        const result = (new java.util.ArrayList());
                        switch ((kind)) {
                            case com.vzome.api.Tool.Kind.SYMMETRY:
                                result.add(new com.vzome.core.tools.OctahedralToolFactory(tools, this.symmetry).createPredefinedTool("octahedral around origin"));
                                result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, this.symmetry).createPredefinedTool("tetrahedral around origin"));
                                result.add(new com.vzome.core.tools.InversionToolFactory(tools).createPredefinedTool("reflection through origin"));
                                result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through XY plane"));
                                result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through X=Y green plane"));
                                result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry).createPredefinedTool("symmetry around green through origin"));
                                break;
                            case com.vzome.api.Tool.Kind.TRANSFORM:
                                result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale down"));
                                result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale up"));
                                result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry, true).createPredefinedTool("rotate around green through origin"));
                                result.add(new com.vzome.core.tools.TranslationToolFactory(tools).createPredefinedTool("b1 move along +X"));
                                break;
                            default:
                                break;
                        }
                        return result;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getModelResourcePath() {
                        return this.modelResourcePath;
                    }
                    setModelResourcePath(resourcePath) {
                        this.modelResourcePath = resourcePath;
                    }
                }
                kinds.OctahedralSymmetryPerspective = OctahedralSymmetryPerspective;
                OctahedralSymmetryPerspective["__class"] = "com.vzome.core.kinds.OctahedralSymmetryPerspective";
                OctahedralSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                class IcosahedralSymmetryPerspective extends com.vzome.core.kinds.AbstractSymmetryPerspective {
                    constructor(af) {
                        if (((af != null && (af.constructor != null && af.constructor["__interfaces"] != null && af.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || af === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let symm = new com.vzome.core.math.symmetry.IcosahedralSymmetry(af);
                                super(symm);
                                if (this.qSymmH4 === undefined) {
                                    this.qSymmH4 = null;
                                }
                                if (this.qSymmH4_ROT === undefined) {
                                    this.qSymmH4_ROT = null;
                                }
                                if (this.qSymmT2 === undefined) {
                                    this.qSymmT2 = null;
                                }
                                if (this.cmdIcosasymm === undefined) {
                                    this.cmdIcosasymm = null;
                                }
                                if (this.cmdTetrasymm === undefined) {
                                    this.cmdTetrasymm = null;
                                }
                                if (this.cmdAxialsymm === undefined) {
                                    this.cmdAxialsymm = null;
                                }
                                if (this.cmdH4symmetry === undefined) {
                                    this.cmdH4symmetry = null;
                                }
                                if (this.cmdH4rotations === undefined) {
                                    this.cmdH4rotations = null;
                                }
                                if (this.cmdIxTsymmetry === undefined) {
                                    this.cmdIxTsymmetry = null;
                                }
                                if (this.cmdTxTsymmetry === undefined) {
                                    this.cmdTxTsymmetry = null;
                                }
                                if (this.cmdVanOss600cell === undefined) {
                                    this.cmdVanOss600cell = null;
                                }
                                const icosadefaultShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "default", "solid connectors", this.symmetry);
                                const printableShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "printable", "printable", this.symmetry, icosadefaultShapes);
                                const lifelikeShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "lifelike", "lifelike", this.symmetry, icosadefaultShapes);
                                const tinyShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "tiny", "tiny connectors", this.symmetry);
                                const tinyDodecs = new com.vzome.core.viewing.ExportedVEFShapes(null, "dodecs", "small dodecahedra", "tiny dodecahedra", this.symmetry, tinyShapes);
                                const bigZome = new com.vzome.core.viewing.ExportedVEFShapes(null, "bigzome", "Big Zome", this.symmetry, tinyShapes);
                                const noTwist = new com.vzome.core.viewing.ExportedVEFShapes(null, "noTwist", "no-twist 121 zone", this.symmetry, true);
                                const vienne2 = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne2", "Vienne", this.symmetry, icosadefaultShapes);
                                const vienne3 = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne3", "Vienne lifelike", this.symmetry, vienne2);
                                const vienne = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne", "Vienne 121 zone", this.symmetry, true);
                                const dimtoolShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "dimtool", "dimtool", this.symmetry, icosadefaultShapes);
                                this.setDefaultGeometry(printableShapes);
                                this.addShapes(icosadefaultShapes);
                                this.addShapes(lifelikeShapes);
                                this.addShapes(tinyShapes);
                                this.addShapes(tinyDodecs);
                                this.addShapes(bigZome);
                                this.addShapes(noTwist);
                                this.addShapes(vienne2);
                                this.addShapes(vienne3);
                                this.addShapes(vienne);
                                this.addShapes(dimtoolShapes);
                                const field = this.symmetry.getField();
                                this.qSymmH4 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", field);
                                this.qSymmH4_ROT = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H4_ROT", "com/vzome/core/math/symmetry/H4roots-rotationalSubgroup.vef", field);
                                this.qSymmT2 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("2T", "com/vzome/core/math/symmetry/binaryTetrahedralGroup.vef", field);
                                this.cmdIcosasymm = new com.vzome.core.commands.CommandSymmetry(this.symmetry);
                                this.cmdTetrasymm = new com.vzome.core.commands.CommandTetrahedralSymmetry(this.symmetry);
                                this.cmdAxialsymm = new com.vzome.core.commands.CommandAxialSymmetry(this.symmetry);
                                this.cmdH4symmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4, this.qSymmH4);
                                this.cmdH4rotations = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4_ROT, this.qSymmH4_ROT);
                                this.cmdIxTsymmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4, this.qSymmT2);
                                this.cmdTxTsymmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmT2, this.qSymmT2);
                                this.cmdVanOss600cell = new com.vzome.core.commands.CommandVanOss600Cell();
                            }
                        }
                        else if (((af != null && af instanceof com.vzome.core.math.symmetry.IcosahedralSymmetry) || af === null)) {
                            let __args = arguments;
                            let symm = __args[0];
                            super(symm);
                            if (this.qSymmH4 === undefined) {
                                this.qSymmH4 = null;
                            }
                            if (this.qSymmH4_ROT === undefined) {
                                this.qSymmH4_ROT = null;
                            }
                            if (this.qSymmT2 === undefined) {
                                this.qSymmT2 = null;
                            }
                            if (this.cmdIcosasymm === undefined) {
                                this.cmdIcosasymm = null;
                            }
                            if (this.cmdTetrasymm === undefined) {
                                this.cmdTetrasymm = null;
                            }
                            if (this.cmdAxialsymm === undefined) {
                                this.cmdAxialsymm = null;
                            }
                            if (this.cmdH4symmetry === undefined) {
                                this.cmdH4symmetry = null;
                            }
                            if (this.cmdH4rotations === undefined) {
                                this.cmdH4rotations = null;
                            }
                            if (this.cmdIxTsymmetry === undefined) {
                                this.cmdIxTsymmetry = null;
                            }
                            if (this.cmdTxTsymmetry === undefined) {
                                this.cmdTxTsymmetry = null;
                            }
                            if (this.cmdVanOss600cell === undefined) {
                                this.cmdVanOss600cell = null;
                            }
                            const icosadefaultShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "default", "solid connectors", this.symmetry);
                            const printableShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "printable", "printable", this.symmetry, icosadefaultShapes);
                            const lifelikeShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "lifelike", "lifelike", this.symmetry, icosadefaultShapes);
                            const tinyShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "tiny", "tiny connectors", this.symmetry);
                            const tinyDodecs = new com.vzome.core.viewing.ExportedVEFShapes(null, "dodecs", "small dodecahedra", "tiny dodecahedra", this.symmetry, tinyShapes);
                            const bigZome = new com.vzome.core.viewing.ExportedVEFShapes(null, "bigzome", "Big Zome", this.symmetry, tinyShapes);
                            const noTwist = new com.vzome.core.viewing.ExportedVEFShapes(null, "noTwist", "no-twist 121 zone", this.symmetry, true);
                            const vienne2 = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne2", "Vienne", this.symmetry, icosadefaultShapes);
                            const vienne3 = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne3", "Vienne lifelike", this.symmetry, vienne2);
                            const vienne = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne", "Vienne 121 zone", this.symmetry, true);
                            const dimtoolShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "dimtool", "dimtool", this.symmetry, icosadefaultShapes);
                            this.setDefaultGeometry(printableShapes);
                            this.addShapes(icosadefaultShapes);
                            this.addShapes(lifelikeShapes);
                            this.addShapes(tinyShapes);
                            this.addShapes(tinyDodecs);
                            this.addShapes(bigZome);
                            this.addShapes(noTwist);
                            this.addShapes(vienne2);
                            this.addShapes(vienne3);
                            this.addShapes(vienne);
                            this.addShapes(dimtoolShapes);
                            const field = this.symmetry.getField();
                            this.qSymmH4 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", field);
                            this.qSymmH4_ROT = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H4_ROT", "com/vzome/core/math/symmetry/H4roots-rotationalSubgroup.vef", field);
                            this.qSymmT2 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("2T", "com/vzome/core/math/symmetry/binaryTetrahedralGroup.vef", field);
                            this.cmdIcosasymm = new com.vzome.core.commands.CommandSymmetry(this.symmetry);
                            this.cmdTetrasymm = new com.vzome.core.commands.CommandTetrahedralSymmetry(this.symmetry);
                            this.cmdAxialsymm = new com.vzome.core.commands.CommandAxialSymmetry(this.symmetry);
                            this.cmdH4symmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4, this.qSymmH4);
                            this.cmdH4rotations = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4_ROT, this.qSymmH4_ROT);
                            this.cmdIxTsymmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4, this.qSymmT2);
                            this.cmdTxTsymmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmT2, this.qSymmT2);
                            this.cmdVanOss600cell = new com.vzome.core.commands.CommandVanOss600Cell();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {com.vzome.core.math.symmetry.IcosahedralSymmetry}
                     */
                    getSymmetry() {
                        return this.symmetry;
                    }
                    /**
                     *
                     * @param {com.vzome.api.Tool.Kind} kind
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     * @return {*}
                     */
                    createToolFactories(kind, tools) {
                        const result = (new java.util.ArrayList());
                        const icosaSymm = this.getSymmetry();
                        switch ((kind)) {
                            case com.vzome.api.Tool.Kind.SYMMETRY:
                                result.add(new com.vzome.core.tools.IcosahedralToolFactory(tools, icosaSymm));
                                result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, icosaSymm));
                                result.add(new com.vzome.core.tools.InversionToolFactory(tools));
                                result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                                result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                                result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, icosaSymm));
                                break;
                            case com.vzome.api.Tool.Kind.TRANSFORM:
                                result.add(new com.vzome.core.tools.ScalingToolFactory(tools, icosaSymm));
                                result.add(new com.vzome.core.tools.RotationToolFactory(tools, icosaSymm));
                                result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                                result.add(new com.vzome.core.tools.ProjectionToolFactory(tools));
                                result.add(new com.vzome.core.tools.PerspectiveProjectionToolFactory(tools));
                                break;
                            case com.vzome.api.Tool.Kind.LINEAR_MAP:
                                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, true, true, true));
                                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, true, false, true));
                                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, true, true, false));
                                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, true, false, false));
                                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, false, true, false));
                                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, false, false, false));
                                result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, icosaSymm, false));
                                break;
                            default:
                                break;
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {com.vzome.api.Tool.Kind} kind
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     * @return {*}
                     */
                    predefineTools(kind, tools) {
                        const result = (new java.util.ArrayList());
                        const icosaSymm = this.getSymmetry();
                        switch ((kind)) {
                            case com.vzome.api.Tool.Kind.SYMMETRY:
                                result.add(new com.vzome.core.tools.IcosahedralToolFactory(tools, icosaSymm).createPredefinedTool("icosahedral around origin"));
                                result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, icosaSymm).createPredefinedTool("tetrahedral around origin"));
                                result.add(new com.vzome.core.tools.InversionToolFactory(tools).createPredefinedTool("reflection through origin"));
                                result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through XY plane"));
                                result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through X=Y green plane"));
                                result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, icosaSymm).createPredefinedTool("symmetry around red through origin"));
                                break;
                            case com.vzome.api.Tool.Kind.TRANSFORM:
                                result.add(new com.vzome.core.tools.ScalingToolFactory(tools, icosaSymm).createPredefinedTool("scale down"));
                                result.add(new com.vzome.core.tools.ScalingToolFactory(tools, icosaSymm).createPredefinedTool("scale up"));
                                result.add(new com.vzome.core.tools.RotationToolFactory(tools, icosaSymm, true).createPredefinedTool("rotate around red through origin"));
                                result.add(new com.vzome.core.tools.TranslationToolFactory(tools).createPredefinedTool("b1 move along +X"));
                                break;
                            default:
                                break;
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {string} action
                     * @return {*}
                     */
                    getLegacyCommand(action) {
                        switch ((action)) {
                            case "icosasymm":
                                return this.cmdIcosasymm;
                            case "tetrasymm":
                                return this.cmdTetrasymm;
                            case "axialsymm":
                                return this.cmdAxialsymm;
                            case "h4symmetry":
                                return this.cmdH4symmetry;
                            case "h4rotations":
                                return this.cmdH4rotations;
                            case "IxTsymmetry":
                                return this.cmdIxTsymmetry;
                            case "TxTsymmetry":
                                return this.cmdTxTsymmetry;
                            case "vanOss600cell":
                                return this.cmdVanOss600cell;
                            default:
                                return super.getLegacyCommand(action);
                        }
                    }
                    getQuaternionSymmetry(name) {
                        switch ((name)) {
                            case "H_4":
                                return this.qSymmH4;
                            case "H4_ROT":
                                return this.qSymmH4_ROT;
                            case "2T":
                                return this.qSymmT2;
                            default:
                                return null;
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getModelResourcePath() {
                        return "org/vorthmann/zome/app/icosahedral-vef.vZome";
                    }
                }
                kinds.IcosahedralSymmetryPerspective = IcosahedralSymmetryPerspective;
                IcosahedralSymmetryPerspective["__class"] = "com.vzome.core.kinds.IcosahedralSymmetryPerspective";
                IcosahedralSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                /**
                 * Everything here is stateless, or at worst, a cache (like Shapes).
                 * An instance of this can be shared by many DocumentModels.
                 * This is why it does not have tool factories, though it does
                 * dictate what tool factories will be present.
                 *
                 * @author Scott Vorthmann
                 * @param {*} field
                 * @class
                 * @extends com.vzome.core.kinds.DefaultFieldApplication
                 */
                class HeptagonFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
                    constructor(field) {
                        super(field);
                        this.correctedAntiprismPerspective = new HeptagonFieldApplication.HeptagonalSymmetryPerspective(this, true);
                        this.originalAntiprismPerspective = new HeptagonFieldApplication.HeptagonalSymmetryPerspective(this, false);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return "Heptagon";
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetryPerspectives() {
                        return java.util.Arrays.asList(this.correctedAntiprismPerspective, super.getDefaultSymmetryPerspective(), this.originalAntiprismPerspective);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getDefaultSymmetryPerspective() {
                        return this.correctedAntiprismPerspective;
                    }
                    /**
                     *
                     * @param {string} symmName
                     * @return {*}
                     */
                    getSymmetryPerspective(symmName) {
                        switch ((symmName)) {
                            case "heptagonal antiprism corrected":
                                return this.correctedAntiprismPerspective;
                            case "heptagonal antiprism":
                                return this.originalAntiprismPerspective;
                            default:
                                return super.getSymmetryPerspective(symmName);
                        }
                    }
                }
                kinds.HeptagonFieldApplication = HeptagonFieldApplication;
                HeptagonFieldApplication["__class"] = "com.vzome.core.kinds.HeptagonFieldApplication";
                HeptagonFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D", "com.vzome.core.editor.FieldApplication"];
                (function (HeptagonFieldApplication) {
                    class HeptagonalSymmetryPerspective extends com.vzome.core.kinds.AbstractSymmetryPerspective {
                        constructor(__parent, corrected) {
                            super(new com.vzome.fields.heptagon.HeptagonalAntiprismSymmetry(__parent.getField(), "blue", corrected).createStandardOrbits("blue"));
                            this.__parent = __parent;
                            if (this.corrected === undefined) {
                                this.corrected = false;
                            }
                            this.axialsymm = new com.vzome.core.commands.CommandAxialSymmetry(this.symmetry);
                            this.corrected = corrected;
                            const octahedralShapes = new com.vzome.core.viewing.OctahedralShapes("octahedral", "triangular antiprism", this.symmetry);
                            const antiprismShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "heptagon/antiprism", "heptagonal antiprism", this.symmetry, octahedralShapes);
                            this.setDefaultGeometry(antiprismShapes);
                            this.addShapes(octahedralShapes);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getLabel() {
                            return this.corrected ? "heptagonal antiprism" : null;
                        }
                        /**
                         *
                         * @param {com.vzome.api.Tool.Kind} kind
                         * @param {com.vzome.core.editor.ToolsModel} tools
                         * @return {*}
                         */
                        createToolFactories(kind, tools) {
                            const result = (new java.util.ArrayList());
                            switch ((kind)) {
                                case com.vzome.api.Tool.Kind.SYMMETRY:
                                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, this.symmetry));
                                    result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry));
                                    break;
                                case com.vzome.api.Tool.Kind.TRANSFORM:
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry));
                                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry));
                                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                                    break;
                                case com.vzome.api.Tool.Kind.LINEAR_MAP:
                                    result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, this.symmetry, false));
                                    break;
                                default:
                                    break;
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {com.vzome.api.Tool.Kind} kind
                         * @param {com.vzome.core.editor.ToolsModel} tools
                         * @return {*}
                         */
                        predefineTools(kind, tools) {
                            const result = (new java.util.ArrayList());
                            switch ((kind)) {
                                case com.vzome.api.Tool.Kind.SYMMETRY:
                                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, this.symmetry).createPredefinedTool("heptagonal antiprism around origin"));
                                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through XY plane"));
                                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry).createPredefinedTool("symmetry around red through origin"));
                                    break;
                                case com.vzome.api.Tool.Kind.TRANSFORM:
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale down"));
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale up"));
                                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry, true).createPredefinedTool("rotate around red through origin"));
                                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools).createPredefinedTool("b1 move along +X"));
                                    break;
                                default:
                                    break;
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {string} action
                         * @return {*}
                         */
                        getLegacyCommand(action) {
                            switch ((action)) {
                                case "axialsymm":
                                    return this.axialsymm;
                                default:
                                    return super.getLegacyCommand(action);
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getModelResourcePath() {
                            return "org/vorthmann/zome/app/heptagonal antiprism.vZome";
                        }
                    }
                    HeptagonFieldApplication.HeptagonalSymmetryPerspective = HeptagonalSymmetryPerspective;
                    HeptagonalSymmetryPerspective["__class"] = "com.vzome.core.kinds.HeptagonFieldApplication.HeptagonalSymmetryPerspective";
                    HeptagonalSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];
                })(HeptagonFieldApplication = kinds.HeptagonFieldApplication || (kinds.HeptagonFieldApplication = {}));
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                /**
                 * Everything here is stateless, or at worst, a cache (like Shapes).
                 * An instance of this can be shared by many DocumentModels.
                 * This is why it does not have tool factories, though it does
                 * dictate what tool factories will be present.
                 *
                 * @author David Hall
                 * @param {com.vzome.core.algebra.PolygonField} field
                 * @class
                 * @extends com.vzome.core.kinds.DefaultFieldApplication
                 */
                class PolygonFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
                    constructor(field) {
                        super(field);
                        this.symmetryPerspectives = (new java.util.ArrayList());
                        if (this.icosahedralPerspective === undefined) {
                            this.icosahedralPerspective = null;
                        }
                        if (this.H4 === undefined) {
                            this.H4 = null;
                        }
                        this.h4Builder = null;
                        this.symmetryPerspectives.add(new PolygonFieldApplication.AntiprismSymmetryPerspective(this));
                        if (field.polygonSides() === 5) {
                            this.icosahedralPerspective = new com.vzome.core.kinds.IcosahedralSymmetryPerspective(this.getField());
                            this.symmetryPerspectives.add(this.icosahedralPerspective);
                            this.H4 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
                        }
                        else {
                            this.icosahedralPerspective = null;
                            this.H4 = null;
                        }
                        this.symmetryPerspectives.add(super.getDefaultSymmetryPerspective());
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.PolygonField}
                     */
                    getField() {
                        return super.getField();
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetryPerspectives() {
                        return this.symmetryPerspectives;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getDefaultSymmetryPerspective() {
                        return (this.icosahedralPerspective == null) ? this.symmetryPerspectives.get(0) : this.icosahedralPerspective;
                    }
                    /**
                     *
                     * @param {string} symmName
                     * @return {*}
                     */
                    getSymmetryPerspective(symmName) {
                        for (let index = this.symmetryPerspectives.iterator(); index.hasNext();) {
                            let sp = index.next();
                            {
                                if (sp.getName() === symmName) {
                                    return sp;
                                }
                            }
                        }
                        return super.getSymmetryPerspective(symmName);
                    }
                    /**
                     *
                     * @param {*} toolFactories
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     */
                    registerToolFactories(toolFactories, tools) {
                        super.registerToolFactories(toolFactories, tools);
                        if (this.icosahedralPerspective != null) {
                            const symm = this.icosahedralPerspective.getSymmetry();
                            toolFactories.put("AxialStretchTool", new com.vzome.core.tools.AxialStretchTool.Factory(tools, symm, false, false, false));
                            toolFactories.put("SymmetryTool", new com.vzome.core.tools.IcosahedralToolFactory(tools, symm));
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {com.vzome.core.math.symmetry.QuaternionicSymmetry}
                     */
                    getQuaternionSymmetry(name) {
                        switch ((name)) {
                            case "H_4":
                                return this.H4;
                            default:
                                return null;
                        }
                    }
                    /**
                     *
                     * @param {string} groupName
                     * @param {number} index
                     * @param {number} edgesToRender
                     * @param {com.vzome.core.algebra.AlgebraicNumber[]} edgeScales
                     * @param {*} listener
                     */
                    constructPolytope(groupName, index, edgesToRender, edgeScales, listener) {
                        switch ((groupName)) {
                            case "H4":
                                if (this.h4Builder == null) {
                                    const qsymm = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
                                    this.h4Builder = new com.vzome.core.commands.CommandUniformH4Polytope(this.getField(), qsymm, 0);
                                }
                                this.h4Builder.generate(index, edgesToRender, edgeScales, listener);
                                break;
                            default:
                                super.constructPolytope(groupName, index, edgesToRender, edgeScales, listener);
                                break;
                        }
                    }
                }
                kinds.PolygonFieldApplication = PolygonFieldApplication;
                PolygonFieldApplication["__class"] = "com.vzome.core.kinds.PolygonFieldApplication";
                PolygonFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D", "com.vzome.core.editor.FieldApplication"];
                (function (PolygonFieldApplication) {
                    class AntiprismSymmetryPerspective extends com.vzome.core.kinds.AbstractSymmetryPerspective {
                        constructor(__parent) {
                            super(new com.vzome.core.math.symmetry.AntiprismSymmetry(__parent.getField()).createStandardOrbits("blue"));
                            this.__parent = __parent;
                            this.axialsymm = new com.vzome.core.commands.CommandAxialSymmetry(this.symmetry);
                            const thinAntiprismShapes = new com.vzome.core.viewing.AntiprismShapes("thin", "thin antiprism", this.getSymmetry());
                            const antiprismShapes = new com.vzome.core.viewing.AntiprismShapes("antiprism", "antiprism", this.getSymmetry());
                            const octahedralShapes = new com.vzome.core.viewing.OctahedralShapes("octahedral", "octahedral", this.symmetry);
                            this.setDefaultGeometry(thinAntiprismShapes);
                            this.addShapes(antiprismShapes);
                            this.addShapes(octahedralShapes);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getLabel() {
                            return "antiprism";
                        }
                        /**
                         *
                         * @return {com.vzome.core.math.symmetry.AntiprismSymmetry}
                         */
                        getSymmetry() {
                            return super.getSymmetry();
                        }
                        /**
                         *
                         * @param {com.vzome.api.Tool.Kind} kind
                         * @param {com.vzome.core.editor.ToolsModel} tools
                         * @return {*}
                         */
                        createToolFactories(kind, tools) {
                            const isTrivial = this.symmetry.isTrivial();
                            const result = (new java.util.ArrayList());
                            switch ((kind)) {
                                case com.vzome.api.Tool.Kind.SYMMETRY:
                                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, this.symmetry));
                                    if (isTrivial) {
                                        result.add(new com.vzome.core.tools.InversionToolFactory(tools));
                                    }
                                    result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry));
                                    break;
                                case com.vzome.api.Tool.Kind.TRANSFORM:
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry));
                                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry));
                                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                                    if (isTrivial) {
                                        result.add(new com.vzome.core.tools.ProjectionToolFactory(tools));
                                    }
                                    break;
                                case com.vzome.api.Tool.Kind.LINEAR_MAP:
                                    result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, this.symmetry, false));
                                    break;
                                default:
                                    break;
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {com.vzome.api.Tool.Kind} kind
                         * @param {com.vzome.core.editor.ToolsModel} tools
                         * @return {*}
                         */
                        predefineTools(kind, tools) {
                            const result = (new java.util.ArrayList());
                            switch ((kind)) {
                                case com.vzome.api.Tool.Kind.SYMMETRY:
                                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, this.symmetry).createPredefinedTool("polygonal antiprism around origin"));
                                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through XY plane"));
                                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry, true).createPredefinedTool("symmetry around red through origin"));
                                    break;
                                case com.vzome.api.Tool.Kind.TRANSFORM:
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale down"));
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale up"));
                                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry, true).createPredefinedTool("rotate around red through origin"));
                                    break;
                                default:
                                    break;
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {string} action
                         * @return {*}
                         */
                        getLegacyCommand(action) {
                            switch ((action)) {
                                case "axialsymm":
                                    return this.axialsymm;
                                default:
                                    return super.getLegacyCommand(action);
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getModelResourcePath() {
                            return "org/vorthmann/zome/app/antiprism-trackball-template.vZome";
                        }
                    }
                    PolygonFieldApplication.AntiprismSymmetryPerspective = AntiprismSymmetryPerspective;
                    AntiprismSymmetryPerspective["__class"] = "com.vzome.core.kinds.PolygonFieldApplication.AntiprismSymmetryPerspective";
                    AntiprismSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];
                })(PolygonFieldApplication = kinds.PolygonFieldApplication || (kinds.PolygonFieldApplication = {}));
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                class SnubCubeFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
                    constructor(field) {
                        super(field);
                        const symmPerspective = super.getDefaultSymmetryPerspective();
                        symmPerspective.setModelResourcePath("org/vorthmann/zome/app/snubCubeTrackball-vef.vZome");
                        const symm = symmPerspective.getSymmetry();
                        const vSnubSquare = field.createVector([[1, 1, 0, 1, 0, 1], [0, 1, 2, 1, -1, 1], [0, 1, 0, 1, 0, 1]]);
                        const vSnubTriangle = field.createVector([[1, 1, 0, 1, 0, 1], [1, 2, 1, 1, -1, 2], [1, 2, -1, 1, 1, 2]]);
                        const vSnubDiagonal = field.createVector([[1, 1, 0, 1, 0, 1], [0, 1, -1, 2, 1, 2], [0, 1, -1, 2, 1, 2]]);
                        const vSnubFaceNormal = field.createVector([[1, 1, 0, 1, 0, 1], [-2, 7, 2, 7, 1, 7], [-1, 7, -6, 7, 4, 7]]);
                        const vSnubVertex = field.createVector([[1, 1, 0, 1, 0, 1], [-1, 1, -1, 1, 1, 1], [0, 1, 2, 1, -1, 1]]);
                        const vSnubSquareMidEdge = field.createVector([[1, 1, 0, 1, 0, 1], [-1, 2, 1, 2, 0, 1], [-1, 2, -3, 2, 1, 1]]);
                        const vSnubTriangleMidEdge = field.createVector([[1, 1, 0, 1, 0, 1], [-1, 1, 1, 1, 0, 1], [-1, 1, -1, 1, 1, 1]]);
                        const nSnubSquare = field.createAlgebraicNumber$int_A([-1, 1, 0]);
                        const nSnubTriangle = field.createAlgebraicNumber$int_A([1, -2, 1]);
                        const nSnubDiagonal = field.createAlgebraicNumber$int_A([0, 4, -2]);
                        const nSnubFaceNormal = field.createAlgebraicNumber$int_A([2, 3, -2]);
                        const nSnubVertex = field.one();
                        const nSnubSquareMidEdge = field.one();
                        const nSnubTriangleMidEdge = field.createAlgebraicNumber$int_A([0, -1, 1]).dividedBy(field.createRational$long(2));
                        symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubSquare", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubSquare, false, false, nSnubSquare);
                        symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubTriangle", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubTriangle, false, false, nSnubTriangle);
                        symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubDiagonal", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubDiagonal, false, false, nSnubDiagonal);
                        symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubFaceNormal", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubFaceNormal, true, false, nSnubFaceNormal);
                        symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubVertex", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubVertex, true, false, nSnubVertex);
                        symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubSquareMid", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubSquareMidEdge, false, false, nSnubSquareMidEdge);
                        symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubTriangleMid", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubTriangleMidEdge, false, false, nSnubTriangleMidEdge);
                        const defaultShapes = symmPerspective.getDefaultGeometry();
                        let resPath = "snubCube";
                        const snubCubeRhShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, resPath, "snub cube right", null, symm, defaultShapes, false);
                        const snubCubeLhShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, resPath, "snub cube left", null, symm, defaultShapes, true);
                        resPath = "snubCube/dual";
                        const snubDualRhShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, resPath, "snub cube dual right", null, symm, defaultShapes, false);
                        const snubDualLhShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, resPath, "snub cube dual left", null, symm, defaultShapes, true);
                        resPath = "snubCube/disdyakisDodec";
                        const disdyakisDodec = new com.vzome.core.viewing.ExportedVEFShapes(null, resPath, "disdyakis dodec", null, symm, defaultShapes, false);
                        symmPerspective.addShapes(disdyakisDodec);
                        symmPerspective.addShapes(snubCubeRhShapes);
                        symmPerspective.addShapes(snubCubeRhShapes);
                        symmPerspective.addShapes(snubCubeLhShapes);
                        symmPerspective.addShapes(snubDualRhShapes);
                        symmPerspective.addShapes(snubDualLhShapes);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return "Snub Cube";
                    }
                }
                kinds.SnubCubeFieldApplication = SnubCubeFieldApplication;
                SnubCubeFieldApplication["__class"] = "com.vzome.core.kinds.SnubCubeFieldApplication";
                SnubCubeFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D", "com.vzome.core.editor.FieldApplication"];
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                /**
                 * Everything here is stateless, or at worst, a cache (like Shapes).
                 * An instance of this can be shared by many DocumentModels.
                 * This is why it does not have tool factories, though it does
                 * dictate what tool factories will be present.
                 *
                 * @author Scott Vorthmann
                 * @param {*} field
                 * @class
                 * @extends com.vzome.core.kinds.DefaultFieldApplication
                 */
                class RootThreeFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
                    constructor(field) {
                        super(field);
                        this.dodecagonalPerspective = new RootThreeFieldApplication.RootThreeFieldApplication$0(this, new com.vzome.core.math.symmetry.DodecagonalSymmetry(this.getField()));
                        const octahedralPerspective = super.getDefaultSymmetryPerspective();
                        const symm = octahedralPerspective.getSymmetry();
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("red", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 1, 2], [1, 2, 0, 1], [0, 1, 0, 1]], true);
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("brown", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 0, 1], [1, 1, 0, 1], [2, 1, 0, 1]]);
                        const defaultShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "rootThreeOctaSmall", "small octahedra", "small connectors", symm);
                        octahedralPerspective.setDefaultGeometry(defaultShapes);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return "\u221a3";
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getDefaultSymmetryPerspective() {
                        return this.dodecagonalPerspective;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetryPerspectives() {
                        return java.util.Arrays.asList(super.getDefaultSymmetryPerspective(), this.dodecagonalPerspective);
                    }
                    /**
                     *
                     * @param {string} symmName
                     * @return {*}
                     */
                    getSymmetryPerspective(symmName) {
                        switch ((symmName)) {
                            case "dodecagonal":
                                return this.dodecagonalPerspective;
                            default:
                                return super.getSymmetryPerspective(symmName);
                        }
                    }
                }
                kinds.RootThreeFieldApplication = RootThreeFieldApplication;
                RootThreeFieldApplication["__class"] = "com.vzome.core.kinds.RootThreeFieldApplication";
                RootThreeFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D", "com.vzome.core.editor.FieldApplication"];
                (function (RootThreeFieldApplication) {
                    class RootThreeFieldApplication$0 extends com.vzome.core.kinds.AbstractSymmetryPerspective {
                        constructor(__parent, __arg0) {
                            super(__arg0);
                            this.__parent = __parent;
                            (() => {
                                const defaultShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "dodecagon3d", "prisms", this.symmetry);
                                const hexagonShapes = new com.vzome.core.viewing.DodecagonalShapes("dodecagonal", "hexagons", "flat hexagons", this.symmetry);
                                this.setDefaultGeometry(defaultShapes);
                                this.addShapes(hexagonShapes);
                            })();
                            this.dodecagonsymm = new com.vzome.core.commands.CommandSymmetry(this.symmetry);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "dodecagonal";
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.Direction} orbit
                         * @return {boolean}
                         */
                        orbitIsBuildDefault(orbit) {
                            switch ((orbit.getName())) {
                                case "blue":
                                case "green":
                                    return true;
                                default:
                                    return false;
                            }
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.Direction} orbit
                         * @return {*}
                         */
                        getOrbitUnitLength(orbit) {
                            switch ((orbit.getName())) {
                                case "blue":
                                case "green":
                                    return this.__parent.getField()['createPower$int'](2);
                                default:
                                    return super.getOrbitUnitLength(orbit);
                            }
                        }
                        /**
                         *
                         * @param {com.vzome.api.Tool.Kind} kind
                         * @param {com.vzome.core.editor.ToolsModel} tools
                         * @return {*}
                         */
                        createToolFactories(kind, tools) {
                            const result = (new java.util.ArrayList());
                            switch ((kind)) {
                                case com.vzome.api.Tool.Kind.SYMMETRY:
                                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, this.symmetry));
                                    result.add(new com.vzome.core.tools.InversionToolFactory(tools));
                                    result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry));
                                    break;
                                case com.vzome.api.Tool.Kind.TRANSFORM:
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry));
                                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry));
                                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                                    result.add(new com.vzome.core.tools.ProjectionToolFactory(tools));
                                    break;
                                case com.vzome.api.Tool.Kind.LINEAR_MAP:
                                    result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, this.symmetry, false));
                                    break;
                                default:
                                    break;
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {com.vzome.api.Tool.Kind} kind
                         * @param {com.vzome.core.editor.ToolsModel} tools
                         * @return {*}
                         */
                        predefineTools(kind, tools) {
                            const result = (new java.util.ArrayList());
                            switch ((kind)) {
                                case com.vzome.api.Tool.Kind.SYMMETRY:
                                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, this.symmetry).createPredefinedTool("dodecagonal antiprism around origin"));
                                    result.add(new com.vzome.core.tools.InversionToolFactory(tools).createPredefinedTool("reflection through origin"));
                                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through XY plane"));
                                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry).createPredefinedTool("symmetry around red through origin"));
                                    break;
                                case com.vzome.api.Tool.Kind.TRANSFORM:
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale down"));
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale up"));
                                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry, true).createPredefinedTool("rotate around red through origin"));
                                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools).createPredefinedTool("b1 move along +X"));
                                    break;
                                default:
                                    break;
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {string} action
                         * @return {*}
                         */
                        getLegacyCommand(action) {
                            switch ((action)) {
                                case "dodecagonsymm":
                                    return this.dodecagonsymm;
                                default:
                                    return super.getLegacyCommand(action);
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getModelResourcePath() {
                            return "org/vorthmann/zome/app/12-gon-trackball-vef.vZome";
                        }
                    }
                    RootThreeFieldApplication.RootThreeFieldApplication$0 = RootThreeFieldApplication$0;
                    RootThreeFieldApplication$0["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];
                })(RootThreeFieldApplication = kinds.RootThreeFieldApplication || (kinds.RootThreeFieldApplication = {}));
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                /**
                 * Everything here is stateless, or at worst, a cache (like Shapes).
                 * An instance of this can be shared by many DocumentModels.
                 * This is why it does not have tool factories, though it does
                 * dictate what tool factories will be present.
                 *
                 * @author vorth
                 * @param {*} field
                 * @class
                 * @extends com.vzome.core.kinds.DefaultFieldApplication
                 */
                class GoldenFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
                    constructor(field) {
                        super(field);
                        if (this.icosahedralPerspective === undefined) {
                            this.icosahedralPerspective = null;
                        }
                        this.h4Builder = null;
                        this.cmdTauDivide = new com.vzome.core.commands.CommandTauDivision();
                        this.icosahedralPerspective = new com.vzome.core.kinds.IcosahedralSymmetryPerspective(this.getField());
                        const octahedralPerspective = super.getDefaultSymmetryPerspective();
                        const symm = octahedralPerspective.getSymmetry();
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("yellow", 0, 4, [[0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]], true, false, this.getField()['createPower$int'](-1));
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("green", 1, 8, [[1, 1, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1]], true, true, this.getField()['createRational$long'](2));
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("lavender", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[2, 1, -1, 1], [0, 1, 1, 1], [2, 1, -1, 1]]);
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("olive", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 1, 1], [0, 1, 1, 1], [2, 1, -1, 1]]);
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("maroon", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 1, 1, 1], [3, 1, -1, 1], [1, 1, -1, 1]]);
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("brown", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 1, 1, 1], [-1, 1, 1, 1], [-2, 1, 2, 1]]);
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("red", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 1, 1], [1, 1, 0, 1], [0, 1, 0, 1]]);
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("purple", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 1, 1], [0, 1, 0, 1], [-1, 1, 0, 1]], false, false, this.getField()['createPower$int'](-1));
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("black", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 2, 0, 1], [0, 1, 1, 2], [-1, 2, 1, 2]], false, false, this.getField()['createRational$long'](2));
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("turquoise", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 2, 1], [3, 1, 4, 1], [3, 1, 4, 1]]);
                        const defaultShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "octahedral", "trapezoids", symm, null);
                        octahedralPerspective.setDefaultGeometry(defaultShapes);
                        octahedralPerspective.addShapes(new com.vzome.core.viewing.ExportedVEFShapes(null, "octahedralFast", "small octahedra", symm, null));
                        octahedralPerspective.addShapes(new com.vzome.core.viewing.ExportedVEFShapes(null, "octahedralRealistic", "vZome logo", symm, defaultShapes));
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return "Zome (Golden)";
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetryPerspectives() {
                        return java.util.Arrays.asList(this.icosahedralPerspective, super.getDefaultSymmetryPerspective());
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getDefaultSymmetryPerspective() {
                        return this.icosahedralPerspective;
                    }
                    /**
                     *
                     * @param {string} symmName
                     * @return {*}
                     */
                    getSymmetryPerspective(symmName) {
                        switch ((symmName)) {
                            case "icosahedral":
                                return this.icosahedralPerspective;
                            default:
                                return super.getSymmetryPerspective(symmName);
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {com.vzome.core.math.symmetry.QuaternionicSymmetry}
                     */
                    getQuaternionSymmetry(name) {
                        return this.icosahedralPerspective.getQuaternionSymmetry(name);
                    }
                    /**
                     *
                     * @param {*} toolFactories
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     */
                    registerToolFactories(toolFactories, tools) {
                        super.registerToolFactories(toolFactories, tools);
                        const symm = this.icosahedralPerspective.getSymmetry();
                        toolFactories.put("AxialStretchTool", new com.vzome.core.tools.AxialStretchTool.Factory(tools, symm, false, false, false));
                        toolFactories.put("SymmetryTool", new com.vzome.core.tools.IcosahedralToolFactory(tools, symm));
                    }
                    /**
                     *
                     * @param {string} groupName
                     * @param {number} index
                     * @param {number} edgesToRender
                     * @param {com.vzome.core.algebra.AlgebraicNumber[]} edgeScales
                     * @param {*} listener
                     */
                    constructPolytope(groupName, index, edgesToRender, edgeScales, listener) {
                        switch ((groupName)) {
                            case "H4":
                                if (this.h4Builder == null) {
                                    const qsymm = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
                                    this.h4Builder = new com.vzome.core.commands.CommandUniformH4Polytope(this.getField(), qsymm, 0);
                                }
                                this.h4Builder.generate(index, edgesToRender, edgeScales, listener);
                                break;
                            default:
                                super.constructPolytope(groupName, index, edgesToRender, edgeScales, listener);
                                break;
                        }
                    }
                    /**
                     *
                     * @param {string} action
                     * @return {*}
                     */
                    getLegacyCommand(action) {
                        switch ((action)) {
                            case "tauDivide":
                                return this.cmdTauDivide;
                            default:
                                return super.getLegacyCommand(action);
                        }
                    }
                }
                kinds.GoldenFieldApplication = GoldenFieldApplication;
                GoldenFieldApplication["__class"] = "com.vzome.core.kinds.GoldenFieldApplication";
                GoldenFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D", "com.vzome.core.editor.FieldApplication"];
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class OffExporter extends com.vzome.core.exporters.GeometryExporter {
                    static __static_initialize() { if (!OffExporter.__static_initialized) {
                        OffExporter.__static_initialized = true;
                        OffExporter.__static_initializer_0();
                    } }
                    static FORMAT_$LI$() { OffExporter.__static_initialize(); if (OffExporter.FORMAT == null) {
                        OffExporter.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
                    } return OffExporter.FORMAT; }
                    static __static_initializer_0() {
                        OffExporter.FORMAT_$LI$().setMinimumFractionDigits(16);
                    }
                    /**
                     *
                     * @param {java.io.File} directory
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(directory, writer, height, width) {
                        let vertices = (new java.util.TreeSet());
                        let numStruts = 0;
                        const arrayComparator = (new com.vzome.core.generic.ArrayComparator());
                        const panelVertices = (new java.util.TreeSet((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                            return funcInst;
                        } return (arg0, arg1) => (funcInst['compare'] ? funcInst['compare'] : funcInst).call(funcInst, arg0, arg1); })(arrayComparator.getLengthFirstArrayComparator()))));
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    const loc = man.getLocation();
                                    vertices.add(loc);
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    ++numStruts;
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    const panel = man;
                                    const corners = (new java.util.ArrayList(panel.getVertexCount()));
                                    for (let index = panel.iterator(); index.hasNext();) {
                                        let vertex = index.next();
                                        {
                                            corners.add(vertex);
                                        }
                                    }
                                    vertices.addAll(corners);
                                    const cornerArray = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(corners.size());
                                    corners.toArray(cornerArray);
                                    panelVertices.add(cornerArray);
                                }
                            }
                        }
                        const sortedVertexList = (new java.util.ArrayList(vertices));
                        vertices = null;
                        this.output = new java.io.PrintWriter(writer);
                        this.output.println$java_lang_Object("OFF");
                        this.output.println$java_lang_Object("# numVertices numFaces numEdges (numEdges is ignored)");
                        this.output.println$java_lang_Object(sortedVertexList.size() + " " + panelVertices.size() + " " + numStruts + "\n");
                        this.output.println$java_lang_Object("# Vertices.  Each line is the XYZ coordinates of one vertex.");
                        for (let index = sortedVertexList.iterator(); index.hasNext();) {
                            let vector = index.next();
                            {
                                const dv = this.mModel.renderVectorDouble(vector);
                                this.output.print(OffExporter.FORMAT_$LI$().format(dv[0]) + " ");
                                this.output.print(OffExporter.FORMAT_$LI$().format(dv[1]) + " ");
                                this.output.print(OffExporter.FORMAT_$LI$().format(dv[2]) + "\n");
                            }
                        }
                        this.output.println$();
                        this.output.println$java_lang_Object("# Faces.  numCorners vertexIndex[0] ... vertexIndex[numCorners-1]");
                        for (let index = panelVertices.iterator(); index.hasNext();) {
                            let corners = index.next();
                            {
                                this.output.print(corners.length);
                                for (let index = 0; index < corners.length; index++) {
                                    let corner = corners[index];
                                    {
                                        this.output.print(" " + sortedVertexList.indexOf(corner));
                                    }
                                }
                                this.output.println$();
                            }
                        }
                        this.output.flush();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "off";
                    }
                }
                OffExporter.__static_initialized = false;
                exporters.OffExporter = OffExporter;
                OffExporter["__class"] = "com.vzome.core.exporters.OffExporter";
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class OpenScadMeshExporter extends com.vzome.core.exporters.GeometryExporter {
                    static __static_initialize() { if (!OpenScadMeshExporter.__static_initialized) {
                        OpenScadMeshExporter.__static_initialized = true;
                        OpenScadMeshExporter.__static_initializer_0();
                    } }
                    static FORMAT_$LI$() { OpenScadMeshExporter.__static_initialize(); if (OpenScadMeshExporter.FORMAT == null) {
                        OpenScadMeshExporter.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
                    } return OpenScadMeshExporter.FORMAT; }
                    static __static_initializer_0() {
                        OpenScadMeshExporter.FORMAT_$LI$().setMinimumFractionDigits(6);
                        OpenScadMeshExporter.FORMAT_$LI$().setMaximumFractionDigits(6);
                    }
                    /**
                     *
                     * @param {java.io.File} directory
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(directory, writer, height, width) {
                        let vertices = (new java.util.TreeSet());
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    const strut = man;
                                    let loc = strut.getLocation();
                                    vertices.add(loc);
                                    loc = strut.getEnd();
                                    vertices.add(loc);
                                }
                            }
                        }
                        const sortedVertexList = (new java.util.ArrayList(vertices));
                        vertices = null;
                        this.output = new java.io.PrintWriter(writer);
                        const prelude = this.getBoilerplate("com/vzome/core/exporters/mesh-prelude.scad");
                        this.output.print(prelude);
                        this.output.println$java_lang_Object("vertices = [");
                        for (let index = sortedVertexList.iterator(); index.hasNext();) {
                            let vector = index.next();
                            {
                                const dv = this.mModel.renderVectorDouble(vector);
                                this.output.print("[ ");
                                this.output.print(OpenScadMeshExporter.FORMAT_$LI$().format(dv[0]) + ", ");
                                this.output.print(OpenScadMeshExporter.FORMAT_$LI$().format(dv[1]) + ", ");
                                this.output.println$java_lang_Object(OpenScadMeshExporter.FORMAT_$LI$().format(dv[2]) + " ],");
                            }
                        }
                        this.output.println$java_lang_Object("];");
                        this.output.println$();
                        this.output.println$java_lang_Object("edges = [");
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    const strut = man;
                                    this.output.println$java_lang_Object("[ " + sortedVertexList.indexOf(strut.getLocation()) + ", " + sortedVertexList.indexOf(strut.getEnd()) + " ],");
                                }
                            }
                        }
                        this.output.println$java_lang_Object("];");
                        const postlude = this.getBoilerplate("com/vzome/core/exporters/mesh-postlude.scad");
                        this.output.print(postlude);
                        this.output.flush();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "scad";
                    }
                }
                OpenScadMeshExporter.__static_initialized = false;
                exporters.OpenScadMeshExporter = OpenScadMeshExporter;
                OpenScadMeshExporter["__class"] = "com.vzome.core.exporters.OpenScadMeshExporter";
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class PythonBuild123dExporter extends com.vzome.core.exporters.GeometryExporter {
                    static __static_initialize() { if (!PythonBuild123dExporter.__static_initialized) {
                        PythonBuild123dExporter.__static_initialized = true;
                        PythonBuild123dExporter.__static_initializer_0();
                    } }
                    static FORMAT_$LI$() { PythonBuild123dExporter.__static_initialize(); if (PythonBuild123dExporter.FORMAT == null) {
                        PythonBuild123dExporter.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
                    } return PythonBuild123dExporter.FORMAT; }
                    static __static_initializer_0() {
                        PythonBuild123dExporter.FORMAT_$LI$().setMinimumFractionDigits(6);
                        PythonBuild123dExporter.FORMAT_$LI$().setMaximumFractionDigits(6);
                    }
                    /**
                     *
                     * @param {java.io.File} directory
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(directory, writer, height, width) {
                        let vertices = (new java.util.TreeSet());
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    const strut = man;
                                    let loc = strut.getLocation();
                                    vertices.add(loc);
                                    loc = strut.getEnd();
                                    vertices.add(loc);
                                }
                            }
                        }
                        const sortedVertexList = (new java.util.ArrayList(vertices));
                        vertices = null;
                        this.output = new java.io.PrintWriter(writer);
                        const prelude = this.getBoilerplate("com/vzome/core/exporters/mesh-prelude.py");
                        this.output.print(prelude);
                        this.output.println$java_lang_Object("vertices = [");
                        for (let index = sortedVertexList.iterator(); index.hasNext();) {
                            let vector = index.next();
                            {
                                const dv = this.mModel.renderVectorDouble(vector);
                                this.output.print("( ");
                                this.output.print(PythonBuild123dExporter.FORMAT_$LI$().format(dv[0]) + ", ");
                                this.output.print(PythonBuild123dExporter.FORMAT_$LI$().format(dv[1]) + ", ");
                                this.output.println$java_lang_Object(PythonBuild123dExporter.FORMAT_$LI$().format(dv[2]) + " ),");
                            }
                        }
                        this.output.println$java_lang_Object("]");
                        this.output.println$();
                        this.output.println$java_lang_Object("edges = [");
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    const strut = man;
                                    this.output.println$java_lang_Object("[ " + sortedVertexList.indexOf(strut.getLocation()) + ", " + sortedVertexList.indexOf(strut.getEnd()) + " ],");
                                }
                            }
                        }
                        this.output.println$java_lang_Object("]");
                        const postlude = this.getBoilerplate("com/vzome/core/exporters/mesh-postlude.py");
                        this.output.print(postlude);
                        this.output.flush();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "py";
                    }
                }
                PythonBuild123dExporter.__static_initialized = false;
                exporters.PythonBuild123dExporter = PythonBuild123dExporter;
                PythonBuild123dExporter["__class"] = "com.vzome.core.exporters.PythonBuild123dExporter";
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class DocumentExporter extends com.vzome.core.exporters.GeometryExporter {
                    constructor() {
                        super();
                        if (this.mLights === undefined) {
                            this.mLights = null;
                        }
                        if (this.mScene === undefined) {
                            this.mScene = null;
                        }
                    }
                    /**
                     * Subclasses can override this if they need to export history, the lesson model, or the selection.
                     * @param {*} doc
                     * @param {java.io.File} file
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    exportDocument(doc, file, writer, height, width) {
                        this.mScene = doc.getCameraModel();
                        this.mLights = doc.getSceneLighting();
                        this.exportGeometry(doc.getRenderedModel(), file, writer, height, width);
                        this.mScene = null;
                        this.mLights = null;
                    }
                }
                exporters.DocumentExporter = DocumentExporter;
                DocumentExporter["__class"] = "com.vzome.core.exporters.DocumentExporter";
                DocumentExporter["__interfaces"] = ["com.vzome.core.exporters.DocumentExporterIntf"];
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class PdbExporter extends com.vzome.core.exporters.GeometryExporter {
                    /**
                     *
                     * @param {java.io.File} directory
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(directory, writer, height, width) {
                        const atoms = (new java.util.HashMap());
                        const atomsList = (new java.util.ArrayList());
                        let indices = 0;
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    const startLoc = man.getLocation();
                                    const endLoc = man.getEnd();
                                    let startAtom = atoms.get(startLoc);
                                    if (startAtom == null) {
                                        startAtom = new PdbExporter.Atom(this, startLoc, ++indices);
                                        atoms.put(startLoc, startAtom);
                                        atomsList.add(startAtom);
                                    }
                                    let endAtom = atoms.get(endLoc);
                                    if (endAtom == null) {
                                        endAtom = new PdbExporter.Atom(this, endLoc, ++indices);
                                        atoms.put(endLoc, endAtom);
                                        atomsList.add(endAtom);
                                    }
                                    startAtom.neighbors.add(endAtom);
                                    endAtom.neighbors.add(startAtom);
                                }
                            }
                        }
                        const field = this.mModel.getField();
                        const scale = field['createAlgebraicNumber$int$int$int$int'](4, 6, 1, 0);
                        const scaleFactor = 5.0 / scale.evaluate();
                        const locations = new java.lang.StringBuilder();
                        const neighbors = new java.lang.StringBuilder();
                        for (let index = atomsList.iterator(); index.hasNext();) {
                            let atom = index.next();
                            {
                                const rv = this.mModel.renderVector(atom.location);
                                console.info(atom.location.toString());
                                locations.append(javaemul.internal.StringHelper.format("HETATM%5d He   UNK  0001     %7.3f %7.3f %7.3f\n", atom.index, rv.x * scaleFactor, rv.y * scaleFactor, rv.z * scaleFactor));
                                neighbors.append(javaemul.internal.StringHelper.format("CONECT%5d", atom.index));
                                for (let index = atom.neighbors.iterator(); index.hasNext();) {
                                    let neighbor = index.next();
                                    {
                                        neighbors.append(javaemul.internal.StringHelper.format("%5d", neighbor.index));
                                    }
                                }
                                neighbors.append("\n");
                            }
                        }
                        this.output = new java.io.PrintWriter(writer);
                        this.output.println$java_lang_Object("HEADER");
                        this.output.println$java_lang_Object("REMARK vZome");
                        this.output.print(locations);
                        this.output.print(neighbors);
                        this.output.println$java_lang_Object("END");
                        this.output.flush();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "pdb";
                    }
                }
                exporters.PdbExporter = PdbExporter;
                PdbExporter["__class"] = "com.vzome.core.exporters.PdbExporter";
                (function (PdbExporter) {
                    class Atom {
                        constructor(__parent, location, i) {
                            this.__parent = __parent;
                            if (this.location === undefined) {
                                this.location = null;
                            }
                            if (this.index === undefined) {
                                this.index = 0;
                            }
                            this.neighbors = (new java.util.HashSet());
                            this.location = location;
                            this.index = i;
                        }
                    }
                    PdbExporter.Atom = Atom;
                    Atom["__class"] = "com.vzome.core.exporters.PdbExporter.Atom";
                })(PdbExporter = exporters.PdbExporter || (exporters.PdbExporter = {}));
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class StlExporter extends com.vzome.core.exporters.GeometryExporter {
                    static FORMAT_$LI$() { if (StlExporter.FORMAT == null) {
                        StlExporter.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
                    } return StlExporter.FORMAT; }
                    /**
                     *
                     * @param {java.io.File} directory
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(directory, writer, height, width) {
                        if (StlExporter.FORMAT_$LI$() != null && StlExporter.FORMAT_$LI$() instanceof java.text.DecimalFormat) {
                            StlExporter.FORMAT_$LI$().applyPattern("0.000000E00");
                        }
                        const mmScaling = this.mModel.getCmScaling() * 10.0;
                        this.output = new java.io.PrintWriter(writer);
                        this.output.println$java_lang_Object("solid vcg");
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    const panel = man;
                                    const norm = this.mModel.renderVector(panel['getNormal$']()).normalize();
                                    let v0 = null;
                                    let v1 = null;
                                    for (let index = panel.iterator(); index.hasNext();) {
                                        let vert = index.next();
                                        {
                                            let vertex = this.mModel.renderVector(vert);
                                            vertex = vertex.scale(mmScaling);
                                            if (v0 == null)
                                                v0 = vertex;
                                            else if (v1 == null)
                                                v1 = vertex;
                                            else {
                                                this.output.print("  facet normal ");
                                                this.output.println$java_lang_Object(StlExporter.FORMAT_$LI$().format(norm.x) + " " + StlExporter.FORMAT_$LI$().format(norm.y) + " " + StlExporter.FORMAT_$LI$().format(norm.z));
                                                this.output.println$java_lang_Object("    outer loop");
                                                this.output.println$java_lang_Object("      vertex " + StlExporter.FORMAT_$LI$().format(v0.x) + " " + StlExporter.FORMAT_$LI$().format(v0.y) + " " + StlExporter.FORMAT_$LI$().format(v0.z));
                                                this.output.println$java_lang_Object("      vertex " + StlExporter.FORMAT_$LI$().format(v1.x) + " " + StlExporter.FORMAT_$LI$().format(v1.y) + " " + StlExporter.FORMAT_$LI$().format(v1.z));
                                                this.output.println$java_lang_Object("      vertex " + StlExporter.FORMAT_$LI$().format(vertex.x) + " " + StlExporter.FORMAT_$LI$().format(vertex.y) + " " + StlExporter.FORMAT_$LI$().format(vertex.z));
                                                this.output.println$java_lang_Object("    endloop");
                                                this.output.println$java_lang_Object("  endfacet");
                                                v1 = vertex;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        this.output.println$java_lang_Object("endsolid vcg");
                        this.output.flush();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "stl";
                    }
                }
                exporters.StlExporter = StlExporter;
                StlExporter["__class"] = "com.vzome.core.exporters.StlExporter";
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class VefExporter extends com.vzome.core.exporters.GeometryExporter {
                    /**
                     *
                     * @param {java.io.File} directory
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(directory, writer, height, width) {
                        const field = this.mModel.getField();
                        const exporter = new com.vzome.core.model.VefModelExporter(writer, field);
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                exporter.exportManifestation(man);
                            }
                        }
                        exporter.finish();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "vef";
                    }
                }
                exporters.VefExporter = VefExporter;
                VefExporter["__class"] = "com.vzome.core.exporters.VefExporter";
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class DxfExporter extends com.vzome.core.exporters.GeometryExporter {
                    /**
                     *
                     * @param {java.io.File} directory
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(directory, writer, height, width) {
                        this.output = new java.io.PrintWriter(writer);
                        this.output.println$java_lang_Object("0");
                        this.output.println$java_lang_Object("SECTION");
                        this.output.println$java_lang_Object("2");
                        this.output.println$java_lang_Object("ENTITIES");
                        const format = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
                        format.setMaximumFractionDigits(6);
                        const inchScaling = this.mModel.getCmScaling() / 2.54;
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    this.output.println$java_lang_Object("0");
                                    this.output.println$java_lang_Object("LINE");
                                    this.output.println$java_lang_Object("8");
                                    this.output.println$java_lang_Object("vZome");
                                    const start = man.getLocation();
                                    const end = man.getEnd();
                                    let rv = this.mModel.renderVector(start);
                                    rv = rv.scale(inchScaling);
                                    this.output.println$java_lang_Object("10");
                                    this.output.println$java_lang_Object(format.format(rv.x));
                                    this.output.println$java_lang_Object("20");
                                    this.output.println$java_lang_Object(format.format(rv.y));
                                    this.output.println$java_lang_Object("30");
                                    this.output.println$java_lang_Object(format.format(rv.z));
                                    rv = this.mModel.renderVector(end);
                                    rv = rv.scale(inchScaling);
                                    this.output.println$java_lang_Object("11");
                                    this.output.println$java_lang_Object(format.format(rv.x));
                                    this.output.println$java_lang_Object("21");
                                    this.output.println$java_lang_Object(format.format(rv.y));
                                    this.output.println$java_lang_Object("31");
                                    this.output.println$java_lang_Object(format.format(rv.z));
                                }
                            }
                        }
                        this.output.println$java_lang_Object("0");
                        this.output.println$java_lang_Object("ENDSEC");
                        this.output.println$java_lang_Object("0");
                        this.output.println$java_lang_Object("EOF");
                        this.output.flush();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "dxf";
                    }
                }
                exporters.DxfExporter = DxfExporter;
                DxfExporter["__class"] = "com.vzome.core.exporters.DxfExporter";
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class SegExporter extends com.vzome.core.exporters.GeometryExporter {
                    constructor() {
                        super();
                        this.vertexData = (new java.util.HashMap());
                        if (this.vertices === undefined) {
                            this.vertices = null;
                        }
                        if (this.struts === undefined) {
                            this.struts = null;
                        }
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        this.format = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
                    }
                    /**
                     *
                     * @param {java.io.File} directory
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(directory, writer, height, width) {
                        this.field = this.mModel.getField();
                        this.vertices = new java.lang.StringBuffer();
                        this.struts = new java.lang.StringBuffer();
                        if (this.format != null && this.format instanceof java.text.DecimalFormat) {
                            this.format.applyPattern("0.0000");
                        }
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    const strut = man;
                                    this.struts.append("s ");
                                    this.struts.append(this.getVertexIndex(strut.getLocation()));
                                    this.struts.append(" ");
                                    this.struts.append(this.getVertexIndex(strut.getEnd()));
                                    this.struts.append("\n");
                                }
                            }
                        }
                        writer.append(this.vertices.toString());
                        writer.append(this.struts.toString());
                        writer.close();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "seg";
                    }
                    getVertexIndex(vertexVector) {
                        let val = this.vertexData.get(vertexVector);
                        if (val == null) {
                            const key = vertexVector;
                            const index = this.vertexData.size();
                            val = index;
                            this.vertexData.put(key, val);
                            this.vertices.append("v ");
                            const vertex = this.mModel.renderVector(vertexVector);
                            this.vertices.append(this.format.format(vertex.x) + " ");
                            this.vertices.append(this.format.format(vertex.y) + " ");
                            this.vertices.append(this.format.format(vertex.z) + " ");
                            this.vertices.append("\n");
                        }
                        return val;
                    }
                }
                exporters.SegExporter = SegExporter;
                SegExporter["__class"] = "com.vzome.core.exporters.SegExporter";
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                /**
                 * @author vorth
                 * @class
                 * @extends com.vzome.core.exporters.GeometryExporter
                 */
                class VRMLExporter extends com.vzome.core.exporters.GeometryExporter {
                    /*private*/ exportColor(name, color) {
                        this.output.println$java_lang_Object("PROTO " + name + " [] {");
                        this.output.print("    Appearance { material Material { diffuseColor ");
                        const rgb = color.getRGBColorComponents([0, 0, 0]);
                        this.output.print(rgb[0] + " ");
                        this.output.print(rgb[1] + " ");
                        this.output.print(rgb[2]);
                        this.output.println$java_lang_Object(" }}}");
                    }
                    /**
                     *
                     * @param {java.io.File} directory
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(directory, writer, height, width) {
                        this.output = new java.io.PrintWriter(writer);
                        this.output.println$java_lang_Object(this.getBoilerplate(VRMLExporter.PREAMBLE_FILE));
                        this.output.println$();
                        let field = null;
                        const instances = new java.lang.StringBuffer();
                        let numShapes = 0;
                        const shapes = (new java.util.HashMap());
                        const colors = (new java.util.HashMap());
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const shape = rm.getShape();
                                if (field == null)
                                    field = shape.getField();
                                let shapeName = shapes.get(shape);
                                if (shapeName == null) {
                                    shapeName = "shape" + numShapes++;
                                    shapes.put(shape, shapeName);
                                    this.exportShape(shapeName, shape);
                                }
                                const transform = rm.getOrientation();
                                const mx = this.mModel.renderVector(transform.timesRow(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X)));
                                const my = this.mModel.renderVector(transform.timesRow(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y)));
                                const mz = this.mModel.renderVector(transform.timesRow(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z)));
                                let x = (Math.fround(mz.y - my.z));
                                let y = (Math.fround(mx.z - mz.x));
                                let z = (Math.fround(my.x - mx.y));
                                const cos = (Math.fround(Math.fround(mx.x + my.y) + mz.z) - 1.0) * 0.5;
                                const sin = 0.5 * Math.sqrt(x * x + y * y + z * z);
                                const angle = Math.fround(Math.atan2(sin, cos));
                                if (Math.abs(angle - Math.PI) < 1.0E-5) {
                                    if ((mx.x >= my.y) && (mx.x >= mz.z)) {
                                        x = Math.sqrt(Math.fround(Math.fround(mx.x - my.y) - mz.z) + 1.0) * 0.5;
                                        y = mx.y / (2.0 * x);
                                        z = mx.z / (2.0 * x);
                                    }
                                    else if ((my.y >= mz.z) && (my.y >= mx.x)) {
                                        y = Math.sqrt(Math.fround(Math.fround(my.y - mx.x) - mz.z) + 1.0) * 0.5;
                                        x = mx.y / (2.0 * y);
                                        z = my.z / (2.0 * y);
                                    }
                                    else {
                                        z = Math.sqrt(Math.fround(Math.fround(mz.z - my.y) - mx.x) + 1.0) * 0.5;
                                        x = mx.z / (2.0 * z);
                                        y = my.z / (2.0 * z);
                                    }
                                }
                                let color = rm.getColor();
                                if (color == null) {
                                    color = com.vzome.core.construction.Color.WHITE_$LI$();
                                }
                                let colorName = colors.get(color);
                                if (colorName == null) {
                                    colorName = "color_" + /* replace */ color.toString().split(',').join('_');
                                    colors.put(color, colorName);
                                    this.exportColor(colorName, color);
                                }
                                instances.append("Transform { translation ");
                                instances.append(rm.getLocation().scale(VRMLExporter.SCALE).spacedString());
                                instances.append(" rotation " + x + " " + y + " " + z + " " + angle);
                                instances.append(" children[ Shape{ geometry " + shapeName + "{} appearance " + colorName + "{}}]}\n");
                            }
                        }
                        this.output.println$java_lang_Object(instances.toString());
                        this.output.flush();
                        this.output.close();
                    }
                    /*private*/ exportShape(shapeName, poly) {
                        this.output.println$java_lang_Object("PROTO " + shapeName + " [] { IndexedFaceSet{ solid FALSE convex FALSE colorPerVertex FALSE");
                        this.output.println$java_lang_Object("   coord Coordinate{ point [");
                        for (let index = poly.getVertexList().iterator(); index.hasNext();) {
                            let gv = index.next();
                            {
                                const v = this.mModel.renderVector(gv);
                                this.output.println$java_lang_Object(v.scale(VRMLExporter.SCALE).spacedString() + ",");
                            }
                        }
                        this.output.println$java_lang_Object("] } coordIndex [");
                        for (let index = poly.getFaceSet().iterator(); index.hasNext();) {
                            let face = index.next();
                            {
                                const arity = face.size();
                                for (let j = 0; j < arity; j++) {
                                    {
                                        const index = face.get(j);
                                        this.output.print(index + ", ");
                                    }
                                    ;
                                }
                                this.output.println$java_lang_Object("-1,");
                            }
                        }
                        this.output.println$java_lang_Object("]}}");
                        this.output.flush();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "wrl";
                    }
                }
                VRMLExporter.PREAMBLE_FILE = "com/vzome/core/exporters/vrml/preamble.wrl";
                VRMLExporter.SCALE = 0.35;
                exporters.VRMLExporter = VRMLExporter;
                VRMLExporter["__class"] = "com.vzome.core.exporters.VRMLExporter";
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class ZomicVirtualMachine extends com.vzome.core.render.AbstractZomicEventHandler {
                    constructor(start, effects, symm) {
                        super(symm);
                        if (this.mLocation === undefined) {
                            this.mLocation = null;
                        }
                        if (this.mEffects === undefined) {
                            this.mEffects = null;
                        }
                        this.mLocation = start;
                        this.mEffects = effects;
                    }
                    getLocation() {
                        return this.mLocation.getLocation();
                    }
                    /**
                     * @return
                     * @return {com.vzome.core.construction.Construction}
                     */
                    getLastPoint() {
                        return this.mLocation;
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Axis} axis
                     * @param {*} length
                     */
                    step(axis, length) {
                        axis = this.mOrientation.permute(axis, this.mHandedNess);
                        length = length['times$com_vzome_core_algebra_AlgebraicNumber'](this.mScale);
                        const segment = new com.vzome.core.construction.AnchoredSegment(axis, length, this.mLocation);
                        const pt2 = new com.vzome.core.construction.SegmentEndPoint(segment);
                        if (this.mAction !== com.vzome.core.render.ZomicEventHandler.JUST_MOVE) {
                            this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](this.mLocation);
                            this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](segment);
                            this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](pt2);
                        }
                        this.mLocation = pt2;
                    }
                    /**
                     *
                     * @return {com.vzome.core.render.AbstractZomicEventHandler}
                     */
                    copyLocation() {
                        return new ZomicVirtualMachine(this.mLocation, this.mEffects, this.mSymmetry);
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.AbstractZomicEventHandler} changed
                     */
                    restoreLocation(changed) {
                        this.mLocation = changed.mLocation;
                    }
                }
                commands.ZomicVirtualMachine = ZomicVirtualMachine;
                ZomicVirtualMachine["__class"] = "com.vzome.core.commands.ZomicVirtualMachine";
                ZomicVirtualMachine["__interfaces"] = ["com.vzome.core.render.ZomicEventHandler"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var viewing;
            (function (viewing) {
                class DodecagonalShapes extends com.vzome.core.viewing.AbstractShapes {
                    constructor(pkgName, name, alias, symm) {
                        super(pkgName, name, alias, symm);
                        if (this.V0 === undefined) {
                            this.V0 = null;
                        }
                        if (this.V1 === undefined) {
                            this.V1 = null;
                        }
                        if (this.V2 === undefined) {
                            this.V2 = null;
                        }
                        if (this.V3 === undefined) {
                            this.V3 = null;
                        }
                        if (this.V4 === undefined) {
                            this.V4 = null;
                        }
                        if (this.V5 === undefined) {
                            this.V5 = null;
                        }
                        if (this.TWO === undefined) {
                            this.TWO = null;
                        }
                        if (this.GREEN === undefined) {
                            this.GREEN = null;
                        }
                        if (this.V6 === undefined) {
                            this.V6 = null;
                        }
                        if (this.V7 === undefined) {
                            this.V7 = null;
                        }
                        const field = symm.getField();
                        this.V0 = field.createVector([[1, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1]]);
                        this.V1 = field.createVector([[1, 2, 0, 1], [0, 1, 1, 2], [0, 1, 0, 1]]);
                        this.V2 = field.createVector([[-1, 2, 0, 1], [0, 1, 1, 2], [0, 1, 0, 1]]);
                        this.V3 = field.createVector([[-1, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1]]);
                        this.V4 = field.createVector([[-1, 2, 0, 1], [0, 1, -1, 2], [0, 1, 0, 1]]);
                        this.V5 = field.createVector([[1, 2, 0, 1], [0, 1, -1, 2], [0, 1, 0, 1]]);
                        this.TWO = field.createVector([[2, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1]]);
                        this.GREEN = field.createVector([[1, 1, 1, 2], [1, 2, 0, 1], [0, 1, 0, 1]]);
                        this.V6 = field.createVector([[1, 1, 0, 1], [0, 1, 1, 3], [0, 1, 0, 1]]);
                        this.V7 = field.createVector([[0, 1, 2, 3], [0, 1, 0, 1], [0, 1, 0, 1]]);
                    }
                    /**
                     *
                     * @param {string} pkgName
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    buildConnectorShape(pkgName) {
                        const hex = new com.vzome.core.math.Polyhedron(this.mSymmetry.getField());
                        hex.addVertex(this.V0);
                        hex.addVertex(this.V1);
                        hex.addVertex(this.V2);
                        hex.addVertex(this.V3);
                        hex.addVertex(this.V4);
                        hex.addVertex(this.V5);
                        let face = hex.newFace();
                        face.add(0);
                        face.add(1);
                        face.add(2);
                        face.add(3);
                        face.add(4);
                        face.add(5);
                        hex.addFace(face);
                        face = hex.newFace();
                        face.add(5);
                        face.add(4);
                        face.add(3);
                        face.add(2);
                        face.add(1);
                        face.add(0);
                        hex.addFace(face);
                        return hex;
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} dir
                     * @return {*}
                     */
                    createStrutGeometry(dir) {
                        if (dir.getName() === ("blue"))
                            return new DodecagonalShapes.BlueStrutGeometry(this);
                        else if (dir.getName() === ("green"))
                            return new DodecagonalShapes.GreenStrutGeometry(this);
                        else
                            return super.createStrutGeometry(dir);
                    }
                }
                viewing.DodecagonalShapes = DodecagonalShapes;
                DodecagonalShapes["__class"] = "com.vzome.core.viewing.DodecagonalShapes";
                DodecagonalShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];
                (function (DodecagonalShapes) {
                    class BlueStrutGeometry {
                        constructor(__parent) {
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @param {*} length
                         * @return {com.vzome.core.math.Polyhedron}
                         */
                        getStrutPolyhedron(length) {
                            const field = this.__parent.mSymmetry.getField();
                            const hex = new com.vzome.core.math.Polyhedron(field);
                            const strut = field.basisVector(3, 0).scale(length);
                            const THIRD = field['createRational$long$long'](1, 3);
                            hex.addVertex(strut.plus(this.__parent.V5.scale(THIRD).minus(this.__parent.TWO)));
                            hex.addVertex(strut.plus(this.__parent.V0.scale(THIRD).minus(this.__parent.TWO)));
                            hex.addVertex(strut.plus(this.__parent.V1.scale(THIRD).minus(this.__parent.TWO)));
                            hex.addVertex(this.__parent.V2.scale(THIRD).plus(this.__parent.TWO));
                            hex.addVertex(this.__parent.V3.scale(THIRD).plus(this.__parent.TWO));
                            hex.addVertex(this.__parent.V4.scale(THIRD).plus(this.__parent.TWO));
                            let face = hex.newFace();
                            face.add(0);
                            face.add(1);
                            face.add(2);
                            face.add(3);
                            face.add(4);
                            face.add(5);
                            hex.addFace(face);
                            face = hex.newFace();
                            face.add(5);
                            face.add(4);
                            face.add(3);
                            face.add(2);
                            face.add(1);
                            face.add(0);
                            hex.addFace(face);
                            return hex;
                        }
                    }
                    DodecagonalShapes.BlueStrutGeometry = BlueStrutGeometry;
                    BlueStrutGeometry["__class"] = "com.vzome.core.viewing.DodecagonalShapes.BlueStrutGeometry";
                    BlueStrutGeometry["__interfaces"] = ["com.vzome.core.parts.StrutGeometry"];
                    class GreenStrutGeometry {
                        constructor(__parent) {
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @param {*} length
                         * @return {com.vzome.core.math.Polyhedron}
                         */
                        getStrutPolyhedron(length) {
                            const field = this.__parent.mSymmetry.getField();
                            const vector = this.__parent.GREEN.scale(length);
                            const hex = new com.vzome.core.math.Polyhedron(field);
                            hex.addVertex(vector.plus(this.__parent.GREEN.plus(this.__parent.V6)).negate());
                            hex.addVertex(vector.plus(this.__parent.GREEN.negate()));
                            hex.addVertex(vector.plus(this.__parent.GREEN.plus(this.__parent.V7).negate()));
                            hex.addVertex(this.__parent.V6.plus(this.__parent.GREEN));
                            hex.addVertex(this.__parent.GREEN);
                            hex.addVertex(this.__parent.V7.plus(this.__parent.GREEN));
                            let face = hex.newFace();
                            face.add(0);
                            face.add(1);
                            face.add(2);
                            face.add(3);
                            face.add(4);
                            face.add(5);
                            hex.addFace(face);
                            face = hex.newFace();
                            face.add(5);
                            face.add(4);
                            face.add(3);
                            face.add(2);
                            face.add(1);
                            face.add(0);
                            hex.addFace(face);
                            return hex;
                        }
                    }
                    DodecagonalShapes.GreenStrutGeometry = GreenStrutGeometry;
                    GreenStrutGeometry["__class"] = "com.vzome.core.viewing.DodecagonalShapes.GreenStrutGeometry";
                    GreenStrutGeometry["__interfaces"] = ["com.vzome.core.parts.StrutGeometry"];
                })(DodecagonalShapes = viewing.DodecagonalShapes || (viewing.DodecagonalShapes = {}));
            })(viewing = core.viewing || (core.viewing = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var viewing;
            (function (viewing) {
                /**
                 * @author David Hall
                 * @param {string} pkgName
                 * @param {string} name
                 * @param {com.vzome.core.math.symmetry.AntiprismSymmetry} symm
                 * @class
                 * @extends com.vzome.core.viewing.AbstractShapes
                 */
                class AntiprismShapes extends com.vzome.core.viewing.AbstractShapes {
                    constructor(pkgName, name, symm) {
                        super(pkgName, name, null, symm);
                    }
                    /**
                     *
                     * @return {com.vzome.core.math.symmetry.AntiprismSymmetry}
                     */
                    getSymmetry() {
                        return super.getSymmetry();
                    }
                    /**
                     *
                     * @param {string} pkgName
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    buildConnectorShape(pkgName) {
                        const symm = this.getSymmetry();
                        const field = symm.getField();
                        const nSides = field.polygonSides();
                        const antiprism = new com.vzome.core.math.Polyhedron(field);
                        const topX = field.one();
                        const topY = field.zero();
                        const maxTerm = field.getUnitDiagonal(field.diagonalCount() - 1);
                        const botX = field.getUnitDiagonal(field.diagonalCount() - 2).dividedBy(maxTerm);
                        const botY = maxTerm.reciprocal();
                        const halfHeight = (pkgName === "thin") ? field.getUnitDiagonal(field.diagonalCount() - 1).reciprocal() : field.one();
                        const rotationMatrix = symm.getRotationMatrix();
                        let vTop = new com.vzome.core.algebra.AlgebraicVector(topX, topY, halfHeight);
                        let vBot = new com.vzome.core.algebra.AlgebraicVector(botX, botY, halfHeight.negate());
                        for (let i = 0; i < nSides; i++) {
                            {
                                antiprism.addVertex(vTop);
                                antiprism.addVertex(vBot);
                                vTop = rotationMatrix.timesColumn(vTop);
                                vBot = rotationMatrix.timesColumn(vBot);
                            }
                            ;
                        }
                        const topFace = antiprism.newFace();
                        const botFace = antiprism.newFace();
                        for (let i = 0; i < nSides * 2; i += 2) {
                            {
                                topFace.add(i);
                            }
                            ;
                        }
                        for (let i = nSides * 2 - 1; i >= 0; i -= 2) {
                            {
                                botFace.add(i);
                            }
                            ;
                        }
                        antiprism.addFace(topFace);
                        antiprism.addFace(botFace);
                        const nVertices = nSides * 2;
                        for (let i = 0; i < nSides * 2; i += 2) {
                            {
                                const face = antiprism.newFace();
                                face.add(i);
                                face.add((i + 1) % nVertices);
                                face.add((i + 2) % nVertices);
                                antiprism.addFace(face);
                            }
                            ;
                        }
                        for (let i = 1; i < nSides * 2; i += 2) {
                            {
                                const face = antiprism.newFace();
                                face.add(i);
                                face.add((i + 2) % nVertices);
                                face.add((i + 1) % nVertices);
                                antiprism.addFace(face);
                            }
                            ;
                        }
                        return antiprism;
                    }
                }
                viewing.AntiprismShapes = AntiprismShapes;
                AntiprismShapes["__class"] = "com.vzome.core.viewing.AntiprismShapes";
                AntiprismShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];
            })(viewing = core.viewing || (core.viewing = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var viewing;
            (function (viewing) {
                class OctahedralShapes extends com.vzome.core.viewing.AbstractShapes {
                    constructor(pkgName, name, symm) {
                        super(pkgName, name, null, symm);
                    }
                    /**
                     *
                     * @param {string} pkgName
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    buildConnectorShape(pkgName) {
                        const field = this.mSymmetry.getField();
                        const cube = new com.vzome.core.math.Polyhedron(field);
                        let scale = field['createPower$int'](-2);
                        scale = field['createRational$long'](2)['times$com_vzome_core_algebra_AlgebraicNumber'](scale);
                        const x = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                        const y = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
                        const z = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                        cube.addVertex(x.scale(scale));
                        cube.addVertex(x.negate().scale(scale));
                        cube.addVertex(y.scale(scale));
                        cube.addVertex(y.negate().scale(scale));
                        cube.addVertex(z.scale(scale));
                        cube.addVertex(z.negate().scale(scale));
                        let face = cube.newFace();
                        face.add(0);
                        face.add(2);
                        face.add(4);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(0);
                        face.add(5);
                        face.add(2);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(0);
                        face.add(3);
                        face.add(5);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(0);
                        face.add(4);
                        face.add(3);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(1);
                        face.add(4);
                        face.add(2);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(1);
                        face.add(2);
                        face.add(5);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(1);
                        face.add(5);
                        face.add(3);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(1);
                        face.add(3);
                        face.add(4);
                        cube.addFace(face);
                        return cube;
                    }
                }
                viewing.OctahedralShapes = OctahedralShapes;
                OctahedralShapes["__class"] = "com.vzome.core.viewing.OctahedralShapes";
                OctahedralShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];
            })(viewing = core.viewing || (core.viewing = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                /**
                 * Implements the Zomic execution model while visiting a program.
                 *
                 * @author Scott Vorthmann 2003
                 * @param {*} renderer
                 * @param {*} symmetry
                 * @class
                 * @extends com.vzome.core.zomic.program.Visitor.Default
                 */
                class Interpreter extends com.vzome.core.zomic.program.Visitor.Default {
                    constructor(renderer, symmetry) {
                        super();
                        if (this.mEvents === undefined) {
                            this.mEvents = null;
                        }
                        if (this.mSymmetry === undefined) {
                            this.mSymmetry = null;
                        }
                        this.mEvents = renderer;
                        this.mSymmetry = symmetry;
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Axis} axis
                     * @param {*} length
                     */
                    visitMove(axis, length) {
                        this.mEvents.step(axis, length);
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Axis} axis
                     * @param {number} steps
                     */
                    visitRotate(axis, steps) {
                        this.mEvents.rotate(axis, steps);
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Axis} blueAxis
                     */
                    visitReflect(blueAxis) {
                        this.mEvents.reflect(blueAxis);
                    }
                    /**
                     *
                     * @param {com.vzome.core.zomic.program.Symmetry} model
                     * @param {com.vzome.core.zomic.program.Permute} permute
                     */
                    visitSymmetry(model, permute) {
                        if (permute != null) {
                            const repetitions = permute.getOrder();
                            if (repetitions === 1)
                                throw new java.lang.RuntimeException("no rotation symmetry around extended axes");
                            for (let i = 0; i < repetitions; i++) {
                                {
                                    this.saveAndNest(model, com.vzome.core.render.ZomicEventHandler.ORIENTATION);
                                    permute.accept(this);
                                }
                                ;
                            }
                        }
                        else {
                            for (let i = 0; i < this.mSymmetry.getChiralOrder(); i++) {
                                {
                                    const current = this.mSymmetry.getPermutation(i);
                                    const saved = this.mEvents;
                                    this.mEvents = this.mEvents.save(com.vzome.core.render.ZomicEventHandler.ALL);
                                    this.mEvents.permute(current, com.vzome.core.math.symmetry.Symmetry.PLUS);
                                    try {
                                        this.visitNested(model);
                                    }
                                    catch (e) {
                                        throw new java.lang.RuntimeException("error in global symmetry");
                                    }
                                    saved.restore(this.mEvents, com.vzome.core.render.ZomicEventHandler.ALL);
                                    this.mEvents = saved;
                                }
                                ;
                            }
                        }
                    }
                    /*private*/ saveAndNest(stmt, state) {
                        const saved = this.mEvents;
                        this.mEvents = this.mEvents.save(state);
                        this.visitNested(stmt);
                        saved.restore(this.mEvents, state);
                        this.mEvents = saved;
                    }
                    /**
                     *
                     * @param {com.vzome.core.zomic.program.Save} stmt
                     * @param {number} state
                     */
                    visitSave(stmt, state) {
                        this.saveAndNest(stmt, state);
                    }
                    /**
                     *
                     * @param {*} size
                     */
                    visitScale(size) {
                        this.mEvents.scale(size);
                    }
                    /**
                     *
                     * @param {boolean} build
                     * @param {boolean} destroy
                     */
                    visitBuild(build, destroy) {
                        let action = com.vzome.core.render.ZomicEventHandler.JUST_MOVE;
                        if (build)
                            action |= com.vzome.core.render.ZomicEventHandler.BUILD;
                        if (destroy)
                            action |= com.vzome.core.render.ZomicEventHandler.DESTROY;
                        this.mEvents.action(action);
                    }
                }
                zomic.Interpreter = Interpreter;
                Interpreter["__class"] = "com.vzome.core.zomic.Interpreter";
                Interpreter["__interfaces"] = ["com.vzome.core.zomic.program.Visitor"];
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    /**
                     * Description here.
                     *
                     * @author Scott Vorthmann 2003
                     * @param {boolean} build
                     * @param {boolean} destroy
                     * @class
                     * @extends com.vzome.core.zomic.program.ZomicStatement
                     */
                    class Build extends com.vzome.core.zomic.program.ZomicStatement {
                        constructor(build, destroy) {
                            super();
                            if (this.m_build === undefined) {
                                this.m_build = false;
                            }
                            if (this.m_destroy === undefined) {
                                this.m_destroy = false;
                            }
                            this.m_build = build;
                            this.m_destroy = destroy;
                        }
                        /**
                         *
                         * @param {*} visitor
                         */
                        accept(visitor) {
                            visitor.visitBuild(this.m_build, this.m_destroy);
                        }
                        setBuild(value) {
                            this.m_build = value;
                        }
                        setDestroy(value) {
                            this.m_destroy = value;
                        }
                        justMoving() {
                            return this.m_build === this.m_destroy;
                        }
                    }
                    program.Build = Build;
                    Build["__class"] = "com.vzome.core.zomic.program.Build";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    /**
                     * @author vorth
                     * @param {string} id
                     * @class
                     * @extends com.vzome.core.zomic.program.ZomicStatement
                     */
                    class Label extends com.vzome.core.zomic.program.ZomicStatement {
                        constructor(id) {
                            super();
                            if (this.mLabel === undefined) {
                                this.mLabel = null;
                            }
                            this.mLabel = id;
                        }
                        /**
                         *
                         * @param {*} visitor
                         */
                        accept(visitor) {
                            visitor.visitLabel(this.mLabel);
                        }
                    }
                    program.Label = Label;
                    Label["__class"] = "com.vzome.core.zomic.program.Label";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    /**
                     * @author vorth
                     * @param {com.vzome.core.math.symmetry.Axis} axis
                     * @class
                     * @extends com.vzome.core.zomic.program.ZomicStatement
                     */
                    class Permute extends com.vzome.core.zomic.program.ZomicStatement {
                        constructor(axis) {
                            super();
                            if (this.m_axis === undefined) {
                                this.m_axis = null;
                            }
                            this.m_axis = axis;
                        }
                        setAxis(axis) {
                            this.m_axis = axis;
                        }
                        getOrder() {
                            if (this.m_axis == null)
                                return 2;
                            return this.m_axis.getRotationPermutation().getOrder();
                        }
                        getAxis() {
                            return this.m_axis;
                        }
                    }
                    program.Permute = Permute;
                    Permute["__class"] = "com.vzome.core.zomic.program.Permute";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    /**
                     * @author vorth
                     * @param {string} msg
                     * @class
                     * @extends com.vzome.core.zomic.program.ZomicStatement
                     */
                    class Untranslatable extends com.vzome.core.zomic.program.ZomicStatement {
                        constructor(msg) {
                            super();
                            if (this.message === undefined) {
                                this.message = null;
                            }
                            this.message = msg;
                        }
                        setMessage(msg) {
                            this.message = msg;
                        }
                        /**
                         *
                         * @param {*} visitor
                         */
                        accept(visitor) {
                            visitor.visitUntranslatable(this.message == null ? "" : this.message);
                        }
                    }
                    program.Untranslatable = Untranslatable;
                    Untranslatable["__class"] = "com.vzome.core.zomic.program.Untranslatable";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    class Nested extends com.vzome.core.zomic.program.ZomicStatement {
                        constructor() {
                            super();
                            if (this.m_body === undefined) {
                                this.m_body = null;
                            }
                        }
                        /**
                         *
                         * @param {*} visitor
                         */
                        accept(visitor) {
                            visitor.visitNested(this);
                        }
                        setBody(body) {
                            this.m_body = body;
                        }
                        getBody() {
                            return this.m_body;
                        }
                    }
                    program.Nested = Nested;
                    Nested["__class"] = "com.vzome.core.zomic.program.Nested";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    class Move extends com.vzome.core.zomic.program.ZomicStatement {
                        constructor(axis, len) {
                            super();
                            if (this.axis === undefined) {
                                this.axis = null;
                            }
                            if (this.length === undefined) {
                                this.length = null;
                            }
                            this.axis = axis;
                            this.length = len;
                        }
                        /**
                         *
                         * @param {*} visitor
                         */
                        accept(visitor) {
                            visitor.visitMove(this.axis, this.length);
                        }
                        /**
                         * @return
                         * @return {*}
                         */
                        getLength() {
                            return this.length;
                        }
                        getAxis() {
                            return this.axis;
                        }
                        /**
                         * Needed only for Zomic XMLS2AST.  TODO: remove this by
                         * rearranging the XML?
                         * @param axis2
                         * @param {*} len
                         * @param {com.vzome.core.math.symmetry.Axis} axis
                         */
                        reset(axis, len) {
                            this.axis = axis;
                            this.length = len;
                        }
                    }
                    program.Move = Move;
                    Move["__class"] = "com.vzome.core.zomic.program.Move";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    class Walk extends com.vzome.core.zomic.program.ZomicStatement {
                        constructor() {
                            super();
                            this.stmts = (new java.util.ArrayList());
                        }
                        /**
                         *
                         * @param {*} visitor
                         */
                        accept(visitor) {
                            visitor.visitWalk(this);
                        }
                        addStatement(stmt) {
                            this.stmts.add(stmt);
                        }
                        /**
                         *
                         * @return {*}
                         */
                        iterator() {
                            return this.stmts.iterator();
                        }
                        size() {
                            return this.stmts.size();
                        }
                    }
                    program.Walk = Walk;
                    Walk["__class"] = "com.vzome.core.zomic.program.Walk";
                    Walk["__interfaces"] = ["java.lang.Iterable"];
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    class Scale extends com.vzome.core.zomic.program.ZomicStatement {
                        constructor(size) {
                            super();
                            if (this.m_scale === undefined) {
                                this.m_scale = null;
                            }
                            this.m_scale = size;
                        }
                        /**
                         *
                         * @param {*} visitor
                         */
                        accept(visitor) {
                            visitor.visitScale(this.m_scale);
                        }
                    }
                    program.Scale = Scale;
                    Scale["__class"] = "com.vzome.core.zomic.program.Scale";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                class GreenDirectionNaming extends com.vzome.core.math.symmetry.DirectionNaming {
                    constructor(dir, reds, yellows) {
                        super(dir, dir.getName());
                        if (this.mMap === undefined) {
                            this.mMap = null;
                        }
                        if (this.mRedNames === undefined) {
                            this.mRedNames = null;
                        }
                        if (this.mYellowNames === undefined) {
                            this.mYellowNames = null;
                        }
                        this.mRedNames = reds;
                        this.mYellowNames = yellows;
                        this.mMap = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(dir.getSymmetry().getChiralOrder());
                        for (let i = 0; i < this.mMap.length; i++) {
                            {
                                let axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, i);
                                const ry = this.getName$com_vzome_core_math_symmetry_Axis(axis);
                                const sense = this.getSign(ry);
                                const index = this.getInteger(ry);
                                if (sense === com.vzome.core.math.symmetry.Symmetry.MINUS)
                                    axis = dir.getAxis$int$int(sense, i);
                                this.mMap[index] = axis;
                            }
                            ;
                        }
                    }
                    /**
                     *
                     * @param {string} axisName
                     * @return {com.vzome.core.math.symmetry.Axis}
                     */
                    getAxis(axisName) {
                        const sense = this.getSign(axisName);
                        const ry = this.getInteger(axisName);
                        let axis = this.mMap[ry];
                        if (sense === com.vzome.core.math.symmetry.Symmetry.MINUS)
                            axis = this.getDirection().getAxis$int$int(sense, axis.getOrientation());
                        return axis;
                    }
                    getName$com_vzome_core_math_symmetry_Axis(axis) {
                        const redNeighbor = this.mRedNames.getDirection().getAxis$int$int(axis.getSense(), axis.getOrientation());
                        const redName = this.mRedNames.getName$com_vzome_core_math_symmetry_Axis(redNeighbor);
                        const yellowNeighbor = this.mYellowNames.getDirection().getAxis$int$int(axis.getSense(), axis.getOrientation());
                        const yellowName = this.mYellowNames.getName$com_vzome_core_math_symmetry_Axis(yellowNeighbor).substring(1);
                        return redName + yellowName;
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Axis} axis
                     * @return {string}
                     */
                    getName(axis) {
                        if (((axis != null && axis instanceof com.vzome.core.math.symmetry.Axis) || axis === null)) {
                            return this.getName$com_vzome_core_math_symmetry_Axis(axis);
                        }
                        else if (axis === undefined) {
                            return this.getName$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                zomic.GreenDirectionNaming = GreenDirectionNaming;
                GreenDirectionNaming["__class"] = "com.vzome.core.zomic.GreenDirectionNaming";
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                class BlackDirectionNaming extends com.vzome.core.math.symmetry.DirectionNaming {
                    constructor(dir, reds, yellows) {
                        super(dir, dir.getName());
                        if (this.mMap === undefined) {
                            this.mMap = null;
                        }
                        if (this.mRedNames === undefined) {
                            this.mRedNames = null;
                        }
                        if (this.mYellowNames === undefined) {
                            this.mYellowNames = null;
                        }
                        this.mRedNames = reds;
                        this.mYellowNames = yellows;
                        this.mMap = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return null;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([2, dir.getSymmetry().getChiralOrder()]);
                        for (let sense = com.vzome.core.math.symmetry.Symmetry.PLUS; sense <= com.vzome.core.math.symmetry.Symmetry.MINUS; sense++) {
                            for (let i = 0; i < this.mMap[com.vzome.core.math.symmetry.Symmetry.PLUS].length; i++) {
                                {
                                    const axis = dir.getAxis$int$int(sense, i);
                                    const ry = this.getName$com_vzome_core_math_symmetry_Axis(axis);
                                    if (this.getSign(ry) === com.vzome.core.math.symmetry.Symmetry.MINUS)
                                        continue;
                                    const minused = ((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(ry, "-");
                                    const index = this.getInteger(ry);
                                    const sign = minused ? com.vzome.core.math.symmetry.Symmetry.MINUS : com.vzome.core.math.symmetry.Symmetry.PLUS;
                                    this.mMap[sign][index] = axis;
                                }
                                ;
                            }
                            ;
                        }
                    }
                    /**
                     *
                     * @param {string} axisName
                     * @return {number}
                     */
                    getInteger(axisName) {
                        if ( /* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(axisName, "-") || /* endsWith */ ((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(axisName, "+"))
                            axisName = axisName.substring(0, axisName.length - 1);
                        if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "-") || /* startsWith */ ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "+"))
                            return javaemul.internal.IntegerHelper.parseInt(axisName.substring(1));
                        return javaemul.internal.IntegerHelper.parseInt(axisName);
                    }
                    /**
                     *
                     * @param {string} axisName
                     * @return {com.vzome.core.math.symmetry.Axis}
                     */
                    getAxis(axisName) {
                        const minused = ((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(axisName, "-");
                        const sense = this.getSign(axisName);
                        const ry = this.getInteger(axisName);
                        let axis = this.mMap[minused ? com.vzome.core.math.symmetry.Symmetry.MINUS : com.vzome.core.math.symmetry.Symmetry.PLUS][ry];
                        if (sense === com.vzome.core.math.symmetry.Symmetry.MINUS)
                            axis = this.getDirection().getAxis$int$int((axis.getSense() + 1) % 2, axis.getOrientation());
                        return axis;
                    }
                    getName$com_vzome_core_math_symmetry_Axis(axis) {
                        let orn = axis.getOrientation();
                        const redNeighbor = this.mRedNames.getDirection().getAxis$int$int(axis.getSense(), orn);
                        const redName = this.mRedNames.getName$com_vzome_core_math_symmetry_Axis(redNeighbor);
                        let rot = redNeighbor.getRotationPermutation();
                        if (axis.getSense() === com.vzome.core.math.symmetry.Symmetry.MINUS)
                            rot = rot.inverse();
                        orn = rot.mapIndex(orn);
                        const redSign = this.getSign(redName);
                        const yellowNeighbor = this.mYellowNames.getDirection().getAxis$int$int(redSign, orn);
                        let yellowName = this.mYellowNames.getName$com_vzome_core_math_symmetry_Axis(yellowNeighbor).substring(1);
                        if (axis.getSense() === redSign)
                            yellowName += "-";
                        return redName + yellowName;
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Axis} axis
                     * @return {string}
                     */
                    getName(axis) {
                        if (((axis != null && axis instanceof com.vzome.core.math.symmetry.Axis) || axis === null)) {
                            return this.getName$com_vzome_core_math_symmetry_Axis(axis);
                        }
                        else if (axis === undefined) {
                            return this.getName$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                zomic.BlackDirectionNaming = BlackDirectionNaming;
                BlackDirectionNaming["__class"] = "com.vzome.core.zomic.BlackDirectionNaming";
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                class ZomodDirectionNaming extends com.vzome.core.math.symmetry.DirectionNaming {
                    constructor(dir, mapping) {
                        super(dir, dir.getName());
                        if (this.mMapping === undefined) {
                            this.mMapping = null;
                        }
                        this.mBackMap = (new java.util.HashMap());
                        this.mMapping = mapping;
                        for (let i = 0; i < this.mMapping.length; i++) {
                            {
                                let axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, this.mMapping[i]);
                                this.mBackMap.put(axis, "+" + i);
                                axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.MINUS, this.mMapping[i]);
                                this.mBackMap.put(axis, "-" + i);
                            }
                            ;
                        }
                    }
                    /**
                     *
                     * @param {string} axisName
                     * @return {com.vzome.core.math.symmetry.Axis}
                     */
                    getAxis(axisName) {
                        const sense = this.getSign(axisName);
                        const index = this.getInteger(axisName);
                        return this.getDirection().getAxis$int$int(sense, this.mMapping[index]);
                    }
                    getName$com_vzome_core_math_symmetry_Axis(axis) {
                        return this.mBackMap.get(axis);
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Axis} axis
                     * @return {string}
                     */
                    getName(axis) {
                        if (((axis != null && axis instanceof com.vzome.core.math.symmetry.Axis) || axis === null)) {
                            return this.getName$com_vzome_core_math_symmetry_Axis(axis);
                        }
                        else if (axis === undefined) {
                            return this.getName$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                zomic.ZomodDirectionNaming = ZomodDirectionNaming;
                ZomodDirectionNaming["__class"] = "com.vzome.core.zomic.ZomodDirectionNaming";
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry_3) {
                    /**
                     * @author Scott Vorthmann
                     * @param {*} field
                     * @class
                     * @extends com.vzome.core.math.symmetry.AbstractSymmetry
                     */
                    class IcosahedralSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
                        constructor(field) {
                            super(60, field, "blue", null);
                            this.INCIDENCES = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                                return 0;
                            }
                            else {
                                let array = [];
                                for (let i = 0; i < dims[0]; i++) {
                                    array.push(allocate(dims.slice(1)));
                                }
                                return array;
                            } }; return allocate(dims); })([60, 3]);
                            this.IDENTITY = new com.vzome.core.math.symmetry.Permutation(this, null);
                            if (this.preferredAxis === undefined) {
                                this.preferredAxis = null;
                            }
                            this.tetrahedralSubgroup = [null, null, null, null, null];
                            this.blueTetrahedral = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(60);
                            this.greenTetrahedral = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(60);
                            this.yellowTetrahedral = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(60);
                            for (let i = 0; i < this.INCIDENCES.length; i++) {
                                {
                                    this.INCIDENCES[i][0] = this.getPermutation(i).mapIndex(30);
                                    this.INCIDENCES[i][1] = this.getPermutation(i).mapIndex(45);
                                    this.INCIDENCES[i][2] = this.getPermutation(i).mapIndex(42);
                                }
                                ;
                            }
                            this.tetrahedralSubgroup[0] = this.closure([1, 15]);
                            this.tetrahedralSubgroup[1] = this.closure([11, 20]);
                            this.tetrahedralSubgroup[2] = this.closure([27, 58]);
                            this.tetrahedralSubgroup[3] = this.closure([17, 4]);
                            this.tetrahedralSubgroup[4] = this.closure([55, 14]);
                            const blueOrbit = this.getDirection("blue");
                            const yellowOrbit = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("yellow", 0, 27, field.createVector([[1, 1, 1, 1], [0, 1, 0, 1], [-1, 1, 0, 1]]), true, false, this.mField['createPower$int'](-1));
                            yellowOrbit.setScaleNames(["y0", "y1", "y2", "y3"]);
                            yellowOrbit.iterator();
                            for (let i = 0; i < 60; i++) {
                                {
                                    const blueZone = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, i);
                                    const yellowZone = yellowOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, i);
                                    for (let j = 0; j < this.tetrahedralSubgroup.length; j++) {
                                        {
                                            for (let k = 0; k < this.tetrahedralSubgroup[j].length; k++) {
                                                {
                                                    if (this.tetrahedralSubgroup[j][k] === blueZone.getRotation())
                                                        this.blueTetrahedral[i] = j;
                                                    if (this.tetrahedralSubgroup[j][k] === yellowZone.getRotation())
                                                        this.yellowTetrahedral[i] = j;
                                                }
                                                ;
                                            }
                                        }
                                        ;
                                    }
                                }
                                ;
                            }
                            const greenSeeds = [6, 9, 12, 0, 3];
                            for (let j = 0; j < this.tetrahedralSubgroup.length; j++) {
                                {
                                    const seedAxis = greenSeeds[j];
                                    for (let k = 0; k < this.tetrahedralSubgroup[j].length; k++) {
                                        {
                                            const mappedAxis = this.mOrientations[this.tetrahedralSubgroup[j][k]].mapIndex(seedAxis);
                                            this.greenTetrahedral[mappedAxis] = j;
                                        }
                                        ;
                                    }
                                }
                                ;
                            }
                            const redOrbit = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("red", 0, 3, this.mField.createVector([[0, 1, 1, 1], [1, 1, 0, 1], [0, 1, 0, 1]]), true);
                            redOrbit.setScaleNames(["r0", "r1", "r2", "r3"]);
                            this.preferredAxis = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1);
                        }
                        /**
                         *
                         * @param {number} orientation
                         * @return {int[]}
                         */
                        getIncidentOrientations(orientation) {
                            return this.INCIDENCES[orientation];
                        }
                        /**
                         * Create a collection of blue-axis normals from a prototype,
                         * by applying known rotations.
                         * @param {com.vzome.core.math.symmetry.Direction} dir
                         * @param {number} prototype
                         * @param {number} rotated
                         * @param {com.vzome.core.algebra.AlgebraicVector} xyz
                         * @private
                         */
                        /*private*/ createBlueAxes(dir, prototype, rotated, xyz) {
                            let orientation = 0;
                            const reflect = [false, false, false];
                            for (let i = 0; i < 3; i++) {
                                {
                                    for (let k = 0; k < 2; k++) {
                                        {
                                            for (let l = 0; l < 2; l++) {
                                                {
                                                    const unit = this.mOrientations[orientation].mapIndex(prototype);
                                                    if (!dir.zoneInitialized(com.vzome.core.math.symmetry.Symmetry.PLUS, unit)) {
                                                        const rot = this.mOrientations[orientation].mapIndex(rotated);
                                                        const rotation = this.getMapping(unit, rot);
                                                        const norm = this.mField.origin(3);
                                                        for (let m = 0; m < 3; m++) {
                                                            {
                                                                const offset = ((m + 3 - i) % 3);
                                                                if (reflect[m]) {
                                                                    norm.setComponent(m, xyz.getComponent(offset).negate());
                                                                }
                                                                else {
                                                                    norm.setComponent(m, xyz.getComponent(offset));
                                                                }
                                                            }
                                                            ;
                                                        }
                                                        dir.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(unit, rotation, norm);
                                                        dir.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(rot, rotation, norm);
                                                    }
                                                    orientation = this.mOrientations[45].mapIndex(orientation);
                                                    reflect[0] = !reflect[0];
                                                    reflect[2] = !reflect[2];
                                                }
                                                ;
                                            }
                                            orientation = this.mOrientations[15].mapIndex(orientation);
                                            reflect[1] = !reflect[1];
                                            reflect[2] = !reflect[2];
                                        }
                                        ;
                                    }
                                    orientation = this.mOrientations[1].mapIndex(orientation);
                                }
                                ;
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "icosahedral";
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.AlgebraicVector[]}
                         */
                        getOrbitTriangle() {
                            const twice = this.mField['createRational$long'](2);
                            const blueVertex = this.getDirection("blue").getPrototype().scale(twice);
                            const redVertex = this.getDirection("red").getPrototype();
                            const phiInv = this.mField.getGoldenRatio().reciprocal();
                            const yellowVertex = this.getDirection("yellow").getPrototype().scale(phiInv);
                            return [blueVertex, redVertex, yellowVertex];
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getSpecialOrbit(which) {
                            switch ((which)) {
                                case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                                    return this.getDirection("blue");
                                case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                                    return this.getDirection("red");
                                case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                                    return this.getDirection("yellow");
                                default:
                                    return this.getDirection("black");
                            }
                        }
                        /**
                         *
                         * @param {string} frameColor
                         */
                        createFrameOrbit(frameColor) {
                            const xAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                            const dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(frameColor, 0, 15, xAxis, true, true, this.mField['createRational$long'](2));
                            dir.setScaleNames(["b0", "b1", "b2", "b3"]);
                            this.createBlueAxes(dir, 0, 15, xAxis);
                            this.createBlueAxes(dir, 9, 13, this.mField.createVector([[1, 2, 0, 1], [0, 1, 1, 2], [-1, 2, 1, 2]]));
                            this.createBlueAxes(dir, 6, 49, this.mField.createVector([[1, 2, 0, 1], [0, 1, 1, 2], [1, 2, -1, 2]]));
                            for (let p = 0; p < this.mOrientations.length; p++) {
                                {
                                    const x = this.mOrientations[p].mapIndex(0);
                                    const y = this.mOrientations[p].mapIndex(1);
                                    const z = this.mOrientations[p].mapIndex(2);
                                    this.mMatrices[p] = new com.vzome.core.algebra.AlgebraicMatrix(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, x).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, y).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, z).normal());
                                    const axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, p);
                                    const norm = this.mMatrices[p].timesColumn(xAxis);
                                    if (!norm.equals(axis.normal()))
                                        throw new java.lang.IllegalStateException("matrix wrong: " + p);
                                }
                                ;
                            }
                        }
                        /**
                         *
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getPreferredAxis() {
                            return this.preferredAxis;
                        }
                        /**
                         * @see com.vzome.core.math.symmetry.AbstractSymmetry#createOtherOrbits()
                         *
                         * @see com.vzome.core.algebra.AlgebraicField#createVector()
                         *
                         * @see com.vzome.core.math.symmetry.AbstractSymmetry#createZoneOrbit(String, int, int, AlgebraicVector, boolean, boolean, AlgebraicNumber)
                         */
                        createOtherOrbits() {
                            const dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("green", 6, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[1, 1, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1]]), true, true, this.mField['createRational$long'](2));
                            dir.setScaleNames(["g0", "g1", "g2", "g3"]);
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("orange", 6, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[1, 1, 0, 1], [0, 1, 1, 1], [0, 1, 0, 1]]));
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("purple", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[1, 1, 1, 1], [1, 1, 0, 1], [0, 1, 0, 1]]), false, false, this.mField['createPower$int'](-1));
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("black", 3, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[0, 1, 1, 1], [1, 1, 0, 1], [1, 1, -1, 1]]));
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("lavender", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[2, 1, -1, 1], [0, 1, 1, 1], [2, 1, -1, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("olive", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[0, 1, 1, 1], [0, 1, 1, 1], [2, 1, -1, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("maroon", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-1, 1, 1, 1], [3, 1, -1, 1], [1, 1, -1, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("rose", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[2, 1, -1, 1], [-1, 1, 2, 1], [0, 1, 0, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("navy", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-1, 1, 2, 1], [1, 1, 1, 1], [0, 1, 0, 1]]), false, false, this.mField['createPower$int'](-1)).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("turquoise", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[2, 1, 0, 1], [2, 1, -1, 1], [-3, 1, 2, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("coral", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-3, 1, 3, 1], [0, 1, 0, 1], [1, 1, 0, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("sulfur", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-3, 1, 3, 1], [2, 1, -1, 1], [0, 1, 0, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("sand", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-2, 1, 2, 1], [-2, 1, 2, 1], [2, 1, 0, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("apple", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[5, 1, -3, 1], [1, 1, 0, 1], [0, 1, 1, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("cinnamon", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[5, 1, -3, 1], [2, 1, -1, 1], [2, 1, 0, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("spruce", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-3, 1, 2, 1], [-3, 1, 2, 1], [5, 1, -2, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("brown", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-1, 1, 1, 1], [-1, 1, 1, 1], [-2, 1, 2, 1]])).withCorrection();
                        }
                        /**
                         *
                         */
                        createInitialPermutations() {
                            const ORDER = 60;
                            this.mOrientations[0] = this.IDENTITY;
                            let map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(ORDER);
                            for (let i = 0; i < 15; i++) {
                                {
                                    map[i] = i + 15;
                                    map[i + 15] = i;
                                    map[i + 30] = i + 45;
                                    map[i + 45] = i + 30;
                                }
                                ;
                            }
                            this.mOrientations[15] = new com.vzome.core.math.symmetry.Permutation(this, map);
                            map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(ORDER);
                            const starts = [[0, 1, 2], [15, 46, 32], [16, 47, 30], [17, 45, 31]];
                            for (let index = 0; index < starts.length; index++) {
                                let start = starts[index];
                                {
                                    for (let j = 0; j < start.length; j++) {
                                        {
                                            for (let k = 0; k < 5; k++) {
                                                {
                                                    map[start[j] + k * 3] = start[(j + 1) % 3] + k * 3;
                                                }
                                                ;
                                            }
                                        }
                                        ;
                                    }
                                }
                            }
                            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
                            map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(ORDER);
                            const cycles = [[0, 3, 6, 9, 12], [30, 42, 39, 36, 33], [2, 21, 29, 55, 4], [5, 24, 17, 58, 7], [8, 27, 20, 46, 10], [11, 15, 23, 49, 13], [1, 14, 18, 26, 52], [16, 50, 57, 38, 40], [19, 53, 45, 41, 43], [22, 56, 48, 44, 31], [25, 59, 51, 32, 34], [28, 47, 54, 35, 37]];
                            for (let index = 0; index < cycles.length; index++) {
                                let cycle = cycles[index];
                                {
                                    for (let j = 0; j < cycle.length; j++) {
                                        {
                                            map[cycle[j]] = cycle[(j + 1) % 5];
                                        }
                                        ;
                                    }
                                }
                            }
                            this.mOrientations[3] = new com.vzome.core.math.symmetry.Permutation(this, map);
                        }
                        subgroup$java_lang_String(name) {
                            if (com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL === name)
                                return this.tetrahedralSubgroup[0];
                            return null;
                        }
                        /**
                         *
                         * @param {string} color
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getDirection(color) {
                            if ("spring" === color)
                                color = "apple";
                            if ("tan" === color)
                                color = "sand";
                            return super.getDirection(color);
                        }
                        subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis(name, zone) {
                            return this.subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis$boolean(name, zone, true);
                        }
                        subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis$boolean(name, zone, allowYellow) {
                            const orientation = zone.getOrientation();
                            const orbit = zone.getDirection();
                            const orbitName = orbit.getName();
                            if (orbitName === ("blue")) {
                                const subgroup = this.blueTetrahedral[orientation];
                                return this.tetrahedralSubgroup[subgroup];
                            }
                            else if (orbitName === ("green")) {
                                const subgroup = this.greenTetrahedral[orientation];
                                return this.tetrahedralSubgroup[subgroup];
                            }
                            else if (allowYellow && (orbitName === ("yellow"))) {
                                const subgroup = this.yellowTetrahedral[orientation];
                                return this.tetrahedralSubgroup[subgroup];
                            }
                            return null;
                        }
                        subgroup(name, zone, allowYellow) {
                            if (((typeof name === 'string') || name === null) && ((zone != null && zone instanceof com.vzome.core.math.symmetry.Axis) || zone === null) && ((typeof allowYellow === 'boolean') || allowYellow === null)) {
                                return this.subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis$boolean(name, zone, allowYellow);
                            }
                            else if (((typeof name === 'string') || name === null) && ((zone != null && zone instanceof com.vzome.core.math.symmetry.Axis) || zone === null) && allowYellow === undefined) {
                                return this.subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis(name, zone);
                            }
                            else if (((typeof name === 'string') || name === null) && zone === undefined && allowYellow === undefined) {
                                return this.subgroup$java_lang_String(name);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        blueTetrahedralFromGreen(greenIndex) {
                            const subgroup = this.greenTetrahedral[greenIndex];
                            for (let i = 0; i < this.blueTetrahedral.length; i++) {
                                {
                                    if (this.blueTetrahedral[i] === subgroup)
                                        return i;
                                }
                                ;
                            }
                            return 0;
                        }
                        interpretScript(script, language, offset, symmetry, effects) {
                            this.mField.interpretScript(script, language, offset, symmetry, effects);
                        }
                    }
                    symmetry_3.IcosahedralSymmetry = IcosahedralSymmetry;
                    IcosahedralSymmetry["__class"] = "com.vzome.core.math.symmetry.IcosahedralSymmetry";
                    IcosahedralSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "com.vzome.core.math.symmetry.Embedding"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     *
                     * @param {*} field
                     * @class
                     * @extends com.vzome.core.math.symmetry.AbstractSymmetry
                     */
                    class OctahedralSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
                        constructor(field, frameColor) {
                            if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((typeof frameColor === 'string') || frameColor === null)) {
                                let __args = arguments;
                                super(OctahedralSymmetry.ORDER, field, frameColor, null);
                                if (this.frameColor === undefined) {
                                    this.frameColor = null;
                                }
                                if (this.tetrahedralSubgroup === undefined) {
                                    this.tetrahedralSubgroup = null;
                                }
                                this.IDENTITY = new com.vzome.core.math.symmetry.Permutation(this, null);
                                this.frameColor = frameColor;
                                this.tetrahedralSubgroup = this.closure([0, 2, 4]);
                            }
                            else if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && frameColor === undefined) {
                                let __args = arguments;
                                {
                                    let __args = arguments;
                                    let frameColor = "blue";
                                    super(OctahedralSymmetry.ORDER, field, frameColor, null);
                                    if (this.frameColor === undefined) {
                                        this.frameColor = null;
                                    }
                                    if (this.tetrahedralSubgroup === undefined) {
                                        this.tetrahedralSubgroup = null;
                                    }
                                    this.IDENTITY = new com.vzome.core.math.symmetry.Permutation(this, null);
                                    this.frameColor = frameColor;
                                    this.tetrahedralSubgroup = this.closure([0, 2, 4]);
                                }
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getSpecialOrbit(which) {
                            switch ((which)) {
                                case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                                    return this.getDirection(this.frameColor);
                                case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                                    return this.getDirection("green");
                                case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                                    return this.getDirection("yellow");
                                default:
                                    return null;
                            }
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        reverseOrbitTriangle() {
                            return true;
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.AlgebraicVector[]}
                         */
                        getOrbitTriangle() {
                            const greenVertex = this.getDirection("green").getPrototype();
                            const blueVertex = this.getDirection("blue").getPrototype();
                            const yellowVertex = this.getDirection("yellow").getPrototype();
                            return [greenVertex, blueVertex, yellowVertex];
                        }
                        /**
                         *
                         */
                        createInitialPermutations() {
                            this.mOrientations[0] = this.IDENTITY;
                            let map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(OctahedralSymmetry.ORDER);
                            for (let i = 0; i < 6; i++) {
                                for (let j = 0; j < 4; j++) {
                                    map[i * 4 + j] = i * 4 + ((j + 1) % 4);
                                }
                                ;
                            }
                            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
                            map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(OctahedralSymmetry.ORDER);
                            let cycles = [[0, 4, 8], [1, 11, 17], [2, 16, 22], [3, 21, 5], [6, 20, 14], [7, 13, 9], [10, 12, 18], [19, 15, 23]];
                            for (let index = 0; index < cycles.length; index++) {
                                let cycle = cycles[index];
                                {
                                    for (let j = 0; j < cycle.length; j++) {
                                        {
                                            map[cycle[j]] = cycle[(j + 1) % 3];
                                        }
                                        ;
                                    }
                                }
                            }
                            this.mOrientations[4] = new com.vzome.core.math.symmetry.Permutation(this, map);
                            map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(OctahedralSymmetry.ORDER);
                            cycles = [[0, 5], [1, 8], [4, 9], [15, 20], [12, 19], [16, 23], [2, 17], [13, 10], [21, 6], [22, 3], [7, 14], [11, 18]];
                            for (let index = 0; index < cycles.length; index++) {
                                let cycle = cycles[index];
                                {
                                    for (let j = 0; j < cycle.length; j++) {
                                        {
                                            map[cycle[j]] = cycle[(j + 1) % 2];
                                        }
                                        ;
                                    }
                                }
                            }
                            this.mOrientations[5] = new com.vzome.core.math.symmetry.Permutation(this, map);
                        }
                        /**
                         *
                         */
                        createOtherOrbits() {
                            const xAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                            const yAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
                            const zAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                            const green = xAxis.plus(yAxis);
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("green", 1, 8, green, true);
                            const yellow = green.plus(zAxis);
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("yellow", 0, 4, yellow, true);
                        }
                        /**
                         *
                         * @param {string} frameColor
                         */
                        createFrameOrbit(frameColor) {
                            const xAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                            const yAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
                            const zAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                            let dir;
                            if (this.mField.doubleFrameVectors())
                                dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(frameColor, 0, 1, xAxis, true, true, this.mField['createRational$long'](2));
                            else
                                dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(frameColor, 0, 1, xAxis, true);
                            this.createBasisAxes(dir, xAxis, 0);
                            this.createBasisAxes(dir, xAxis.negate(), 12);
                            this.createBasisAxes(dir, yAxis, 5);
                            this.createBasisAxes(dir, yAxis.negate(), 7);
                            this.createBasisAxes(dir, zAxis, 4);
                            this.createBasisAxes(dir, zAxis.negate(), 6);
                            for (let p = 0; p < OctahedralSymmetry.ORDER; p++) {
                                {
                                    const x = this.mOrientations[p].mapIndex(0);
                                    const y = this.mOrientations[p].mapIndex(8);
                                    const z = this.mOrientations[p].mapIndex(4);
                                    this.mMatrices[p] = new com.vzome.core.algebra.AlgebraicMatrix(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, x).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, y).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, z).normal());
                                    const axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, p);
                                    const norm = this.mMatrices[p].timesColumn(xAxis);
                                    if (!norm.equals(axis.normal()))
                                        throw new java.lang.IllegalStateException("matrix wrong: " + p);
                                }
                                ;
                            }
                        }
                        /*private*/ createBasisAxes(dir, norm, orientation) {
                            for (let i = 0; i < 4; i++) {
                                {
                                    const prototype = this.mOrientations[orientation].mapIndex(i);
                                    const rotatedPrototype = this.mOrientations[orientation].mapIndex((i + 1) % 4);
                                    const rotation = this.getMapping(prototype, rotatedPrototype);
                                    dir.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(prototype, rotation, norm);
                                }
                                ;
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "octahedral";
                        }
                        /**
                         *
                         * @param {string} name
                         * @return {int[]}
                         */
                        subgroup(name) {
                            if (com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL === name)
                                return this.tetrahedralSubgroup;
                            return null;
                        }
                    }
                    OctahedralSymmetry.ORDER = 24;
                    symmetry.OctahedralSymmetry = OctahedralSymmetry;
                    OctahedralSymmetry["__class"] = "com.vzome.core.math.symmetry.OctahedralSymmetry";
                    OctahedralSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "com.vzome.core.math.symmetry.Embedding"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     * @param {*} field
                     * @class
                     * @extends com.vzome.core.math.symmetry.AbstractSymmetry
                     */
                    class DodecagonalSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
                        constructor(field) {
                            super(DodecagonalSymmetry.ORDER, field, "blue", null);
                            this.IDENTITY = new com.vzome.core.math.symmetry.Permutation(this, null);
                        }
                        /**
                         *
                         */
                        createInitialPermutations() {
                            this.mOrientations[0] = this.IDENTITY;
                            const map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(DodecagonalSymmetry.ORDER);
                            for (let i = 0; i < DodecagonalSymmetry.ORDER; i++) {
                                map[i] = (i + 1) % DodecagonalSymmetry.ORDER;
                            }
                            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
                        }
                        /**
                         *
                         * @param {string} frameColor
                         */
                        createFrameOrbit(frameColor) {
                            const xAxis = this.mField.createVector([[1, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1]]);
                            const dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(frameColor, 0, 15, xAxis, true);
                            dir.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, xAxis);
                            dir.createAxis$int$int$int_A_A(1, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 1, 2], [1, 2, 0, 1], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(2, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 2, 0, 1], [0, 1, 1, 2], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(3, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(4, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 2, 0, 1], [0, 1, 1, 2], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(5, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, -1, 2], [1, 2, 0, 1], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(6, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(7, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, -1, 2], [-1, 2, 0, 1], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(8, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 2, 0, 1], [0, 1, -1, 2], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(9, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 0, 1], [-1, 1, 0, 1], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(10, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 2, 0, 1], [0, 1, -1, 2], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(11, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 1, 2], [-1, 2, 0, 1], [0, 1, 0, 1]]);
                            const zAxis = this.mField.createVector([[0, 1, 0, 1], [0, 1, 0, 1], [1, 1, 0, 1]]);
                            for (let p = 0; p < DodecagonalSymmetry.ORDER; p++) {
                                {
                                    const x = this.mOrientations[p].mapIndex(0);
                                    const y = this.mOrientations[p].mapIndex(3);
                                    this.mMatrices[p] = new com.vzome.core.algebra.AlgebraicMatrix(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, x).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, y).normal(), zAxis);
                                    const axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, p);
                                    const norm = this.mMatrices[p].timesColumn(xAxis);
                                    if (!norm.equals(axis.normal()))
                                        throw new java.lang.IllegalStateException("matrix wrong: " + p);
                                }
                                ;
                            }
                        }
                        /**
                         *
                         */
                        createOtherOrbits() {
                            this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("green", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 1, 2], [1, 2, 0, 1], [0, 1, 0, 1]], true);
                            this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("red", 0, 1, [[0, 1, 0, 1], [0, 1, 0, 1], [1, 1, 0, 1]], true);
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getSpecialOrbit(which) {
                            switch ((which)) {
                                case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                                    return this.getDirection("blue");
                                case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                                    return this.getDirection("red");
                                case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                                    return this.getDirection("green");
                                default:
                                    return null;
                            }
                        }
                        /**
                         *
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getPreferredAxis() {
                            return this.getDirection("red").getAxis$int$int(0, 0);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "dodecagonal";
                        }
                        /**
                         *
                         * @param {string} name
                         * @return {int[]}
                         */
                        subgroup(name) {
                            return null;
                        }
                    }
                    DodecagonalSymmetry.ORDER = 12;
                    symmetry.DodecagonalSymmetry = DodecagonalSymmetry;
                    DodecagonalSymmetry["__class"] = "com.vzome.core.math.symmetry.DodecagonalSymmetry";
                    DodecagonalSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "com.vzome.core.math.symmetry.Embedding"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author David Hall
                     * This class is a generalized implementation initially based on the HeptagonalAntiprismSymmetry by Scott Vorthmann
                     * @param {com.vzome.core.algebra.PolygonField} field
                     * @class
                     * @extends com.vzome.core.math.symmetry.AbstractSymmetry
                     */
                    class AntiprismSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
                        constructor(field) {
                            super(field.polygonSides() * 2, field, "blue", field.isEven() ? null : new com.vzome.core.algebra.AlgebraicMatrix(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X), field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y), field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).negate()));
                            if (this.preferredAxis === undefined) {
                                this.preferredAxis = null;
                            }
                            if (this.useShear === undefined) {
                                this.useShear = false;
                            }
                            if (this.shearTransform === undefined) {
                                this.shearTransform = null;
                            }
                            this.rotationMatrix = null;
                            const nSides = field.polygonSides();
                            let m10 = 0;
                            let m11 = 1;
                            this.useShear = field.isOdd();
                            if (this.useShear) {
                                m10 = field.getUnitDiagonal(field.diagonalCount() - 1).reciprocal().evaluate() / 2.0;
                                m11 = Math.cos(Math.PI / (2.0 * nSides));
                            }
                            this.shearTransform = [new com.vzome.core.math.RealVector(1, m10, 0), new com.vzome.core.math.RealVector(0, m11, 0), new com.vzome.core.math.RealVector(0, 0, 1)];
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.PolygonField}
                         */
                        getField() {
                            return super.getField();
                        }
                        /**
                         * Called by the super constructor.
                         */
                        createInitialPermutations() {
                            const nSides = this.getField().polygonSides();
                            this.mOrientations[0] = new com.vzome.core.math.symmetry.Permutation(this, null);
                            const map1 = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(nSides * 2);
                            for (let i = 0; i < nSides; i++) {
                                {
                                    map1[i] = (i + 1) % nSides;
                                    map1[i + nSides] = map1[i] + nSides;
                                }
                                ;
                            }
                            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map1);
                            const map2 = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(map1.length);
                            let n = nSides * 2;
                            for (let i = 0; i < map2.length; i++) {
                                {
                                    n--;
                                    map2[i] = map1[n];
                                }
                                ;
                            }
                            this.mOrientations[nSides] = new com.vzome.core.math.symmetry.Permutation(this, map2);
                        }
                        /**
                         *
                         * @param {string} frameColor
                         */
                        createFrameOrbit(frameColor) {
                            const field = this.getField();
                            const nSides = field.polygonSides();
                            const nDiags = field.diagonalCount();
                            const rotationMatrix = this.getRotationMatrix();
                            let vX = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                            let vY = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
                            let vZ = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                            for (let i = 0; i < nSides * 2; i++) {
                                {
                                    if (i === nSides) {
                                        vY = vY.negate();
                                        if (field.isOdd()) {
                                            vY = vY.setComponent(com.vzome.core.algebra.AlgebraicVector.X, field.getUnitDiagonal(nDiags - 1).reciprocal());
                                        }
                                        vZ = vZ.negate();
                                    }
                                    this.mMatrices[i] = new com.vzome.core.algebra.AlgebraicMatrix(vX, vY, vZ);
                                    vX = rotationMatrix.timesColumn(vX);
                                    vY = rotationMatrix.timesColumn(vY);
                                }
                                ;
                            }
                        }
                        getRotationMatrix() {
                            if (this.rotationMatrix == null) {
                                const field = this.getField();
                                const diagCount = field.diagonalCount();
                                const p_x = field.getUnitDiagonal(diagCount - 3);
                                const q_y = field.getUnitDiagonal(diagCount - (field.isEven() ? 3 : 2));
                                const den = field.getUnitDiagonal(diagCount - 1);
                                const num = field.getUnitDiagonal(1);
                                const p = field.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, p_x.dividedBy(den)).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, num.dividedBy(den));
                                const q = field.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, num.dividedBy(den).negate()).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, q_y.dividedBy(den));
                                const zAxis = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                                this.rotationMatrix = new com.vzome.core.algebra.AlgebraicMatrix(p, q, zAxis);
                            }
                            return this.rotationMatrix;
                        }
                        /**
                         *
                         */
                        createOtherOrbits() {
                        }
                        createStandardOrbits(frameColor) {
                            const redOrbit = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("red", 0, 1, this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z), true);
                            this.preferredAxis = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0);
                            const blueFrameVector = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                            const nSides = this.getField().polygonSides();
                            const blueOrbit = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(frameColor, 0, nSides, blueFrameVector, true);
                            let greenVector;
                            if (this.getField().isOdd()) {
                                const blueRotatedVector = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, ((nSides + 1) / 2 | 0)).normal();
                                greenVector = blueFrameVector.minus(blueRotatedVector);
                            }
                            else {
                                const blueRotatedVector = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1).normal();
                                greenVector = blueFrameVector.plus(blueRotatedVector);
                            }
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("green", 0, nSides, greenVector, false);
                            const yellowVector = greenVector.plus(redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1).normal());
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("yellow", 0, nSides, yellowVector, false);
                            return this;
                        }
                        /**
                         *
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getPreferredAxis() {
                            return this.preferredAxis;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} v
                         * @return {com.vzome.core.math.RealVector}
                         */
                        embedInR3(v) {
                            const rv = super.embedInR3(v);
                            if (this.useShear) {
                                const sums = [0, 0, 0];
                                for (let i = 0; i < this.shearTransform.length; i++) {
                                    {
                                        sums[i] += Math.fround(this.shearTransform[i].x * rv.x);
                                        sums[i] += Math.fround(this.shearTransform[i].y * rv.y);
                                        sums[i] += Math.fround(this.shearTransform[i].z * rv.z);
                                    }
                                    ;
                                }
                                return new com.vzome.core.math.RealVector(sums[0], sums[1], sums[2]);
                            }
                            return rv;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} v
                         * @return {double[]}
                         */
                        embedInR3Double(v) {
                            const dv = super.embedInR3Double(v);
                            if (this.useShear) {
                                const sums = [0, 0, 0];
                                for (let i = 0; i < this.shearTransform.length; i++) {
                                    {
                                        sums[i] += this.shearTransform[i].x * dv[0];
                                        sums[i] += this.shearTransform[i].y * dv[1];
                                        sums[i] += this.shearTransform[i].z * dv[2];
                                    }
                                    ;
                                }
                                return sums;
                            }
                            return dv;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isTrivial() {
                            return !this.useShear;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return ("antiprism" + this.getField().polygonSides());
                        }
                        /**
                         *
                         * @param {string} name
                         * @return {int[]}
                         */
                        subgroup(name) {
                            return null;
                        }
                        /**
                         * These three vertices represent the corners of the canonical orbit triangle.
                         * They must correspond to the three "special" orbits returned by getSpecialOrbit().
                         * All other canonical direction prototype vectors
                         * must intersect this plane at a unique point within the triangle.
                         *
                         * OrbitDotLocator will use the three vectors to locate the dots in this order:
                         * AlgebraicVector[] triangle = getOrbitTriangle();
                         * triangle[0] .. // SpecialOrbit.BLUE   = orthoVertex
                         * triangle[1] .. // SpecialOrbit.RED    = sideVertex
                         * triangle[2] .. // SpecialOrbit.YELLOW = topVertex
                         *
                         * These variable names and their position in the array
                         * correspond to the positions where they will be shown in the orbit triangle
                         * rather than any specific colors.
                         * The SpecialOrbit names originally matched the color position in the icosa orbit triangle
                         * but other symmetries don't necessarily have any such corellation.
                         *
                         * top
                         * @
                         * | `\
                         * |    `\
                         * @-------`@
                         * ortho     side
                         *
                         * AntiprismTrackball also uses these 3 vertices to locate the trackball orbit triangle hints.
                         * @return {com.vzome.core.algebra.AlgebraicVector[]}
                         */
                        getOrbitTriangle() {
                            const field = this.getField();
                            const diagCount = field.diagonalCount();
                            const sideVertex = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                            const blueOrbit = this.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.BLUE);
                            const topVertex = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, diagCount).normal();
                            const bottomVert = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, diagCount + 1).normal();
                            const orthoVertex = com.vzome.core.algebra.AlgebraicVectors.getCentroid([topVertex, bottomVert]);
                            return [orthoVertex, sideVertex, topVertex];
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getSpecialOrbit(which) {
                            switch ((which)) {
                                case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                                    return this.getDirection("blue");
                                case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                                    return this.getDirection("red");
                                case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                                    return this.getDirection(this.getField().isEven() ? "green" : "blue");
                                default:
                                    return null;
                            }
                        }
                    }
                    symmetry.AntiprismSymmetry = AntiprismSymmetry;
                    AntiprismSymmetry["__class"] = "com.vzome.core.math.symmetry.AntiprismSymmetry";
                    AntiprismSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "com.vzome.core.math.symmetry.Embedding"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var fields;
        (function (fields) {
            var heptagon;
            (function (heptagon) {
                class HeptagonalAntiprismSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
                    constructor(field, frameColor, correctedOrbits) {
                        if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((typeof frameColor === 'string') || frameColor === null) && ((typeof correctedOrbits === 'boolean') || correctedOrbits === null)) {
                            let __args = arguments;
                            super(14, field, frameColor, correctedOrbits ? new com.vzome.core.algebra.AlgebraicMatrix(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X), field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y), field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).negate()) : null);
                            if (this.sigmaX2 === undefined) {
                                this.sigmaX2 = 0;
                            }
                            if (this.skewFactor === undefined) {
                                this.skewFactor = 0;
                            }
                            if (this.correctedOrbits === undefined) {
                                this.correctedOrbits = false;
                            }
                            if (this.preferredAxis === undefined) {
                                this.preferredAxis = null;
                            }
                            this.sigmaX2 = field.getAffineScalar()['times$com_vzome_core_algebra_AlgebraicNumber'](field['createRational$long'](2)).evaluate();
                            this.skewFactor = Math.sin((3.0 / 7.0) * Math.PI);
                            this.correctedOrbits = correctedOrbits;
                        }
                        else if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((typeof frameColor === 'string') || frameColor === null) && correctedOrbits === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let correctedOrbits = false;
                                super(14, field, frameColor, correctedOrbits ? new com.vzome.core.algebra.AlgebraicMatrix(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X), field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y), field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).negate()) : null);
                                if (this.sigmaX2 === undefined) {
                                    this.sigmaX2 = 0;
                                }
                                if (this.skewFactor === undefined) {
                                    this.skewFactor = 0;
                                }
                                if (this.correctedOrbits === undefined) {
                                    this.correctedOrbits = false;
                                }
                                if (this.preferredAxis === undefined) {
                                    this.preferredAxis = null;
                                }
                                this.sigmaX2 = field.getAffineScalar()['times$com_vzome_core_algebra_AlgebraicNumber'](field['createRational$long'](2)).evaluate();
                                this.skewFactor = Math.sin((3.0 / 7.0) * Math.PI);
                                this.correctedOrbits = correctedOrbits;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Called by the super constructor.
                     */
                    createInitialPermutations() {
                        this.mOrientations[0] = new com.vzome.core.math.symmetry.Permutation(this, null);
                        let map = [1, 2, 3, 4, 5, 6, 0, 8, 9, 10, 11, 12, 13, 7];
                        this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
                        map = [7, 13, 12, 11, 10, 9, 8, 0, 6, 5, 4, 3, 2, 1];
                        this.mOrientations[7] = new com.vzome.core.math.symmetry.Permutation(this, map);
                    }
                    /**
                     *
                     * @param {string} frameColor
                     */
                    createFrameOrbit(frameColor) {
                        const hf = this.mField;
                        const one = hf.one();
                        const s = hf.getAffineScalar().reciprocal();
                        const R = hf['createPower$int'](1)['times$com_vzome_core_algebra_AlgebraicNumber'](s);
                        const zAxis = hf.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                        const zAxisNeg = zAxis.negate();
                        const axis0 = hf.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                        const axis1 = hf.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, s).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, R);
                        const axis2 = hf.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, s.negate()).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, one);
                        const axis3 = hf.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, one.negate()).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, s);
                        const axis4 = hf.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, R.negate()).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, s.negate());
                        const axis5 = hf.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, one.negate());
                        const axis6 = hf.origin(3).setComponent(com.vzome.core.algebra.AlgebraicVector.X, R).setComponent(com.vzome.core.algebra.AlgebraicVector.Y, R.negate());
                        this.mMatrices[0] = hf.identityMatrix(3);
                        this.mMatrices[1] = new com.vzome.core.algebra.AlgebraicMatrix(axis1, axis6.negate(), zAxis);
                        this.mMatrices[2] = new com.vzome.core.algebra.AlgebraicMatrix(axis2, axis0.negate(), zAxis);
                        this.mMatrices[3] = new com.vzome.core.algebra.AlgebraicMatrix(axis3, axis1.negate(), zAxis);
                        this.mMatrices[4] = new com.vzome.core.algebra.AlgebraicMatrix(axis4, axis2.negate(), zAxis);
                        this.mMatrices[5] = new com.vzome.core.algebra.AlgebraicMatrix(axis5, axis3.negate(), zAxis);
                        this.mMatrices[6] = new com.vzome.core.algebra.AlgebraicMatrix(axis6, axis4.negate(), zAxis);
                        this.mMatrices[7] = new com.vzome.core.algebra.AlgebraicMatrix(axis0, axis2.negate(), zAxisNeg);
                        this.mMatrices[8] = this.mMatrices[1].times(this.mMatrices[7]);
                        this.mMatrices[9] = this.mMatrices[2].times(this.mMatrices[7]);
                        this.mMatrices[10] = this.mMatrices[3].times(this.mMatrices[7]);
                        this.mMatrices[11] = this.mMatrices[4].times(this.mMatrices[7]);
                        this.mMatrices[12] = this.mMatrices[5].times(this.mMatrices[7]);
                        this.mMatrices[13] = this.mMatrices[6].times(this.mMatrices[7]);
                    }
                    /**
                     *
                     */
                    createOtherOrbits() {
                    }
                    createStandardOrbits(frameColor) {
                        const redOrbit = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("red", 0, 1, this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z), true);
                        this.preferredAxis = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0);
                        const blueFrameVector = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                        const blueOrbit = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(frameColor, 0, 7, blueFrameVector, true);
                        const blueRotatedVector = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, ((7 + 1) / 2 | 0)).normal();
                        const greenVector = blueFrameVector.minus(blueRotatedVector);
                        this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("green", 0, 7, greenVector);
                        return this;
                    }
                    /**
                     *
                     * @return {com.vzome.core.math.symmetry.Axis}
                     */
                    getPreferredAxis() {
                        return this.preferredAxis;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v
                     * @return {com.vzome.core.math.RealVector}
                     */
                    embedInR3(v) {
                        const rv = super.embedInR3(v);
                        const x = rv.x + (rv.y / this.sigmaX2);
                        const y = rv.y * this.skewFactor;
                        return new com.vzome.core.math.RealVector(x, y, rv.z);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v
                     * @return {double[]}
                     */
                    embedInR3Double(v) {
                        const dv = super.embedInR3Double(v);
                        const x = dv[0] + (dv[1] / this.sigmaX2);
                        const y = dv[1] * this.skewFactor;
                        return [x, y, dv[2]];
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isTrivial() {
                        return false;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        if (this.correctedOrbits)
                            return "heptagonal antiprism corrected";
                        else
                            return "heptagonal antiprism";
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {int[]}
                     */
                    subgroup(name) {
                        return null;
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector[]}
                     */
                    getOrbitTriangle() {
                        const field = this.getField();
                        const zero = field.zero();
                        let x = field['createAlgebraicNumber$int_A']([0, -1, -1]).dividedBy(field['createAlgebraicNumber$int_A']([0, 0, 2]));
                        const orthoVertex = new com.vzome.core.algebra.AlgebraicVector(x, zero, zero);
                        const sideVertex = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                        x = field['createRational$long'](-1);
                        const y = field['createAlgebraicNumber$int_A']([0, -1, 1]);
                        const topVertex = new com.vzome.core.algebra.AlgebraicVector(x, y, zero);
                        return [orthoVertex, sideVertex, topVertex];
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
                     * @return {com.vzome.core.math.symmetry.Direction}
                     */
                    getSpecialOrbit(which) {
                        switch ((which)) {
                            case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                                return this.getDirection("blue");
                            case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                                return this.getDirection("red");
                            case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                                return this.getDirection("blue");
                            default:
                                return null;
                        }
                    }
                }
                heptagon.HeptagonalAntiprismSymmetry = HeptagonalAntiprismSymmetry;
                HeptagonalAntiprismSymmetry["__class"] = "com.vzome.fields.heptagon.HeptagonalAntiprismSymmetry";
                HeptagonalAntiprismSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "com.vzome.core.math.symmetry.Embedding"];
            })(heptagon = fields.heptagon || (fields.heptagon = {}));
        })(fields = vzome.fields || (vzome.fields = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var fields;
        (function (fields) {
            var sqrtphi;
            (function (sqrtphi) {
                class PentagonalAntiprismSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
                    constructor(field, frameColor) {
                        super(10, field, frameColor, field.createMatrix(PentagonalAntiprismSymmetry.PRINCIPAL_REFLECTION_$LI$()));
                        if (this.preferredAxis === undefined) {
                            this.preferredAxis = null;
                        }
                    }
                    static FIVEFOLD_AXIS_$LI$() { if (PentagonalAntiprismSymmetry.FIVEFOLD_AXIS == null) {
                        PentagonalAntiprismSymmetry.FIVEFOLD_AXIS = [[-3, 1, 0, 1, -5, 1, 0, 1], [3, 1, 0, 1, 5, 1, 0, 1], [0, 1, 1, 1, 0, 1, 2, 1]];
                    } return PentagonalAntiprismSymmetry.FIVEFOLD_AXIS; }
                    static TWOFOLD_AXIS_$LI$() { if (PentagonalAntiprismSymmetry.TWOFOLD_AXIS == null) {
                        PentagonalAntiprismSymmetry.TWOFOLD_AXIS = [[0, 1], [2, 1, 0, 1, 3, 1, 0, 1], [0, 1, -3, 1, 0, 1, -5, 1]];
                    } return PentagonalAntiprismSymmetry.TWOFOLD_AXIS; }
                    static NEXT_TWOFOLD_AXIS_$LI$() { if (PentagonalAntiprismSymmetry.NEXT_TWOFOLD_AXIS == null) {
                        PentagonalAntiprismSymmetry.NEXT_TWOFOLD_AXIS = [[2, 1, 0, 1, 3, 1, 0, 1], [3, 1, 0, 1, 5, 1, 0, 1], [0, 1, -2, 1, 0, 1, -3, 1]];
                    } return PentagonalAntiprismSymmetry.NEXT_TWOFOLD_AXIS; }
                    static FIVEFOLD_ROTATION_$LI$() { if (PentagonalAntiprismSymmetry.FIVEFOLD_ROTATION == null) {
                        PentagonalAntiprismSymmetry.FIVEFOLD_ROTATION = [[[-1, 1, 0, 1, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 1, 1, 0, 1, -1, 1]], [[1, 1, 0, 1, -1, 1, 0, 1], [-1, 1, 0, 1, 1, 1, 0, 1], [0, 1, -2, 1, 0, 1, 1, 1]], [[0, 1, 2, 1, 0, 1, -1, 1], [0, 1, -1, 1, 0, 1, 1, 1], [2, 1, 0, 1, -1, 1, 0, 1]]];
                    } return PentagonalAntiprismSymmetry.FIVEFOLD_ROTATION; }
                    static TWOFOLD_ROTATION_$LI$() { if (PentagonalAntiprismSymmetry.TWOFOLD_ROTATION == null) {
                        PentagonalAntiprismSymmetry.TWOFOLD_ROTATION = [[[-1, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1]], [[0, 1, 0, 1, 0, 1, 0, 1], [1, 1, 0, 1, -1, 1, 0, 1], [0, 1, 1, 1, 0, 1, -1, 1]], [[0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 1, 1, 0, 1, -1, 1], [-1, 1, 0, 1, 1, 1, 0, 1]]];
                    } return PentagonalAntiprismSymmetry.TWOFOLD_ROTATION; }
                    static PRINCIPAL_REFLECTION_$LI$() { if (PentagonalAntiprismSymmetry.PRINCIPAL_REFLECTION == null) {
                        PentagonalAntiprismSymmetry.PRINCIPAL_REFLECTION = [[[7, 5, 0, 1, -4, 5, 0, 1], [-2, 5, 0, 1, 4, 5, 0, 1], [0, 1, -8, 5, 0, 1, 6, 5]], [[-2, 5, 0, 1, 4, 5, 0, 1], [7, 5, 0, 1, -4, 5, 0, 1], [0, 1, 8, 5, 0, 1, -6, 5]], [[0, 1, -8, 5, 0, 1, 6, 5], [0, 1, 8, 5, 0, 1, -6, 5], [-9, 5, 0, 1, 8, 5, 0, 1]]];
                    } return PentagonalAntiprismSymmetry.PRINCIPAL_REFLECTION; }
                    /**
                     * Called by the super constructor.
                     */
                    createInitialPermutations() {
                        this.mOrientations[0] = new com.vzome.core.math.symmetry.Permutation(this, null);
                        let map = [1, 2, 3, 4, 0, 6, 7, 8, 9, 5];
                        this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
                        map = [5, 9, 8, 7, 6, 0, 4, 3, 2, 1];
                        this.mOrientations[5] = new com.vzome.core.math.symmetry.Permutation(this, map);
                    }
                    /**
                     *
                     * @param {string} frameColor
                     */
                    createFrameOrbit(frameColor) {
                        this.mMatrices[0] = this.mField.identityMatrix(3);
                        this.mMatrices[1] = this.mField.createMatrix(PentagonalAntiprismSymmetry.FIVEFOLD_ROTATION_$LI$());
                        this.mMatrices[2] = this.mMatrices[1].times(this.mMatrices[1]);
                        this.mMatrices[3] = this.mMatrices[1].times(this.mMatrices[2]);
                        this.mMatrices[4] = this.mMatrices[1].times(this.mMatrices[3]);
                        this.mMatrices[5] = this.mField.createMatrix(PentagonalAntiprismSymmetry.TWOFOLD_ROTATION_$LI$());
                        this.mMatrices[6] = this.mMatrices[1].times(this.mMatrices[5]);
                        this.mMatrices[7] = this.mMatrices[2].times(this.mMatrices[5]);
                        this.mMatrices[8] = this.mMatrices[3].times(this.mMatrices[5]);
                        this.mMatrices[9] = this.mMatrices[4].times(this.mMatrices[5]);
                    }
                    /**
                     *
                     */
                    createOtherOrbits() {
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector[]}
                     */
                    getOrbitTriangle() {
                        const redVertex = this.mField.createVector(PentagonalAntiprismSymmetry.FIVEFOLD_AXIS_$LI$());
                        const greenVertex = this.mField.createVector(PentagonalAntiprismSymmetry.TWOFOLD_AXIS_$LI$());
                        const orthoVertex = this.mField.createVector(PentagonalAntiprismSymmetry.NEXT_TWOFOLD_AXIS_$LI$());
                        return [greenVertex, redVertex, orthoVertex];
                    }
                    createStandardOrbits(frameColor) {
                        const redVertex = this.mField.createVector(PentagonalAntiprismSymmetry.FIVEFOLD_AXIS_$LI$());
                        const greenVertex = this.mField.createVector(PentagonalAntiprismSymmetry.TWOFOLD_AXIS_$LI$());
                        let unitLength = this.mField['createPower$int'](-6);
                        const redOrbit = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("red", 0, 1, redVertex, true, false, unitLength);
                        this.preferredAxis = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0);
                        this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("green", 0, 5, greenVertex, true, false, unitLength);
                        unitLength = this.mField['createPower$int'](6);
                        this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("blue", 0, -1, this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X), true, false, unitLength);
                        return this;
                    }
                    /**
                     *
                     * @return {com.vzome.core.math.symmetry.Axis}
                     */
                    getPreferredAxis() {
                        return this.preferredAxis;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return "pentagonal";
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {int[]}
                     */
                    subgroup(name) {
                        return null;
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
                     * @return {com.vzome.core.math.symmetry.Direction}
                     */
                    getSpecialOrbit(which) {
                        switch ((which)) {
                            case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                                return this.getDirection("blue");
                            case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                                return this.getDirection("red");
                            case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                                return this.getDirection("green");
                            default:
                                return null;
                        }
                    }
                }
                sqrtphi.PentagonalAntiprismSymmetry = PentagonalAntiprismSymmetry;
                PentagonalAntiprismSymmetry["__class"] = "com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry";
                PentagonalAntiprismSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "com.vzome.core.math.symmetry.Embedding"];
            })(sqrtphi = fields.sqrtphi || (fields.sqrtphi = {}));
        })(fields = vzome.fields || (vzome.fields = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class PlaneOrbitSet extends com.vzome.core.math.symmetry.OrbitSet {
                        constructor(delegate, normal) {
                            super(delegate.getSymmetry());
                            if (this.delegate === undefined) {
                                this.delegate = null;
                            }
                            if (this.normal === undefined) {
                                this.normal = null;
                            }
                            this.__zones = (new java.util.HashSet());
                            this.delegate = delegate;
                            this.normal = normal;
                            for (let index = delegate.getDirections().iterator(); index.hasNext();) {
                                let dir = index.next();
                                {
                                    for (let index = dir.iterator(); index.hasNext();) {
                                        let axis = index.next();
                                        {
                                            if (axis.normal().dot(this.normal).isZero())
                                                this.__zones.add(axis);
                                        }
                                    }
                                }
                            }
                        }
                        zones() {
                            return this.__zones.iterator();
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.RealVector} vector
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getAxis(vector) {
                            if (com.vzome.core.math.RealVector.ORIGIN_$LI$().equals(vector)) {
                                return null;
                            }
                            let maxCosine = -1.0;
                            let closest = null;
                            for (let index = this.__zones.iterator(); index.hasNext();) {
                                let axis = index.next();
                                {
                                    const axisV = axis.normal().toRealVector();
                                    const cosine = vector.dot(axisV) / (vector.length() * axisV.length());
                                    if (cosine > maxCosine) {
                                        maxCosine = cosine;
                                        closest = axis;
                                    }
                                }
                            }
                            return closest;
                        }
                        /**
                         *
                         * @param {string} name
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getDirection(name) {
                            return this.delegate.getDirection(name);
                        }
                    }
                    symmetry.PlaneOrbitSet = PlaneOrbitSet;
                    PlaneOrbitSet["__class"] = "com.vzome.core.math.symmetry.PlaneOrbitSet";
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class F4Group extends com.vzome.core.math.symmetry.B4Group {
                        constructor(field) {
                            super(field);
                            this.ROOTS = [null, null, null, null];
                            this.WEIGHTS = [null, null, null, null];
                            if (this.A === undefined) {
                                this.A = null;
                            }
                            const one = field['createRational$long'](1);
                            const two = field['createRational$long'](2);
                            const three = field['createRational$long'](3);
                            const four = field['createRational$long'](4);
                            const neg_one = field['createRational$long'](-1);
                            const neg_two = field['createRational$long'](-2);
                            this.ROOTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.ROOTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, two);
                            this.ROOTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_two);
                            this.ROOTS[1] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
                            this.ROOTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, two);
                            this.ROOTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_two);
                            this.ROOTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
                            this.ROOTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, two);
                            this.ROOTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.W4);
                            this.ROOTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, neg_one);
                            this.ROOTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_one);
                            this.ROOTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_one);
                            this.WEIGHTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.WEIGHTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, two);
                            this.WEIGHTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, two);
                            this.WEIGHTS[1] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
                            this.WEIGHTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, two);
                            this.WEIGHTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, two);
                            this.WEIGHTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, four);
                            this.WEIGHTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, one);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, one);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, three);
                            this.WEIGHTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.W4);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, two);
                            if (field.scale4dRoots()) {
                                const scale = field['createPower$int'](1);
                                this.ROOTS[2] = this.ROOTS[2].scale(scale);
                                this.WEIGHTS[2] = this.WEIGHTS[2].scale(scale);
                            }
                            const half = field['createRational$long$long'](1, 2);
                            const neg_half = field['createRational$long$long'](-1, 2);
                            const col1 = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            col1.setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            col1.setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
                            col1.setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
                            col1.setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_half);
                            const col2 = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            col2.setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            col2.setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
                            col2.setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_half);
                            col2.setComponent(com.vzome.core.algebra.AlgebraicVector.W4, half);
                            const col3 = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            col3.setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            col3.setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_half);
                            col3.setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
                            col3.setComponent(com.vzome.core.algebra.AlgebraicVector.W4, half);
                            const col4 = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            col4.setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            col4.setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_half);
                            col4.setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_half);
                            col4.setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_half);
                            this.A = new com.vzome.core.algebra.AlgebraicMatrix(col1, col2, col3, col4);
                        }
                        /**
                         *
                         * @return {number}
                         */
                        getOrder() {
                            return 3 * super.getOrder();
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        groupAction(model, element) {
                            const b4Order = super.getOrder();
                            const aPower = (element / b4Order | 0);
                            const b4Element = element % b4Order;
                            switch ((aPower)) {
                                case 0:
                                    return super.groupAction(model, b4Element);
                                case 1:
                                    return super.groupAction(this.A.timesColumn(model), b4Element);
                                case 2:
                                    return super.groupAction(this.A.timesColumn(this.A.timesColumn(model)), b4Element);
                                default:
                                    break;
                            }
                            return null;
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getWeight(i) {
                            return this.WEIGHTS[i];
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getSimpleRoot(i) {
                            return this.ROOTS[i];
                        }
                    }
                    symmetry.F4Group = F4Group;
                    F4Group["__class"] = "com.vzome.core.math.symmetry.F4Group";
                    F4Group["__interfaces"] = ["com.vzome.core.math.symmetry.CoxeterGroup"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var viewing;
            (function (viewing) {
                /**
                 * @author vorth
                 * @param {java.io.File} prefsFolder
                 * @param {string} pkgName
                 * @param {string} name
                 * @param {string} alias
                 * @param {*} symm
                 * @param {com.vzome.core.viewing.AbstractShapes} fallback
                 * @param {boolean} isSnub
                 * @class
                 * @extends com.vzome.core.viewing.AbstractShapes
                 */
                class ExportedVEFShapes extends com.vzome.core.viewing.AbstractShapes {
                    constructor(prefsFolder, pkgName, name, alias, symm, fallback, isSnub) {
                        if (((prefsFolder != null && prefsFolder instanceof java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((typeof alias === 'string') || alias === null) && ((symm != null && (symm.constructor != null && symm.constructor["__interfaces"] != null && symm.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symm === null) && ((fallback != null && fallback instanceof com.vzome.core.viewing.AbstractShapes) || fallback === null) && ((typeof isSnub === 'boolean') || isSnub === null)) {
                            let __args = arguments;
                            super(pkgName, name, alias, symm);
                            if (this.fallback === undefined) {
                                this.fallback = null;
                            }
                            if (this.isSnub === undefined) {
                                this.isSnub = false;
                            }
                            this.colors = new java.util.Properties();
                            this.fallback = fallback;
                            this.isSnub = isSnub;
                            const colorProps = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                            const resource = com.vzome.xml.ResourceLoader.loadStringResource(colorProps);
                            if (resource != null)
                                try {
                                    const inputStream = new java.io.ByteArrayInputStream(/* getBytes */ (resource).split('').map(s => s.charCodeAt(0)));
                                    this.colors.load(inputStream);
                                }
                                catch (ioe) {
                                    if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE))
                                        ExportedVEFShapes.LOGGER_$LI$().fine("problem with shape color properties: " + colorProps);
                                }
                        }
                        else if (((prefsFolder != null && prefsFolder instanceof java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((typeof alias === 'string') || alias === null) && ((symm != null && (symm.constructor != null && symm.constructor["__interfaces"] != null && symm.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symm === null) && ((fallback != null && fallback instanceof com.vzome.core.viewing.AbstractShapes) || fallback === null) && isSnub === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let isSnub = false;
                                super(pkgName, name, alias, symm);
                                if (this.fallback === undefined) {
                                    this.fallback = null;
                                }
                                if (this.isSnub === undefined) {
                                    this.isSnub = false;
                                }
                                this.colors = new java.util.Properties();
                                this.fallback = fallback;
                                this.isSnub = isSnub;
                                const colorProps = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                                const resource = com.vzome.xml.ResourceLoader.loadStringResource(colorProps);
                                if (resource != null)
                                    try {
                                        const inputStream = new java.io.ByteArrayInputStream(/* getBytes */ (resource).split('').map(s => s.charCodeAt(0)));
                                        this.colors.load(inputStream);
                                    }
                                    catch (ioe) {
                                        if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE))
                                            ExportedVEFShapes.LOGGER_$LI$().fine("problem with shape color properties: " + colorProps);
                                    }
                            }
                        }
                        else if (((prefsFolder != null && prefsFolder instanceof java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((typeof alias === 'string') || alias === null) && ((symm != null && (symm.constructor != null && symm.constructor["__interfaces"] != null && symm.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symm === null) && fallback === undefined && isSnub === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let fallback = new com.vzome.core.viewing.OctahedralShapes(__args[1], __args[2], __args[4]);
                                {
                                    let __args = arguments;
                                    let isSnub = false;
                                    super(pkgName, name, alias, symm);
                                    if (this.fallback === undefined) {
                                        this.fallback = null;
                                    }
                                    if (this.isSnub === undefined) {
                                        this.isSnub = false;
                                    }
                                    this.colors = new java.util.Properties();
                                    this.fallback = fallback;
                                    this.isSnub = isSnub;
                                    const colorProps = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                                    const resource = com.vzome.xml.ResourceLoader.loadStringResource(colorProps);
                                    if (resource != null)
                                        try {
                                            const inputStream = new java.io.ByteArrayInputStream(/* getBytes */ (resource).split('').map(s => s.charCodeAt(0)));
                                            this.colors.load(inputStream);
                                        }
                                        catch (ioe) {
                                            if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE))
                                                ExportedVEFShapes.LOGGER_$LI$().fine("problem with shape color properties: " + colorProps);
                                        }
                                }
                            }
                        }
                        else if (((prefsFolder != null && prefsFolder instanceof java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((alias != null && (alias.constructor != null && alias.constructor["__interfaces"] != null && alias.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || alias === null) && ((symm != null && symm instanceof com.vzome.core.viewing.AbstractShapes) || symm === null) && fallback === undefined && isSnub === undefined) {
                            let __args = arguments;
                            let symm = __args[3];
                            let fallback = __args[4];
                            {
                                let __args = arguments;
                                let alias = null;
                                {
                                    let __args = arguments;
                                    let isSnub = false;
                                    super(pkgName, name, alias, symm);
                                    if (this.fallback === undefined) {
                                        this.fallback = null;
                                    }
                                    if (this.isSnub === undefined) {
                                        this.isSnub = false;
                                    }
                                    this.colors = new java.util.Properties();
                                    this.fallback = fallback;
                                    this.isSnub = isSnub;
                                    const colorProps = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                                    const resource = com.vzome.xml.ResourceLoader.loadStringResource(colorProps);
                                    if (resource != null)
                                        try {
                                            const inputStream = new java.io.ByteArrayInputStream(/* getBytes */ (resource).split('').map(s => s.charCodeAt(0)));
                                            this.colors.load(inputStream);
                                        }
                                        catch (ioe) {
                                            if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE))
                                                ExportedVEFShapes.LOGGER_$LI$().fine("problem with shape color properties: " + colorProps);
                                        }
                                }
                            }
                        }
                        else if (((prefsFolder != null && prefsFolder instanceof java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((alias != null && (alias.constructor != null && alias.constructor["__interfaces"] != null && alias.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || alias === null) && ((typeof symm === 'boolean') || symm === null) && fallback === undefined && isSnub === undefined) {
                            let __args = arguments;
                            let symm = __args[3];
                            let useZomic = __args[4];
                            {
                                let __args = arguments;
                                let alias = null;
                                let fallback = new com.vzome.core.viewing.OctahedralShapes(__args[1], __args[2], __args[4]);
                                {
                                    let __args = arguments;
                                    let isSnub = false;
                                    super(pkgName, name, alias, symm);
                                    if (this.fallback === undefined) {
                                        this.fallback = null;
                                    }
                                    if (this.isSnub === undefined) {
                                        this.isSnub = false;
                                    }
                                    this.colors = new java.util.Properties();
                                    this.fallback = fallback;
                                    this.isSnub = isSnub;
                                    const colorProps = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                                    const resource = com.vzome.xml.ResourceLoader.loadStringResource(colorProps);
                                    if (resource != null)
                                        try {
                                            const inputStream = new java.io.ByteArrayInputStream(/* getBytes */ (resource).split('').map(s => s.charCodeAt(0)));
                                            this.colors.load(inputStream);
                                        }
                                        catch (ioe) {
                                            if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE))
                                                ExportedVEFShapes.LOGGER_$LI$().fine("problem with shape color properties: " + colorProps);
                                        }
                                }
                            }
                        }
                        else if (((prefsFolder != null && prefsFolder instanceof java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((alias != null && (alias.constructor != null && alias.constructor["__interfaces"] != null && alias.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || alias === null) && symm === undefined && fallback === undefined && isSnub === undefined) {
                            let __args = arguments;
                            let symm = __args[3];
                            {
                                let __args = arguments;
                                let alias = null;
                                {
                                    let __args = arguments;
                                    let fallback = new com.vzome.core.viewing.OctahedralShapes(__args[1], __args[2], __args[4]);
                                    {
                                        let __args = arguments;
                                        let isSnub = false;
                                        super(pkgName, name, alias, symm);
                                        if (this.fallback === undefined) {
                                            this.fallback = null;
                                        }
                                        if (this.isSnub === undefined) {
                                            this.isSnub = false;
                                        }
                                        this.colors = new java.util.Properties();
                                        this.fallback = fallback;
                                        this.isSnub = isSnub;
                                        const colorProps = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                                        const resource = com.vzome.xml.ResourceLoader.loadStringResource(colorProps);
                                        if (resource != null)
                                            try {
                                                const inputStream = new java.io.ByteArrayInputStream(/* getBytes */ (resource).split('').map(s => s.charCodeAt(0)));
                                                this.colors.load(inputStream);
                                            }
                                            catch (ioe) {
                                                if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE))
                                                    ExportedVEFShapes.LOGGER_$LI$().fine("problem with shape color properties: " + colorProps);
                                            }
                                    }
                                }
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static LOGGER_$LI$() { if (ExportedVEFShapes.LOGGER == null) {
                        ExportedVEFShapes.LOGGER = java.util.logging.Logger.getLogger("com.vzome.core.viewing.shapes");
                    } return ExportedVEFShapes.LOGGER; }
                    static injectShapeVEF(key, vef) {
                    }
                    /**
                     *
                     * @param {string} pkgName
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    buildConnectorShape(pkgName) {
                        const vefData = this.loadVefData(ExportedVEFShapes.NODE_MODEL);
                        if (vefData != null) {
                            const parser = new ExportedVEFShapes.VefToShape(this);
                            parser.invertSnubBall = this.isSnub;
                            parser.parseVEF(vefData, this.mSymmetry.getField());
                            return parser.getConnectorPolyhedron();
                        }
                        const logLevel = java.util.logging.Level.FINE;
                        if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(logLevel)) {
                            ExportedVEFShapes.LOGGER_$LI$().log(logLevel, this.toString() + " has no VEF data for " + ExportedVEFShapes.NODE_MODEL + " at " + pkgName);
                        }
                        if (this.fallback != null) {
                            if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(logLevel)) {
                                ExportedVEFShapes.LOGGER_$LI$().log(logLevel, "\t" + ExportedVEFShapes.NODE_MODEL + " --> fallback to " + this.fallback.toString());
                            }
                            return this.fallback.buildConnectorShape(pkgName);
                        }
                        throw new java.lang.IllegalStateException("missing connector shape: " + pkgName);
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} dir
                     * @return {*}
                     */
                    createStrutGeometry(dir) {
                        if (!dir.isAutomatic()) {
                            const defaultGeometry = new com.vzome.core.parts.FastDefaultStrutGeometry(dir);
                            let shortGeometry = defaultGeometry;
                            let vefData = this.loadVefData(dir.getName() + "-short");
                            if (vefData != null) {
                                const parser = new ExportedVEFShapes.VefToShape(this);
                                parser.parseVEF(vefData, this.mSymmetry.getField());
                                shortGeometry = parser.getStrutGeometry(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0).normal());
                                shortGeometry.setShortGeometry(defaultGeometry);
                            }
                            vefData = this.loadVefData(dir.getName());
                            if (vefData != null) {
                                const parser = new ExportedVEFShapes.VefToShape(this);
                                parser.parseVEF(vefData, this.mSymmetry.getField());
                                const geometry = parser.getStrutGeometry(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0).normal());
                                geometry.setShortGeometry(shortGeometry);
                                return geometry;
                            }
                            const logLevel = java.util.logging.Level.FINER;
                            if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(logLevel)) {
                                ExportedVEFShapes.LOGGER_$LI$().log(logLevel, this.toString() + " has no VEF data for strut: " + dir.getName());
                            }
                            if (this.fallback != null) {
                                if (ExportedVEFShapes.LOGGER_$LI$().isLoggable(logLevel)) {
                                    ExportedVEFShapes.LOGGER_$LI$().log(logLevel, "\t" + dir.getName() + " strut --> fallback to " + this.fallback.toString());
                                }
                                return this.fallback.createStrutGeometry(dir);
                            }
                        }
                        return super.createStrutGeometry(dir);
                    }
                    loadVefData(name) {
                        const script = this.mPkgName + "/" + name + ".vef";
                        return com.vzome.xml.ResourceLoader.loadStringResource(ExportedVEFShapes.MODEL_PREFIX + script);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasColors() {
                        return !this.colors.isEmpty();
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} dir
                     * @return {com.vzome.core.construction.Color}
                     */
                    getColor(dir) {
                        if (this.colors.isEmpty())
                            return null;
                        const dirName = (dir == null) ? ExportedVEFShapes.NODE_MODEL : dir.getName();
                        const colorString = this.colors.getProperty(dirName);
                        if (colorString == null)
                            return null;
                        return com.vzome.core.render.Colors.parseColor(colorString);
                    }
                }
                ExportedVEFShapes.MODEL_PREFIX = "com/vzome/core/parts/";
                ExportedVEFShapes.NODE_MODEL = "connector";
                viewing.ExportedVEFShapes = ExportedVEFShapes;
                ExportedVEFShapes["__class"] = "com.vzome.core.viewing.ExportedVEFShapes";
                ExportedVEFShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];
                (function (ExportedVEFShapes) {
                    class VefToShape extends com.vzome.core.math.VefParser {
                        constructor(__parent) {
                            super();
                            this.__parent = __parent;
                            this.tipVertexIndices = (new java.util.HashSet());
                            this.midpointVertexIndices = (new java.util.HashSet());
                            if (this.tipVertex === undefined) {
                                this.tipVertex = null;
                            }
                            this.vertices = (new java.util.ArrayList());
                            this.faces = (new java.util.ArrayList());
                            this.invertSnubBall = false;
                        }
                        getStrutGeometry(prototype) {
                            const tipAxis = this.__parent.mSymmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](this.tipVertex);
                            const midpoint = this.tipVertex.scale(this.__parent.mSymmetry.getField()['createRational$long$long'](1, 2));
                            const orientation = this.__parent.mSymmetry.inverse(tipAxis.getOrientation());
                            const adjustment = this.__parent.mSymmetry.getMatrix(orientation);
                            const newVertices = (new java.util.ArrayList());
                            for (let i = 0; i < this.vertices.size(); i++) {
                                {
                                    let originalVertex = this.vertices.get(i);
                                    if (this.tipVertexIndices.contains(i))
                                        originalVertex = originalVertex.minus(this.tipVertex);
                                    else if (this.midpointVertexIndices.contains(i))
                                        originalVertex = originalVertex.minus(midpoint);
                                    const adjustedVertex = adjustment.timesColumn(originalVertex);
                                    newVertices.add(adjustedVertex);
                                }
                                ;
                            }
                            return new com.vzome.core.viewing.ExportedVEFStrutGeometry(newVertices, this.faces, prototype, this.tipVertexIndices, this.midpointVertexIndices, this.__parent.mSymmetry.getField());
                        }
                        getConnectorPolyhedron() {
                            const result = new com.vzome.core.math.Polyhedron(this.__parent.mSymmetry.getField());
                            for (let index = this.vertices.iterator(); index.hasNext();) {
                                let vertex = index.next();
                                {
                                    result.addVertex(vertex);
                                }
                            }
                            for (let index = this.faces.iterator(); index.hasNext();) {
                                let prototypeFace = index.next();
                                {
                                    const face = result.newFace();
                                    face.addAll(prototypeFace);
                                    result.addFace(face);
                                }
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {int[]} verts
                         */
                        addFace(index, verts) {
                            const face = (new java.util.ArrayList());
                            for (let i = 0; i < verts.length; i++) {
                                {
                                    const n = this.invertSnubBall ? verts.length - 1 - i : i;
                                    const j = verts[n];
                                    face.add(j);
                                }
                                ;
                            }
                            this.faces.add(face);
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {com.vzome.core.algebra.AlgebraicVector} location
                         */
                        addVertex(index, location) {
                            let vertex = this.__parent.mSymmetry.getField().projectTo3d(location, this.wFirst());
                            if (this.invertSnubBall) {
                                vertex = vertex.negate();
                            }
                            this.vertices.add(vertex);
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {number} vertex
                         */
                        addBall(index, vertex) {
                            this.tipVertexIndices.add(vertex);
                        }
                        /**
                         *
                         * @param {java.util.StringTokenizer} tokens
                         */
                        endFile(tokens) {
                            if (!tokens.hasMoreTokens())
                                return;
                            let token = tokens.nextToken();
                            if (!("tip" === token))
                                throw new java.lang.IllegalStateException("VEF format error: token after face list (\"" + token + "\" should be \"tip\"");
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e1) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"tip\"");
                            }
                            let tipIndex;
                            try {
                                tipIndex = javaemul.internal.IntegerHelper.parseInt(token);
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException("VEF format error: strut tip vertex index (\"" + token + "\") must be an integer", e);
                            }
                            this.tipVertex = this.vertices.get(tipIndex);
                            if (!tokens.hasMoreTokens())
                                return;
                            token = tokens.nextToken();
                            if (!("middle" === token))
                                throw new java.lang.IllegalStateException("VEF format error: token after tip vertex (\"" + token + "\" should be \"middle\"");
                            while ((tokens.hasMoreTokens())) {
                                {
                                    token = tokens.nextToken();
                                    let vertexIndex;
                                    try {
                                        vertexIndex = javaemul.internal.IntegerHelper.parseInt(token);
                                    }
                                    catch (e) {
                                        throw new java.lang.RuntimeException("VEF format error: middle vertex index (\"" + token + "\") must be an integer", e);
                                    }
                                    this.midpointVertexIndices.add(vertexIndex);
                                }
                            }
                            ;
                        }
                        /**
                         *
                         * @param {number} numVertices
                         */
                        startBalls(numVertices) {
                        }
                        /**
                         *
                         * @param {number} numEdges
                         */
                        startEdges(numEdges) {
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {number} v1
                         * @param {number} v2
                         */
                        addEdge(index, v1, v2) {
                        }
                        /**
                         *
                         * @param {number} numFaces
                         */
                        startFaces(numFaces) {
                        }
                        /**
                         *
                         * @param {number} numVertices
                         */
                        startVertices(numVertices) {
                        }
                    }
                    ExportedVEFShapes.VefToShape = VefToShape;
                    VefToShape["__class"] = "com.vzome.core.viewing.ExportedVEFShapes.VefToShape";
                })(ExportedVEFShapes = viewing.ExportedVEFShapes || (viewing.ExportedVEFShapes = {}));
            })(viewing = core.viewing || (core.viewing = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     * @param {string} name
                     * @param {string} rootsResource
                     * @param {*} field
                     * @class
                     */
                    class QuaternionicSymmetry {
                        constructor(name, rootsResource, field) {
                            if (this.mRoots === undefined) {
                                this.mRoots = null;
                            }
                            if (this.mName === undefined) {
                                this.mName = null;
                            }
                            this.mName = name;
                            const vefData = com.vzome.xml.ResourceLoader.loadStringResource(rootsResource);
                            const parser = new QuaternionicSymmetry.RootParser(field);
                            parser.parseVEF(vefData, field);
                            this.mRoots = parser.getQuaternions();
                        }
                        getRoots() {
                            return this.mRoots;
                        }
                        getName() {
                            return this.mName;
                        }
                    }
                    symmetry.QuaternionicSymmetry = QuaternionicSymmetry;
                    QuaternionicSymmetry["__class"] = "com.vzome.core.math.symmetry.QuaternionicSymmetry";
                    (function (QuaternionicSymmetry) {
                        class RootParser extends com.vzome.core.math.VefParser {
                            constructor(field) {
                                super();
                                if (this.mRoots === undefined) {
                                    this.mRoots = null;
                                }
                                if (this.__com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field === undefined) {
                                    this.__com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field = null;
                                }
                                if (this.HALF === undefined) {
                                    this.HALF = null;
                                }
                                this.__com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field = field;
                                this.HALF = field['createRational$long$long'](1, 2);
                            }
                            /**
                             *
                             * @param {number} numVertices
                             */
                            startVertices(numVertices) {
                                this.mRoots = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(numVertices);
                            }
                            getQuaternions() {
                                return this.mRoots;
                            }
                            /**
                             *
                             * @param {number} index
                             * @param {com.vzome.core.algebra.AlgebraicVector} location
                             */
                            addVertex(index, location) {
                                this.mRoots[index] = new com.vzome.core.algebra.Quaternion(this.__com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field, location.scale(this.HALF));
                            }
                            /**
                             *
                             * @param {number} numEdges
                             */
                            startEdges(numEdges) {
                            }
                            /**
                             *
                             * @param {number} index
                             * @param {number} v1
                             * @param {number} v2
                             */
                            addEdge(index, v1, v2) {
                            }
                            /**
                             *
                             * @param {number} numFaces
                             */
                            startFaces(numFaces) {
                            }
                            /**
                             *
                             * @param {number} index
                             * @param {int[]} verts
                             */
                            addFace(index, verts) {
                            }
                            /**
                             *
                             * @param {number} index
                             * @param {number} vertex
                             */
                            addBall(index, vertex) {
                            }
                            /**
                             *
                             * @param {number} numVertices
                             */
                            startBalls(numVertices) {
                            }
                            /**
                             *
                             * @param {java.util.StringTokenizer} tokens
                             */
                            endFile(tokens) {
                            }
                        }
                        QuaternionicSymmetry.RootParser = RootParser;
                        RootParser["__class"] = "com.vzome.core.math.symmetry.QuaternionicSymmetry.RootParser";
                    })(QuaternionicSymmetry = symmetry.QuaternionicSymmetry || (symmetry.QuaternionicSymmetry = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                class VefToPolyhedron extends com.vzome.core.math.VefParser {
                    constructor(polyhedron) {
                        super();
                        if (this.polyhedron === undefined) {
                            this.polyhedron = null;
                        }
                        this.polyhedron = polyhedron;
                    }
                    static importPolyhedron(field, vef) {
                        const result = new com.vzome.core.math.Polyhedron(field);
                        const parser = new VefToPolyhedron(result);
                        parser.parseVEF(vef, field);
                        return result;
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {com.vzome.core.algebra.AlgebraicVector} location
                     */
                    addVertex(index, location) {
                        this.polyhedron.addVertex(this.getField().projectTo3d(location, true));
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {int[]} verts
                     */
                    addFace(index, verts) {
                        const face = this.polyhedron.newFace();
                        for (let index1 = 0; index1 < verts.length; index1++) {
                            let i = verts[index1];
                            face.add(i);
                        }
                        this.polyhedron.addFace(face);
                    }
                    /**
                     *
                     * @param {number} numVertices
                     */
                    startVertices(numVertices) {
                    }
                    /**
                     *
                     * @param {number} numFaces
                     */
                    startFaces(numFaces) {
                    }
                    /**
                     *
                     * @param {number} numEdges
                     */
                    startEdges(numEdges) {
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {number} v1
                     * @param {number} v2
                     */
                    addEdge(index, v1, v2) {
                    }
                    /**
                     *
                     * @param {number} numVertices
                     */
                    startBalls(numVertices) {
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {number} vertex
                     */
                    addBall(index, vertex) {
                    }
                }
                math.VefToPolyhedron = VefToPolyhedron;
                VefToPolyhedron["__class"] = "com.vzome.core.math.VefToPolyhedron";
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class VefToModel extends com.vzome.core.math.VefParser {
                    constructor(projection, effects, scale, offset) {
                        super();
                        if (this.offset === undefined) {
                            this.offset = null;
                        }
                        if (this.scale === undefined) {
                            this.scale = null;
                        }
                        if (this.__com_vzome_core_construction_VefToModel_field === undefined) {
                            this.__com_vzome_core_construction_VefToModel_field = null;
                        }
                        if (this.mProjection === undefined) {
                            this.mProjection = null;
                        }
                        if (this.mVertices === undefined) {
                            this.mVertices = null;
                        }
                        if (this.mEffects === undefined) {
                            this.mEffects = null;
                        }
                        this.noBallsSection = true;
                        this.mEffects = effects;
                        this.__com_vzome_core_construction_VefToModel_field = scale.getField();
                        this.scale = scale;
                        this.offset = offset;
                        this.mProjection = projection == null ? new com.vzome.core.math.Projection.Default(this.__com_vzome_core_construction_VefToModel_field) : projection;
                        if (projection != null && VefToModel.logger_$LI$().isLoggable(java.util.logging.Level.FINEST)) {
                            VefToModel.logger_$LI$().finest("projection = " + projection.getProjectionName());
                        }
                    }
                    static logger_$LI$() { if (VefToModel.logger == null) {
                        VefToModel.logger = java.util.logging.Logger.getLogger("com.vzome.core.construction.VefToModel");
                    } return VefToModel.logger; }
                    /**
                     *
                     * @param {number} numVertices
                     */
                    startVertices(numVertices) {
                        this.mVertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(numVertices);
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {com.vzome.core.algebra.AlgebraicVector} location
                     */
                    addVertex(index, location) {
                        VefToModel.logger_$LI$().finest("addVertex location = " + location.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
                        if (this.scale != null) {
                            location = location.scale(this.scale);
                            VefToModel.logger_$LI$().finest("scaled = " + location.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
                        }
                        if (this.wFirst() && location.dimension() === 3) {
                            location = location.inflateTo4d$();
                        }
                        location = this.mProjection.projectImage(location, this.wFirst());
                        VefToModel.logger_$LI$().finest("projected = " + location.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
                        if (this.offset != null) {
                            location = location.plus(this.offset);
                            VefToModel.logger_$LI$().finest("translated = " + location.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
                        }
                        this.mVertices[index] = new com.vzome.core.construction.FreePoint(location);
                        this.mVertices[index].setIndex(index);
                    }
                    /**
                     *
                     * @param {number} numEdges
                     */
                    startEdges(numEdges) {
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {number} v1
                     * @param {number} v2
                     */
                    addEdge(index, v1, v2) {
                        const p1 = this.mVertices[v1];
                        const p2 = this.mVertices[v2];
                        if (p1 == null || p2 == null)
                            return;
                        const seg = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                        seg.setIndex(index);
                        this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](seg);
                    }
                    /**
                     *
                     * @param {number} numFaces
                     */
                    startFaces(numFaces) {
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {int[]} verts
                     */
                    addFace(index, verts) {
                        const points = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(verts.length);
                        for (let i = 0; i < verts.length; i++) {
                            points[i] = this.mVertices[verts[i]];
                        }
                        const panel = new com.vzome.core.construction.PolygonFromVertices(points);
                        panel.setIndex(index);
                        this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](panel);
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {number} vertex
                     */
                    addBall(index, vertex) {
                        this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](this.mVertices[vertex]);
                    }
                    /**
                     *
                     * @param {number} numVertices
                     */
                    startBalls(numVertices) {
                        this.noBallsSection = false;
                    }
                    /**
                     *
                     * @param {java.util.StringTokenizer} tokens
                     */
                    endFile(tokens) {
                        if (this.noBallsSection) {
                            for (let index = 0; index < this.mVertices.length; index++) {
                                let vertex = this.mVertices[index];
                                {
                                    this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](vertex);
                                }
                            }
                        }
                    }
                }
                construction.VefToModel = VefToModel;
                VefToModel["__class"] = "com.vzome.core.construction.VefToModel";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var model;
            (function (model) {
                /**
                 * Create a panel from a list of AlgebraicVectors
                 *
                 * @param {*} vertices
                 * @class
                 * @extends com.vzome.core.model.ManifestationImpl
                 */
                class PanelImpl extends com.vzome.core.model.ManifestationImpl {
                    constructor(vertices) {
                        super();
                        if (this.mVertices === undefined) {
                            this.mVertices = null;
                        }
                        if (this.zoneVector === undefined) {
                            this.zoneVector = null;
                        }
                        if (this.label === undefined) {
                            this.label = null;
                        }
                        this.mVertices = (new java.util.ArrayList(vertices));
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    getZoneVector() {
                        if (this.zoneVector != null)
                            return this.zoneVector;
                        else
                            return this.getNormal$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector
                     */
                    setZoneVector(vector) {
                        this.zoneVector = vector;
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    getLocation() {
                        return null;
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    getFirstVertex() {
                        return this.mVertices.get(0);
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    getCentroid() {
                        return com.vzome.core.algebra.AlgebraicVectors.calculateCentroid(this.mVertices);
                    }
                    /**
                     *
                     * @return {com.vzome.core.construction.Construction}
                     */
                    toConstruction() {
                        const first = this.getFirstConstruction();
                        if (first != null && first.is3d())
                            return first;
                        const field = this.mVertices.get(0).getField();
                        const projected = (this.mVertices.stream().map(((field) => {
                            return (pt) => new com.vzome.core.construction.FreePoint(field.projectTo3d(pt, true));
                        })(field)).collect(java.util.stream.Collectors.toList()));
                        return new com.vzome.core.construction.PolygonFromVertices(projected);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    iterator() {
                        return this.mVertices.iterator();
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getVertexCount() {
                        return this.mVertices.size();
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        const len = this.mVertices.size();
                        if (len === 0)
                            return 0;
                        let val = ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })((this.mVertices.get(0)));
                        for (let i = 1; i < len; i++) {
                            val ^= /* hashCode */ ((o) => { if (o.hashCode) {
                                return o.hashCode();
                            }
                            else {
                                return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                            } })((this.mVertices.get(i)));
                        }
                        return val;
                    }
                    /**
                     *
                     * @param {*} other
                     * @return {boolean}
                     */
                    equals(other) {
                        if (other == null)
                            return false;
                        if (other === this)
                            return true;
                        if (!(other != null && other instanceof com.vzome.core.model.PanelImpl))
                            return false;
                        const panel = other;
                        const size = this.mVertices.size();
                        if (size !== panel.mVertices.size())
                            return false;
                        const found = (s => { let a = []; while (s-- > 0)
                            a.push(false); return a; })(size);
                        for (let i = 0; i < size; i++) {
                            {
                                let found_i = false;
                                for (let j = 0; j < size; j++) {
                                    {
                                        if (found[j])
                                            continue;
                                        if (this.mVertices.get(j).equals(panel.mVertices.get(i))) {
                                            found[j] = true;
                                            found_i = true;
                                            break;
                                        }
                                    }
                                    ;
                                }
                                if (!found_i)
                                    return false;
                            }
                            ;
                        }
                        for (let j = 0; j < size; j++) {
                            if (!found[j])
                                return false;
                            ;
                        }
                        return true;
                    }
                    getNormal$() {
                        const v0 = this.mVertices.get(0);
                        const v1 = this.mVertices.get(1);
                        const v2 = this.mVertices.get(2);
                        return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
                    }
                    getNormal$com_vzome_core_math_symmetry_Embedding(embedding) {
                        const v0 = this.mVertices.get(0);
                        const v1 = this.mVertices.get(1);
                        const v2 = this.mVertices.get(2);
                        const rv1 = embedding.embedInR3(v1.minus(v0));
                        const rv2 = embedding.embedInR3(v2.minus(v0));
                        return rv1.cross(rv2);
                    }
                    /**
                     *
                     * @param {*} embedding
                     * @return {com.vzome.core.math.RealVector}
                     */
                    getNormal(embedding) {
                        if (((embedding != null && (embedding.constructor != null && embedding.constructor["__interfaces"] != null && embedding.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Embedding") >= 0)) || embedding === null)) {
                            return this.getNormal$com_vzome_core_math_symmetry_Embedding(embedding);
                        }
                        else if (embedding === undefined) {
                            return this.getNormal$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        const buf = new java.lang.StringBuilder("panel: ");
                        let delim = "";
                        for (let index = this.mVertices.iterator(); index.hasNext();) {
                            let vertex = index.next();
                            {
                                buf.append(delim).append(vertex.toString());
                                delim = ", ";
                            }
                        }
                        return buf.toString();
                    }
                    /**
                     *
                     * @param {string} label
                     */
                    setLabel(label) {
                        this.label = label;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return this.label;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getQuadrea() {
                        const field = this.mVertices.get(0).getField();
                        return field.one();
                    }
                }
                model.PanelImpl = PanelImpl;
                PanelImpl["__class"] = "com.vzome.core.model.PanelImpl";
                PanelImpl["__interfaces"] = ["com.vzome.core.model.HasRenderedObject", "com.vzome.core.model.GroupElement", "com.vzome.core.model.Panel", "com.vzome.core.model.Manifestation", "java.lang.Iterable"];
            })(model = core.model || (core.model = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var model;
            (function (model) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.algebra.AlgebraicVector} end1
                 * @param {com.vzome.core.algebra.AlgebraicVector} end2
                 * @class
                 * @extends com.vzome.core.model.ManifestationImpl
                 */
                class StrutImpl extends com.vzome.core.model.ManifestationImpl {
                    constructor(end1, end2) {
                        super();
                        if (this.m_end1 === undefined) {
                            this.m_end1 = null;
                        }
                        if (this.m_end2 === undefined) {
                            this.m_end2 = null;
                        }
                        if (this.zoneVector === undefined) {
                            this.zoneVector = null;
                        }
                        if (this.label === undefined) {
                            this.label = null;
                        }
                        this.m_end1 = end1;
                        this.m_end2 = end2;
                    }
                    getZoneVector() {
                        if (this.zoneVector != null)
                            return this.zoneVector;
                        else
                            return this.getOffset();
                    }
                    setZoneVector(vector) {
                        this.zoneVector = vector;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        const result = ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.m_end1) ^ /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.m_end2);
                        return result;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (obj == null)
                            return false;
                        if (obj === this)
                            return true;
                        if (!(obj != null && obj instanceof com.vzome.core.model.StrutImpl))
                            return false;
                        const other = obj;
                        const otherStart = other.m_end1;
                        const otherEnd = other.m_end2;
                        if (otherStart.equals(this.m_end1))
                            return otherEnd.equals(this.m_end2);
                        else if (otherEnd.equals(this.m_end1))
                            return otherStart.equals(this.m_end2);
                        else
                            return false;
                    }
                    /**
                     *
                     * @param {*} other
                     * @return {number}
                     */
                    compareTo(other) {
                        if (this === other) {
                            return 0;
                        }
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(other, this)) {
                            return 0;
                        }
                        const thisFirst = this.getCanonicalLesserEnd();
                        const thisLast = this.getCanonicalGreaterEnd();
                        const otherFirst = other.getCanonicalLesserEnd();
                        const otherLast = other.getCanonicalGreaterEnd();
                        const comparison = thisFirst.compareTo(otherFirst);
                        return (comparison === 0) ? thisLast.compareTo(otherLast) : comparison;
                    }
                    getCanonicalLesserEnd() {
                        return (this.m_end1.compareTo(this.m_end2) < 0) ? this.m_end1 : this.m_end2;
                    }
                    getCanonicalGreaterEnd() {
                        return (this.m_end1.compareTo(this.m_end2) > 0) ? this.m_end1 : this.m_end2;
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    getLocation() {
                        return this.m_end1;
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    getCentroid() {
                        return com.vzome.core.algebra.AlgebraicVectors.getCentroid([this.m_end1, this.m_end2]);
                    }
                    /**
                     *
                     * @return {com.vzome.core.construction.Construction}
                     */
                    toConstruction() {
                        const first = this.getFirstConstruction();
                        if (first != null && first.is3d())
                            return first;
                        const field = this.m_end1.getField();
                        const pt1 = new com.vzome.core.construction.FreePoint(field.projectTo3d(this.m_end1, true));
                        const pt2 = new com.vzome.core.construction.FreePoint(field.projectTo3d(this.m_end2, true));
                        return new com.vzome.core.construction.SegmentJoiningPoints(pt1, pt2);
                    }
                    getEnd() {
                        return this.m_end2;
                    }
                    getOffset() {
                        return this.m_end2.minus(this.m_end1);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return "strut from " + this.m_end1.toString() + " to " + this.m_end2.toString();
                    }
                    /**
                     *
                     * @param {string} label
                     */
                    setLabel(label) {
                        this.label = label;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return this.label;
                    }
                }
                model.StrutImpl = StrutImpl;
                StrutImpl["__class"] = "com.vzome.core.model.StrutImpl";
                StrutImpl["__interfaces"] = ["com.vzome.core.model.HasRenderedObject", "com.vzome.core.model.GroupElement", "com.vzome.core.model.Strut", "java.lang.Comparable", "com.vzome.core.model.Manifestation"];
            })(model = core.model || (core.model = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var model;
            (function (model) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.algebra.AlgebraicVector} loc
                 * @class
                 * @extends com.vzome.core.model.ManifestationImpl
                 */
                class ConnectorImpl extends com.vzome.core.model.ManifestationImpl {
                    constructor(loc) {
                        super();
                        if (this.m_center === undefined) {
                            this.m_center = null;
                        }
                        if (this.label === undefined) {
                            this.label = null;
                        }
                        this.m_center = loc;
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    getLocation() {
                        return this.m_center;
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    getCentroid() {
                        return this.m_center;
                    }
                    /**
                     *
                     * @return {com.vzome.core.construction.Construction}
                     */
                    toConstruction() {
                        const first = this.getFirstConstruction();
                        if (first != null && first.is3d())
                            return first;
                        const field = this.m_center.getField();
                        return new com.vzome.core.construction.FreePoint(field.projectTo3d(this.m_center, true));
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        return /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.m_center);
                    }
                    /**
                     *
                     * @param {*} other
                     * @return {boolean}
                     */
                    equals(other) {
                        if (other == null)
                            return false;
                        if (other === this)
                            return true;
                        if (!(other != null && other instanceof com.vzome.core.model.ConnectorImpl))
                            return false;
                        const conn = other;
                        return this.getLocation().equals(conn.getLocation());
                    }
                    /**
                     *
                     * @param {*} other
                     * @return {number}
                     */
                    compareTo(other) {
                        if (this === other) {
                            return 0;
                        }
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(other, this)) {
                            return 0;
                        }
                        return this.getLocation().compareTo(other.getLocation());
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return "connector at " + this.m_center.toString();
                    }
                    /**
                     *
                     * @param {string} label
                     */
                    setLabel(label) {
                        this.label = label;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return this.label;
                    }
                }
                model.ConnectorImpl = ConnectorImpl;
                ConnectorImpl["__class"] = "com.vzome.core.model.ConnectorImpl";
                ConnectorImpl["__interfaces"] = ["com.vzome.core.model.HasRenderedObject", "com.vzome.core.model.GroupElement", "com.vzome.core.model.Connector", "java.lang.Comparable", "com.vzome.core.model.Manifestation"];
            })(model = core.model || (core.model = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class Polygon extends com.vzome.core.construction.Construction {
                    constructor(field) {
                        super(field);
                        if (this.mVertices === undefined) {
                            this.mVertices = null;
                        }
                        this.STRING_COMPARATOR = (s1, s2) => /* compareTo */ s1.localeCompare(s2);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return "polygon " + java.util.Arrays.toString(this.mVertices);
                    }
                    getSignature() {
                        const strArray = java.util.Arrays.stream(this.mVertices).map((av) => av.projectTo3d(true).toString()).toArray((arg0) => { return new Array(arg0); });
                        java.util.Arrays.sort(strArray, 0, strArray.length, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                            return funcInst;
                        } return (arg0, arg1) => (funcInst['compare'] ? funcInst['compare'] : funcInst).call(funcInst, arg0, arg1); })(this.STRING_COMPARATOR)));
                        return java.util.Arrays.toString(strArray);
                    }
                    setStateVariable(vertices, impossible) {
                        if (impossible) {
                            if (this.isImpossible())
                                return false;
                            this.setImpossible(true);
                            return true;
                        }
                        this.mVertices = vertices;
                        this.setImpossible(false);
                        return true;
                    }
                    getXml$org_w3c_dom_Document(doc) {
                        const result = doc.createElement("polygon");
                        this.getXml$org_w3c_dom_Element$java_lang_String(result, "vertex");
                        return result;
                    }
                    getXml$org_w3c_dom_Element$java_lang_String(result, vertexChildName) {
                        for (let index = 0; index < this.mVertices.length; index++) {
                            let vertex = this.mVertices[index];
                            {
                                const child = result.getOwnerDocument().createElement(vertexChildName);
                                com.vzome.xml.DomUtils.addAttribute(child, "at", vertex.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                                result.appendChild(child);
                            }
                        }
                    }
                    getXml(result, vertexChildName) {
                        if (((result != null && (result.constructor != null && result.constructor["__interfaces"] != null && result.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || result === null) && ((typeof vertexChildName === 'string') || vertexChildName === null)) {
                            return this.getXml$org_w3c_dom_Element$java_lang_String(result, vertexChildName);
                        }
                        else if (((result != null && (result.constructor != null && result.constructor["__interfaces"] != null && result.constructor["__interfaces"].indexOf("org.w3c.dom.Document") >= 0)) || result === null) && vertexChildName === undefined) {
                            return this.getXml$org_w3c_dom_Document(result);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        for (let index = 0; index < this.mVertices.length; index++) {
                            let algebraicVector = this.mVertices[index];
                            {
                                if (algebraicVector.dimension() !== 3)
                                    return false;
                            }
                        }
                        return true;
                    }
                    getVertexCount() {
                        return this.mVertices.length;
                    }
                    getVertex(i) {
                        return this.mVertices[i];
                    }
                    getNormal() {
                        return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.mVertices[0], this.mVertices[1], this.mVertices[2]);
                    }
                    getCentroid() {
                        return com.vzome.core.algebra.AlgebraicVectors.getCentroid(this.mVertices);
                    }
                    getVertices() {
                        return java.util.Arrays.copyOf(this.mVertices, this.mVertices.length);
                    }
                }
                construction.Polygon = Polygon;
                Polygon["__class"] = "com.vzome.core.construction.Polygon";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @extends com.vzome.core.construction.Construction
                 * @class
                 */
                class Transformation extends com.vzome.core.construction.Construction {
                    constructor(field) {
                        super(field);
                        if (this.mTransform === undefined) {
                            this.mTransform = null;
                        }
                        if (this.mOffset === undefined) {
                            this.mOffset = null;
                        }
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        return true;
                    }
                    /**
                     *
                     * @param {*} that
                     * @return {boolean}
                     */
                    equals(that) {
                        if (this === that) {
                            return true;
                        }
                        if (that == null) {
                            return false;
                        }
                        if (!(that != null && that instanceof com.vzome.core.construction.Transformation)) {
                            return false;
                        }
                        const other = that;
                        if (this.mOffset == null) {
                            if (other.mOffset != null) {
                                return false;
                            }
                        }
                        else if (!this.mOffset.equals(other.mOffset)) {
                            return false;
                        }
                        if (this.mTransform == null) {
                            if (other.mTransform != null) {
                                return false;
                            }
                        }
                        else if (!this.mTransform.equals(other.mTransform)) {
                            return false;
                        }
                        return true;
                    }
                    setStateVariables(transform, offset, impossible) {
                        if (impossible) {
                            if (this.isImpossible())
                                return false;
                            this.setImpossible(true);
                            return true;
                        }
                        if (transform != null && transform.equals(this.mTransform) && offset.equals(this.mOffset) && !this.isImpossible())
                            return false;
                        this.mTransform = transform;
                        this.mOffset = offset;
                        this.setImpossible(false);
                        return true;
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        arg = arg.minus(this.mOffset);
                        arg = this.mTransform.timesColumn(arg);
                        arg = arg.plus(this.mOffset);
                        return arg;
                    }
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    transform$com_vzome_core_construction_Construction(c) {
                        if (c != null && c instanceof com.vzome.core.construction.Point) {
                            return new com.vzome.core.construction.TransformedPoint(this, c);
                        }
                        else if (c != null && c instanceof com.vzome.core.construction.Segment) {
                            return new com.vzome.core.construction.TransformedSegment(this, c);
                        }
                        else if (c != null && c instanceof com.vzome.core.construction.Polygon) {
                            return new com.vzome.core.construction.TransformedPolygon(this, c);
                        }
                        else {
                            return null;
                        }
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        const result = doc.createElement("transformation");
                        return result;
                    }
                }
                construction.Transformation = Transformation;
                Transformation["__class"] = "com.vzome.core.construction.Transformation";
                (function (Transformation) {
                    class Identity extends com.vzome.core.construction.Transformation {
                        transform$int_A(arg) {
                            return arg;
                        }
                        transform(arg) {
                            if (((arg != null && arg instanceof Array && (arg.length == 0 || arg[0] == null || (typeof arg[0] === 'number'))) || arg === null)) {
                                return this.transform$int_A(arg);
                            }
                            else if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                                return super.transform(arg);
                            }
                            else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                                return this.transform$com_vzome_core_construction_Construction(arg);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor(field) {
                            super(field);
                        }
                        attach() {
                        }
                        detach() {
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        mapParamsToState() {
                            return true;
                        }
                    }
                    Transformation.Identity = Identity;
                    Identity["__class"] = "com.vzome.core.construction.Transformation.Identity";
                })(Transformation = construction.Transformation || (construction.Transformation = {}));
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @extends com.vzome.core.construction.Construction
                 * @class
                 */
                class Segment extends com.vzome.core.construction.Construction {
                    constructor(field) {
                        super(field);
                        if (this.mStart === undefined) {
                            this.mStart = null;
                        }
                        if (this.mOffset === undefined) {
                            this.mOffset = null;
                        }
                        if (this.mEnd === undefined) {
                            this.mEnd = null;
                        }
                    }
                    getSignature() {
                        const start = this.mStart.projectTo3d(true).toString();
                        const end = this.getEnd().projectTo3d(true).toString();
                        if ( /* compareTo */start.localeCompare(end) <= 0)
                            return start + "," + end;
                        else
                            return end + "," + start;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        return this.mStart.dimension() === 3 && this.mOffset.dimension() === 3;
                    }
                    setStateVariables(start, offset, impossible) {
                        if (impossible) {
                            if (this.isImpossible())
                                return false;
                            this.setImpossible(true);
                            return true;
                        }
                        if (offset.equals(this.mOffset) && !this.isImpossible() && start.equals(this.mStart))
                            return false;
                        this.mOffset = offset;
                        this.mStart = start;
                        this.mEnd = null;
                        this.setImpossible(false);
                        return true;
                    }
                    getStart() {
                        return this.mStart;
                    }
                    getEnd() {
                        if (this.mEnd == null)
                            this.mEnd = this.mStart.plus(this.mOffset);
                        return this.mEnd;
                    }
                    getOffset() {
                        return this.mOffset;
                    }
                    getCentroid() {
                        return com.vzome.core.algebra.AlgebraicVectors.getCentroid([this.mStart, this.mEnd]);
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        const result = doc.createElement("segment");
                        result.setAttribute("start", this.mStart.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                        result.setAttribute("end", this.getEnd().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                        return result;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return "segment from " + this.mStart + " to " + this.getEnd();
                    }
                }
                construction.Segment = Segment;
                Segment["__class"] = "com.vzome.core.construction.Segment";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @extends com.vzome.core.construction.Construction
                 * @class
                 */
                class Point extends com.vzome.core.construction.Construction {
                    constructor(field) {
                        super(field);
                        if (this.mLocation === undefined) {
                            this.mLocation = null;
                        }
                    }
                    getSignature() {
                        return this.mLocation.projectTo3d(true).toString();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        return this.mLocation.dimension() === 3;
                    }
                    setStateVariable(loc, impossible) {
                        if (impossible) {
                            if (this.isImpossible())
                                return false;
                            this.setImpossible(true);
                            return true;
                        }
                        if (loc.equals(this.mLocation) && !this.isImpossible())
                            return false;
                        this.mLocation = loc;
                        this.setImpossible(false);
                        return true;
                    }
                    getLocation() {
                        return this.mLocation;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        const result = doc.createElement("point");
                        result.setAttribute("at", this.getLocation().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                        return result;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return "point at " + this.mLocation;
                    }
                }
                construction.Point = Point;
                Point["__class"] = "com.vzome.core.construction.Point";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class Marker extends com.vzome.core.construction.Construction {
                    constructor(target) {
                        super(target.field);
                        if (this.mTarget === undefined) {
                            this.mTarget = null;
                        }
                        this.mTarget = target;
                    }
                    getTarget() {
                        return this.mTarget;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return false;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        const result = doc.createElement("marker");
                        return result;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        return this.mTarget.is3d();
                    }
                }
                construction.Marker = Marker;
                Marker["__class"] = "com.vzome.core.construction.Marker";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @extends com.vzome.core.construction.Construction
                 * @class
                 */
                class Plane extends com.vzome.core.construction.Construction {
                    constructor(field) {
                        super(field);
                        if (this.mBase === undefined) {
                            this.mBase = null;
                        }
                        if (this.mNormal === undefined) {
                            this.mNormal = null;
                        }
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        return true;
                    }
                    setStateVariables(base, normal, impossible) {
                        if (impossible) {
                            if (this.isImpossible())
                                return false;
                            this.setImpossible(true);
                            return true;
                        }
                        if (normal.equals(this.mNormal) && !this.isImpossible() && base.equals(this.mBase))
                            return false;
                        normal = normal.projectTo3d(true);
                        this.mNormal = normal;
                        this.mBase = base.projectTo3d(true);
                        this.setImpossible(false);
                        return true;
                    }
                    getBase() {
                        return this.mBase;
                    }
                    getNormal() {
                        return this.mNormal;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        const result = doc.createElement("plane");
                        return result;
                    }
                    getHomogeneous() {
                        return null;
                    }
                }
                construction.Plane = Plane;
                Plane["__class"] = "com.vzome.core.construction.Plane";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @extends com.vzome.core.construction.Construction
                 * @class
                 */
                class Line extends com.vzome.core.construction.Construction {
                    constructor(field) {
                        super(field);
                        if (this.mDirection === undefined) {
                            this.mDirection = null;
                        }
                        if (this.mStart === undefined) {
                            this.mStart = null;
                        }
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} start
                     * @param {com.vzome.core.algebra.AlgebraicVector} norm need not be normalized yet
                     * @return
                     * @param {boolean} impossible
                     * @return {boolean}
                     */
                    setStateVariables(start, norm, impossible) {
                        if (impossible) {
                            if (this.isImpossible())
                                return false;
                            this.setImpossible(true);
                            return true;
                        }
                        if (norm.equals(this.mDirection) && start.equals(this.mStart) && !this.isImpossible())
                            return false;
                        this.mDirection = norm;
                        this.mStart = start;
                        this.setImpossible(false);
                        return true;
                    }
                    getStart() {
                        return this.mStart;
                    }
                    /**
                     * @return {com.vzome.core.algebra.AlgebraicVector} a "unit" vector... always normalized
                     */
                    getDirection() {
                        return this.mDirection;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        const result = doc.createElement("line");
                        return result;
                    }
                    getHomogeneous() {
                        const v1 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mStart, this.getField());
                        const v2 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mStart.plus(this.mDirection), this.getField());
                        return v1.outer(v2);
                    }
                }
                construction.Line = Line;
                Line["__class"] = "com.vzome.core.construction.Line";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    /**
                     * @author David Hall
                     * @class
                     */
                    class Manifestations {
                        static visibleManifestations$java_lang_Iterable(manifestations) {
                            return new Manifestations.ManifestationIterator((man) => { return Manifestations.Filters.isVisible(man); }, manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(null)));
                        }
                        static visibleManifestations$java_util_function_Predicate$java_lang_Iterable(preTest, manifestations) {
                            return new Manifestations.ManifestationIterator((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(preTest)), manifestations, (man) => { return Manifestations.Filters.isVisible(man); });
                        }
                        static visibleManifestations(preTest, manifestations) {
                            if (((typeof preTest === 'function' && preTest.length === 1) || preTest === null) && ((manifestations != null && (manifestations.constructor != null && manifestations.constructor["__interfaces"] != null && manifestations.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || manifestations === null)) {
                                return com.vzome.core.editor.api.Manifestations.visibleManifestations$java_util_function_Predicate$java_lang_Iterable(preTest, manifestations);
                            }
                            else if (((preTest != null && (preTest.constructor != null && preTest.constructor["__interfaces"] != null && preTest.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preTest === null) && ((typeof manifestations === 'function' && manifestations.length === 1) || manifestations === null)) {
                                return com.vzome.core.editor.api.Manifestations.visibleManifestations$java_lang_Iterable$java_util_function_Predicate(preTest, manifestations);
                            }
                            else if (((preTest != null && (preTest.constructor != null && preTest.constructor["__interfaces"] != null && preTest.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preTest === null) && manifestations === undefined) {
                                return com.vzome.core.editor.api.Manifestations.visibleManifestations$java_lang_Iterable(preTest);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static visibleManifestations$java_lang_Iterable$java_util_function_Predicate(manifestations, postTest) {
                            return new Manifestations.ManifestationIterator((man) => { return Manifestations.Filters.isVisible(man); }, manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postTest)));
                        }
                        static getConnectors$java_lang_Iterable(manifestations) {
                            return new Manifestations.ConnectorIterator((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(null)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(null)));
                        }
                        static getConnectors$java_lang_Iterable$java_util_function_Predicate(manifestations, postFilter) {
                            return new Manifestations.ConnectorIterator((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(null)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        static getConnectors$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter) {
                            return new Manifestations.ConnectorIterator((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(preFilter)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        static getConnectors(preFilter, manifestations, postFilter) {
                            if (((typeof preFilter === 'function' && preFilter.length === 1) || preFilter === null) && ((manifestations != null && (manifestations.constructor != null && manifestations.constructor["__interfaces"] != null && manifestations.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || manifestations === null) && ((typeof postFilter === 'function' && postFilter.length === 1) || postFilter === null)) {
                                return com.vzome.core.editor.api.Manifestations.getConnectors$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter);
                            }
                            else if (((preFilter != null && (preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && ((typeof manifestations === 'function' && manifestations.length === 1) || manifestations === null) && postFilter === undefined) {
                                return com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations);
                            }
                            else if (((preFilter != null && (preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && manifestations === undefined && postFilter === undefined) {
                                return com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(preFilter);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static getVisibleConnectors(manifestations, postFilter = null) {
                            return new Manifestations.ConnectorIterator((man) => { return Manifestations.Filters.isVisible(man); }, manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        static getHiddenConnectors(manifestations, postFilter = null) {
                            return new Manifestations.ConnectorIterator((man) => { return Manifestations.Filters.isHidden(man); }, manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        static getStruts$java_lang_Iterable(manifestations) {
                            return new Manifestations.StrutIterator((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(null)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(null)));
                        }
                        static getStruts$java_lang_Iterable$java_util_function_Predicate(manifestations, postFilter) {
                            return new Manifestations.StrutIterator((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(null)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        static getStruts$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter) {
                            return new Manifestations.StrutIterator((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(preFilter)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        static getStruts(preFilter, manifestations, postFilter) {
                            if (((typeof preFilter === 'function' && preFilter.length === 1) || preFilter === null) && ((manifestations != null && (manifestations.constructor != null && manifestations.constructor["__interfaces"] != null && manifestations.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || manifestations === null) && ((typeof postFilter === 'function' && postFilter.length === 1) || postFilter === null)) {
                                return com.vzome.core.editor.api.Manifestations.getStruts$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter);
                            }
                            else if (((preFilter != null && (preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && ((typeof manifestations === 'function' && manifestations.length === 1) || manifestations === null) && postFilter === undefined) {
                                return com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations);
                            }
                            else if (((preFilter != null && (preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && manifestations === undefined && postFilter === undefined) {
                                return com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(preFilter);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static getVisibleStruts(manifestations, postFilter = null) {
                            return new Manifestations.StrutIterator((man) => { return Manifestations.Filters.isVisible(man); }, manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        static getHiddenStruts(manifestations, postFilter = null) {
                            return new Manifestations.StrutIterator((man) => { return Manifestations.Filters.isHidden(man); }, manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        static getPanels$java_lang_Iterable(manifestations) {
                            return new Manifestations.PanelIterator((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(null)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(null)));
                        }
                        static getPanels$java_lang_Iterable$java_util_function_Predicate(manifestations, postFilter) {
                            return new Manifestations.PanelIterator((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(null)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        static getPanels$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter) {
                            return new Manifestations.PanelIterator((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(preFilter)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        static getPanels(preFilter, manifestations, postFilter) {
                            if (((typeof preFilter === 'function' && preFilter.length === 1) || preFilter === null) && ((manifestations != null && (manifestations.constructor != null && manifestations.constructor["__interfaces"] != null && manifestations.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || manifestations === null) && ((typeof postFilter === 'function' && postFilter.length === 1) || postFilter === null)) {
                                return com.vzome.core.editor.api.Manifestations.getPanels$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter);
                            }
                            else if (((preFilter != null && (preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && ((typeof manifestations === 'function' && manifestations.length === 1) || manifestations === null) && postFilter === undefined) {
                                return com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations);
                            }
                            else if (((preFilter != null && (preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && manifestations === undefined && postFilter === undefined) {
                                return com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(preFilter);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static getVisiblePanels(manifestations, postFilter = null) {
                            return new Manifestations.PanelIterator((man) => { return Manifestations.Filters.isVisible(man); }, manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        static getHiddenPanels(manifestations, postFilter = null) {
                            return new Manifestations.PanelIterator((man) => { return Manifestations.Filters.isHidden(man); }, manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        /**
                         *
                         * @param {*} manifestations
                         * @param {*} output
                         * @return {com.vzome.core.algebra.AlgebraicVector} last selected Connector location, or last selected Strut location, or last vertex of last selected Panel
                         */
                        static sortVertices(manifestations, output) {
                            let lastBall = null;
                            let lastVertex = null;
                            for (let index = manifestations.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        lastBall = man.getLocation();
                                        output.add(lastBall);
                                    }
                                    else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                        lastVertex = man.getLocation();
                                        output.add(lastVertex);
                                        output.add(man.getEnd());
                                    }
                                    else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                        for (let index = man.iterator(); index.hasNext();) {
                                            let vertex = index.next();
                                            {
                                                lastVertex = vertex;
                                                output.add(vertex);
                                            }
                                        }
                                    }
                                }
                            }
                            return (lastBall != null) ? lastBall : lastVertex;
                        }
                    }
                    api.Manifestations = Manifestations;
                    Manifestations["__class"] = "com.vzome.core.editor.api.Manifestations";
                    (function (Manifestations) {
                        class ManifestationIterator extends com.vzome.core.generic.FilteredIterator {
                            constructor(preTest, manifestations, postTest) {
                                super((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                    return funcInst;
                                } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(preTest)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                    return funcInst;
                                } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postTest)));
                            }
                            apply$com_vzome_core_model_Manifestation(element) {
                                return element;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {*}
                             */
                            apply(element) {
                                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.apply$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)');
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                        }
                        Manifestations.ManifestationIterator = ManifestationIterator;
                        ManifestationIterator["__class"] = "com.vzome.core.editor.api.Manifestations.ManifestationIterator";
                        ManifestationIterator["__interfaces"] = ["java.util.Iterator", "java.lang.Iterable"];
                        class ConnectorIterator extends com.vzome.core.generic.FilteredIterator {
                            preFilter$com_vzome_core_model_Manifestation(element) {
                                return (element != null && (element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))) ? super.preFilter(element) : false;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {boolean}
                             */
                            preFilter(element) {
                                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.preFilter$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    return super.preFilter(element);
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                            apply$com_vzome_core_model_Manifestation(element) {
                                return element;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {*}
                             */
                            apply(element) {
                                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.apply$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)');
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                            constructor(preFilter, manifestations, postFilter) {
                                super((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                    return funcInst;
                                } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(preFilter)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                    return funcInst;
                                } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                            }
                        }
                        Manifestations.ConnectorIterator = ConnectorIterator;
                        ConnectorIterator["__class"] = "com.vzome.core.editor.api.Manifestations.ConnectorIterator";
                        ConnectorIterator["__interfaces"] = ["java.util.Iterator", "java.lang.Iterable"];
                        class StrutIterator extends com.vzome.core.generic.FilteredIterator {
                            preFilter$com_vzome_core_model_Manifestation(element) {
                                return (element != null && (element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))) ? super.preFilter(element) : false;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {boolean}
                             */
                            preFilter(element) {
                                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.preFilter$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    return super.preFilter(element);
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                            apply$com_vzome_core_model_Manifestation(element) {
                                return element;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {*}
                             */
                            apply(element) {
                                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.apply$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)');
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                            constructor(preFilter, manifestations, postFilter) {
                                super((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                    return funcInst;
                                } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(preFilter)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                    return funcInst;
                                } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                            }
                        }
                        Manifestations.StrutIterator = StrutIterator;
                        StrutIterator["__class"] = "com.vzome.core.editor.api.Manifestations.StrutIterator";
                        StrutIterator["__interfaces"] = ["java.util.Iterator", "java.lang.Iterable"];
                        class PanelIterator extends com.vzome.core.generic.FilteredIterator {
                            preFilter$com_vzome_core_model_Manifestation(element) {
                                return (element != null && (element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))) ? super.preFilter(element) : false;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {boolean}
                             */
                            preFilter(element) {
                                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.preFilter$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    return super.preFilter(element);
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                            apply$com_vzome_core_model_Manifestation(element) {
                                return element;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {*}
                             */
                            apply(element) {
                                if (((element != null && (element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.apply$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)');
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                            constructor(preFilter, manifestations, postFilter) {
                                super((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                    return funcInst;
                                } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(preFilter)), manifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                    return funcInst;
                                } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                            }
                        }
                        Manifestations.PanelIterator = PanelIterator;
                        PanelIterator["__class"] = "com.vzome.core.editor.api.Manifestations.PanelIterator";
                        PanelIterator["__interfaces"] = ["java.util.Iterator", "java.lang.Iterable"];
                        class Filters {
                            constructor() {
                            }
                            static isRendered(man) {
                                return man.isRendered();
                            }
                            static isVisible(man) {
                                return !man.isHidden();
                            }
                            static isHidden(man) {
                                return man.isHidden();
                            }
                            static is(man) {
                                return true;
                            }
                        }
                        Manifestations.Filters = Filters;
                        Filters["__class"] = "com.vzome.core.editor.api.Manifestations.Filters";
                    })(Manifestations = api.Manifestations || (api.Manifestations = {}));
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class XmlSymmetryFormat extends com.vzome.core.commands.XmlSaveFormat {
                    constructor(version, capabilities) {
                        super(version, capabilities);
                        if (this.symmetries === undefined) {
                            this.symmetries = null;
                        }
                    }
                    static __static_initialize() { if (!XmlSymmetryFormat.__static_initialized) {
                        XmlSymmetryFormat.__static_initialized = true;
                        XmlSymmetryFormat.__static_initializer_0();
                    } }
                    static __com_vzome_core_commands_XmlSymmetryFormat_logger_$LI$() { XmlSymmetryFormat.__static_initialize(); if (XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger == null) {
                        XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger = java.util.logging.Logger.getLogger("com.vzome.core.commands.XmlSaveFormat");
                    } return XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger; }
                    static __static_initializer_0() {
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.0/", [com.vzome.core.commands.XmlSaveFormat.PROJECT_4D, com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.0.1/", [com.vzome.core.commands.XmlSaveFormat.PROJECT_4D, com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.0.2/", [com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.0.3/", [com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.1.0/", [com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED, com.vzome.core.commands.XmlSaveFormat.FORMAT_2_1_0]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/3.0.0/", [com.vzome.core.commands.XmlSaveFormat.GROUPING_IN_SELECTION]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/4.0.0/", [com.vzome.core.commands.XmlSaveFormat.RATIONAL_VECTORS, com.vzome.core.commands.XmlSaveFormat.GROUPING_IN_SELECTION]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/5.0.0/", [com.vzome.core.commands.XmlSaveFormat.RATIONAL_VECTORS, com.vzome.core.commands.XmlSaveFormat.COMPACTED_COMMAND_EDITS]);
                        new XmlSymmetryFormat(com.vzome.core.commands.XmlSaveFormat.CURRENT_FORMAT, [com.vzome.core.commands.XmlSaveFormat.RATIONAL_VECTORS, com.vzome.core.commands.XmlSaveFormat.COMPACTED_COMMAND_EDITS, com.vzome.core.commands.XmlSaveFormat.MULTIPLE_DESIGNS]);
                    }
                    static getFormat(namespace) {
                        return com.vzome.core.commands.XmlSaveFormat.FORMATS_$LI$().get(namespace);
                    }
                    initialize$com_vzome_core_algebra_AlgebraicField$com_vzome_core_math_symmetry_OrbitSet_Field$int$java_lang_String$java_util_Properties(field, symms, scale, writerVersion, props) {
                        super.initialize(field, scale, writerVersion, props);
                        this.symmetries = symms;
                    }
                    initialize(field, symms, scale, writerVersion, props) {
                        if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((symms != null && (symms.constructor != null && symms.constructor["__interfaces"] != null && symms.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.OrbitSet.Field") >= 0)) || symms === null) && ((typeof scale === 'number') || scale === null) && ((typeof writerVersion === 'string') || writerVersion === null) && ((props != null && props instanceof java.util.Properties) || props === null)) {
                            return this.initialize$com_vzome_core_algebra_AlgebraicField$com_vzome_core_math_symmetry_OrbitSet_Field$int$java_lang_String$java_util_Properties(field, symms, scale, writerVersion, props);
                        }
                        else if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((typeof symms === 'number') || symms === null) && ((typeof scale === 'string') || scale === null) && ((writerVersion != null && writerVersion instanceof java.util.Properties) || writerVersion === null) && props === undefined) {
                            super.initialize(field, symms, scale, writerVersion);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    parseAlgebraicObject(valName, val) {
                        if (valName === ("Symmetry")) {
                            const name = val.getAttribute("name");
                            return this.parseSymmetry(name);
                        }
                        else if (valName === ("QuaternionicSymmetry")) {
                            const name = val.getAttribute("name");
                            return this.getQuaternionicSymmetry(name);
                        }
                        else if (valName === ("Axis"))
                            return this.parseAxis(val, "symm", "dir", "index", "sense");
                        else {
                            return super.parseAlgebraicObject(valName, val);
                        }
                    }
                    getQuaternionicSymmetry(name) {
                        return this.symmetries.getQuaternionSet(name);
                    }
                    parseSymmetry(sname) {
                        const group = this.symmetries.getGroup(sname);
                        const symm = group.getSymmetry();
                        if (symm == null) {
                            XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger_$LI$().severe("UNSUPPORTED symmetry: " + sname);
                            throw new java.lang.IllegalStateException("no symmetry with name=" + sname);
                        }
                        else
                            return symm;
                    }
                    static serializeAxis(xml, symmAttr, dirAttr, indexAttr, senseAttr, axis) {
                        let str = axis.getDirection().getSymmetry().getName();
                        if (!("icosahedral" === str))
                            com.vzome.xml.DomUtils.addAttribute(xml, symmAttr, str);
                        str = axis.getDirection().getName();
                        if (!("blue" === str))
                            com.vzome.xml.DomUtils.addAttribute(xml, dirAttr, str);
                        com.vzome.xml.DomUtils.addAttribute(xml, indexAttr, /* toString */ ('' + (axis.getOrientation())));
                        if (axis.getSense() !== com.vzome.core.math.symmetry.Symmetry.PLUS)
                            com.vzome.xml.DomUtils.addAttribute(xml, "sense", "minus");
                        if (!axis.isOutbound())
                            com.vzome.xml.DomUtils.addAttribute(xml, "outbound", "false");
                    }
                    parseAxis(xml, symmAttr, dirAttr, indexAttr, senseAttr) {
                        let sname = xml.getAttribute(symmAttr);
                        if (sname == null || /* isEmpty */ (sname.length === 0))
                            sname = "icosahedral";
                        const group = this.symmetries.getGroup(sname);
                        let aname = xml.getAttribute(dirAttr);
                        if (aname == null || /* isEmpty */ (aname.length === 0))
                            aname = "blue";
                        else if (aname === ("tan"))
                            aname = "sand";
                        else if (aname === ("spring"))
                            aname = "apple";
                        const iname = xml.getAttribute(indexAttr);
                        const index = javaemul.internal.IntegerHelper.parseInt(iname);
                        let sense = com.vzome.core.math.symmetry.Symmetry.PLUS;
                        if ("minus" === xml.getAttribute(senseAttr)) {
                            sense = com.vzome.core.math.symmetry.Symmetry.MINUS;
                        }
                        let outbound = true;
                        const outs = xml.getAttribute("outbound");
                        if (outs != null && (outs === ("false")))
                            outbound = false;
                        const dir = group.getDirection(aname);
                        if (dir == null) {
                            const msg = "Unsupported direction \'" + aname + "\' in " + sname + " symmetry";
                            XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger_$LI$().severe(msg);
                            throw new java.lang.IllegalStateException(msg);
                        }
                        return dir.getAxis$int$int$boolean(sense, index, outbound);
                    }
                }
                XmlSymmetryFormat.__static_initialized = false;
                commands.XmlSymmetryFormat = XmlSymmetryFormat;
                XmlSymmetryFormat["__class"] = "com.vzome.core.commands.XmlSymmetryFormat";
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandFreePoint extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAMS_$LI$() { if (CommandFreePoint.PARAMS == null) {
                        CommandFreePoint.PARAMS = [];
                    } return CommandFreePoint.PARAMS; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandFreePoint.PARAMS_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return null;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        const result = new com.vzome.core.construction.ConstructionList();
                        const loc = attributes.get("where");
                        const pt2 = new com.vzome.core.construction.FreePoint(loc);
                        effects['constructionAdded$com_vzome_core_construction_Construction'](pt2);
                        result.addConstruction(pt2);
                        return result;
                    }
                }
                commands.CommandFreePoint = CommandFreePoint;
                CommandFreePoint["__class"] = "com.vzome.core.commands.CommandFreePoint";
                CommandFreePoint["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandHide extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandHide.PARAM_SIGNATURE == null) {
                        CommandHide.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Construction]];
                    } return CommandHide.PARAM_SIGNATURE; }
                    static ATTR_SIGNATURE_$LI$() { if (CommandHide.ATTR_SIGNATURE == null) {
                        CommandHide.ATTR_SIGNATURE = [];
                    } return CommandHide.ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandHide.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandHide.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        throw new commands.Command.Failure("CommandHide apply attempted");
                    }
                }
                commands.CommandHide = CommandHide;
                CommandHide["__class"] = "com.vzome.core.commands.CommandHide";
                CommandHide["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class CommandSetColor extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandSetColor.PARAM_SIGNATURE == null) {
                        CommandSetColor.PARAM_SIGNATURE = [];
                    } return CommandSetColor.PARAM_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandSetColor.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return null;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        return parameters;
                    }
                }
                CommandSetColor.MANIFESTATION_ATTR = "manifestation.context";
                CommandSetColor.COLOR_ATTR = "color";
                commands.CommandSetColor = CommandSetColor;
                CommandSetColor["__class"] = "com.vzome.core.commands.CommandSetColor";
                CommandSetColor["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandLoad extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandLoad.PARAM_SIGNATURE == null) {
                        CommandLoad.PARAM_SIGNATURE = [];
                    } return CommandLoad.PARAM_SIGNATURE; }
                    static ATTR_SIGNATURE_$LI$() { if (CommandLoad.ATTR_SIGNATURE == null) {
                        CommandLoad.ATTR_SIGNATURE = [[CommandLoad.XML_ATTR, "org.w3c.dom.Element"]];
                    } return CommandLoad.ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandLoad.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandLoad.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        const result = new com.vzome.core.construction.ConstructionList();
                        return result;
                    }
                }
                CommandLoad.XML_ATTR = "xml";
                commands.CommandLoad = CommandLoad;
                CommandLoad["__class"] = "com.vzome.core.commands.CommandLoad";
                CommandLoad["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class GroupSelection extends com.vzome.core.editor.api.UndoableEdit {
                    constructor(editor) {
                        super();
                        if (this.mSelection === undefined) {
                            this.mSelection = null;
                        }
                        this.mGrouping = false;
                        this.recursiveGroups = true;
                        this.unnecessary = false;
                        this.mSelection = editor.getSelection();
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        const mode = props.get("mode");
                        this.mGrouping = (mode == null) || /* isEmpty */ (mode.length === 0) || (mode === ("group"));
                        this.unnecessary = this.mGrouping === this.mSelection.isSelectionAGroup();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return this.unnecessary;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        const elem = doc.createElement("GroupSelection");
                        if (!this.mGrouping)
                            com.vzome.xml.DomUtils.addAttribute(elem, "grouping", "false");
                        return elem;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getDetailXml(doc) {
                        return this.getXml(doc);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        const grouping = xml.getAttribute("grouping");
                        this.mGrouping = (grouping == null) || /* isEmpty */ (grouping.length === 0) || (grouping === ("true"));
                        this.recursiveGroups = format.groupingRecursive();
                        context.performAndRecord(this);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isDestructive() {
                        return true;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isVisible() {
                        return true;
                    }
                    /**
                     *
                     */
                    redo() {
                        if (this.mGrouping)
                            if (this.recursiveGroups)
                                this.mSelection.gatherGroup();
                            else
                                this.mSelection.gatherGroup211();
                        else if (this.recursiveGroups)
                            this.mSelection.scatterGroup();
                        else
                            this.mSelection.scatterGroup211();
                    }
                    /**
                     *
                     */
                    undo() {
                        if (!this.mGrouping)
                            if (this.recursiveGroups)
                                this.mSelection.gatherGroup();
                            else
                                this.mSelection.gatherGroup211();
                        else if (this.recursiveGroups)
                            this.mSelection.scatterGroup();
                        else
                            this.mSelection.scatterGroup211();
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.unnecessary)
                            return;
                        this.redo();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return false;
                    }
                }
                edits.GroupSelection = GroupSelection;
                GroupSelection["__class"] = "com.vzome.core.edits.GroupSelection";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * Used by CommandEdit.
                 * @param {*} editor
                 * @param m
                 * @param {com.vzome.core.construction.Point} newCenter
                 * @class
                 * @extends com.vzome.core.editor.api.UndoableEdit
                 */
                class SymmetryCenterChange extends com.vzome.core.editor.api.UndoableEdit {
                    constructor(editor, newCenter) {
                        if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0)) || editor === null) && ((newCenter != null && newCenter instanceof com.vzome.core.construction.Point) || newCenter === null)) {
                            let __args = arguments;
                            super();
                            if (this.mOldCenter === undefined) {
                                this.mOldCenter = null;
                            }
                            if (this.mNewCenter === undefined) {
                                this.mNewCenter = null;
                            }
                            if (this.editor === undefined) {
                                this.editor = null;
                            }
                            this.mOldCenter = editor.getCenterPoint();
                            this.mNewCenter = newCenter;
                            this.editor = editor;
                        }
                        else if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0)) || editor === null) && newCenter === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let newCenter = null;
                                super();
                                if (this.mOldCenter === undefined) {
                                    this.mOldCenter = null;
                                }
                                if (this.mNewCenter === undefined) {
                                    this.mNewCenter = null;
                                }
                                if (this.editor === undefined) {
                                    this.editor = null;
                                }
                                this.mOldCenter = editor.getCenterPoint();
                                this.mNewCenter = newCenter;
                                this.editor = editor;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    configure(props) {
                        const man = props.get("picked");
                        if (man != null)
                            this.mNewCenter = man.getFirstConstruction();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return this.mNewCenter == null || this.mNewCenter.getLocation().equals(this.mOldCenter.getLocation());
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isVisible() {
                        return false;
                    }
                    /**
                     *
                     */
                    redo() {
                        if (this.isNoOp())
                            return;
                        this.editor.setCenterPoint(this.mNewCenter);
                    }
                    /**
                     *
                     */
                    undo() {
                        if (this.isNoOp())
                            return;
                        this.editor.setCenterPoint(this.mOldCenter);
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        const result = doc.createElement("SymmetryCenterChange");
                        com.vzome.core.commands.XmlSaveFormat.serializePoint(result, "new", this.mNewCenter);
                        return result;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getDetailXml(doc) {
                        return this.getXml(doc);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        if (format.rationalVectors()) {
                            this.mNewCenter = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "new");
                        }
                        else {
                            const attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                            const center = attrs.get("new");
                            this.mNewCenter = new com.vzome.core.construction.FreePoint(center.getLocation().projectTo3d(true));
                        }
                        context.performAndRecord(this);
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.mNewCenter == null) {
                            this.mNewCenter = this.editor.getSelectedConstruction(com.vzome.core.construction.Point);
                            if (this.mNewCenter == null)
                                throw new com.vzome.core.commands.Command.Failure("Selection is not a single ball.");
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isDestructive() {
                        return true;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return false;
                    }
                }
                edits.SymmetryCenterChange = SymmetryCenterChange;
                SymmetryCenterChange["__class"] = "com.vzome.core.edits.SymmetryCenterChange";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * Used by CommandEdit.
                 * @param {*} editor
                 * @param m
                 * @param {com.vzome.core.construction.Segment} newAxis
                 * @class
                 * @extends com.vzome.core.editor.api.UndoableEdit
                 */
                class SymmetryAxisChange extends com.vzome.core.editor.api.UndoableEdit {
                    constructor(editor, newAxis) {
                        if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0)) || editor === null) && ((newAxis != null && newAxis instanceof com.vzome.core.construction.Segment) || newAxis === null)) {
                            let __args = arguments;
                            super();
                            if (this.mOldAxis === undefined) {
                                this.mOldAxis = null;
                            }
                            if (this.mNewAxis === undefined) {
                                this.mNewAxis = null;
                            }
                            if (this.mEditor === undefined) {
                                this.mEditor = null;
                            }
                            this.mOldAxis = editor.getSymmetrySegment();
                            this.mNewAxis = newAxis;
                            this.mEditor = editor;
                        }
                        else if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0)) || editor === null) && newAxis === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let newAxis = null;
                                super();
                                if (this.mOldAxis === undefined) {
                                    this.mOldAxis = null;
                                }
                                if (this.mNewAxis === undefined) {
                                    this.mNewAxis = null;
                                }
                                if (this.mEditor === undefined) {
                                    this.mEditor = null;
                                }
                                this.mOldAxis = editor.getSymmetrySegment();
                                this.mNewAxis = newAxis;
                                this.mEditor = editor;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    configure(props) {
                        const man = props.get("picked");
                        if (man != null)
                            this.mNewAxis = man.getFirstConstruction();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isVisible() {
                        return false;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return this.mNewAxis == null || (this.mOldAxis != null && this.mNewAxis.getStart().equals(this.mOldAxis.getStart()) && this.mNewAxis.getEnd().equals(this.mOldAxis.getEnd()));
                    }
                    /**
                     *
                     */
                    redo() {
                        if (this.isNoOp())
                            return;
                        this.mEditor.setSymmetrySegment(this.mNewAxis);
                    }
                    /**
                     *
                     */
                    undo() {
                        if (this.isNoOp())
                            return;
                        this.mEditor.setSymmetrySegment(this.mOldAxis);
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        const result = doc.createElement("SymmetryAxisChange");
                        com.vzome.core.commands.XmlSaveFormat.serializeSegment(result, "start", "end", this.mNewAxis);
                        return result;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getDetailXml(doc) {
                        return this.getXml(doc);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        if (format.rationalVectors()) {
                            this.mNewAxis = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "start", "end");
                        }
                        else {
                            const attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                            this.mNewAxis = attrs.get("new");
                        }
                        context.performAndRecord(this);
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.mNewAxis == null) {
                            this.mNewAxis = this.mEditor.getSelectedConstruction(com.vzome.core.construction.Segment);
                            if (this.mNewAxis == null)
                                throw new com.vzome.core.commands.Command.Failure("Selection is not a single strut.");
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isDestructive() {
                        return true;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return false;
                    }
                }
                edits.SymmetryAxisChange = SymmetryAxisChange;
                SymmetryAxisChange["__class"] = "com.vzome.core.edits.SymmetryAxisChange";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor_3) {
                /**
                 * Just a marker in the history.
                 * @author Scott Vorthmann
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.UndoableEdit
                 */
                class EndBlock extends com.vzome.core.editor.api.UndoableEdit {
                    constructor(editor) {
                        super();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return false;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        return doc.createElement("EndBlock");
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getDetailXml(doc) {
                        return this.getXml(doc);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isVisible() {
                        return false;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isDestructive() {
                        return false;
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        context.performAndRecord(this);
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                    }
                    /**
                     *
                     */
                    perform() {
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return false;
                    }
                }
                editor_3.EndBlock = EndBlock;
                EndBlock["__class"] = "com.vzome.core.editor.EndBlock";
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class EditHistory {
                    constructor() {
                        this.mEdits = (new java.util.ArrayList());
                        this.mEditNumber = 0;
                        this.breakpointHit = false;
                        if (this.listener === undefined) {
                            this.listener = null;
                        }
                        if (this.serializer === undefined) {
                            this.serializer = null;
                        }
                    }
                    static logger_$LI$() { if (EditHistory.logger == null) {
                        EditHistory.logger = java.util.logging.Logger.getLogger("com.vzome.core.EditHistory");
                    } return EditHistory.logger; }
                    static breakpointLogger_$LI$() { if (EditHistory.breakpointLogger == null) {
                        EditHistory.breakpointLogger = java.util.logging.Logger.getLogger("com.vzome.core.editor.Breakpoint");
                    } return EditHistory.breakpointLogger; }
                    setListener(listener) {
                        this.listener = listener;
                    }
                    setSerializer(serializer) {
                        this.serializer = serializer;
                    }
                    addEdit(edit, context) {
                        if (!edit.isDestructive()) {
                            this.mEdits.add(this.mEditNumber, edit);
                            ++this.mEditNumber;
                            return;
                        }
                        if (this.mEditNumber < this.mEdits.size()) {
                            let makeBranch = false;
                            let lastStickyEdit = this.mEditNumber - 1;
                            let deadEditIndex = this.mEditNumber;
                            for (const deadEdits = this.mEdits.listIterator(this.mEditNumber); deadEdits.hasNext();) {
                                {
                                    const dead = deadEdits.next();
                                    if (dead.isSticky()) {
                                        makeBranch = true;
                                        lastStickyEdit = deadEditIndex;
                                    }
                                    ++deadEditIndex;
                                }
                                ;
                            }
                            const branch = makeBranch ? new com.vzome.core.editor.Branch(context) : null;
                            deadEditIndex = this.mEditNumber;
                            for (const deadEdits = this.mEdits.listIterator(this.mEditNumber); deadEdits.hasNext();) {
                                {
                                    const removed = deadEdits.next();
                                    deadEdits.remove();
                                    if (deadEditIndex <= lastStickyEdit) {
                                        branch.addEdit(removed);
                                    }
                                    ++deadEditIndex;
                                }
                                ;
                            }
                            if (makeBranch) {
                                this.mEdits.add(branch);
                                ++this.mEditNumber;
                            }
                        }
                        this.mEdits.add(edit);
                        ++this.mEditNumber;
                    }
                    undoAll() {
                        let last = null;
                        do {
                            {
                                const edit = this.undo$();
                                if (edit == null)
                                    break;
                                last = edit;
                            }
                        } while ((true));
                        this.listener.publishChanges();
                        return last;
                    }
                    undoToManifestation(man) {
                        let edit = null;
                        do {
                            {
                                edit = this.undo$();
                                if (edit == null)
                                    break;
                                if ((edit != null && edit instanceof com.vzome.core.editor.api.ChangeManifestations) && edit.showsManifestation(man)) {
                                    break;
                                }
                            }
                        } while ((true));
                        this.listener.publishChanges();
                        return edit;
                    }
                    redoToBreakpoint() {
                        let edit = this.redo$();
                        if (edit == null)
                            return edit;
                        do {
                            {
                                if (this.atBreakpoint())
                                    break;
                                edit = this.redo$();
                                if (edit == null)
                                    break;
                            }
                        } while ((true));
                        this.listener.publishChanges();
                        return edit;
                    }
                    atBreakpoint() {
                        if (this.mEditNumber === this.mEdits.size())
                            return false;
                        const edit = this.mEdits.get(this.mEditNumber);
                        return edit.hasBreakpoint();
                    }
                    setBreakpoints(lineNumbers) {
                        java.util.Arrays.sort(lineNumbers);
                        let index = 0;
                        let lineNumber = lineNumbers[index];
                        for (let index1 = this.mEdits.iterator(); index1.hasNext();) {
                            let edit = index1.next();
                            {
                                const startLine = edit.getLineNumber();
                                if (startLine !== 0 && startLine >= lineNumber) {
                                    edit.setBreakpoint(true);
                                    ++index;
                                    if (index < lineNumbers.length)
                                        lineNumber = lineNumbers[index];
                                    else
                                        lineNumber = javaemul.internal.IntegerHelper.MAX_VALUE;
                                }
                                else {
                                    edit.setBreakpoint(false);
                                }
                            }
                        }
                    }
                    getBreakpoints() {
                        const result = (new java.util.ArrayList());
                        for (let index = this.mEdits.iterator(); index.hasNext();) {
                            let edit = index.next();
                            {
                                if (edit.hasBreakpoint())
                                    result.add(edit.getLineNumber());
                            }
                        }
                        return result;
                    }
                    redoAll(breakpoint) {
                        let last = null;
                        this.breakpointHit = false;
                        do {
                            {
                                const edit = this.redo$();
                                if (edit == null)
                                    break;
                                last = edit;
                                if (this.breakpointHit) {
                                    this.breakpointHit = false;
                                    break;
                                }
                            }
                        } while ((breakpoint === -1 || this.mEditNumber < breakpoint));
                        this.listener.publishChanges();
                        return last;
                    }
                    goToEdit(editNum) {
                        if (editNum === -1)
                            editNum = this.mEdits.size();
                        if (editNum === this.mEditNumber)
                            return;
                        while ((this.mEditNumber < editNum)) {
                            {
                                if (this.mEditNumber === this.mEdits.size())
                                    break;
                                const undoable = this.mEdits.get(this.mEditNumber++);
                                undoable.redo();
                            }
                        }
                        ;
                        while ((this.mEditNumber > editNum)) {
                            {
                                if (this.mEditNumber === 0)
                                    break;
                                const undoable = this.mEdits.get(--this.mEditNumber);
                                undoable.undo();
                            }
                        }
                        ;
                        this.listener.publishChanges();
                    }
                    undo$() {
                        return this.undo$boolean(true);
                    }
                    undo$boolean(useBlocks) {
                        if (this.mEditNumber === 0)
                            return null;
                        const undoable = this.mEdits.get(--this.mEditNumber);
                        if (useBlocks && (undoable != null && undoable instanceof com.vzome.core.editor.EndBlock))
                            return this.undoBlock();
                        undoable.undo();
                        EditHistory.logger_$LI$().fine("undo: " + undoable.toString());
                        if (undoable != null && undoable instanceof com.vzome.core.editor.BeginBlock)
                            return undoable;
                        if (!undoable.isVisible())
                            return this.undo$();
                        this.listener.publishChanges();
                        return undoable;
                    }
                    undo(useBlocks) {
                        if (((typeof useBlocks === 'boolean') || useBlocks === null)) {
                            return this.undo$boolean(useBlocks);
                        }
                        else if (useBlocks === undefined) {
                            return this.undo$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    undoBlock() {
                        let undone;
                        do {
                            {
                                undone = this.undo$();
                            }
                        } while ((!(undone != null && undone instanceof com.vzome.core.editor.BeginBlock)));
                        return undone;
                    }
                    getNextLineNumber() {
                        if (this.mEdits.isEmpty())
                            return 3;
                        let editNumber = this.mEditNumber;
                        if (editNumber >= this.mEdits.size())
                            editNumber = this.mEdits.size() - 1;
                        const undoable = this.mEdits.get(editNumber);
                        if (undoable != null && undoable instanceof com.vzome.core.editor.EditHistory.DeferredEdit)
                            return undoable.getLineNumber();
                        else
                            return 0;
                    }
                    redo$() {
                        return this.redo$boolean(true);
                    }
                    redo$boolean(useBlocks) {
                        if (this.mEditNumber === this.mEdits.size())
                            return null;
                        const undoable = this.mEdits.get(this.mEditNumber++);
                        if (useBlocks && (undoable != null && undoable instanceof com.vzome.core.editor.BeginBlock))
                            return this.redoBlock();
                        try {
                            if (EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                EditHistory.logger_$LI$().fine("redo: " + undoable.toString());
                            undoable.redo();
                        }
                        catch (e) {
                            if (EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.WARNING))
                                EditHistory.logger_$LI$().warning("edit number that failed is " + (this.mEditNumber - 1));
                            throw e;
                        }
                        if (undoable != null && undoable instanceof com.vzome.core.editor.EndBlock)
                            return undoable;
                        if (!undoable.isVisible())
                            return this.redo$();
                        this.listener.publishChanges();
                        return undoable;
                    }
                    redo(useBlocks) {
                        if (((typeof useBlocks === 'boolean') || useBlocks === null)) {
                            return this.redo$boolean(useBlocks);
                        }
                        else if (useBlocks === undefined) {
                            return this.redo$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    redoBlock() {
                        let lastSuccessfulRedo = "none";
                        const startingEditNumber = this.mEditNumber;
                        let redone;
                        do {
                            {
                                redone = this.redo$();
                                if (redone == null) {
                                    throw new java.lang.IllegalStateException("All " + this.mEditNumber + " edits have been redone without reaching an EndBlock. Starting edit number was " + startingEditNumber + ". Last successful redo was " + lastSuccessfulRedo + ". ");
                                }
                                lastSuccessfulRedo = /* getSimpleName */ (c => typeof c === 'string' ? c.substring(c.lastIndexOf('.') + 1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))(redone.constructor);
                                if (EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.FINE)) {
                                    const msg = "redoBlock is redoing edits from " + startingEditNumber + ". Current edit number is " + this.mEditNumber + ". Last redone was " + lastSuccessfulRedo;
                                    EditHistory.logger_$LI$().fine(msg);
                                }
                            }
                        } while ((!(redone != null && redone instanceof com.vzome.core.editor.EndBlock)));
                        return redone;
                    }
                    getDetailXml(doc) {
                        const result = doc.createElement("EditHistoryDetails");
                        com.vzome.xml.DomUtils.addAttribute(result, "editNumber", /* toString */ ('' + (this.mEditNumber)));
                        let edits = 0;
                        let lastStickyEdit = -1;
                        for (let index = this.iterator(); index.hasNext();) {
                            let undoable = index.next();
                            {
                                const edit = undoable.getDetailXml(doc);
                                ++edits;
                                com.vzome.xml.DomUtils.addAttribute(edit, "editNumber", /* toString */ ('' + (edits)));
                                if (EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))
                                    EditHistory.logger_$LI$().finest("side-effect: " + this.serializer.serialize(edit));
                                result.appendChild(edit);
                                if (undoable.isSticky())
                                    lastStickyEdit = edits;
                            }
                        }
                        result.setAttribute("lastStickyEdit", /* toString */ ('' + (lastStickyEdit)));
                        return result;
                    }
                    getXml(doc) {
                        const result = doc.createElement("EditHistory");
                        com.vzome.xml.DomUtils.addAttribute(result, "editNumber", /* toString */ ('' + (this.mEditNumber)));
                        return result;
                    }
                    mergeSelectionChanges() {
                        let cursor = this.mEditNumber;
                        if (cursor === 0)
                            return;
                        --cursor;
                        const above = this.mEdits.get(cursor);
                        if (above != null && above instanceof com.vzome.core.editor.api.ChangeManifestations)
                            return;
                        if (!(above != null && above instanceof com.vzome.core.editor.api.ChangeSelection))
                            return;
                        if (cursor === 0)
                            return;
                        --cursor;
                        const below = this.mEdits.get(cursor);
                        if (below != null && below instanceof com.vzome.core.editor.api.ChangeManifestations)
                            return;
                        if (below != null && below instanceof com.vzome.core.editor.api.ChangeSelection) {
                            let bracket = new com.vzome.core.editor.BeginBlock(null);
                            this.mEdits.add(cursor, bracket);
                            bracket = new com.vzome.core.editor.EndBlock(null);
                            this.mEdits.add(bracket);
                            this.mEditNumber += 2;
                        }
                        else if (below != null && below instanceof com.vzome.core.editor.EndBlock) {
                            let scan = cursor - 1;
                            const done = false;
                            while ((!done)) {
                                {
                                    const next = this.mEdits.get(scan);
                                    if (next != null && next instanceof com.vzome.core.editor.api.ChangeManifestations)
                                        return;
                                    if (next != null && next instanceof com.vzome.core.editor.api.ChangeSelection)
                                        --scan;
                                    else if (next != null && next instanceof com.vzome.core.editor.BeginBlock) {
                                        this.mEdits.remove(above);
                                        this.mEdits.add(cursor, above);
                                        return;
                                    }
                                    else
                                        return;
                                }
                            }
                            ;
                        }
                    }
                    replaceEdit(oldEdit, newEdit) {
                        this.mEdits.set(this.mEdits.indexOf(oldEdit), newEdit);
                    }
                    /**
                     * This is used during DeferredEdit .redo(), possibly to migrate one UndoableEdit into several.
                     * It must maintain the invariant that the next UndoableEdit is the next DeferredEdit to redo.
                     * @param {com.vzome.core.editor.api.UndoableEdit} edit
                     */
                    insert(edit) {
                        this.mEdits.add(this.mEditNumber++, edit);
                    }
                    /**
                     * Redo to greater of lastStickyEdit and lastDoneEdit, undo back to lastDoneEdit.
                     * If there are explicitSnapshots, this is a migration of an old Article, using edit
                     * numbers, and we have to redo as far as the last one, inserting snapshots as we go.
                     * Note that lastStickyEdit and explicitSnapshots are mutually exclusive, after and before
                     * migration, respectively.
                     *
                     * @param {number} lastDoneEdit
                     * @param {number} lastStickyEdit
                     * @param {com.vzome.core.editor.api.UndoableEdit[]} explicitSnapshots
                     * @throws Failure
                     */
                    synchronize(lastDoneEdit, lastStickyEdit, explicitSnapshots) {
                        let redoThreshold = Math.max(lastDoneEdit, lastStickyEdit);
                        if (explicitSnapshots != null)
                            redoThreshold = Math.max(redoThreshold, explicitSnapshots.length - 1);
                        this.mEditNumber = 0;
                        let targetEdit = 0;
                        const toRedo = (new java.util.ArrayList());
                        for (let i = 0; i < redoThreshold; i++) {
                            if (i < this.mEdits.size())
                                toRedo.add(this.mEdits.get(i));
                            else
                                break;
                            ;
                        }
                        for (let oldIndex = 0; oldIndex < toRedo.size(); oldIndex++) {
                            {
                                const edit = toRedo.get(oldIndex);
                                try {
                                    if (explicitSnapshots != null && explicitSnapshots.length > oldIndex && explicitSnapshots[oldIndex] != null) {
                                        const snapshot = explicitSnapshots[oldIndex];
                                        this.mEdits.add(this.mEditNumber, snapshot);
                                        if (this.mEditNumber <= lastDoneEdit)
                                            ++lastDoneEdit;
                                        ++this.mEditNumber;
                                        snapshot.perform();
                                    }
                                    ++this.mEditNumber;
                                    edit.redo();
                                    if (oldIndex + 1 === lastDoneEdit)
                                        targetEdit = this.mEditNumber;
                                }
                                catch (e) {
                                    if (EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.WARNING))
                                        EditHistory.logger_$LI$().warning("edit number that failed is " + (this.mEditNumber - 1));
                                    const t = null;
                                    if (t != null && t instanceof com.vzome.core.commands.Command.Failure)
                                        throw t;
                                    else
                                        throw e;
                                }
                            }
                            ;
                        }
                        if (explicitSnapshots != null && explicitSnapshots.length > redoThreshold && explicitSnapshots[redoThreshold] != null) {
                            const snapshot = explicitSnapshots[redoThreshold];
                            this.mEdits.add(this.mEditNumber, snapshot);
                            ++this.mEditNumber;
                            snapshot.perform();
                        }
                        this.goToEdit(targetEdit);
                    }
                    loadEdit(format, editElem, context) {
                        const edit = new EditHistory.DeferredEdit(this, format, editElem, context);
                        this.addEdit(edit, context);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    iterator() {
                        return this.mEdits.iterator();
                    }
                    getEditNumber() {
                        return this.mEditNumber;
                    }
                }
                editor.EditHistory = EditHistory;
                EditHistory["__class"] = "com.vzome.core.editor.EditHistory";
                EditHistory["__interfaces"] = ["java.lang.Iterable"];
                (function (EditHistory) {
                    class Breakpoint extends com.vzome.core.editor.api.UndoableEdit {
                        constructor(__parent) {
                            super();
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @param {*} doc
                         * @return {*}
                         */
                        getXml(doc) {
                            return doc.createElement("Breakpoint");
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isNoOp() {
                            return false;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isVisible() {
                            return true;
                        }
                        /**
                         *
                         * @param {*} xml
                         * @param {com.vzome.core.commands.XmlSaveFormat} format
                         * @param {*} context
                         */
                        loadAndPerform(xml, format, context) {
                            context.performAndRecord(this);
                        }
                        /**
                         *
                         */
                        perform() {
                            com.vzome.core.editor.EditHistory.breakpointLogger_$LI$().info("hit a Breakpoint at " + this.__parent.mEditNumber);
                            this.__parent.breakpointHit = true;
                        }
                        /**
                         *
                         */
                        redo() {
                            this.perform();
                        }
                        /**
                         *
                         */
                        undo() {
                        }
                        /**
                         *
                         * @param {*} props
                         */
                        configure(props) {
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isSticky() {
                            return false;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isDestructive() {
                            return false;
                        }
                        /**
                         *
                         * @param {*} doc
                         * @return {*}
                         */
                        getDetailXml(doc) {
                            return this.getXml(doc);
                        }
                    }
                    EditHistory.Breakpoint = Breakpoint;
                    Breakpoint["__class"] = "com.vzome.core.editor.EditHistory.Breakpoint";
                    class DeferredEdit extends com.vzome.core.editor.api.UndoableEdit {
                        constructor(__parent, format, editElem, context) {
                            super();
                            this.__parent = __parent;
                            if (this.format === undefined) {
                                this.format = null;
                            }
                            if (this.xml === undefined) {
                                this.xml = null;
                            }
                            if (this.context === undefined) {
                                this.context = null;
                            }
                            this.isBreakpoint = false;
                            this.format = format;
                            this.xml = editElem;
                            this.context = context;
                        }
                        /**
                         *
                         * @param {boolean} value
                         */
                        setBreakpoint(value) {
                            this.isBreakpoint = value;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        hasBreakpoint() {
                            return this.isBreakpoint;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isNoOp() {
                            return false;
                        }
                        /**
                         *
                         * @return {number}
                         */
                        getLineNumber() {
                            const locationData = this.xml.getUserData(com.vzome.xml.LocationData.LOCATION_DATA_KEY);
                            if (locationData != null)
                                return locationData.getStartLine();
                            else
                                return 0;
                        }
                        /**
                         *
                         * @param {*} doc
                         * @return {*}
                         */
                        getXml(doc) {
                            return ((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(doc, this.xml.getOwnerDocument()) ? this.xml : doc.importNode(this.xml, true);
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isVisible() {
                            return true;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isDestructive() {
                            return true;
                        }
                        /**
                         *
                         */
                        redo() {
                            const num = this.getLineNumber();
                            this.__parent.mEdits.remove(--this.__parent.mEditNumber);
                            if (com.vzome.core.editor.EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                com.vzome.core.editor.EditHistory.logger_$LI$().fine("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% " + num + ": " + this.__parent.serializer.serialize(this.xml));
                            let realized = null;
                            const cmdName = this.xml.getLocalName();
                            if (cmdName === ("Breakpoint")) {
                                realized = new EditHistory.Breakpoint(this.__parent);
                            }
                            else
                                realized = this.context.createEdit(this.xml);
                            realized.setLineNumber(num);
                            try {
                                this.__parent.listener.showCommand(this.xml, num);
                                realized.loadAndPerform(this.xml, this.format, new DeferredEdit.DeferredEdit$0(this));
                            }
                            catch (e) {
                                com.vzome.core.editor.EditHistory.logger_$LI$().warning("failure during initial edit replay:\n" + this.__parent.serializer.serialize(this.xml));
                                throw e;
                            }
                        }
                        /**
                         *
                         * @param {*} xml
                         * @param {com.vzome.core.commands.XmlSaveFormat} format
                         * @param {*} context
                         */
                        loadAndPerform(xml, format, context) {
                            throw new java.lang.IllegalStateException("should never be called");
                        }
                        /**
                         *
                         */
                        undo() {
                        }
                        /**
                         *
                         * @param {*} props
                         */
                        configure(props) {
                        }
                        /**
                         *
                         */
                        perform() {
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isSticky() {
                            return false;
                        }
                        /**
                         *
                         * @param {*} doc
                         * @return {*}
                         */
                        getDetailXml(doc) {
                            return doc.createElement("deferredEdit");
                        }
                    }
                    EditHistory.DeferredEdit = DeferredEdit;
                    DeferredEdit["__class"] = "com.vzome.core.editor.EditHistory.DeferredEdit";
                    (function (DeferredEdit) {
                        class DeferredEdit$0 {
                            constructor(__parent) {
                                this.__parent = __parent;
                            }
                            /**
                             *
                             * @param {com.vzome.core.editor.api.UndoableEdit} edit
                             */
                            performAndRecord(edit) {
                                try {
                                    edit.perform();
                                    if (edit.isNoOp())
                                        return;
                                    if (com.vzome.core.editor.EditHistory.logger_$LI$().isLoggable(java.util.logging.Level.FINEST)) {
                                        const details = edit.getDetailXml(this.__parent.xml.getOwnerDocument());
                                        com.vzome.core.editor.EditHistory.logger_$LI$().finest("side-effect: " + this.__parent.__parent.serializer.serialize(details));
                                    }
                                }
                                catch (e) {
                                    throw new java.lang.RuntimeException(e);
                                }
                                this.__parent.__parent.insert(edit);
                            }
                            /**
                             *
                             * @param {*} xml
                             * @return {com.vzome.core.editor.api.UndoableEdit}
                             */
                            createEdit(xml) {
                                const edit = this.__parent.context.createEdit(xml);
                                edit.setLineNumber(this.__parent.getLineNumber());
                                return edit;
                            }
                            /**
                             *
                             * @param {string} cmdName
                             * @return {*}
                             */
                            createLegacyCommand(cmdName) {
                                return this.__parent.context.createLegacyCommand(cmdName);
                            }
                            /**
                             *
                             * @param {string} action
                             * @param {*} props
                             * @return {boolean}
                             */
                            doEdit(action, props) {
                                return false;
                            }
                        }
                        DeferredEdit.DeferredEdit$0 = DeferredEdit$0;
                        DeferredEdit$0["__interfaces"] = ["com.vzome.core.editor.api.Context"];
                    })(DeferredEdit = EditHistory.DeferredEdit || (EditHistory.DeferredEdit = {}));
                })(EditHistory = editor.EditHistory || (editor.EditHistory = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class Snapshot extends com.vzome.core.editor.api.UndoableEdit {
                    constructor(id, controller) {
                        super();
                        if (this.id === undefined) {
                            this.id = 0;
                        }
                        if (this.recorder === undefined) {
                            this.recorder = null;
                        }
                        this.id = id;
                        this.recorder = controller;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return false;
                    }
                    /**
                     *
                     */
                    perform() {
                        this.recorder.recordSnapshot(this.id);
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        const idProp = props.get("id");
                        if (idProp != null)
                            this.id = /* intValue */ (idProp | 0);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isVisible() {
                        return false;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isDestructive() {
                        return false;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        const xml = doc.createElement("Snapshot");
                        com.vzome.xml.DomUtils.addAttribute(xml, "id", /* toString */ ('' + (this.id)));
                        return xml;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getDetailXml(doc) {
                        return this.getXml(doc);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        this.id = javaemul.internal.IntegerHelper.parseInt(xml.getAttribute("id"));
                        context.performAndRecord(this);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return true;
                    }
                }
                editor.Snapshot = Snapshot;
                Snapshot["__class"] = "com.vzome.core.editor.Snapshot";
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class Branch extends com.vzome.core.editor.api.UndoableEdit {
                    constructor(context) {
                        super();
                        if (this.context === undefined) {
                            this.context = null;
                        }
                        this.edits = (new java.util.ArrayList());
                        if (this.format === undefined) {
                            this.format = null;
                        }
                        if (this.xml === undefined) {
                            this.xml = null;
                        }
                        this.context = context;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return false;
                    }
                    addEdit(edit) {
                        this.edits.add(edit);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isDestructive() {
                        return false;
                    }
                    /**
                     *
                     */
                    perform() {
                        const toUndo = (new java.util.Stack());
                        const nodes = this.xml.getChildNodes();
                        for (let i = 0; i < nodes.getLength(); i++) {
                            {
                                const kid = nodes.item(i);
                                if (kid != null && (kid.constructor != null && kid.constructor["__interfaces"] != null && kid.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) {
                                    const editElem = kid;
                                    const edit = this.context.createEdit(editElem);
                                    this.addEdit(edit);
                                    edit.loadAndPerform(editElem, this.format, new Branch.Branch$0(this, toUndo));
                                }
                            }
                            ;
                        }
                        while ((!toUndo.isEmpty())) {
                            {
                                const edit = toUndo.pop();
                                edit.undo();
                            }
                        }
                        ;
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isVisible() {
                        return false;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        const branch = doc.createElement("Branch");
                        for (let index = this.edits.iterator(); index.hasNext();) {
                            let edit = index.next();
                            {
                                branch.appendChild(edit.getXml(doc));
                            }
                        }
                        return branch;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getDetailXml(doc) {
                        const branch = doc.createElement("Branch");
                        for (let index = this.edits.iterator(); index.hasNext();) {
                            let edit = index.next();
                            {
                                branch.appendChild(edit.getDetailXml(doc));
                            }
                        }
                        return branch;
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        this.xml = xml;
                        this.format = format;
                        context.performAndRecord(this);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return true;
                    }
                }
                editor.Branch = Branch;
                Branch["__class"] = "com.vzome.core.editor.Branch";
                (function (Branch) {
                    class Branch$0 {
                        constructor(__parent, toUndo) {
                            this.toUndo = toUndo;
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @param {com.vzome.core.editor.api.UndoableEdit} edit
                         */
                        performAndRecord(edit) {
                            try {
                                edit.perform();
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException(e);
                            }
                            this.toUndo.push(edit);
                        }
                        /**
                         *
                         * @param {*} xml
                         * @return {com.vzome.core.editor.api.UndoableEdit}
                         */
                        createEdit(xml) {
                            return this.__parent.context.createEdit(xml);
                        }
                        /**
                         *
                         * @param {string} cmdName
                         * @return {*}
                         */
                        createLegacyCommand(cmdName) {
                            return this.__parent.context.createLegacyCommand(cmdName);
                        }
                        /**
                         *
                         * @param {string} action
                         * @param {*} props
                         * @return {boolean}
                         */
                        doEdit(action, props) {
                            return false;
                        }
                    }
                    Branch.Branch$0 = Branch$0;
                    Branch$0["__interfaces"] = ["com.vzome.core.editor.api.Context"];
                })(Branch = editor.Branch || (editor.Branch = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor_4) {
                /**
                 * Just a marker in the history.
                 * @author Scott Vorthmann
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.UndoableEdit
                 */
                class BeginBlock extends com.vzome.core.editor.api.UndoableEdit {
                    constructor(editor) {
                        super();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return false;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        return doc.createElement("BeginBlock");
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getDetailXml(doc) {
                        return this.getXml(doc);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isVisible() {
                        return false;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isDestructive() {
                        return false;
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        context.performAndRecord(this);
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     */
                    perform() {
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return false;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                    }
                }
                editor_4.BeginBlock = BeginBlock;
                BeginBlock["__class"] = "com.vzome.core.editor.BeginBlock";
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    class SideEffects extends com.vzome.core.editor.api.UndoableEdit {
                        constructor() {
                            super();
                            this.mItems = (new java.util.ArrayList());
                            this.redone = 0;
                        }
                        /**
                         *
                         * @param {*} doc
                         * @return {*}
                         */
                        getDetailXml(doc) {
                            const result = this.getXml(doc);
                            const effects = doc.createElement("effects");
                            for (let index = this.mItems.iterator(); index.hasNext();) {
                                let se = index.next();
                                {
                                    if (se != null) {
                                        const effect = se.getXml(doc);
                                        if (effect != null) {
                                            effects.appendChild(effect);
                                        }
                                    }
                                }
                            }
                            result.appendChild(effects);
                            return result;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isSticky() {
                            return false;
                        }
                        static BUG_ACCOMMODATION_LOGGER_$LI$() { if (SideEffects.BUG_ACCOMMODATION_LOGGER == null) {
                            SideEffects.BUG_ACCOMMODATION_LOGGER = java.util.logging.Logger.getLogger("com.vzome.core.bug.accommodations");
                        } return SideEffects.BUG_ACCOMMODATION_LOGGER; }
                        static logBugAccommodation(accommodation) {
                            if (SideEffects.BUG_ACCOMMODATION_LOGGER_$LI$().isLoggable(java.util.logging.Level.WARNING))
                                SideEffects.BUG_ACCOMMODATION_LOGGER_$LI$().warning("ACCOMMODATION: " + accommodation);
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isVisible() {
                            return true;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isDestructive() {
                            return true;
                        }
                        plan(se) {
                            this.mItems.add(se);
                        }
                        /**
                         *
                         */
                        perform() {
                            this.redo();
                        }
                        fail(message) {
                            this.undo();
                            throw new com.vzome.core.commands.Command.Failure(message);
                        }
                        /**
                         *
                         * @param {*} props
                         */
                        configure(props) {
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isNoOp() {
                            return this.mItems.size() === 0;
                        }
                        /**
                         *
                         */
                        redo() {
                            for (let i = this.redone; i < this.mItems.size(); i++) {
                                {
                                    const se = this.mItems.get(i);
                                    if (se != null)
                                        se.redo();
                                }
                                ;
                            }
                            this.redone = this.mItems.size();
                        }
                        /**
                         *
                         */
                        undo() {
                            for (let i = this.mItems.size(); i > 0; i--) {
                                {
                                    const se = this.mItems.get(i - 1);
                                    if (se != null)
                                        se.undo();
                                }
                                ;
                            }
                            this.redone = 0;
                        }
                        getEffects() {
                            return this.mItems.iterator();
                        }
                    }
                    api.SideEffects = SideEffects;
                    SideEffects["__class"] = "com.vzome.core.editor.api.SideEffects";
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_1) {
                class LinearMapToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools, symmetry, originalScaling) {
                        super(tools, symmetry, com.vzome.core.tools.LinearMapTool.CATEGORY, com.vzome.core.tools.LinearMapTool.LABEL, com.vzome.core.tools.LinearMapTool.TOOLTIP);
                        if (this.originalScaling === undefined) {
                            this.originalScaling = false;
                        }
                        this.originalScaling = originalScaling;
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 7 && balls === 1 && struts === 6) || (total === 4 && balls === 1 && struts === 3);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.LinearMapTool(id, this.getToolsModel(), this.originalScaling);
                    }
                    /**
                     *
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createTool() {
                        const result = super.createTool();
                        result.setCopyColors(false);
                        return result;
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        let index = 0;
                        const segments = [null, null, null, null, null, null];
                        for (let index1 = selection.iterator(); index1.hasNext();) {
                            let man = index1.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))
                                    segments[index++] = man.getFirstConstruction();
                            }
                        }
                        let c1 = com.vzome.core.construction.ChangeOfBasis.findCommonVertex(segments[0], segments[1]);
                        let c2 = com.vzome.core.construction.ChangeOfBasis.findCommonVertex(segments[2], segments[1]);
                        if (c1 == null || c2 == null || !c1.equals(c2))
                            return false;
                        if (index === 3)
                            return true;
                        c1 = com.vzome.core.construction.ChangeOfBasis.findCommonVertex(segments[3], segments[4]);
                        c2 = com.vzome.core.construction.ChangeOfBasis.findCommonVertex(segments[5], segments[4]);
                        if (c1 == null || c2 == null || !c1.equals(c2))
                            return false;
                        return true;
                    }
                }
                tools_1.LinearMapToolFactory = LinearMapToolFactory;
                LinearMapToolFactory["__class"] = "com.vzome.core.tools.LinearMapToolFactory";
                LinearMapToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_2) {
                class TranslationToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools) {
                        super(tools, null, com.vzome.core.tools.TranslationTool.ID, com.vzome.core.tools.TranslationTool.LABEL, com.vzome.core.tools.TranslationTool.TOOLTIP);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 2 && balls === 2);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.TranslationTool(id, this.getToolsModel());
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        return true;
                    }
                }
                tools_2.TranslationToolFactory = TranslationToolFactory;
                TranslationToolFactory["__class"] = "com.vzome.core.tools.TranslationToolFactory";
                TranslationToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_3) {
                class OctahedralToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools, symmetry, id = OctahedralToolFactory.ID, label = OctahedralToolFactory.LABEL, tooltip = OctahedralToolFactory.TOOLTIP2) {
                        super(tools, symmetry, id, label, tooltip);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 1 && balls === 1) || (total === 2 && balls === 1 && struts === 1);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.SymmetryTool(id, this.getSymmetry(), this.getToolsModel());
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        const symmetry = this.getSymmetry();
                        const total = this.getSelection().size();
                        if (symmetry != null && symmetry instanceof com.vzome.core.math.symmetry.IcosahedralSymmetry) {
                            if (total !== 2)
                                return false;
                            for (let index = selection.iterator(); index.hasNext();) {
                                let man = index.next();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    const zone = symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](man.getOffset());
                                    if (zone == null)
                                        return false;
                                    switch ((zone.getDirection().getName())) {
                                        case "blue":
                                        case "green":
                                            return true;
                                        default:
                                            return false;
                                    }
                                }
                            }
                            return false;
                        }
                        else {
                            return total === 1;
                        }
                    }
                }
                OctahedralToolFactory.ID = "octahedral";
                OctahedralToolFactory.LABEL = "Create an octahedral symmetry tool";
                OctahedralToolFactory.TOOLTIP2 = "<p>Each tool produces up to 23 copies of the input<br>selection, using the rotation symmetries of a<br>cube or octahedron.  To create a tool, select a<br>ball that defines the center of symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 48 symmetries of the octahedron, including<br>reflections.<br></p>";
                tools_3.OctahedralToolFactory = OctahedralToolFactory;
                OctahedralToolFactory["__class"] = "com.vzome.core.tools.OctahedralToolFactory";
                OctahedralToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_4) {
                class PlaneSelectionToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools) {
                        super(tools, null, "plane", "", "");
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 3 && balls === 3);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.PlaneSelectionTool(id, this.getToolsModel());
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        return true;
                    }
                }
                tools_4.PlaneSelectionToolFactory = PlaneSelectionToolFactory;
                PlaneSelectionToolFactory["__class"] = "com.vzome.core.tools.PlaneSelectionToolFactory";
                PlaneSelectionToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_5) {
                class InversionToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools) {
                        super(tools, null, com.vzome.core.tools.InversionTool.ID, com.vzome.core.tools.InversionTool.LABEL, com.vzome.core.tools.InversionTool.TOOLTIP);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 1 && balls === 1);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.InversionTool(id, this.getToolsModel());
                    }
                    /**
                     *
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createTool() {
                        const result = super.createTool();
                        result.setCopyColors(false);
                        return result;
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        return true;
                    }
                }
                tools_5.InversionToolFactory = InversionToolFactory;
                InversionToolFactory["__class"] = "com.vzome.core.tools.InversionToolFactory";
                InversionToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_6) {
                class BookmarkToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools) {
                        super(tools, null, com.vzome.core.tools.BookmarkTool.ID, com.vzome.core.tools.BookmarkTool.LABEL, com.vzome.core.tools.BookmarkTool.TOOLTIP);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total > 0);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.BookmarkTool(id, this.getToolsModel());
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        return true;
                    }
                }
                tools_6.BookmarkToolFactory = BookmarkToolFactory;
                BookmarkToolFactory["__class"] = "com.vzome.core.tools.BookmarkToolFactory";
                BookmarkToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_7) {
                class RotationToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools, symmetry, id, label, tooltip) {
                        if (((tools != null && tools instanceof com.vzome.core.editor.ToolsModel) || tools === null) && ((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null) && ((typeof id === 'string') || id === null) && ((typeof label === 'string') || label === null) && ((typeof tooltip === 'string') || tooltip === null)) {
                            let __args = arguments;
                            super(tools, symmetry, id, label, tooltip);
                            if (this.noStrut === undefined) {
                                this.noStrut = false;
                            }
                        }
                        else if (((tools != null && tools instanceof com.vzome.core.editor.ToolsModel) || tools === null) && ((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null) && ((typeof id === 'boolean') || id === null) && label === undefined && tooltip === undefined) {
                            let __args = arguments;
                            let useSymmetryName = __args[2];
                            {
                                let __args = arguments;
                                let id = (useSymmetryName ? __args[1].getName() + ' ' : "") + RotationToolFactory.ID;
                                let label = RotationToolFactory.LABEL;
                                let tooltip = RotationToolFactory.TOOLTIP;
                                super(tools, symmetry, id, label, tooltip);
                                if (this.noStrut === undefined) {
                                    this.noStrut = false;
                                }
                            }
                        }
                        else if (((tools != null && tools instanceof com.vzome.core.editor.ToolsModel) || tools === null) && ((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null) && id === undefined && label === undefined && tooltip === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let useSymmetryName = false;
                                {
                                    let __args = arguments;
                                    let id = (useSymmetryName ? __args[1].getName() + ' ' : "") + RotationToolFactory.ID;
                                    let label = RotationToolFactory.LABEL;
                                    let tooltip = RotationToolFactory.TOOLTIP;
                                    super(tools, symmetry, id, label, tooltip);
                                    if (this.noStrut === undefined) {
                                        this.noStrut = false;
                                    }
                                }
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        if (total === 1 && balls === 1) {
                            this.noStrut = true;
                            return true;
                        }
                        else if ((total === 1 && struts === 1) || (total === 2 && balls === 1 && struts === 1)) {
                            this.noStrut = false;
                            return true;
                        }
                        return false;
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.RotationTool(id, this.getSymmetry(), this.getToolsModel(), false);
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        const symmetry = this.getSymmetry();
                        for (let index = selection.iterator(); index.hasNext();) {
                            let man = index.next();
                            if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                const axisStrut = man;
                                let vector = axisStrut.getOffset();
                                vector = symmetry.getField().projectTo3d(vector, true);
                                const axis = symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
                                if (axis == null)
                                    return false;
                                const perm = axis.getRotationPermutation();
                                if (perm == null)
                                    return false;
                            }
                            else if (this.noStrut) {
                                const axis = symmetry.getPreferredAxis();
                                if (axis == null)
                                    return false;
                            }
                        }
                        return true;
                    }
                }
                RotationToolFactory.ID = "rotation";
                RotationToolFactory.LABEL = "Create a rotation tool";
                RotationToolFactory.TOOLTIP = "<p>Each tool rotates the selected objects around an axis<br>of symmetry.  To create a tool, select a strut that<br>defines that axis.  You can also define the direction<br>and center independently, by selecting a ball for the<br>center and a strut for the axis.  Note: not all struts<br>correspond to rotational symmetries!<br><br>The direction of rotation depends on the strut<br>orientation, which is hard to discover, but easy to<br>control, by dragging out a new strut.<br><br>By default, the input selection will be moved to the new,<br>rotated orientation.  After creating a tool, you can<br>right-click to configure the tool to create a copy, instead.<br></p>";
                tools_7.RotationToolFactory = RotationToolFactory;
                RotationToolFactory["__class"] = "com.vzome.core.tools.RotationToolFactory";
                RotationToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_8) {
                class MirrorToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools) {
                        super(tools, null, com.vzome.core.tools.MirrorTool.ID, com.vzome.core.tools.MirrorTool.LABEL, com.vzome.core.tools.MirrorTool.TOOLTIP);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 2 && balls === 1 && struts === 1) || (total === 1 && panels === 1);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.MirrorTool(id, this.getToolsModel());
                    }
                    /**
                     *
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createTool() {
                        const result = super.createTool();
                        result.setCopyColors(false);
                        return result;
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        return true;
                    }
                }
                tools_8.MirrorToolFactory = MirrorToolFactory;
                MirrorToolFactory["__class"] = "com.vzome.core.tools.MirrorToolFactory";
                MirrorToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_9) {
                class ProjectionToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools) {
                        super(tools, null, com.vzome.core.tools.ProjectionTool.ID, com.vzome.core.tools.ProjectionTool.LABEL, com.vzome.core.tools.ProjectionTool.TOOLTIP);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 2 && panels === 1 && struts === 1) || (total === 1 && panels === 1) || (total === 2 && balls === 1 && struts === 1);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.ProjectionTool(id, this.getToolsModel());
                    }
                    /**
                     *
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createTool() {
                        const result = super.createTool();
                        result.setCopyColors(false);
                        return result;
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        return true;
                    }
                }
                tools_9.ProjectionToolFactory = ProjectionToolFactory;
                ProjectionToolFactory["__class"] = "com.vzome.core.tools.ProjectionToolFactory";
                ProjectionToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_10) {
                class SymmetryToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools, symmetry) {
                        super(tools, symmetry, com.vzome.core.tools.SymmetryTool.ID, com.vzome.core.tools.SymmetryTool.LABEL, com.vzome.core.tools.SymmetryTool.TOOLTIP);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 1 && balls === 1);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.SymmetryTool(id, this.getSymmetry(), this.getToolsModel());
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        return selection.size() === 1 && (selection.iterator().next() != null && (selection.iterator().next().constructor != null && selection.iterator().next().constructor["__interfaces"] != null && selection.iterator().next().constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0));
                    }
                }
                tools_10.SymmetryToolFactory = SymmetryToolFactory;
                SymmetryToolFactory["__class"] = "com.vzome.core.tools.SymmetryToolFactory";
                SymmetryToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_11) {
                class IcosahedralToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools, symmetry) {
                        super(tools, symmetry, IcosahedralToolFactory.ID, IcosahedralToolFactory.LABEL, IcosahedralToolFactory.TOOLTIP);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 1 && balls === 1);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.SymmetryTool(id, this.getSymmetry(), this.getToolsModel());
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        return selection.size() === 1 && (selection.iterator().next() != null && (selection.iterator().next().constructor != null && selection.iterator().next().constructor["__interfaces"] != null && selection.iterator().next().constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0));
                    }
                }
                IcosahedralToolFactory.ID = "icosahedral";
                IcosahedralToolFactory.LABEL = "Create an icosahedral symmetry tool";
                IcosahedralToolFactory.TOOLTIP = "<p>Each tool produces up to 59 copies of the input<br>selection, using the rotation symmetries of an<br>icosahedron.  To create a tool, select a single<br>ball that defines the center of symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 120 symmetries of the icosahedron, including<br>reflections.<br></p>";
                tools_11.IcosahedralToolFactory = IcosahedralToolFactory;
                IcosahedralToolFactory["__class"] = "com.vzome.core.tools.IcosahedralToolFactory";
                IcosahedralToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_12) {
                class PerspectiveProjectionToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools) {
                        super(tools, null, com.vzome.core.tools.PerspectiveProjectionTool.ID, com.vzome.core.tools.PerspectiveProjectionTool.LABEL, com.vzome.core.tools.PerspectiveProjectionTool.TOOLTIP);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 2 && panels === 1 && balls === 1);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.PerspectiveProjectionTool(id, this.getToolsModel());
                    }
                    /**
                     *
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createTool() {
                        const result = super.createTool();
                        result.setCopyColors(false);
                        return result;
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        return true;
                    }
                }
                tools_12.PerspectiveProjectionToolFactory = PerspectiveProjectionToolFactory;
                PerspectiveProjectionToolFactory["__class"] = "com.vzome.core.tools.PerspectiveProjectionToolFactory";
                PerspectiveProjectionToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_13) {
                class LineReflectionToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools) {
                        super(tools, null, LineReflectionToolFactory.ID, LineReflectionToolFactory.LABEL, LineReflectionToolFactory.TOOLTIP);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.LineReflectionTool(id, this.getToolsModel());
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 1 && struts === 1);
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        return true;
                    }
                }
                LineReflectionToolFactory.ID = "line reflection";
                LineReflectionToolFactory.LABEL = "Create a line reflection tool";
                LineReflectionToolFactory.TOOLTIP = "<p>Each tool duplicates the selection by reflecting<br>each object in a line.  To create a tool,<br>define the mirror line by selecting a strut.<br></p>";
                tools_13.LineReflectionToolFactory = LineReflectionToolFactory;
                LineReflectionToolFactory["__class"] = "com.vzome.core.tools.LineReflectionToolFactory";
                LineReflectionToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_14) {
                class ModuleToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools) {
                        super(tools, null, com.vzome.core.tools.ModuleTool.ID, com.vzome.core.tools.ModuleTool.LABEL, com.vzome.core.tools.ModuleTool.TOOLTIP);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total > 0);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.ModuleTool(id, this.getToolsModel());
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        return true;
                    }
                }
                tools_14.ModuleToolFactory = ModuleToolFactory;
                ModuleToolFactory["__class"] = "com.vzome.core.tools.ModuleToolFactory";
                ModuleToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_15) {
                class ScalingToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools, symmetry) {
                        super(tools, symmetry, com.vzome.core.tools.ScalingTool.ID, com.vzome.core.tools.ScalingTool.LABEL, com.vzome.core.tools.ScalingTool.TOOLTIP);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 3 && balls === 1 && struts === 2);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        const tool = new com.vzome.core.tools.ScalingTool(id, this.getSymmetry(), this.getToolsModel());
                        let scalePower = 0;
                        switch ((id)) {
                            case "scaling.builtin/scale up":
                                scalePower = 1;
                                break;
                            case "scaling.builtin/scale down":
                                scalePower = -1;
                                break;
                            default:
                                return tool;
                        }
                        const field = this.getToolsModel().getEditorModel().getRealizedModel().getField();
                        tool.setScaleFactor(field['createPower$int'](scalePower));
                        return tool;
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        const symmetry = this.getSymmetry();
                        let offset1 = null;
                        let offset2 = null;
                        for (let index = selection.iterator(); index.hasNext();) {
                            let man = index.next();
                            if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                const strut = man;
                                if (offset1 == null)
                                    offset1 = strut.getOffset();
                                else
                                    offset2 = strut.getOffset();
                            }
                        }
                        const zone1 = symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](offset1);
                        const zone2 = symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](offset2);
                        if (zone1 == null || zone2 == null)
                            return false;
                        const orbit1 = zone1.getDirection();
                        const orbit2 = zone2.getDirection();
                        if (orbit1 !== orbit2)
                            return false;
                        if (orbit1.isAutomatic())
                            return false;
                        const l1 = zone1.getLength(offset1);
                        const l2 = zone2.getLength(offset2);
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(l1, l2))
                            return false;
                        return true;
                    }
                }
                tools_15.ScalingToolFactory = ScalingToolFactory;
                ScalingToolFactory["__class"] = "com.vzome.core.tools.ScalingToolFactory";
                ScalingToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class MathTableExporter extends com.vzome.core.exporters.GeometryExporter {
                    static X_$LI$() { if (MathTableExporter.X == null) {
                        MathTableExporter.X = com.vzome.core.algebra.AlgebraicVector.X;
                    } return MathTableExporter.X; }
                    static Y_$LI$() { if (MathTableExporter.Y == null) {
                        MathTableExporter.Y = com.vzome.core.algebra.AlgebraicVector.Y;
                    } return MathTableExporter.Y; }
                    /**
                     *
                     * @param {java.io.File} file
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(file, writer, height, width) {
                        const field = this.mModel.getField();
                        const buf = new java.lang.StringBuilder();
                        buf.append("{\n");
                        MathTableExporter.writeFieldData(field, buf);
                        MathTableExporter.writeUnitTermsOrDiagonals(field, buf);
                        MathTableExporter.writeMultiplicationTable(field, buf);
                        MathTableExporter.writeDivisionTable(field, buf);
                        MathTableExporter.writeExponentsTable(field, buf);
                        if (field != null && field instanceof com.vzome.core.algebra.PolygonField) {
                            MathTableExporter.writeNamedNumbers(field, buf);
                            MathTableExporter.writeEmbedding(field, buf);
                            MathTableExporter.writeTrigTable(field, buf);
                        }
                        buf.setLength(buf.length() - 2);
                        buf.append("\n}\n");
                        this.output = new java.io.PrintWriter(writer);
                        this.output.println$java_lang_Object(/* replace */ buf.toString().split("\'").join("\""));
                        this.output.flush();
                    }
                    /*private*/ static getUnitTermOrDiagonal(field, i) {
                        return (field != null && field instanceof com.vzome.core.algebra.PolygonField) ? field.getUnitDiagonal(i) : field.getUnitTerm(i);
                    }
                    /*private*/ static getFieldOrderOrDiagonalCount(field) {
                        return (field != null && field instanceof com.vzome.core.algebra.PolygonField) ? field.diagonalCount() : field.getOrder();
                    }
                    /*private*/ static writeFieldData(field, buf) {
                        buf.append(" \'field\': { ").append("\'name\': \'").append(field.getName()).append("\', ").append("\'order\': ").append(field.getOrder());
                        if (field != null && field instanceof com.vzome.core.algebra.PolygonField) {
                            const pfield = field;
                            buf.append(", \'parity\': \'").append(pfield.isOdd() ? "odd" : "even").append("\', ").append("\'diagonalCount\': ").append(pfield.diagonalCount()).append(", ").append("\'polygonSides\': ").append(pfield.polygonSides());
                        }
                        buf.append(" },\n");
                    }
                    /*private*/ static writeEmbedding(field, buf) {
                        const symm = new com.vzome.core.math.symmetry.AntiprismSymmetry(field);
                        const embeddingRows = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                        for (let i = 0; i < 3; i++) {
                            {
                                const column = symm.embedInR3(field.basisVector(3, i));
                                embeddingRows[0 + i] = column.x;
                                embeddingRows[4 + i] = column.y;
                                embeddingRows[8 + i] = column.z;
                            }
                            ;
                        }
                        buf.append(" \'embedding\': [ ");
                        let delim = "";
                        for (let index = 0; index < embeddingRows.length; index++) {
                            let f = embeddingRows[index];
                            {
                                buf.append(delim).append(f);
                                delim = ", ";
                            }
                        }
                        buf.append(" ],\n");
                    }
                    /*private*/ static writeUnitTermsOrDiagonals(field, buf) {
                        const limit = MathTableExporter.getFieldOrderOrDiagonalCount(field);
                        buf.append(" \'unitTerms\': [ ");
                        let delim = "\n";
                        for (let i = 0; i < limit; i++) {
                            {
                                const number = MathTableExporter.getUnitTermOrDiagonal(field, i);
                                const name = (i === 0) ? "1" : field['getIrrational$int'](i);
                                buf.append(delim);
                                delim = ",\n";
                                buf.append("  { \'name\': \'").append(name).append("\'");
                                buf.append(", \'value\': ").append(MathTableExporter.formatAN(number));
                                buf.append(" }");
                            }
                            ;
                        }
                        buf.append("\n ],\n");
                    }
                    static OPTIONAL_NAMED_VALUES_$LI$() { if (MathTableExporter.OPTIONAL_NAMED_VALUES == null) {
                        MathTableExporter.OPTIONAL_NAMED_VALUES = ["phi", "rho", "sigma", "alpha", "beta", "gamma", "delta", "epsilon", "theta", "kappa", "lambda", "mu", "\u221a2", "\u221a3", "\u221a5", "\u221a6", "\u221a7", "\u221a8", "\u221a10"];
                    } return MathTableExporter.OPTIONAL_NAMED_VALUES; }
                    /*private*/ static writeNamedNumbers(field, buf) {
                        buf.append(" \'namedNumbers\': [");
                        let delim = "\n";
                        for (let index = 0; index < MathTableExporter.OPTIONAL_NAMED_VALUES_$LI$().length; index++) {
                            let name = MathTableExporter.OPTIONAL_NAMED_VALUES_$LI$()[index];
                            {
                                const number = field.getNumberByName(name);
                                if (number != null) {
                                    buf.append(delim);
                                    delim = ",\n";
                                    buf.append("  { \'name\': \'").append(name).append("\', ");
                                    buf.append("\'value\': ").append(MathTableExporter.formatAN(number)).append(", ");
                                    switch ((name)) {
                                        case "phi":
                                            MathTableExporter.writeDiagonalRatio(field, 5, buf);
                                            break;
                                        case "rho":
                                            MathTableExporter.writeDiagonalRatio(field, 7, buf);
                                            break;
                                        case "sigma":
                                            MathTableExporter.writeDiagonalRatio(field, 7, buf, 3);
                                            break;
                                        case "\u221a2":
                                            MathTableExporter.writeDiagonalRatio(field, 4, buf);
                                            break;
                                        case "\u221a3":
                                            MathTableExporter.writeDiagonalRatio(field, 6, buf);
                                            break;
                                        default:
                                            break;
                                    }
                                    buf.append("\'reciprocal\': ").append(MathTableExporter.formatAN(number.reciprocal()));
                                    buf.append(" }");
                                }
                            }
                        }
                        buf.append("\n ],\n");
                    }
                    /*private*/ static writeTrigTable(field, buf) {
                        const rotationMatrix = (new com.vzome.core.math.symmetry.AntiprismSymmetry(field)).getRotationMatrix();
                        const vX = field.basisVector(3, MathTableExporter.X_$LI$());
                        const v1 = rotationMatrix.timesColumn(vX);
                        let bisector = vX.plus(v1).scale(field.getUnitTerm(1).reciprocal());
                        let v = vX;
                        const nSides = field.polygonSides();
                        buf.append(" \'trig\': [\n");
                        for (let i = 0; i < nSides; i++) {
                            {
                                MathTableExporter.writeTrigEntry(i, nSides, v, bisector, buf);
                                buf.append(i === nSides - 1 ? "\n" : ",\n");
                                v = rotationMatrix.timesColumn(v);
                                bisector = rotationMatrix.timesColumn(bisector);
                            }
                            ;
                        }
                        buf.append(" ],\n");
                    }
                    /*private*/ static writeMultiplicationTable(field, buf) {
                        MathTableExporter.writeTable(field, buf, "multiplication", (n1, n2) => n1['times$com_vzome_core_algebra_AlgebraicNumber'](n2));
                    }
                    /*private*/ static writeDivisionTable(field, buf) {
                        MathTableExporter.writeTable(field, buf, "division", (n1, n2) => n1.dividedBy(n2));
                    }
                    /*private*/ static writeTable(field, buf, tableName, op) {
                        const operandFactory = (field != null && field instanceof com.vzome.core.algebra.PolygonField) ? (instance$PolygonField, n) => { return instance$PolygonField.getUnitDiagonal(n); } : (n) => { return field.getUnitTerm(n); };
                        const limit = (field != null && field instanceof com.vzome.core.algebra.PolygonField) ? field.diagonalCount() : field.getOrder();
                        buf.append(" \'").append(tableName).append("\': [\n");
                        let delim1 = "";
                        for (let i = 0; i < limit; i++) {
                            {
                                const n1 = (target => (typeof target === 'function') ? target(i) : target.apply(i))(operandFactory);
                                buf.append(delim1).append("  [ ");
                                delim1 = ",\n";
                                let delim2 = "";
                                for (let j = 0; j < limit; j++) {
                                    {
                                        const n2 = (target => (typeof target === 'function') ? target(j) : target.apply(j))(operandFactory);
                                        const result = (target => (typeof target === 'function') ? target(n1, n2) : target.apply(n1, n2))(op);
                                        buf.append(delim2);
                                        delim2 = ", ";
                                        buf.append(MathTableExporter.formatAN(result));
                                    }
                                    ;
                                }
                                buf.append(" ]");
                            }
                            ;
                        }
                        buf.append("\n ],\n");
                    }
                    /*private*/ static writeExponentsTable(field, buf) {
                        const limit = MathTableExporter.getFieldOrderOrDiagonalCount(field);
                        const range = 6;
                        buf.append(" \'exponents\': [\n");
                        let delim1 = "";
                        for (let i = 1; i < limit; i++) {
                            {
                                buf.append(delim1).append("  {");
                                delim1 = ",\n";
                                const name = field['getIrrational$int'](i);
                                buf.append(" \'base\': \'").append(name).append("\'");
                                {
                                    buf.append(",\n    \'positivePowers\': [ ");
                                    let delim2 = "";
                                    const base = MathTableExporter.getUnitTermOrDiagonal(field, i);
                                    let result = base;
                                    for (let power = 1; power <= range; power++) {
                                        {
                                            buf.append(delim2);
                                            delim2 = ", ";
                                            buf.append(MathTableExporter.formatAN(result));
                                            result = result['times$com_vzome_core_algebra_AlgebraicNumber'](base);
                                        }
                                        ;
                                    }
                                    buf.append(" ]");
                                }
                                ;
                                {
                                    buf.append(",\n    \'negativePowers\': [ ");
                                    let delim2 = "";
                                    const base = MathTableExporter.getUnitTermOrDiagonal(field, i).reciprocal();
                                    let result = base;
                                    for (let power = 1; power <= range; power++) {
                                        {
                                            buf.append(delim2);
                                            delim2 = ", ";
                                            buf.append(MathTableExporter.formatAN(result));
                                            result = result['times$com_vzome_core_algebra_AlgebraicNumber'](base);
                                        }
                                        ;
                                    }
                                    buf.append(" ]");
                                }
                                ;
                                buf.append("\n  }");
                            }
                            ;
                        }
                        buf.append("\n ],\n");
                    }
                    static writeDiagonalRatio(field, divisor, buf, step = 2) {
                        if (field.polygonSides() % divisor === 0) {
                            const n = (field.polygonSides() / divisor | 0);
                            const denominator = field.getUnitDiagonal(n - 1);
                            const numerator = field.getUnitDiagonal((step * n) - 1);
                            buf.append("\'numerator\': ").append(MathTableExporter.formatAN(numerator)).append(", ");
                            buf.append("\'denominator\': ").append(MathTableExporter.formatAN(denominator)).append(", ");
                        }
                        else {
                            throw new java.lang.IllegalStateException("shouldn\'t ever get here");
                        }
                    }
                    /*private*/ static writeTrigEntry(i, nSides, vStep, bisector, buf) {
                        const delim1 = "\', ";
                        const delim2 = ", ";
                        const infinite = "{ \'alg\': \'\u221e\', \'dec\': \'\u221e\', \'tdf\': \'\u221e\' }";
                        let v = vStep;
                        for (let n = 0; n < 2; n++) {
                            {
                                const k = (i * 2) + n;
                                const degrees = k * 180.0 / nSides;
                                const sin = v.getComponent(MathTableExporter.Y_$LI$());
                                const cos = v.getComponent(MathTableExporter.X_$LI$());
                                buf.append("  { ");
                                buf.append("\'rot\': \'").append(k).append("/").append(nSides * 2).append(delim1);
                                buf.append("\'rad\': \'").append(k).append("\u03c0/").append(nSides).append(delim1);
                                buf.append("\'deg\': ").append(degrees).append(delim2);
                                buf.append("\'sin\': ").append(MathTableExporter.formatAN(sin)).append(delim2);
                                buf.append("\'cos\': ").append(MathTableExporter.formatAN(cos)).append(delim2);
                                buf.append("\'tan\': ").append(cos.isZero() ? infinite : MathTableExporter.formatAN(sin.dividedBy(cos))).append(delim2);
                                buf.append("\'csc\': ").append(sin.isZero() ? infinite : MathTableExporter.formatAN(sin.reciprocal())).append(delim2);
                                buf.append("\'sec\': ").append(cos.isZero() ? infinite : MathTableExporter.formatAN(cos.reciprocal())).append(delim2);
                                buf.append("\'cot\': ").append(sin.isZero() ? infinite : MathTableExporter.formatAN(cos.dividedBy(sin)));
                                buf.append(" }");
                                if (n === 0) {
                                    buf.append(",\n");
                                }
                                v = bisector;
                            }
                            ;
                        }
                    }
                    /*private*/ static formatAN(n) {
                        const buf = new java.lang.StringBuilder();
                        buf.append("{ \'alg\': \'").append(n).append("\', \'dec\': ").append(n.evaluate()).append(", \'tdf\': [");
                        let delim = "";
                        {
                            let array = n.toTrailingDivisor();
                            for (let index = 0; index < array.length; index++) {
                                let term = array[index];
                                {
                                    buf.append(delim);
                                    delim = ", ";
                                    buf.append(term);
                                }
                            }
                        }
                        buf.append("] }");
                        return buf.toString();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "math.json";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getContentType() {
                        return "application/json";
                    }
                }
                exporters.MathTableExporter = MathTableExporter;
                MathTableExporter["__class"] = "com.vzome.core.exporters.MathTableExporter";
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class SnubDodecField extends com.vzome.core.algebra.AbstractAlgebraicField {
                    constructor(factory) {
                        super(SnubDodecField.FIELD_NAME, 6, factory);
                    }
                    /**
                     *
                     * @return {double[]} the coefficients of this AlgebraicField class.
                     * This can be used to determine when two fields have compatible coefficients
                     * without having to generate an instance of the class.
                     */
                    static getFieldCoefficients() {
                        return [1.0, SnubDodecField.PHI_VALUE_$LI$(), SnubDodecField.XI_VALUE, SnubDodecField.PHI_VALUE_$LI$() * SnubDodecField.XI_VALUE, SnubDodecField.XI_VALUE * SnubDodecField.XI_VALUE, SnubDodecField.PHI_VALUE_$LI$() * SnubDodecField.XI_VALUE * SnubDodecField.XI_VALUE];
                    }
                    /**
                     *
                     * @return {double[]}
                     */
                    getCoefficients() {
                        return SnubDodecField.getFieldCoefficients();
                    }
                    static PHI_VALUE_$LI$() { if (SnubDodecField.PHI_VALUE == null) {
                        SnubDodecField.PHI_VALUE = (1.0 + Math.sqrt(5.0)) / 2.0;
                    } return SnubDodecField.PHI_VALUE; }
                    /**
                     *
                     * @param {com.vzome.core.algebra.BigRational[]} a
                     * @param {com.vzome.core.algebra.BigRational[]} b
                     * @return {com.vzome.core.algebra.BigRational[]}
                     */
                    multiply(a, b) {
                        const result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.getOrder());
                        let factor = a[SnubDodecField.A].times(b[SnubDodecField.A]);
                        factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.B]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.C]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
                        result[SnubDodecField.A] = factor;
                        factor = a[SnubDodecField.B].times(b[SnubDodecField.A]);
                        factor = factor.plus(a[SnubDodecField.A].times(b[SnubDodecField.B]));
                        factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.B]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.C]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.C]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
                        result[SnubDodecField.B] = factor;
                        factor = a[SnubDodecField.C].times(b[SnubDodecField.A]);
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.B]));
                        factor = factor.plus(a[SnubDodecField.A].times(b[SnubDodecField.C]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.C]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.C]));
                        factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
                        result[SnubDodecField.C] = factor;
                        factor = a[SnubDodecField.D].times(b[SnubDodecField.A]);
                        factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.B]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.B]));
                        factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.C]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.C]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.C]));
                        factor = factor.plus(a[SnubDodecField.A].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
                        result[SnubDodecField.D] = factor;
                        factor = a[SnubDodecField.E].times(b[SnubDodecField.A]);
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.B]));
                        factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.C]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.A].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
                        result[SnubDodecField.E] = factor;
                        factor = a[SnubDodecField.F].times(b[SnubDodecField.A]);
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.B]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.B]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.C]));
                        factor = factor.plus(a[SnubDodecField.C].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.D].times(b[SnubDodecField.D]));
                        factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.E]));
                        factor = factor.plus(a[SnubDodecField.A].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.B].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.E].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
                        factor = factor.plus(a[SnubDodecField.F].times(b[SnubDodecField.F]));
                        result[SnubDodecField.F] = factor;
                        return result;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getNumMultipliers() {
                        return 2;
                    }
                    /**
                     * scalar for an affine pentagon
                     * @return {*}
                     */
                    getAffineScalar() {
                        return this.getUnitTerm(1);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getGoldenRatio() {
                        return this.getUnitTerm(1);
                    }
                    static IRRATIONAL_LABELS_$LI$() { if (SnubDodecField.IRRATIONAL_LABELS == null) {
                        SnubDodecField.IRRATIONAL_LABELS = [[" ", " "], ["\u03c6", "phi"], ["\u03be", "xi"], ["\u03c6\u03be", "phi*xi"], ["\u03be\u00b2", "xi^2"], ["\u03c6\u03be\u00b2", "phi*xi^2"]];
                    } return SnubDodecField.IRRATIONAL_LABELS; }
                    getIrrational$int$int(i, format) {
                        return SnubDodecField.IRRATIONAL_LABELS_$LI$()[i][format];
                    }
                    /**
                     *
                     * @param {number} i
                     * @param {number} format
                     * @return {string}
                     */
                    getIrrational(i, format) {
                        if (((typeof i === 'number') || i === null) && ((typeof format === 'number') || format === null)) {
                            return this.getIrrational$int$int(i, format);
                        }
                        else if (((typeof i === 'number') || i === null) && format === undefined) {
                            return this.getIrrational$int(i);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.BigRational[]} factors
                     * @return {number}
                     */
                    evaluateNumber(factors) {
                        let result = 0.0;
                        result += factors[SnubDodecField.A].evaluate();
                        result += SnubDodecField.PHI_VALUE_$LI$() * factors[SnubDodecField.B].evaluate();
                        result += SnubDodecField.XI_VALUE * factors[SnubDodecField.C].evaluate();
                        result += SnubDodecField.PHI_VALUE_$LI$() * SnubDodecField.XI_VALUE * factors[SnubDodecField.D].evaluate();
                        result += SnubDodecField.XI_VALUE * SnubDodecField.XI_VALUE * factors[SnubDodecField.E].evaluate();
                        result += SnubDodecField.XI_VALUE * SnubDodecField.XI_VALUE * SnubDodecField.PHI_VALUE_$LI$() * factors[SnubDodecField.F].evaluate();
                        return result;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.BigRational[]} factors
                     * @param {number} whichIrrational
                     * @return {com.vzome.core.algebra.BigRational[]}
                     */
                    scaleBy(factors, whichIrrational) {
                        switch ((whichIrrational)) {
                            case 0 /* A */:
                                return factors;
                            case 1 /* B */:
                                return [factors[SnubDodecField.B], factors[SnubDodecField.A].plus(factors[SnubDodecField.B]), factors[SnubDodecField.D], factors[SnubDodecField.C].plus(factors[SnubDodecField.D]), factors[SnubDodecField.F], factors[SnubDodecField.E].plus(factors[SnubDodecField.F])];
                            case 2 /* C */:
                                return [factors[SnubDodecField.F], factors[SnubDodecField.E].plus(factors[SnubDodecField.F]), factors[SnubDodecField.A].plus(factors[SnubDodecField.E]).plus(factors[SnubDodecField.E]), factors[SnubDodecField.B].plus(factors[SnubDodecField.F]).plus(factors[SnubDodecField.F]), factors[SnubDodecField.C], factors[SnubDodecField.D]];
                            case 3 /* D */:
                                return this.scaleBy(this.scaleBy(factors, SnubDodecField.B), SnubDodecField.C);
                            case 4 /* E */:
                                return this.scaleBy(this.scaleBy(factors, SnubDodecField.C), SnubDodecField.C);
                            case 5 /* F */:
                                return this.scaleBy(this.scaleBy(factors, SnubDodecField.D), SnubDodecField.C);
                            default:
                                throw new java.lang.IllegalArgumentException(whichIrrational + " is not a valid irrational in this field");
                        }
                    }
                }
                SnubDodecField.FIELD_NAME = "snubDodec";
                SnubDodecField.XI_VALUE = 1.7155614996973678;
                SnubDodecField.A = 0;
                SnubDodecField.B = 1;
                SnubDodecField.C = 2;
                SnubDodecField.D = 3;
                SnubDodecField.E = 4;
                SnubDodecField.F = 5;
                algebra.SnubDodecField = SnubDodecField;
                SnubDodecField["__class"] = "com.vzome.core.algebra.SnubDodecField";
                SnubDodecField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                /**
                 * @author David Hall
                 * @param {string} name
                 * @param {number} order
                 * @param {*} factory
                 * @class
                 * @extends com.vzome.core.algebra.AbstractAlgebraicField
                 */
                class ParameterizedField extends com.vzome.core.algebra.AbstractAlgebraicField {
                    constructor(name, order, factory) {
                        super(name, order, factory);
                        if (this.coefficients === undefined) {
                            this.coefficients = null;
                        }
                        if (this.multiplicationTensor === undefined) {
                            this.multiplicationTensor = null;
                        }
                        if (this.irrationalLabels === undefined) {
                            this.irrationalLabels = null;
                        }
                        this.normalizer = (field, factors) => { return ParameterizedField.doNothing(field, factors); };
                        this.coefficients = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(order);
                        this.multiplicationTensor = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return 0;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([order, order, order]);
                        this.irrationalLabels = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return null;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([order, 2]);
                        this.irrationalLabels[0] = [" ", " "];
                    }
                    /**
                     * doNothing is the default normalizer method.
                     * @param {com.vzome.core.algebra.BigRational[]} factors
                     * @param {*} field
                     */
                    static doNothing(field, factors) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.BigRational[]} factors
                     */
                    normalize(factors) {
                        (target => (typeof target === 'function') ? target(this, factors) : target.accept(this, factors))(this.normalizer);
                    }
                    initialize() {
                        this.initializeNormalizer();
                        this.initializeMultiplicationTensor();
                        this.initializeCoefficients();
                        this.initializeLabels();
                    }
                    initializeNormalizer() {
                        this.normalizer = (field, factors) => { return ParameterizedField.doNothing(field, factors); };
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.BigRational[]} v1
                     * @param {com.vzome.core.algebra.BigRational[]} v2
                     * @return {com.vzome.core.algebra.BigRational[]}
                     */
                    multiply(v1, v2) {
                        const order = this.getOrder();
                        const result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(order);
                        for (let i = 0; i < order; i++) {
                            {
                                result[i] = this.numberFactory.zero();
                                for (let j = 0; j < order; j++) {
                                    {
                                        for (let k = 0; k < order; k++) {
                                            {
                                                const multiplier = this.multiplicationTensor[i][j][k];
                                                if (multiplier !== 0) {
                                                    let product = v1[j].times(v2[k]);
                                                    if (multiplier !== 1) {
                                                        product = product.timesInt(multiplier);
                                                    }
                                                    result[i] = result[i].plus(product);
                                                }
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.BigRational[]} factors
                     * @param {number} whichIrrational
                     * @return {com.vzome.core.algebra.BigRational[]}
                     */
                    scaleBy(factors, whichIrrational) {
                        if (whichIrrational === 0) {
                            return factors;
                        }
                        const order = this.getOrder();
                        const result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(order);
                        for (let i = 0; i < order; i++) {
                            {
                                result[i] = this.numberFactory.zero();
                                for (let j = 0; j < order; j++) {
                                    {
                                        const multiplier = this.multiplicationTensor[i][j][whichIrrational];
                                        if (multiplier !== 0) {
                                            if (multiplier === 1) {
                                                result[i] = result[i].plus(factors[j]);
                                            }
                                            else {
                                                result[i] = result[i].plus(factors[j].timesInt(multiplier));
                                            }
                                        }
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        this.normalize(result);
                        return result;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.BigRational[]} factors
                     * @return {number}
                     */
                    evaluateNumber(factors) {
                        let result = 0.0;
                        const order = this.getOrder();
                        for (let i = 0; i < order; i++) {
                            {
                                result += factors[i].evaluate() * this.coefficients[i];
                            }
                            ;
                        }
                        return result;
                    }
                    getIrrational$int$int(i, format) {
                        return this.irrationalLabels[i][format];
                    }
                    /**
                     *
                     * @param {number} i
                     * @param {number} format
                     * @return {string}
                     */
                    getIrrational(i, format) {
                        if (((typeof i === 'number') || i === null) && ((typeof format === 'number') || format === null)) {
                            return this.getIrrational$int$int(i, format);
                        }
                        else if (((typeof i === 'number') || i === null) && format === undefined) {
                            return this.getIrrational$int(i);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getCoefficient(i) {
                        return this.coefficients[i];
                    }
                }
                algebra.ParameterizedField = ParameterizedField;
                ParameterizedField["__class"] = "com.vzome.core.algebra.ParameterizedField";
                ParameterizedField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var model;
            (function (model) {
                class VefModelExporter extends com.vzome.core.algebra.VefVectorExporter {
                    constructor(writer, field, scale = null, withOffset = false) {
                        super(writer, field, scale, withOffset);
                    }
                    /**
                     *
                     * @param {*} man
                     */
                    exportManifestation(man) {
                        if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                            this.exportPoint(man.getLocation());
                        }
                        else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                            const strut = man;
                            this.exportSegment(strut.getLocation(), strut.getEnd());
                        }
                        else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                            const panel = man;
                            const corners = (new java.util.ArrayList(panel.getVertexCount()));
                            for (let index = panel.iterator(); index.hasNext();) {
                                let vertex = index.next();
                                {
                                    corners.add(vertex);
                                }
                            }
                            this.exportPolygon(corners);
                        }
                    }
                    /**
                     * This is used only for vZome part geometry export
                     * @param {*} man
                     */
                    exportSelectedManifestation(man) {
                        if (man == null) {
                            this.output.println$();
                            this.output.flush();
                        }
                        else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                            if (this.strTip != null) {
                                this.output.print(this.strTip);
                                this.strTip = null;
                            }
                            const loc = man.getLocation();
                            this.output.println$java_lang_Object(" " + this.sortedVertexList.indexOf(loc));
                        }
                        else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                            if (this.strMiddle != null) {
                                this.output.println$java_lang_Object(this.strMiddle);
                                this.strMiddle = null;
                            }
                            const panel = man;
                            for (let index = panel.iterator(); index.hasNext();) {
                                let corner = index.next();
                                {
                                    this.output.print(this.sortedVertexList.indexOf(corner) + " ");
                                }
                            }
                            this.output.println$();
                        }
                    }
                    /**
                     *
                     */
                    finish() {
                        super.finishExport();
                    }
                }
                model.VefModelExporter = VefModelExporter;
                VefModelExporter["__class"] = "com.vzome.core.model.VefModelExporter";
                VefModelExporter["__interfaces"] = ["com.vzome.core.model.Exporter"];
            })(model = core.model || (core.model = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class PolytopesController extends com.vzome.desktop.controller.DefaultController {
                    constructor(model, context) {
                        super();
                        if (this.model === undefined) {
                            this.model = null;
                        }
                        if (this.context === undefined) {
                            this.context = null;
                        }
                        this.group = "H4";
                        if (this.groups === undefined) {
                            this.groups = null;
                        }
                        this.generateEdge = [false, false, false, true];
                        this.renderEdge = [true, true, true, true];
                        this.edgeScales = [null, null, null, null];
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        if (this.defaultScaleFactor === undefined) {
                            this.defaultScaleFactor = null;
                        }
                        this.model = model;
                        this.context = context;
                        this.field = model.getRealizedModel().getField();
                        this.defaultScaleFactor = this.field['createPower$int'](com.vzome.core.math.symmetry.Direction.USER_SCALE + 2);
                        for (let i = 0; i < this.edgeScales.length; i++) {
                            {
                                this.edgeScales[i] = this.field.one();
                            }
                            ;
                        }
                        if (null == this.field.getGoldenRatio()) {
                            this.groups = ["A4", "B4/C4", "D4", "F4"];
                            this.group = "F4";
                        }
                        else {
                            this.groups = ["A4", "B4/C4", "D4", "F4", "H4"];
                            this.group = "H4";
                        }
                    }
                    /**
                     *
                     * @param {string} action
                     */
                    doAction(action) {
                        switch ((action)) {
                            case "setQuaternion":
                                const strut = this.model.getSelectedConstruction(com.vzome.core.construction.Segment);
                                if (strut != null) {
                                    let vector = strut.getOffset();
                                    const symm = this.model['getSymmetrySystem$']();
                                    const zone = symm.getAxis(vector);
                                    let len = zone.getLength(vector);
                                    len = zone.getOrbit().getLengthInUnits(len);
                                    vector = zone.normal().scale(len);
                                    const vc = super.getSubController("quaternion");
                                    vc.setVector(vector.inflateTo4d$());
                                }
                                else {
                                }
                                return;
                            default:
                                break;
                        }
                        if ("generate" === action) {
                            const index = PolytopesController.encodeBits(this.generateEdge);
                            const edgesToRender = PolytopesController.encodeBits(this.renderEdge);
                            const vc = super.getSubController("quaternion");
                            const quaternion = vc.getVector().scale(this.defaultScaleFactor);
                            const params = (new java.util.HashMap());
                            params.put("groupName", this.group);
                            params.put("renderGroupName", this.group);
                            params.put("index", index);
                            params.put("edgesToRender", edgesToRender);
                            params.put("edgeScales", this.edgeScales);
                            params.put("quaternion", quaternion);
                            this.context.doEdit("Polytope4d", params);
                        }
                        else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "setGroup.")) {
                            const oldGroup = this.group;
                            this.group = action.substring("setGroup.".length);
                            this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("group", oldGroup, this.group);
                        }
                        else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "edge.")) {
                            const edgeName = action.substring("edge.".length);
                            const edge = javaemul.internal.IntegerHelper.parseInt(edgeName);
                            const state = this.generateEdge[edge];
                            this.generateEdge[edge] = !state;
                            this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("edge." + edge, state, this.generateEdge[edge]);
                        }
                        else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "render.")) {
                            const edgeName = action.substring("render.".length);
                            const edge = javaemul.internal.IntegerHelper.parseInt(edgeName);
                            const state = this.renderEdge[edge];
                            this.renderEdge[edge] = !state;
                        }
                        else
                            super.doAction(action);
                    }
                    /*private*/ static encodeBits(bits) {
                        let result = 0;
                        for (let i = 0; i < 4; i++) {
                            {
                                if (bits[i])
                                    result += 1 << i;
                            }
                            ;
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {string} command
                     * @param {java.io.File} file
                     */
                    doFileAction(command, file) {
                        try {
                            const out = new java.io.FileWriter(file);
                            try {
                                const index = PolytopesController.encodeBits(this.generateEdge);
                                const edgesToRender = PolytopesController.encodeBits(this.renderEdge);
                                const vc = super.getSubController("quaternion");
                                let quaternion = vc.getVector().scale(this.defaultScaleFactor);
                                quaternion = quaternion.scale(this.field['createPower$int'](-5));
                                const rightQuat = new com.vzome.core.algebra.Quaternion(this.field, quaternion);
                                const exporter = new com.vzome.core.algebra.VefVectorExporter(out, this.field);
                                this.model.get4dSymmetries().constructPolytope(this.group, index, edgesToRender, this.edgeScales, new PolytopesController.PolytopesController$0(this, rightQuat, exporter));
                                exporter.finishExport();
                            }
                            finally {
                                out.close();
                            }
                        }
                        catch (e) {
                            this.mErrors.reportError(com.vzome.desktop.api.Controller.UNKNOWN_ERROR_CODE, [e]);
                        }
                    }
                    /**
                     *
                     * @param {string} listName
                     * @return {java.lang.String[]}
                     */
                    getCommandList(listName) {
                        return this.groups;
                    }
                    /**
                     *
                     * @param {string} propName
                     * @return {string}
                     */
                    getProperty(propName) {
                        if ("group" === propName) {
                            return this.group;
                        }
                        else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(propName, "edge.")) {
                            const edgeName = propName.substring("edge.".length);
                            const edge = javaemul.internal.IntegerHelper.parseInt(edgeName);
                            return javaemul.internal.BooleanHelper.toString(this.generateEdge[edge]);
                        }
                        else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(propName, "render.")) {
                            const edgeName = propName.substring("render.".length);
                            const edge = javaemul.internal.IntegerHelper.parseInt(edgeName);
                            return javaemul.internal.BooleanHelper.toString(this.renderEdge[edge]);
                        }
                        else
                            return super.getProperty(propName);
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {*}
                     */
                    getSubController(name) {
                        switch ((name)) {
                            default:
                                return super.getSubController(name);
                        }
                    }
                }
                controller.PolytopesController = PolytopesController;
                PolytopesController["__class"] = "com.vzome.desktop.controller.PolytopesController";
                PolytopesController["__interfaces"] = ["com.vzome.desktop.api.Controller"];
                (function (PolytopesController) {
                    class PolytopesController$0 {
                        constructor(__parent, rightQuat, exporter) {
                            this.rightQuat = rightQuat;
                            this.exporter = exporter;
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} v
                         * @return {*}
                         */
                        addVertex(v) {
                            const projected = this.rightQuat.leftMultiply(v);
                            this.exporter.exportPoint(projected);
                            return projected;
                        }
                        /**
                         *
                         * @param {*} p1
                         * @param {*} p2
                         * @return {*}
                         */
                        addEdge(p1, p2) {
                            this.exporter.exportSegment(p1, p2);
                            return null;
                        }
                        /**
                         *
                         * @param {java.lang.Object[]} vertices
                         * @return {*}
                         */
                        addFace(vertices) {
                            return null;
                        }
                    }
                    PolytopesController.PolytopesController$0 = PolytopesController$0;
                    PolytopesController$0["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];
                })(PolytopesController = controller.PolytopesController || (controller.PolytopesController = {}));
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class VectorController extends com.vzome.desktop.controller.DefaultController {
                    constructor(initial) {
                        super();
                        if (this.coordinates === undefined) {
                            this.coordinates = null;
                        }
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        this.field = initial.getField();
                        this.coordinates = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(initial.dimension());
                        for (let i = 0; i < this.coordinates.length; i++) {
                            {
                                this.coordinates[i] = new com.vzome.desktop.controller.NumberController(initial.getField());
                                this.coordinates[i].setValue(initial.getComponent(i));
                            }
                            ;
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {*}
                     */
                    getSubController(name) {
                        switch ((name)) {
                            case "w":
                                return this.coordinates[0];
                            case "x":
                                return this.coordinates[1];
                            case "y":
                                return this.coordinates[2];
                            case "z":
                                return this.coordinates[3];
                            default:
                                return super.getSubController(name);
                        }
                    }
                    setVector(vector) {
                        for (let i = 0; i < this.coordinates.length; i++) {
                            {
                                const numberController = this.coordinates[i];
                                const coord = vector.getComponent(i);
                                numberController.setValue(coord);
                            }
                            ;
                        }
                    }
                    getVector() {
                        const result = this.field.basisVector(this.coordinates.length, 0);
                        for (let i = 0; i < this.coordinates.length; i++) {
                            {
                                const numberController = this.coordinates[i];
                                const coord = numberController.getValue();
                                result.setComponent(i, coord);
                            }
                            ;
                        }
                        return result;
                    }
                }
                controller.VectorController = VectorController;
                VectorController["__class"] = "com.vzome.desktop.controller.VectorController";
                VectorController["__interfaces"] = ["com.vzome.desktop.api.Controller"];
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class OrbitSetController extends com.vzome.desktop.controller.DefaultController {
                    constructor(orbits, allOrbits, colorSource) {
                        super();
                        if (this.colorSource === undefined) {
                            this.colorSource = null;
                        }
                        if (this.orbits === undefined) {
                            this.orbits = null;
                        }
                        if (this.allOrbits === undefined) {
                            this.allOrbits = null;
                        }
                        this.lastOrbit = null;
                        this.mOneAtATime = true;
                        this.orbitDots = (new java.util.HashMap());
                        this.orbits = orbits;
                        this.allOrbits = allOrbits;
                        this.colorSource = colorSource;
                        this.mOneAtATime = orbits.size() === 1;
                        this.recalculateDots();
                    }
                    recalculateDots() {
                        this.orbits.retainAll(this.allOrbits);
                        const symmetry = this.allOrbits.getSymmetry();
                        let test = new com.vzome.core.math.RealVector(0.1, 0.1, 1.0);
                        if (symmetry != null && symmetry instanceof com.vzome.core.math.symmetry.OctahedralSymmetry)
                            test = new com.vzome.core.math.RealVector(2.0, 1.0, 4.0);
                        else if (symmetry != null && symmetry instanceof com.vzome.core.math.symmetry.DodecagonalSymmetry)
                            test = new com.vzome.core.math.RealVector(10.0, 1.0, 1.0);
                        symmetry.computeOrbitDots();
                        this.orbitDots.clear();
                        let lastOrbitChanged = false;
                        for (let index = this.allOrbits.getDirections().iterator(); index.hasNext();) {
                            let dir = index.next();
                            {
                                if (this.lastOrbit == null) {
                                    this.lastOrbit = dir;
                                    lastOrbitChanged = true;
                                }
                                const orbit = new OrbitSetController.OrbitState();
                                this.orbitDots.put(dir, orbit);
                                orbit.color = this.colorSource.getColor(dir);
                                orbit.dotX = dir.getDotX();
                                if (orbit.dotX >= -90.0) {
                                    orbit.dotY = dir.getDotY();
                                }
                                else {
                                    const axis = symmetry['getAxis$com_vzome_core_math_RealVector$java_util_Collection'](test, java.util.Collections.singleton(dir));
                                    const v = axis.normal();
                                    let z = v.getComponent(2).evaluate();
                                    if (z === 0.0) {
                                        z = 1.0;
                                    }
                                    orbit.dotX = v.getComponent(0).evaluate();
                                    orbit.dotX = orbit.dotX / z;
                                    orbit.dotY = v.getComponent(1).evaluate();
                                    orbit.dotY = orbit.dotY / z;
                                }
                            }
                        }
                        if ((this.lastOrbit == null) || (!this.allOrbits.contains(this.lastOrbit))) {
                            lastOrbitChanged = true;
                            if (!this.orbits.isEmpty())
                                this.lastOrbit = this.orbits.last();
                            else if (!this.orbitDots.isEmpty())
                                this.lastOrbit = this.orbitDots.keySet().iterator().next();
                            else
                                this.lastOrbit = null;
                        }
                        if (lastOrbitChanged)
                            this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("selectedOrbit", null, this.lastOrbit == null ? null : this.lastOrbit.getName());
                    }
                    /**
                     *
                     * @param {string} action
                     */
                    doAction(action) {
                        if (action === ("refreshDots")) {
                            this.recalculateDots();
                            return;
                        }
                        if ((action === ("toggleHalf")) || (action === ("reset")) || (action === ("short")) || (action === ("medium")) || (action === ("long")) || /* startsWith */ ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "adjustScale.") || (action === ("scaleUp")) || (action === ("scaleDown"))) {
                            this.getSubController("currentLength").actionPerformed(null, action);
                            return;
                        }
                        if (action === ("setNoDirections")) {
                            this.orbits.clear();
                        }
                        else if (action === ("setAllDirections")) {
                            this.mOneAtATime = false;
                            this.orbits.addAll(this.allOrbits);
                        }
                        else if (action === ("rZomeOrbits")) {
                            this.mOneAtATime = false;
                            this.orbits.clear();
                            for (let index = this.allOrbits.getDirections().iterator(); index.hasNext();) {
                                let dir = index.next();
                                {
                                    if (dir.isStandard()) {
                                        this.orbits.add(dir);
                                    }
                                }
                            }
                        }
                        else if (action === ("predefinedOrbits")) {
                            this.mOneAtATime = false;
                            this.orbits.clear();
                            for (let index = this.allOrbits.getDirections().iterator(); index.hasNext();) {
                                let dir = index.next();
                                {
                                    if (!dir.isAutomatic()) {
                                        this.orbits.add(dir);
                                    }
                                }
                            }
                        }
                        else if (action === ("oneAtATime")) {
                            this.mOneAtATime = !this.mOneAtATime;
                            if (!this.mOneAtATime)
                                return;
                            this.orbits.clear();
                            if (this.lastOrbit != null)
                                this.orbits.add(this.lastOrbit);
                        }
                        else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "setSingleOrbit.")) {
                            const lastValue = this.mOneAtATime;
                            const value = action.substring("setSingleOrbit.".length);
                            this.mOneAtATime = javaemul.internal.BooleanHelper.parseBoolean(value);
                            if (this.mOneAtATime) {
                                this.orbits.clear();
                                if (this.lastOrbit != null)
                                    this.orbits.add(this.lastOrbit);
                            }
                            this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("oneAtATime", lastValue, this.mOneAtATime);
                        }
                        else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "enableDirection.")) {
                            const dirName = action.substring("enableDirection.".length);
                            const dir = this.allOrbits.getDirection(dirName);
                            if (dir != null && !this.orbits.contains(dir))
                                this.toggleOrbit(dir);
                        }
                        else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "toggleDirection.")) {
                            const dirName = action.substring("toggleDirection.".length);
                            const dir = this.allOrbits.getDirection(dirName);
                            this.toggleOrbit(dir);
                        }
                        else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "setSingleDirection.")) {
                            this.mOneAtATime = true;
                            const dirName = action.substring("setSingleDirection.".length);
                            const dir = this.allOrbits.getDirection(dirName);
                            this.toggleOrbit(dir);
                        }
                        this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("orbits", true, false);
                    }
                    /**
                     *
                     * @param {java.beans.PropertyChangeEvent} evt
                     */
                    propertyChange(evt) {
                        if (("length" === evt.getPropertyName()) && evt.getSource() === this.getSubController("currentLength"))
                            this.firePropertyChange$java_beans_PropertyChangeEvent(evt);
                        if ("orbits" === evt.getPropertyName()) {
                            this.recalculateDots();
                            this.firePropertyChange$java_beans_PropertyChangeEvent(evt);
                        }
                    }
                    toggleOrbit(dir) {
                        if (this.mOneAtATime)
                            this.orbits.clear();
                        if (this.orbits.add(dir)) {
                            this.lastOrbit = dir;
                            this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("selectedOrbit", null, dir.getName());
                        }
                        else if (this.orbits.remove(dir)) {
                        }
                        else
                            throw new java.lang.IllegalStateException("could not toggle direction " + dir.getName());
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {*}
                     */
                    getSubController(name) {
                        if ("currentLength" === name)
                            return super.getSubController("length." + this.getProperty("selectedOrbit"));
                        return super.getSubController(name);
                    }
                    /**
                     *
                     * @param {string} string
                     * @return {string}
                     */
                    getProperty(string) {
                        if ("oneAtATime" === string)
                            return javaemul.internal.BooleanHelper.toString(this.mOneAtATime);
                        if ("reverseOrbitTriangle" === string)
                            return javaemul.internal.BooleanHelper.toString(this.allOrbits.getSymmetry().reverseOrbitTriangle());
                        if ("selectedOrbit" === string)
                            if (this.lastOrbit != null)
                                return this.lastOrbit.getName();
                            else
                                return null;
                        if ("halfSizes" === string)
                            if (this.lastOrbit != null && this.lastOrbit.hasHalfSizes())
                                return "true";
                            else
                                return "false";
                        if ("scaleName.superShort" === string)
                            return (this.lastOrbit == null) ? null : this.lastOrbit.getScaleName(0);
                        if ("scaleName.short" === string)
                            return (this.lastOrbit == null) ? null : this.lastOrbit.getScaleName(1);
                        if ("scaleName.medium" === string)
                            return (this.lastOrbit == null) ? null : this.lastOrbit.getScaleName(2);
                        if ("scaleName.long" === string)
                            return (this.lastOrbit == null) ? null : this.lastOrbit.getScaleName(3);
                        if ("color" === string) {
                            const color = this.colorSource.getColor(this.lastOrbit);
                            if (color == null)
                                return null;
                            const rgb = color.getRGB();
                            return "0x" + javaemul.internal.IntegerHelper.toHexString(rgb);
                        }
                        if (((lhs, rhs) => lhs || rhs)(((lhs, rhs) => lhs || rhs)("half" === string, "unitText" === string), "multiplierText" === string))
                            return this.getSubController("currentLength").getProperty(string);
                        if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "orbitDot.")) {
                            const orbitName = string.substring("orbitDot.".length);
                            const orbit = this.allOrbits.getDirection(orbitName);
                            const dot = this.orbitDots.get(orbit);
                            if (dot == null)
                                return "0xffffff/0/0";
                            return "0x" + javaemul.internal.IntegerHelper.toHexString(dot.color.getRGB()) + "/" + dot.dotX + "/" + dot.dotY;
                        }
                        if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "orbitEnabled.")) {
                            const orbitName = string.substring("orbitEnabled.".length);
                            const orbit = this.orbits.getDirection(orbitName);
                            return javaemul.internal.BooleanHelper.toString(orbit != null);
                        }
                        return super.getProperty(string);
                    }
                    /**
                     *
                     * @param {string} cmd
                     * @param {*} value
                     */
                    setModelProperty(cmd, value) {
                        if ("oneAtATime" === cmd)
                            this.mOneAtATime = /* equals */ ((o1, o2) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)("true", value);
                        else if (((lhs, rhs) => lhs || rhs)("multiplier" === cmd, "half" === cmd))
                            this.getSubController("currentLength").setProperty(cmd, value);
                        else
                            super.setModelProperty(cmd, value);
                    }
                    /**
                     *
                     * @param {string} listName
                     * @return {java.lang.String[]}
                     */
                    getCommandList(listName) {
                        if (listName === ("orbits")) {
                            const result = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(this.orbits.size());
                            let i = 0;
                            for (let index = this.orbits.getDirections().iterator(); index.hasNext();) {
                                let dir = index.next();
                                {
                                    result[i] = dir.getName();
                                    i++;
                                }
                            }
                            return result;
                        }
                        if (listName === ("allOrbits")) {
                            const result = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(this.allOrbits.size());
                            let i = 0;
                            for (let index = this.allOrbits.getDirections().iterator(); index.hasNext();) {
                                let dir = index.next();
                                {
                                    result[i] = dir.getName();
                                    i++;
                                }
                            }
                            return result;
                        }
                        return super.getCommandList(listName);
                    }
                }
                controller.OrbitSetController = OrbitSetController;
                OrbitSetController["__class"] = "com.vzome.desktop.controller.OrbitSetController";
                OrbitSetController["__interfaces"] = ["java.util.EventListener", "java.beans.PropertyChangeListener", "com.vzome.desktop.api.Controller"];
                (function (OrbitSetController) {
                    class OrbitState {
                        constructor() {
                            if (this.dotX === undefined) {
                                this.dotX = 0;
                            }
                            if (this.dotY === undefined) {
                                this.dotY = 0;
                            }
                            if (this.color === undefined) {
                                this.color = null;
                            }
                        }
                    }
                    OrbitSetController.OrbitState = OrbitState;
                    OrbitState["__class"] = "com.vzome.desktop.controller.OrbitSetController.OrbitState";
                })(OrbitSetController = controller.OrbitSetController || (controller.OrbitSetController = {}));
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class StrutBuilderController extends com.vzome.desktop.controller.DefaultController {
                    constructor(context, field) {
                        super();
                        this.useGraphicalViews = false;
                        this.showStrutScales = false;
                        this.useWorkingPlane = false;
                        this.workingPlaneAxis = null;
                        if (this.previewStrut === undefined) {
                            this.previewStrut = null;
                        }
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        if (this.context === undefined) {
                            this.context = null;
                        }
                        this.context = context;
                        this.field = field;
                    }
                    withGraphicalViews(value) {
                        this.useGraphicalViews = value;
                        return this;
                    }
                    withShowStrutScales(value) {
                        this.showStrutScales = value;
                        return this;
                    }
                    /**
                     *
                     * @param {string} propName
                     * @return {string}
                     */
                    getProperty(propName) {
                        switch ((propName)) {
                            case "useGraphicalViews":
                                return javaemul.internal.BooleanHelper.toString(this.useGraphicalViews);
                            case "useWorkingPlane":
                                return javaemul.internal.BooleanHelper.toString(this.useWorkingPlane);
                            case "workingPlaneDefined":
                                return javaemul.internal.BooleanHelper.toString(this.workingPlaneAxis != null);
                            case "showStrutScales":
                                return javaemul.internal.BooleanHelper.toString(this.showStrutScales);
                            default:
                                return super.getProperty(propName);
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @param {*} value
                     */
                    setModelProperty(name, value) {
                        switch ((name)) {
                            case "useGraphicalViews":
                                {
                                    const old = this.useGraphicalViews;
                                    this.useGraphicalViews = /* equals */ ((o1, o2) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)("true", value);
                                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(name, old, this.useGraphicalViews);
                                    break;
                                }
                                ;
                            case "showStrutScales":
                                {
                                    const old = this.showStrutScales;
                                    this.showStrutScales = /* equals */ ((o1, o2) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)("true", value);
                                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(name, old, this.showStrutScales);
                                    break;
                                }
                                ;
                            default:
                                super.setModelProperty(name, value);
                        }
                    }
                    /**
                     *
                     * @param {string} action
                     */
                    doAction(action) {
                        switch ((action)) {
                            case "toggleWorkingPlane":
                                this.useWorkingPlane = !this.useWorkingPlane;
                                break;
                            case "toggleOrbitViews":
                                {
                                    const old = this.useGraphicalViews;
                                    this.useGraphicalViews = !old;
                                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("useGraphicalViews", old, this.useGraphicalViews);
                                    break;
                                }
                                ;
                            case "toggleStrutScales":
                                {
                                    const old = this.showStrutScales;
                                    this.showStrutScales = !old;
                                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("showStrutScales", old, this.showStrutScales);
                                    break;
                                }
                                ;
                            default:
                                super.doAction(action);
                        }
                    }
                    setWorkingPlaneAxis(axis) {
                        this.workingPlaneAxis = axis;
                        this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("workingPlaneDefined", false, true);
                    }
                    setMainScene(mainScene) {
                        this.previewStrut = new com.vzome.desktop.controller.PreviewStrut(this.field, mainScene, this.context);
                    }
                    getPreviewStrut() {
                        return this.previewStrut;
                    }
                    startRendering(point, worldEye) {
                        const axis = this.useWorkingPlane ? this.workingPlaneAxis : null;
                        this.previewStrut.startRendering(point, axis, worldEye);
                    }
                    setSymmetryController(symmetryController) {
                        if (this.previewStrut != null)
                            this.previewStrut.setSymmetryController(symmetryController);
                    }
                }
                controller.StrutBuilderController = StrutBuilderController;
                StrutBuilderController["__class"] = "com.vzome.desktop.controller.StrutBuilderController";
                StrutBuilderController["__interfaces"] = ["com.vzome.desktop.api.Controller"];
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class NumberController extends com.vzome.desktop.controller.DefaultController {
                    constructor(field) {
                        super();
                        if (this.value === undefined) {
                            this.value = null;
                        }
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        this.field = field;
                        this.value = field.one();
                    }
                    /**
                     *
                     * @param {string} listName
                     * @return {java.lang.String[]}
                     */
                    getCommandList(listName) {
                        switch ((listName)) {
                            case "labels":
                                const order = this.field.getOrder();
                                let result = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(order + 1);
                                result[0] = "1";
                                result[order] = "/";
                                for (let i = 1; i < order; i++) {
                                    result[i] = this.field['getIrrational$int'](i);
                                }
                                return result;
                            case "values":
                                const td = this.value.toTrailingDivisor();
                                result = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(td.length);
                                for (let i = 0; i < td.length; i++) {
                                    result[i] = /* toString */ ('' + (td[i]));
                                }
                                return result;
                            case "named-values":
                                return this.getNamedValues();
                            case "math.operations":
                                return NumberController.MATH_OPS_$LI$();
                            default:
                                return super.getCommandList(listName);
                        }
                    }
                    static OPTIONAL_NAMED_VALUES_$LI$() { if (NumberController.OPTIONAL_NAMED_VALUES == null) {
                        NumberController.OPTIONAL_NAMED_VALUES = ["phi", "rho", "sigma", "alpha", "beta", "gamma", "delta", "epsilon", "theta", "kappa", "lambda", "mu", "seperator", "\u221a2", "\u221a3", "\u221a5", "\u221a6", "\u221a7", "\u221a8", "\u221a10"];
                    } return NumberController.OPTIONAL_NAMED_VALUES; }
                    /*private*/ getNamedValues() {
                        let seperateNext = false;
                        const list = (new java.util.ArrayList());
                        list.add("zero");
                        list.add("one");
                        for (let index = 0; index < NumberController.OPTIONAL_NAMED_VALUES_$LI$().length; index++) {
                            let test = NumberController.OPTIONAL_NAMED_VALUES_$LI$()[index];
                            {
                                if (test === ("seperator")) {
                                    seperateNext = true;
                                }
                                else {
                                    if (this.field.getNumberByName(test) != null) {
                                        if (seperateNext) {
                                            seperateNext = false;
                                            list.add("seperator");
                                        }
                                        list.add(test);
                                    }
                                }
                            }
                        }
                        return list.toArray((s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(list.size()));
                    }
                    /**
                     *
                     * @param {string} property
                     * @param {*} value
                     */
                    setModelProperty(property, value) {
                        switch ((property)) {
                            case "values":
                                const values = new java.util.StringTokenizer(value);
                                const inputs = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(this.field.getOrder());
                                let divisor = 1;
                                for (let i = 0; values.hasMoreTokens(); i++) {
                                    if (i < inputs.length)
                                        inputs[i] = javaemul.internal.IntegerHelper.parseInt(values.nextToken());
                                    else
                                        divisor = javaemul.internal.IntegerHelper.parseInt(values.nextToken());
                                    ;
                                }
                                this.value = this.field['createAlgebraicNumber$int_A'](inputs).dividedBy(this.field['createRational$long'](divisor));
                                return;
                            case "named-value":
                                this.setValueByName(/* valueOf */ String(value).toString());
                                return;
                            case "math.operation":
                                if (this.doMath(/* valueOf */ String(value).toString())) {
                                    return;
                                }
                        }
                        super.setModelProperty(property, value);
                    }
                    /*private*/ setValueByName(name) {
                        const n = this.field.getNumberByName(name);
                        if (n != null) {
                            this.setValue(n);
                        }
                    }
                    static MATH_OPS_$LI$() { if (NumberController.MATH_OPS == null) {
                        NumberController.MATH_OPS = ["Negate", "Reciprocal", "Square"];
                    } return NumberController.MATH_OPS; }
                    /*private*/ doMath(operation) {
                        switch ((operation)) {
                            case "Negate":
                                this.setValue(this.getValue().negate());
                                return true;
                            case "Reciprocal":
                                if (!this.getValue().isZero()) {
                                    this.setValue(this.getValue().reciprocal());
                                }
                                return true;
                            case "Square":
                                this.setValue(this.getValue()['times$com_vzome_core_algebra_AlgebraicNumber'](this.getValue()));
                                return true;
                        }
                        return false;
                    }
                    /**
                     *
                     * @param {string} property
                     * @return {string}
                     */
                    getProperty(property) {
                        switch ((property)) {
                            case "value":
                                return this.value.toString(com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT);
                            case "evaluate":
                                return /* valueOf */ String(this.value.evaluate()).toString();
                            default:
                                return super.getProperty(property);
                        }
                    }
                    getValue() {
                        return this.value;
                    }
                    setValue(value) {
                        this.value = value;
                    }
                }
                controller.NumberController = NumberController;
                NumberController["__class"] = "com.vzome.desktop.controller.NumberController";
                NumberController["__interfaces"] = ["com.vzome.desktop.api.Controller"];
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class UndoRedoController extends com.vzome.desktop.controller.DefaultController {
                    constructor(model) {
                        super();
                        if (this.model === undefined) {
                            this.model = null;
                        }
                        this.model = model;
                    }
                    /**
                     *
                     * @param {string} key
                     * @return {string}
                     */
                    getProperty(key) {
                        switch ((key)) {
                            case "line.number":
                                return /* toString */ ('' + (this.model.getNextLineNumber()));
                            case "breakpoints":
                                return (this.model.getBreakpoints().stream().map((x) => x.toString()).collect(java.util.stream.Collectors.joining(",")));
                            default:
                                return super.getProperty(key);
                        }
                    }
                    /**
                     *
                     * @param {string} action
                     */
                    doAction(action) {
                        switch ((action)) {
                            case "undo":
                                this.model.undo$boolean(true);
                                break;
                            case "redo":
                                this.model.redo$boolean(true);
                                break;
                            case "redoToBreakpoint":
                                this.model.redoToBreakpoint();
                                break;
                            case "undoAll":
                                this.model.undoAll();
                                break;
                            case "redoAll":
                                this.model.redoAll(-1);
                                break;
                            default:
                                if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "setBreakpoints.")) {
                                    const breakpointList = action.substring("setBreakpoints.".length).trim();
                                    const breakpoints = breakpointList.split(",");
                                    const breakpointInts = (s => { let a = []; while (s-- > 0)
                                        a.push(0); return a; })(breakpoints.length);
                                    for (let i = 0; i < breakpointInts.length; i++) {
                                        {
                                            const breakpoint = breakpoints[i];
                                            let lineNum = -1;
                                            try {
                                                lineNum = javaemul.internal.IntegerHelper.parseInt(breakpoint);
                                            }
                                            catch (ex) {
                                                this.mErrors.reportError("\'" + breakpoint + "\' is not a valid integer. Line number must be a positive integer.", []);
                                            }
                                            if (lineNum <= 0) {
                                                this.mErrors.reportError("Edit number must be a positive integer.", []);
                                            }
                                            else {
                                                breakpointInts[i] = lineNum;
                                            }
                                        }
                                        ;
                                    }
                                    this.model.setBreakpoints(breakpointInts);
                                }
                                else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "redoUntilEdit.")) {
                                    const editNum = action.substring("redoUntilEdit.".length).trim();
                                    if (!((editNum === ("null")) || (editNum === ("")))) {
                                        let eNum = -1;
                                        try {
                                            eNum = javaemul.internal.IntegerHelper.parseInt(editNum);
                                        }
                                        catch (ex) {
                                            this.mErrors.reportError("\'" + editNum + "\' is not a valid integer. Edit number must be a positive integer.", []);
                                        }
                                        if (eNum <= 0) {
                                            this.mErrors.reportError("Edit number must be a positive integer.", []);
                                        }
                                        else {
                                            this.model.redoAll(eNum);
                                        }
                                    }
                                }
                                else
                                    super.doAction(action);
                                break;
                        }
                    }
                }
                controller.UndoRedoController = UndoRedoController;
                UndoRedoController["__class"] = "com.vzome.desktop.controller.UndoRedoController";
                UndoRedoController["__interfaces"] = ["com.vzome.desktop.api.Controller"];
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class MeasureController extends com.vzome.desktop.controller.DefaultController {
                    constructor(model, renderedModel) {
                        super();
                        if (this.selection === undefined) {
                            this.selection = null;
                        }
                        if (this.editorModel === undefined) {
                            this.editorModel = null;
                        }
                        this.measurements = (new java.util.LinkedHashMap());
                        if (this.renderedModel === undefined) {
                            this.renderedModel = null;
                        }
                        this.twoPlaces = java.text.NumberFormat.getInstance();
                        this.fourPlaces = java.text.NumberFormat.getInstance();
                        this.renderedModel = renderedModel;
                        this.selection = model.getSelection();
                        this.editorModel = model;
                        model.addSelectionSummaryListener(this);
                        this.twoPlaces.setMaximumFractionDigits(2);
                        this.fourPlaces.setMaximumFractionDigits(4);
                    }
                    /**
                     *
                     * @param {string} listName
                     * @return {java.lang.String[]}
                     */
                    getCommandList(listName) {
                        return this.measurements.keySet().toArray((s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.measurements.keySet().size()));
                    }
                    /**
                     *
                     * @param {string} key
                     * @return {string}
                     */
                    getProperty(key) {
                        return this.measurements.get(key);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     */
                    selectionChanged(total, balls, struts, panels) {
                        this.measurements.clear();
                        if (total !== 0) {
                            if (balls !== 0) {
                                this.measurements.put("balls", /* toString */ ('' + (balls)));
                            }
                            if (struts !== 0) {
                                this.measurements.put("struts", /* toString */ ('' + (struts)));
                            }
                            if (panels !== 0) {
                                this.measurements.put("panels", /* toString */ ('' + (panels)));
                            }
                            if (total === 1 || total === 2) {
                                this.measurements.put("", "");
                            }
                            if (total === 1) {
                                if (panels === 1) {
                                    const panel = com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.selection).next();
                                    this.measurements.put("vertices", /* toString */ ('' + (panel.getVertexCount())));
                                }
                                else if (struts === 1) {
                                    const strut = com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(this.selection).next();
                                    const cm = this.renderedModel.measureLengthCm$com_vzome_core_model_Strut(strut);
                                    this.measurements.put("length (cm)", this.twoPlaces.format(cm) + " cm");
                                    const inches = cm / 2.54;
                                    this.measurements.put("length (in)", this.twoPlaces.format(inches) + " in");
                                    const offset = strut.getOffset();
                                    this.measurements.put("quadrance", offset.dot(offset).toString(com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT));
                                }
                                else if (balls === 1) {
                                    const conn = com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(this.selection).next();
                                    this.measurements.put("location", conn.getLocation().toString());
                                }
                            }
                            else if (total === 2) {
                                if (panels === 2) {
                                    let p1 = null;
                                    let p2 = null;
                                    for (let index = com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.selection).iterator(); index.hasNext();) {
                                        let panel = index.next();
                                        {
                                            if (p1 == null)
                                                p1 = panel;
                                            else
                                                p2 = panel;
                                        }
                                    }
                                    const radians = this.renderedModel.measureDihedralAngle(p1, p2);
                                    this.reportAngles(radians);
                                }
                                else if (struts === 2) {
                                    let s1 = null;
                                    let s2 = null;
                                    for (let index = com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(this.selection).iterator(); index.hasNext();) {
                                        let strut = index.next();
                                        {
                                            if (s1 == null)
                                                s1 = strut;
                                            else
                                                s2 = strut;
                                        }
                                    }
                                    const points = (new java.util.HashSet());
                                    points.add(s1.getLocation());
                                    points.add(s1.getEnd());
                                    points.add(s2.getLocation());
                                    points.add(s2.getEnd());
                                    if (points.size() > 3) {
                                        this.measurements.put("coplanar", com.vzome.core.algebra.AlgebraicVectors.areCoplanar(points) ? "yes" : "no");
                                    }
                                    const radians = this.renderedModel.measureAngle(s1, s2);
                                    this.reportAngles(radians);
                                    this.reportSpread(s1, s2);
                                    this.reportRatio(s1, s2);
                                }
                                else if (balls === 2) {
                                    let b1 = null;
                                    let b2 = null;
                                    for (let index = com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(this.selection).iterator(); index.hasNext();) {
                                        let conn = index.next();
                                        {
                                            if (b1 == null)
                                                b1 = conn;
                                            else
                                                b2 = conn;
                                        }
                                    }
                                    const cm = this.renderedModel.measureDistanceCm(b1, b2);
                                    this.measurements.put("distance (cm)", this.twoPlaces.format(cm) + " cm");
                                    const inches = cm / 2.54;
                                    this.measurements.put("distance (in)", this.twoPlaces.format(inches) + " in");
                                }
                            }
                        }
                        this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("measures", false, true);
                    }
                    /*private*/ reportAngles(radians) {
                        if ( /* isFinite */((value) => !isNaN(value) && Number.NEGATIVE_INFINITY !== value && Number.POSITIVE_INFINITY !== value)(radians)) {
                            const fraction = radians / Math.PI;
                            const supplement = 1.0 - fraction;
                            this.measurements.put("radians", this.fourPlaces.format(fraction) + "\u03c0");
                            this.measurements.put("radians (supplement)", this.fourPlaces.format(supplement) + "\u03c0");
                            this.measurements.put("degrees", this.twoPlaces.format(fraction * 180) + "\u00b0");
                            this.measurements.put("degrees (supplement)", this.twoPlaces.format(supplement * 180) + "\u00b0");
                        }
                        else {
                            this.measurements.put("angle", /* toString */ ('' + (radians)));
                        }
                    }
                    /**
                     * Use Rational Trigonometry (the cross law) to compute the spread between struts
                     * @param {*} s1
                     * @param {*} s2
                     * @private
                     */
                    /*private*/ reportSpread(s1, s2) {
                        const v1 = s1.getOffset();
                        const v2 = s2.getOffset();
                        const v3 = v2.minus(v1);
                        const Q1 = v2.dot(v2);
                        const Q2 = v1.dot(v1);
                        const Q3 = v3.dot(v3);
                        const one = Q1.getField().one();
                        const four = Q1.getField()['createRational$long'](4);
                        const a = Q1['plus$com_vzome_core_algebra_AlgebraicNumber'](Q2)['minus$com_vzome_core_algebra_AlgebraicNumber'](Q3);
                        const denom = four['times$com_vzome_core_algebra_AlgebraicNumber'](Q1)['times$com_vzome_core_algebra_AlgebraicNumber'](Q2);
                        const ratio = a['times$com_vzome_core_algebra_AlgebraicNumber'](a).dividedBy(denom);
                        const spread3 = one['minus$com_vzome_core_algebra_AlgebraicNumber'](ratio);
                        this.measurements.put("spread", spread3.toString(com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT));
                    }
                    /*private*/ reportRatio(s1, s2) {
                        const v1 = s1.getOffset();
                        const v2 = s2.getOffset();
                        const ss = this.editorModel['getSymmetrySystem$']();
                        const axis1 = ss.getAxis(v1);
                        const axis2 = ss.getAxis(v2);
                        const dir1 = axis1.getDirection();
                        const dir2 = axis2.getDirection();
                        const sameOrbit = dir1.equals(dir2);
                        let name1 = dir1.getName();
                        let name2 = dir2.getName();
                        const auto = "auto";
                        if (dir1.isAutomatic()) {
                            name1 = auto + name1;
                        }
                        if (dir2.isAutomatic()) {
                            name2 = auto + name2;
                        }
                        if (sameOrbit) {
                            name1 += "\u2081";
                            name2 += "\u2082";
                        }
                        const n1n2 = name1 + " / " + name2;
                        const n2n1 = name2 + " / " + name1;
                        this.measurements.put(" ", " ");
                        const len1 = ss.getSymmetry().embedInR3(v1).length();
                        const len2 = ss.getSymmetry().embedInR3(v2).length();
                        const length1 = len1;
                        const length2 = len2;
                        const ratio = Math.fround(length1 / length2);
                        let comparison = "equal";
                        if (Math.abs(Math.fround(length1 - length2)) > 1.0E-6) {
                            comparison = name1 + " " + (length1 > length2 ? ">" : "<") + " " + name2;
                        }
                        this.measurements.put("relative strut lengths", comparison);
                        if (!(comparison === ("equal"))) {
                            const recip = Math.fround(1.0 / ratio);
                            this.measurements.put(n1n2 + " (approx)", this.fourPlaces.format(ratio));
                            this.measurements.put(n2n1 + " (approx)", this.fourPlaces.format(recip));
                            if (sameOrbit) {
                                const exactLength1 = axis1.getLength(v1);
                                const exactength2 = axis2.getLength(v2);
                                const exactRatio = exactLength1.dividedBy(exactength2);
                                const exactRecip = exactRatio.reciprocal();
                                this.measurements.put(n1n2, exactRatio.toString(com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT));
                                this.measurements.put(n2n1, exactRecip.toString(com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT));
                            }
                        }
                    }
                }
                controller.MeasureController = MeasureController;
                MeasureController["__class"] = "com.vzome.desktop.controller.MeasureController";
                MeasureController["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.desktop.api.Controller"];
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class ToolController extends com.vzome.desktop.controller.DefaultController {
                    constructor(tool) {
                        super();
                        if (this.tool === undefined) {
                            this.tool = null;
                        }
                        if (this.selectOutputs === undefined) {
                            this.selectOutputs = false;
                        }
                        if (this.justSelect === undefined) {
                            this.justSelect = false;
                        }
                        this.tool = tool;
                        this.selectOutputs = true;
                        this.justSelect = false;
                    }
                    /**
                     *
                     * @param {string} action
                     */
                    doAction(action) {
                        const selectInputs = this.tool.isSelectInputs();
                        let deleteInputs = this.tool.isDeleteInputs();
                        let copyColors = this.tool.isCopyColors();
                        switch ((action)) {
                            case "apply":
                                const createOutputs = !this.justSelect;
                                this.tool.apply(selectInputs, deleteInputs, createOutputs, this.selectOutputs, copyColors);
                                break;
                            case "hideTool":
                                this.tool.setHidden(true);
                                break;
                            case "selectParams":
                                this.tool.selectParameters();
                                break;
                            case "selectInputs":
                                this.tool.setInputBehaviors(!selectInputs, deleteInputs);
                                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("selectInputs", null, javaemul.internal.BooleanHelper.toString(this.tool.isSelectInputs()));
                                break;
                            case "deleteInputs":
                                deleteInputs = !deleteInputs;
                                this.tool.setInputBehaviors(selectInputs && !deleteInputs, deleteInputs);
                                if (deleteInputs) {
                                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("selectInputs", null, "false");
                                }
                                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("deleteInputs", null, javaemul.internal.BooleanHelper.toString(deleteInputs));
                                break;
                            case "copyColors":
                                copyColors = !copyColors;
                                this.tool.setCopyColors(copyColors);
                                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("copyColors", null, javaemul.internal.BooleanHelper.toString(copyColors));
                                break;
                            case "selectOutputs":
                                this.selectOutputs = !this.selectOutputs;
                                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("selectOutputs", null, javaemul.internal.BooleanHelper.toString(this.selectOutputs));
                                break;
                            case "createOutputs":
                                this.justSelect = !this.justSelect;
                                if (this.justSelect) {
                                    this.selectOutputs = true;
                                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("selectOutputs", null, "true");
                                }
                                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("createOutputs", null, javaemul.internal.BooleanHelper.toString(!this.justSelect));
                                break;
                            default:
                                super.doAction(action);
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {string}
                     */
                    getProperty(name) {
                        switch ((name)) {
                            case "id":
                                return this.tool.getId();
                            case "label":
                                return this.tool.getLabel();
                            case "kind":
                                return this.tool.getCategory();
                            case "predefined":
                                return javaemul.internal.BooleanHelper.toString(this.tool.isPredefined());
                            case "selectInputs":
                                return javaemul.internal.BooleanHelper.toString(this.tool.isSelectInputs());
                            case "deleteInputs":
                                return javaemul.internal.BooleanHelper.toString(this.tool.isDeleteInputs());
                            case "copyColors":
                                return javaemul.internal.BooleanHelper.toString(this.tool.isCopyColors());
                            case "selectOutputs":
                                return javaemul.internal.BooleanHelper.toString(this.selectOutputs);
                            case "createOutputs":
                                return javaemul.internal.BooleanHelper.toString(!this.justSelect);
                            default:
                                return super.getProperty(name);
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @param {*} value
                     */
                    setModelProperty(name, value) {
                        switch ((name)) {
                            case "label":
                                this.tool.setLabel(value);
                                this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("label", null, value);
                                return;
                            default:
                                super.setModelProperty(name, value);
                        }
                    }
                }
                controller.ToolController = ToolController;
                ToolController["__class"] = "com.vzome.desktop.controller.ToolController";
                ToolController["__interfaces"] = ["com.vzome.desktop.api.Controller"];
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class PartsController extends com.vzome.desktop.controller.DefaultController {
                    constructor(orbits) {
                        super();
                        if (this.oldOrbits === undefined) {
                            this.oldOrbits = null;
                        }
                        if (this.newOrbits === undefined) {
                            this.newOrbits = null;
                        }
                        this.oldOrbits = orbits;
                        this.newOrbits = orbits;
                    }
                    startSwitch(switchTo) {
                        this.newOrbits = switchTo;
                    }
                    endSwitch() {
                        this.oldOrbits = this.newOrbits;
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} rendered
                     */
                    manifestationAdded(rendered) {
                        this.fireManifestationCountChanged("add", rendered, this.newOrbits);
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} rendered
                     */
                    manifestationRemoved(rendered) {
                        this.fireManifestationCountChanged("remove", rendered, this.oldOrbits);
                    }
                    fireManifestationCountChanged(action, rendered, orbitSource) {
                        const man = rendered.getManifestation();
                        let partTypeName = null;
                        let partInfo = null;
                        if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                            partTypeName = "Ball";
                            partInfo = new PartsController.PartInfo(man);
                        }
                        else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                            partTypeName = "Strut";
                            const length = rendered.getShape().getLength();
                            partInfo = new PartsController.PartInfo(man, orbitSource, length);
                        }
                        else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                            partTypeName = "Panel";
                            partInfo = new PartsController.PartInfo(man, orbitSource);
                        }
                        if (partTypeName != null && partInfo != null) {
                            const propertyName = action + partTypeName;
                            switch ((action)) {
                                case "add":
                                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName, null, partInfo);
                                    break;
                                case "remove":
                                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object(propertyName, partInfo, null);
                                    break;
                                default:
                                    throw new java.lang.IllegalArgumentException("Unsupported action: " + (action == null ? "<null>" : action) + ".");
                            }
                        }
                    }
                    /**
                     *
                     */
                    reset() {
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} from
                     * @param {com.vzome.core.render.RenderedManifestation} to
                     */
                    manifestationSwitched(from, to) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    glowChanged(manifestation) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    colorChanged(manifestation) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    labelChanged(manifestation) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    locationChanged(manifestation) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    orientationChanged(manifestation) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.render.RenderedManifestation} manifestation
                     */
                    shapeChanged(manifestation) {
                    }
                    /**
                     *
                     * @param {*} shapes
                     * @return {boolean}
                     */
                    shapesChanged(shapes) {
                        return false;
                    }
                }
                controller.PartsController = PartsController;
                PartsController["__class"] = "com.vzome.desktop.controller.PartsController";
                PartsController["__interfaces"] = ["com.vzome.core.render.RenderingChanges", "com.vzome.desktop.api.Controller"];
                (function (PartsController) {
                    /**
                     * PartInfo is passed to the PartsPanel in the PropertyChangeEvent.
                     * @param {string} name
                     * @param {java.lang.Class} partType
                     * @class
                     */
                    class PartInfo {
                        constructor(strut, orbits, length) {
                            if (((strut != null && (strut.constructor != null && strut.constructor["__interfaces"] != null && strut.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || strut === null) && ((orbits != null && (orbits.constructor != null && orbits.constructor["__interfaces"] != null && orbits.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.OrbitSource") >= 0)) || orbits === null) && ((length != null && (length.constructor != null && length.constructor["__interfaces"] != null && length.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || length === null)) {
                                let __args = arguments;
                                if (this.orbitStr === undefined) {
                                    this.orbitStr = null;
                                }
                                if (this.rgbColor === undefined) {
                                    this.rgbColor = 0;
                                }
                                if (this.sizeNameStr === undefined) {
                                    this.sizeNameStr = null;
                                }
                                if (this.lengthStr === undefined) {
                                    this.lengthStr = null;
                                }
                                if (this.strutLength === undefined) {
                                    this.strutLength = null;
                                }
                                if (this.automaticDirectionIndex === undefined) {
                                    this.automaticDirectionIndex = null;
                                }
                                if (this.realLength === undefined) {
                                    this.realLength = null;
                                }
                                if (this.partClass === undefined) {
                                    this.partClass = null;
                                }
                                const orbit = strut.getRenderedObject().getStrutOrbit();
                                this.orbitStr = orbit.getName();
                                this.rgbColor = orbits.getColor(orbit).getRGB();
                                const buf = new java.lang.StringBuffer();
                                orbit.getLengthExpression(buf, length);
                                const lengthExpression = buf.toString();
                                const tokens = new java.util.StringTokenizer(lengthExpression, ":");
                                this.sizeNameStr = tokens.nextToken();
                                this.lengthStr = tokens.nextToken();
                                this.strutLength = length;
                                this.automaticDirectionIndex = orbit.isAutomatic() ? javaemul.internal.IntegerHelper.parseInt(this.orbitStr) : -1;
                                this.realLength = length.evaluate();
                                this.partClass = strut.constructor;
                            }
                            else if (((typeof strut === 'string') || strut === null) && ((orbits != null && (orbits["__class"] != null || ((t) => { try {
                                new t;
                                return true;
                            }
                            catch (_a) {
                                return false;
                            } })(orbits))) || orbits === null) && length === undefined) {
                                let __args = arguments;
                                let name = __args[0];
                                let partType = __args[1];
                                if (this.orbitStr === undefined) {
                                    this.orbitStr = null;
                                }
                                if (this.rgbColor === undefined) {
                                    this.rgbColor = 0;
                                }
                                if (this.sizeNameStr === undefined) {
                                    this.sizeNameStr = null;
                                }
                                if (this.lengthStr === undefined) {
                                    this.lengthStr = null;
                                }
                                if (this.strutLength === undefined) {
                                    this.strutLength = null;
                                }
                                if (this.automaticDirectionIndex === undefined) {
                                    this.automaticDirectionIndex = null;
                                }
                                if (this.realLength === undefined) {
                                    this.realLength = null;
                                }
                                if (this.partClass === undefined) {
                                    this.partClass = null;
                                }
                                this.orbitStr = "";
                                this.rgbColor = com.vzome.core.construction.Color.WHITE_$LI$().getRGB();
                                this.sizeNameStr = name;
                                this.lengthStr = "";
                                this.strutLength = null;
                                this.automaticDirectionIndex = -1;
                                this.realLength = 0.0;
                                this.partClass = partType;
                            }
                            else if (((strut != null && (strut.constructor != null && strut.constructor["__interfaces"] != null && strut.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || strut === null) && ((orbits != null && (orbits.constructor != null && orbits.constructor["__interfaces"] != null && orbits.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.OrbitSource") >= 0)) || orbits === null) && length === undefined) {
                                let __args = arguments;
                                let panel = __args[0];
                                if (this.orbitStr === undefined) {
                                    this.orbitStr = null;
                                }
                                if (this.rgbColor === undefined) {
                                    this.rgbColor = 0;
                                }
                                if (this.sizeNameStr === undefined) {
                                    this.sizeNameStr = null;
                                }
                                if (this.lengthStr === undefined) {
                                    this.lengthStr = null;
                                }
                                if (this.strutLength === undefined) {
                                    this.strutLength = null;
                                }
                                if (this.automaticDirectionIndex === undefined) {
                                    this.automaticDirectionIndex = null;
                                }
                                if (this.realLength === undefined) {
                                    this.realLength = null;
                                }
                                if (this.partClass === undefined) {
                                    this.partClass = null;
                                }
                                let orbitName = "";
                                let color = com.vzome.core.construction.Color.WHITE_$LI$();
                                let autoDirIdx = -1;
                                const normal = panel['getNormal$']();
                                if (!normal.isOrigin()) {
                                    const axis = orbits.getAxis(normal);
                                    if (axis != null) {
                                        const orbit = axis.getDirection();
                                        orbitName = orbit.getName();
                                        color = orbits.getColor(orbit);
                                        if (orbit.isAutomatic()) {
                                            autoDirIdx = javaemul.internal.IntegerHelper.parseInt(orbitName);
                                        }
                                    }
                                }
                                this.orbitStr = orbitName;
                                this.rgbColor = color.getRGB();
                                this.sizeNameStr = "";
                                this.lengthStr = "";
                                this.strutLength = null;
                                this.automaticDirectionIndex = autoDirIdx;
                                this.realLength = 0.0;
                                this.partClass = panel.constructor;
                            }
                            else if (((strut != null && (strut.constructor != null && strut.constructor["__interfaces"] != null && strut.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || strut === null) && orbits === undefined && length === undefined) {
                                let __args = arguments;
                                let ball = __args[0];
                                if (this.orbitStr === undefined) {
                                    this.orbitStr = null;
                                }
                                if (this.rgbColor === undefined) {
                                    this.rgbColor = 0;
                                }
                                if (this.sizeNameStr === undefined) {
                                    this.sizeNameStr = null;
                                }
                                if (this.lengthStr === undefined) {
                                    this.lengthStr = null;
                                }
                                if (this.strutLength === undefined) {
                                    this.strutLength = null;
                                }
                                if (this.automaticDirectionIndex === undefined) {
                                    this.automaticDirectionIndex = null;
                                }
                                if (this.realLength === undefined) {
                                    this.realLength = null;
                                }
                                if (this.partClass === undefined) {
                                    this.partClass = null;
                                }
                                this.orbitStr = "";
                                this.rgbColor = com.vzome.core.construction.Color.WHITE_$LI$().getRGB();
                                this.sizeNameStr = "";
                                this.lengthStr = "";
                                this.strutLength = null;
                                this.automaticDirectionIndex = -1;
                                this.realLength = 0.0;
                                this.partClass = ball.constructor;
                            }
                            else
                                throw new Error('invalid overload');
                        }
                    }
                    PartsController.PartInfo = PartInfo;
                    PartInfo["__class"] = "com.vzome.desktop.controller.PartsController.PartInfo";
                })(PartsController = controller.PartsController || (controller.PartsController = {}));
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class ToolFactoryController extends com.vzome.desktop.controller.DefaultController {
                    constructor(factory) {
                        super();
                        if (this.factory === undefined) {
                            this.factory = null;
                        }
                        this.factory = factory;
                        factory.addListener(this);
                    }
                    /**
                     *
                     * @param {java.beans.PropertyChangeEvent} evt
                     */
                    propertyChange(evt) {
                        switch ((evt.getPropertyName())) {
                            case "enabled":
                                this.firePropertyChange$java_beans_PropertyChangeEvent(evt);
                                break;
                            default:
                                break;
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {string}
                     */
                    getProperty(name) {
                        switch ((name)) {
                            case "title":
                                return this.factory.getLabel();
                            case "tooltip":
                                return this.factory.getToolTip();
                            case "enabled":
                                return javaemul.internal.BooleanHelper.toString(this.factory.isEnabled());
                            default:
                                return super.getProperty(name);
                        }
                    }
                    /**
                     *
                     * @param {string} action
                     */
                    doAction(action) {
                        switch ((action)) {
                            case "createTool":
                                this.factory.createTool();
                                break;
                            default:
                                super.doAction(action);
                        }
                    }
                }
                controller.ToolFactoryController = ToolFactoryController;
                ToolFactoryController["__class"] = "com.vzome.desktop.controller.ToolFactoryController";
                ToolFactoryController["__interfaces"] = ["java.util.EventListener", "java.beans.PropertyChangeListener", "com.vzome.desktop.api.Controller"];
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class SymmetryController extends com.vzome.desktop.controller.DefaultController {
                    constructor(label, parent, model, mRenderedModel) {
                        super();
                        if (this.symmetrySystem === undefined) {
                            this.symmetrySystem = null;
                        }
                        if (this.availableOrbits === undefined) {
                            this.availableOrbits = null;
                        }
                        if (this.snapOrbits === undefined) {
                            this.snapOrbits = null;
                        }
                        if (this.buildOrbits === undefined) {
                            this.buildOrbits = null;
                        }
                        if (this.renderOrbits === undefined) {
                            this.renderOrbits = null;
                        }
                        if (this.snapper === undefined) {
                            this.snapper = null;
                        }
                        if (this.availableController === undefined) {
                            this.availableController = null;
                        }
                        if (this.snapController === undefined) {
                            this.snapController = null;
                        }
                        if (this.buildController === undefined) {
                            this.buildController = null;
                        }
                        if (this.renderController === undefined) {
                            this.renderController = null;
                        }
                        this.orbitLengths = (new java.util.HashMap());
                        this.symmetryToolFactories = (new java.util.LinkedHashMap());
                        this.transformToolFactories = (new java.util.LinkedHashMap());
                        this.linearMapToolFactories = (new java.util.LinkedHashMap());
                        if (this.renderedModel === undefined) {
                            this.renderedModel = null;
                        }
                        if (this.label === undefined) {
                            this.label = null;
                        }
                        this.label = label;
                        this.symmetrySystem = model;
                        this.renderedModel = mRenderedModel;
                        const symmetry = model.getSymmetry();
                        this.availableOrbits = new com.vzome.core.math.symmetry.OrbitSet(symmetry);
                        this.snapOrbits = new com.vzome.core.math.symmetry.OrbitSet(symmetry);
                        this.buildOrbits = new com.vzome.core.math.symmetry.OrbitSet(symmetry);
                        this.renderOrbits = new com.vzome.core.math.symmetry.OrbitSet(symmetry);
                        this.snapper = new com.vzome.desktop.controller.SymmetrySnapper(this.snapOrbits);
                        for (let index = symmetry.getOrbitSet().getDirections().iterator(); index.hasNext();) {
                            let orbit = index.next();
                            {
                                if (model.orbitIsStandard(orbit)) {
                                    this.availableOrbits.add(orbit);
                                    this.snapOrbits.add(orbit);
                                    if (model.orbitIsBuildDefault(orbit)) {
                                        this.buildOrbits.add(orbit);
                                    }
                                }
                                this.renderOrbits.add(orbit);
                            }
                        }
                        this.availableController = new com.vzome.desktop.controller.OrbitSetController(this.availableOrbits, this.symmetrySystem.getOrbits(), this.symmetrySystem);
                        this.addSubController("availableOrbits", this.availableController);
                        this.snapController = new com.vzome.desktop.controller.OrbitSetController(this.snapOrbits, this.availableOrbits, this.symmetrySystem);
                        this.addSubController("snapOrbits", this.snapController);
                        this.buildController = new com.vzome.desktop.controller.OrbitSetController(this.buildOrbits, this.availableOrbits, this.symmetrySystem);
                        this.addSubController("buildOrbits", this.buildController);
                        if (parent.propertyIsTrue("single.orbit"))
                            try {
                                this.buildController.doAction("oneAtATime");
                            }
                            catch (e) {
                                console.error(e.message, e);
                            }
                        this.renderController = new com.vzome.desktop.controller.OrbitSetController(this.renderOrbits, this.symmetrySystem.getOrbits(), this.symmetrySystem);
                        this.addSubController("renderOrbits", this.renderController);
                        for (let index = this.symmetrySystem.getOrbits().getDirections().iterator(); index.hasNext();) {
                            let orbit = index.next();
                            {
                                const unitLength = this.symmetrySystem.getOrbitUnitLength(orbit);
                                const field = symmetry.getField();
                                const lengthModel = new com.vzome.desktop.controller.LengthController(unitLength, field.one(), field);
                                this.buildController.addSubController("length." + orbit.getName(), lengthModel);
                                this.orbitLengths.put(orbit, lengthModel);
                            }
                        }
                        if (parent.propertyIsTrue("disable.known.directions"))
                            this.symmetrySystem.disableKnownDirection();
                        this.availableController.addPropertyListener(this.buildController);
                        this.availableController.addPropertyListener(this.snapController);
                        this.availableController.addPropertyListener(new SymmetryController.SymmetryController$0(this));
                        const presetStyle = parent.getProperty("defaultShapes." + model.getSymmetry().getField().getName() + "." + model.getName());
                        if (presetStyle != null)
                            this.symmetrySystem.setStyle(presetStyle);
                    }
                    /**
                     *
                     * @param {string} string
                     * @return {string}
                     */
                    getProperty(string) {
                        switch ((string)) {
                            case "label":
                                return this.label;
                            case "name":
                                return this.symmetrySystem.getName();
                            case "renderingStyle":
                                return this.symmetrySystem.getStyle$().getName();
                            case "modelResourcePath":
                                return this.symmetrySystem.getModelResourcePath();
                            default:
                                if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "orbitColor.")) {
                                    const name = string.substring("orbitColor.".length);
                                    const dir = this.buildOrbits.getDirection(name);
                                    const color = this.getColor(dir);
                                    return color.toString();
                                }
                                return super.getProperty(string);
                        }
                    }
                    getSymmetry() {
                        return this.symmetrySystem.getSymmetry();
                    }
                    getSnapper() {
                        return this.snapper;
                    }
                    /**
                     *
                     * @param {string} listName
                     * @return {java.lang.String[]}
                     */
                    getCommandList(listName) {
                        switch ((listName)) {
                            case "styles":
                                return this.symmetrySystem.getStyleNames();
                            case "orbits":
                                const result = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(this.symmetrySystem.getOrbits().size());
                                let i = 0;
                                for (let index = this.symmetrySystem.getOrbits().getDirections().iterator(); index.hasNext();) {
                                    let orbit = index.next();
                                    {
                                        result[i] = orbit.getName();
                                        i++;
                                    }
                                }
                                return result;
                            case "symmetryToolFactories":
                                if (this.symmetryToolFactories.isEmpty()) {
                                    for (let index = this.symmetrySystem.getToolFactories(com.vzome.api.Tool.Kind.SYMMETRY).iterator(); index.hasNext();) {
                                        let factory = index.next();
                                        this.symmetryToolFactories.put(factory.getId(), new com.vzome.desktop.controller.ToolFactoryController(factory));
                                    }
                                }
                                return this.symmetryToolFactories.keySet().toArray([]);
                            case "transformToolFactories":
                                if (this.transformToolFactories.isEmpty()) {
                                    for (let index = this.symmetrySystem.getToolFactories(com.vzome.api.Tool.Kind.TRANSFORM).iterator(); index.hasNext();) {
                                        let factory = index.next();
                                        this.transformToolFactories.put(factory.getId(), new com.vzome.desktop.controller.ToolFactoryController(factory));
                                    }
                                }
                                return this.transformToolFactories.keySet().toArray([]);
                            case "linearMapToolFactories":
                                if (this.linearMapToolFactories.isEmpty()) {
                                    for (let index = this.symmetrySystem.getToolFactories(com.vzome.api.Tool.Kind.LINEAR_MAP).iterator(); index.hasNext();) {
                                        let factory = index.next();
                                        this.linearMapToolFactories.put(factory.getId(), new com.vzome.desktop.controller.ToolFactoryController(factory));
                                    }
                                }
                                return this.linearMapToolFactories.keySet().toArray([]);
                            case "builtInSymmetryTools":
                                const toolNames = (new java.util.ArrayList());
                                for (let index = this.symmetrySystem.getPredefinedTools(com.vzome.api.Tool.Kind.SYMMETRY).iterator(); index.hasNext();) {
                                    let tool = index.next();
                                    toolNames.add(tool.getId());
                                }
                                return toolNames.toArray([]);
                            case "builtInTransformTools":
                                const transformToolNames = (new java.util.ArrayList());
                                for (let index = this.symmetrySystem.getPredefinedTools(com.vzome.api.Tool.Kind.TRANSFORM).iterator(); index.hasNext();) {
                                    let tool = index.next();
                                    transformToolNames.add(tool.getId());
                                }
                                return transformToolNames.toArray([]);
                            default:
                                return super.getCommandList(listName);
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {*}
                     */
                    getSubController(name) {
                        switch ((name)) {
                            case "availableOrbits":
                                return this.availableController;
                            case "snapOrbits":
                                return this.snapController;
                            case "buildOrbits":
                                return this.buildController;
                            case "renderOrbits":
                                return this.renderController;
                            default:
                                if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, "length.")) {
                                    const dirName = name.substring("length.".length);
                                    const dir = this.symmetrySystem.getOrbits().getDirection(dirName);
                                    return this.getLengthController(dir);
                                }
                                let result = this.symmetryToolFactories.get(name);
                                if (result != null)
                                    return result;
                                result = this.transformToolFactories.get(name);
                                if (result != null)
                                    return result;
                                result = this.linearMapToolFactories.get(name);
                                if (result != null)
                                    return result;
                                return super.getSubController(name);
                        }
                    }
                    /**
                     *
                     * @param {string} action
                     */
                    doAction(action) {
                        switch ((action)) {
                            case "rZomeOrbits":
                            case "predefinedOrbits":
                            case "setAllDirections":
                                this.availableController.doAction(action);
                                break;
                            case "ReplaceWithShape":
                                action += "/" + this.symmetrySystem.getName() + ":" + this.symmetrySystem.getStyle$().getName();
                                super.doAction(action);
                                break;
                            case "resetOrbitColors":
                                this.symmetrySystem.resetColors();
                                this.availableController.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("orbits", true, false);
                                break;
                            default:
                                if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "setStyle.")) {
                                    const styleName = action.substring("setStyle.".length);
                                    this.symmetrySystem.setStyle(styleName);
                                    this.renderedModel.setShapes(this.symmetrySystem.getShapes());
                                    this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("renderingStyle", null, styleName);
                                }
                                else {
                                    const handled = this.symmetrySystem.doAction(action);
                                    if (!handled)
                                        super.doAction(action);
                                }
                                break;
                        }
                    }
                    /*private*/ getLengthController(orbit) {
                        let result = this.orbitLengths.get(orbit);
                        if (result == null && orbit != null) {
                            const unitLength = this.symmetrySystem.getOrbitUnitLength(orbit);
                            const field = this.symmetrySystem.getSymmetry().getField();
                            result = new com.vzome.desktop.controller.LengthController(unitLength, field.one(), field);
                            this.buildController.addSubController("length." + orbit.getName(), result);
                            this.orbitLengths.put(orbit, result);
                            this.renderOrbits.add(orbit);
                            this.availableOrbits.add(orbit);
                        }
                        return result;
                    }
                    getOrbits() {
                        return this.symmetrySystem.getOrbits();
                    }
                    getOrbitSource() {
                        return this.symmetrySystem;
                    }
                    getZone(offset) {
                        return this.symmetrySystem.getAxis(offset);
                    }
                    getColor(orbit) {
                        return this.symmetrySystem.getColor(orbit);
                    }
                    getBuildOrbits() {
                        return this.buildOrbits;
                    }
                    getRenderingStyle() {
                        return this.symmetrySystem.getRenderingStyle();
                    }
                }
                controller.SymmetryController = SymmetryController;
                SymmetryController["__class"] = "com.vzome.desktop.controller.SymmetryController";
                SymmetryController["__interfaces"] = ["com.vzome.desktop.api.Controller"];
                (function (SymmetryController) {
                    class SymmetryController$0 {
                        constructor(__parent) {
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @param {java.beans.PropertyChangeEvent} event
                         */
                        propertyChange(event) {
                            if ("orbits" === event.getPropertyName()) {
                            }
                        }
                    }
                    SymmetryController.SymmetryController$0 = SymmetryController$0;
                    SymmetryController$0["__interfaces"] = ["java.util.EventListener", "java.beans.PropertyChangeListener"];
                })(SymmetryController = controller.SymmetryController || (controller.SymmetryController = {}));
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller_2) {
                class ToolsController extends com.vzome.desktop.controller.DefaultController {
                    constructor(tools) {
                        super();
                        if (this.tools === undefined) {
                            this.tools = null;
                        }
                        this.tools = tools;
                        tools.addPropertyListener(this);
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {*}
                     */
                    getSubController(name) {
                        const tool = this.tools.get(name);
                        if (tool != null) {
                            const controller = new com.vzome.desktop.controller.ToolController(tool);
                            this.addSubController(name, controller);
                            return controller;
                        }
                        return null;
                    }
                    addTool(tool) {
                        const controller = new com.vzome.desktop.controller.ToolController(tool);
                        this.addSubController(tool.getId(), controller);
                        this.firePropertyChange$java_beans_PropertyChangeEvent(new java.beans.PropertyChangeEvent(this, "tool.added", null, controller));
                    }
                    /**
                     *
                     * @param {java.beans.PropertyChangeEvent} evt
                     */
                    propertyChange(evt) {
                        switch ((evt.getPropertyName())) {
                            case "customTools":
                            case "customBookmarks":
                                this.firePropertyChange$java_beans_PropertyChangeEvent(new java.beans.PropertyChangeEvent(this, evt.getPropertyName(), null, evt.getNewValue()));
                                break;
                            case "tool.instances":
                                if (evt.getOldValue() == null) {
                                    const tool = evt.getNewValue();
                                    if (tool.isPredefined() || tool.isHidden())
                                        return;
                                    const controller = new com.vzome.desktop.controller.ToolController(tool);
                                    this.firePropertyChange$java_beans_PropertyChangeEvent(new java.beans.PropertyChangeEvent(this, "tool.added", null, controller));
                                }
                                else {
                                    const tool = evt.getOldValue();
                                    this.firePropertyChange$java_beans_PropertyChangeEvent(new java.beans.PropertyChangeEvent(this, "tool.hidden", tool.getId(), null));
                                }
                                break;
                            default:
                                break;
                        }
                    }
                    /**
                     *
                     * @param {string} listName
                     * @return {java.lang.String[]}
                     */
                    getCommandList(listName) {
                        switch ((listName)) {
                            case "customTools":
                                return this.tools.getToolIDs(false);
                            case "customBookmarks":
                                return this.tools.getToolIDs(true);
                            default:
                                break;
                        }
                        return super.getCommandList(listName);
                    }
                }
                controller_2.ToolsController = ToolsController;
                ToolsController["__class"] = "com.vzome.desktop.controller.ToolsController";
                ToolsController["__interfaces"] = ["java.util.EventListener", "java.beans.PropertyChangeListener", "com.vzome.desktop.api.Controller"];
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class LengthController extends com.vzome.desktop.controller.DefaultController {
                    constructor(fixedFactor, standardUnitFactor, field) {
                        if (((fixedFactor != null && (fixedFactor.constructor != null && fixedFactor.constructor["__interfaces"] != null && fixedFactor.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || fixedFactor === null) && ((standardUnitFactor != null && (standardUnitFactor.constructor != null && standardUnitFactor.constructor["__interfaces"] != null && standardUnitFactor.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || standardUnitFactor === null) && ((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null)) {
                            let __args = arguments;
                            super();
                            if (this.currentScales === undefined) {
                                this.currentScales = null;
                            }
                            if (this.unitController === undefined) {
                                this.unitController = null;
                            }
                            if (this.fixedFactor === undefined) {
                                this.fixedFactor = null;
                            }
                            if (this.unitFactor === undefined) {
                                this.unitFactor = null;
                            }
                            if (this.multiplier === undefined) {
                                this.multiplier = 0;
                            }
                            if (this.standardUnitFactor === undefined) {
                                this.standardUnitFactor = null;
                            }
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            this.half = false;
                            this.fixedFactor = fixedFactor;
                            this.standardUnitFactor = standardUnitFactor;
                            this.field = field;
                            this.multiplier = 0;
                            this.unitFactor = standardUnitFactor;
                            this.currentScales = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(field.getNumMultipliers());
                            for (let i = 0; i < this.currentScales.length; i++) {
                                {
                                    this.currentScales[i] = new LengthController.ScaleController(this);
                                    this.addSubController("scale." + i, this.currentScales[i]);
                                }
                                ;
                            }
                            this.unitController = new com.vzome.desktop.controller.NumberController(field);
                            this.addSubController("unit", this.unitController);
                        }
                        else if (((fixedFactor != null && (fixedFactor.constructor != null && fixedFactor.constructor["__interfaces"] != null && fixedFactor.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || fixedFactor === null) && standardUnitFactor === undefined && field === undefined) {
                            let __args = arguments;
                            let field = __args[0];
                            {
                                let __args = arguments;
                                let fixedFactor = __args[2].one();
                                let standardUnitFactor = __args[2].one();
                                super();
                                if (this.currentScales === undefined) {
                                    this.currentScales = null;
                                }
                                if (this.unitController === undefined) {
                                    this.unitController = null;
                                }
                                if (this.fixedFactor === undefined) {
                                    this.fixedFactor = null;
                                }
                                if (this.unitFactor === undefined) {
                                    this.unitFactor = null;
                                }
                                if (this.multiplier === undefined) {
                                    this.multiplier = 0;
                                }
                                if (this.standardUnitFactor === undefined) {
                                    this.standardUnitFactor = null;
                                }
                                if (this.field === undefined) {
                                    this.field = null;
                                }
                                this.half = false;
                                this.fixedFactor = fixedFactor;
                                this.standardUnitFactor = standardUnitFactor;
                                this.field = field;
                                this.multiplier = 0;
                                this.unitFactor = standardUnitFactor;
                                this.currentScales = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(field.getNumMultipliers());
                                for (let i = 0; i < this.currentScales.length; i++) {
                                    {
                                        this.currentScales[i] = new LengthController.ScaleController(this);
                                        this.addSubController("scale." + i, this.currentScales[i]);
                                    }
                                    ;
                                }
                                this.unitController = new com.vzome.desktop.controller.NumberController(field);
                                this.addSubController("unit", this.unitController);
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static SCALE_OFFSET_$LI$() { if (LengthController.SCALE_OFFSET == null) {
                        LengthController.SCALE_OFFSET = com.vzome.core.math.symmetry.Direction.USER_SCALE;
                    } return LengthController.SCALE_OFFSET; }
                    /**
                     *
                     * @param {string} name
                     * @return {*}
                     */
                    getSubController(name) {
                        switch ((name)) {
                            case "unit":
                                return this.unitController;
                            case "scale":
                                return this.currentScales[this.multiplier];
                            default:
                                return super.getSubController(name);
                        }
                    }
                    fireLengthChange() {
                        this.firePropertyChange$java_lang_String$java_lang_Object$java_lang_Object("length", true, false);
                    }
                    resetScales() {
                        for (let i = 0; i < this.currentScales.length; i++) {
                            {
                                this.currentScales[i].setScale(0);
                            }
                            ;
                        }
                    }
                    /**
                     *
                     * @param {string} action
                     */
                    doAction(action) {
                        switch ((action)) {
                            case "setCustomUnit":
                                this.unitController.setValue(this.unitFactor);
                                return;
                            case "getCustomUnit":
                                this.unitFactor = this.unitController.getValue();
                                this.resetScales();
                                this.multiplier = 0;
                                this.fireLengthChange();
                                return;
                            case "toggleHalf":
                                {
                                    this.half = !this.half;
                                    this.fireLengthChange();
                                    return;
                                }
                                ;
                            case "reset":
                            case "short":
                                {
                                    this.unitFactor = this.standardUnitFactor;
                                    this.resetScales();
                                    this.multiplier = 0;
                                    this.fireLengthChange();
                                    return;
                                }
                                ;
                            case "supershort":
                                {
                                    this.unitFactor = this.standardUnitFactor;
                                    this.resetScales();
                                    this.currentScales[0].setScale(-1);
                                    this.multiplier = 0;
                                    this.fireLengthChange();
                                    return;
                                }
                                ;
                            case "medium":
                                {
                                    this.unitFactor = this.standardUnitFactor;
                                    this.resetScales();
                                    this.currentScales[0].setScale(1);
                                    this.multiplier = 0;
                                    this.fireLengthChange();
                                    return;
                                }
                                ;
                            case "long":
                                {
                                    this.unitFactor = this.standardUnitFactor;
                                    this.resetScales();
                                    this.currentScales[0].setScale(2);
                                    this.multiplier = 0;
                                    this.fireLengthChange();
                                    return;
                                }
                                ;
                            case "scaleUp":
                            case "scaleDown":
                                this.currentScales[this.multiplier].doAction(action);
                                return;
                            case "newZeroScale":
                                {
                                    this.unitFactor = this.applyScales(this.unitFactor);
                                    this.resetScales();
                                    this.multiplier = 0;
                                    this.fireLengthChange();
                                    return;
                                }
                                ;
                            default:
                                if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(action, "setMultiplier.")) {
                                    action = action.substring("setMultiplier.".length);
                                    const i = javaemul.internal.IntegerHelper.parseInt(action);
                                    this.multiplier = i;
                                    this.fireLengthChange();
                                }
                                else
                                    super.doAction(action);
                        }
                    }
                    /**
                     *
                     * @param {string} property
                     * @param {*} value
                     */
                    setModelProperty(property, value) {
                        switch ((property)) {
                            case "half":
                                {
                                    const oldHalf = this.half;
                                    this.half = javaemul.internal.BooleanHelper.parseBoolean(value);
                                    if (this.half !== oldHalf)
                                        this.fireLengthChange();
                                    break;
                                }
                                ;
                            case "scale":
                                {
                                    this.currentScales[this.multiplier].setModelProperty(property, value);
                                    return;
                                }
                                ;
                            default:
                                super.setModelProperty(property, value);
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {string}
                     */
                    getProperty(name) {
                        switch ((name)) {
                            case "multiplier":
                                return /* toString */ ('' + (this.multiplier));
                            case "half":
                                return javaemul.internal.BooleanHelper.toString(this.half);
                            case "scale":
                                return this.currentScales[this.multiplier].getProperty(name);
                            case "unitText":
                                return this.readable(this.unitFactor);
                            case "unitIsCustom":
                                return javaemul.internal.BooleanHelper.toString(!((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(this.unitFactor, this.standardUnitFactor));
                            case "lengthText":
                                {
                                    let result = this.unitFactor;
                                    result = this.applyScales(result);
                                    return this.readable(result);
                                }
                                ;
                            case "lengthMathML":
                                {
                                    let result = this.unitFactor;
                                    result = this.applyScales(result);
                                    return result.getMathML();
                                }
                                ;
                            case "scaleFactorHtml":
                                {
                                    let html = "";
                                    for (let i = 0; i < this.currentScales.length; i++) {
                                        {
                                            html += this.field['getIrrational$int'](i + 1) + this.currentScales[i].getProperty("scaleHtml") + "  \u2715  ";
                                        }
                                        ;
                                    }
                                    return html;
                                }
                                ;
                            default:
                                return super.getProperty(name);
                        }
                    }
                    applyScales(value) {
                        for (let i = 0; i < this.currentScales.length; i++) {
                            {
                                const scale = this.currentScales[i].getScale();
                                value = value['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createPower$int$int'](scale, i + 1));
                            }
                            ;
                        }
                        return value;
                    }
                    readable(unitFactor2) {
                        const buf = new java.lang.StringBuffer();
                        unitFactor2.getNumberExpression(buf, com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT);
                        return buf.toString();
                    }
                    /**
                     * Get the actual length value to use when rendering.  This value will multiply the zone's normal vector,
                     * whatever its length is (not necessarily a unit vector).
                     * @return {*}
                     */
                    getValue() {
                        let result = this.unitFactor['times$com_vzome_core_algebra_AlgebraicNumber'](this.fixedFactor);
                        if (this.half)
                            result = result['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createRational$long$long'](1, 2));
                        result = result['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createPower$int'](LengthController.SCALE_OFFSET_$LI$()));
                        result = this.applyScales(result);
                        return result;
                    }
                    getScale() {
                        return this.currentScales[this.multiplier].getScale();
                    }
                    setScale(amt) {
                        this.currentScales[this.multiplier].setScale(amt);
                    }
                    /**
                     * This is basically an inverse of getValue(), but with scale fixed at zero,
                     * thus forcing unitFactor to float.
                     *
                     * @param {*} length
                     */
                    setActualLength(length) {
                        this.half = false;
                        this.resetScales();
                        length = length['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createPower$int'](-LengthController.SCALE_OFFSET_$LI$()));
                        this.unitFactor = length.dividedBy(this.fixedFactor);
                        this.fireLengthChange();
                    }
                }
                controller.LengthController = LengthController;
                LengthController["__class"] = "com.vzome.desktop.controller.LengthController";
                LengthController["__interfaces"] = ["com.vzome.desktop.api.Controller"];
                (function (LengthController) {
                    /**
                     * A model for a scale slider.  Value range centers on scale 0.
                     *
                     * Actual scale
                     *
                     * @author Scott Vorthmann
                     * @extends com.vzome.desktop.controller.DefaultController
                     * @class
                     */
                    class ScaleController extends com.vzome.desktop.controller.DefaultController {
                        constructor(__parent) {
                            super();
                            this.__parent = __parent;
                            this.scale = 0;
                        }
                        /**
                         *
                         * @param {string} action
                         */
                        doAction(action) {
                            if ("scaleUp" === action)
                                this.setScale(this.scale + 1);
                            else if ("scaleDown" === action)
                                this.setScale(this.scale - 1);
                            else
                                super.doAction(action);
                        }
                        /**
                         *
                         * @param {string} property
                         * @param {*} value
                         */
                        setModelProperty(property, value) {
                            if ("scale" === property) {
                                this.setScale(javaemul.internal.IntegerHelper.parseInt(value));
                                return;
                            }
                            else
                                super.setModelProperty(property, value);
                        }
                        /**
                         *
                         * @param {string} string
                         * @return {string}
                         */
                        getProperty(string) {
                            if ("scale" === string)
                                return /* toString */ ('' + (this.scale));
                            if ("scaleHtml" === string) {
                                if (this.scale === 0)
                                    return "\u2070";
                                const absScale = Math.abs(this.scale);
                                let result = (absScale === this.scale) ? "" : "\u207b";
                                switch ((absScale)) {
                                    case 1:
                                        result += "\u00b9";
                                        break;
                                    case 2:
                                        result += "\u00b2";
                                        break;
                                    case 3:
                                        result += "\u00b3";
                                        break;
                                    case 4:
                                        result += "\u2074";
                                        break;
                                    case 5:
                                        result += "\u2075";
                                        break;
                                    case 6:
                                        result += "\u2076";
                                        break;
                                    case 7:
                                        result += "\u2077";
                                        break;
                                    case 8:
                                        result += "\u2078";
                                        break;
                                    case 9:
                                        result += "\u2079";
                                        break;
                                    default:
                                        result += "\u207f";
                                        break;
                                }
                                return result;
                            }
                            return super.getProperty(string);
                        }
                        setScale(amt) {
                            const oldScale = this.scale;
                            this.scale = amt;
                            if (this.scale > ScaleController.MAX_SCALE)
                                this.scale = ScaleController.MAX_SCALE;
                            else if (this.scale < ScaleController.MIN_SCALE)
                                this.scale = ScaleController.MIN_SCALE;
                            if (oldScale !== this.scale)
                                this.__parent.fireLengthChange();
                        }
                        getScale() {
                            return this.scale;
                        }
                    }
                    ScaleController.MAX_SCALE = 6;
                    ScaleController.MIN_SCALE = -6;
                    LengthController.ScaleController = ScaleController;
                    ScaleController["__class"] = "com.vzome.desktop.controller.LengthController.ScaleController";
                    ScaleController["__interfaces"] = ["com.vzome.desktop.api.Controller"];
                })(LengthController = controller.LengthController || (controller.LengthController = {}));
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var desktop;
        (function (desktop) {
            var controller;
            (function (controller) {
                class PreviewStrut {
                    constructor(field, mainScene, context) {
                        if (this.model === undefined) {
                            this.model = null;
                        }
                        if (this.editorModel === undefined) {
                            this.editorModel = null;
                        }
                        if (this.rendering === undefined) {
                            this.rendering = null;
                        }
                        if (this.zoneBall === undefined) {
                            this.zoneBall = null;
                        }
                        if (this.context === undefined) {
                            this.context = null;
                        }
                        if (this.point === undefined) {
                            this.point = null;
                        }
                        if (this.zone === undefined) {
                            this.zone = null;
                        }
                        if (this.symmetryController === undefined) {
                            this.symmetryController = null;
                        }
                        if (this.length === undefined) {
                            this.length = null;
                        }
                        if (this.strut === undefined) {
                            this.strut = null;
                        }
                        this.workingPlaneDual = null;
                        this.context = context;
                        this.rendering = new com.vzome.core.render.RenderedModel(field, null);
                        const transp = new com.vzome.core.render.TransparentRendering(mainScene);
                        this.rendering.addListener(transp);
                        this.model = new com.vzome.core.model.RealizedModelImpl(field, new com.vzome.core.math.Projection.Default(field));
                        this.model.addListener(this.rendering);
                        this.editorModel = new PreviewStrut.PreviewStrut$0(this);
                        this.zoneBall = new PreviewStrut.PreviewStrut$1(this);
                    }
                    static logger_$LI$() { if (PreviewStrut.logger == null) {
                        PreviewStrut.logger = java.util.logging.Logger.getLogger("org.vorthmann.zome.app.impl.PreviewStrut");
                    } return PreviewStrut.logger; }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj)
                            return true;
                        if (obj == null)
                            return false;
                        if (this.constructor !== obj.constructor)
                            return false;
                        return false;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        return /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this);
                    }
                    /*private*/ setZone(zone) {
                        this.zone = zone;
                    }
                    startRendering(point, workingPlaneAxis, worldEye) {
                        this.point = point;
                        let orbits = this.symmetryController.getBuildOrbits();
                        if (workingPlaneAxis != null) {
                            orbits = new com.vzome.core.math.symmetry.PlaneOrbitSet(orbits, workingPlaneAxis);
                            const normal = workingPlaneAxis.toRealVector();
                            let other = new com.vzome.core.math.RealVector(1.0, 0.0, 0.0);
                            let v1 = normal.cross(other);
                            const len = v1.length();
                            if (len < 1.0E-4) {
                                other = new com.vzome.core.math.RealVector(0.0, 1.0, 0.0);
                                v1 = normal.cross(other);
                            }
                            const v2 = normal.cross(v1);
                            const p = this.point.getLocation().toRealVector();
                            const q = p.plus(v1);
                            const r = p.plus(v2);
                            const e12 = Math.fround(Math.fround(p.x * q.y) - Math.fround(q.x * p.y));
                            const e23 = Math.fround(Math.fround(p.y * q.z) - Math.fround(q.y * p.z));
                            const e31 = Math.fround(Math.fround(p.z * q.x) - Math.fround(q.z * p.x));
                            const e10 = Math.fround(p.x - q.x);
                            const e20 = Math.fround(p.y - q.y);
                            const e30 = Math.fround(p.z - q.z);
                            const P_e123 = e12 * r.z + e23 * r.x + e31 * r.y;
                            const P_e310 = e10 * r.z + e31 * 1.0 - e30 * r.x;
                            const P_e320 = e20 * r.z - e30 * r.y - e23 * 1.0;
                            const P_e120 = e12 * 1.0 + e20 * r.x - e10 * r.y;
                            this.workingPlaneDual = [0, 0, 0, 0];
                            this.workingPlaneDual[0] = -P_e123;
                            this.workingPlaneDual[1] = -P_e320;
                            this.workingPlaneDual[2] = P_e310;
                            this.workingPlaneDual[3] = P_e120;
                        }
                        this.zone = this.zoneBall.initializeZone(orbits, worldEye);
                        if (this.zone == null) {
                            this.length = null;
                            return;
                        }
                        this.length = this.symmetryController.orbitLengths.get(this.zone.getDirection());
                        this.adjustStrut();
                        this.length.addPropertyListener(this);
                    }
                    finishPreview() {
                        if (this.length == null)
                            return;
                        this.length.removePropertyListener(this);
                        this.strut.undo();
                        this.strut = null;
                        if (PreviewStrut.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                            PreviewStrut.logger_$LI$().fine("preview finished at  " + this.zone);
                        const params = (new java.util.HashMap());
                        params.put("anchor", this.point);
                        params.put("zone", this.zone);
                        params.put("length", this.length.getValue());
                        this.context.doEdit("StrutCreation", params);
                        this.point = null;
                        this.zone = null;
                        this.length = null;
                        this.workingPlaneDual = null;
                    }
                    /*private*/ adjustStrut() {
                        if (this.strut != null)
                            this.strut.undo();
                        if (this.length == null)
                            return;
                        if (PreviewStrut.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                            PreviewStrut.logger_$LI$().finer("preview now " + this.zone);
                        this.strut = new com.vzome.core.edits.StrutCreation(this.point, this.zone, this.length.getValue(), this.editorModel);
                        this.strut.perform();
                    }
                    /**
                     *
                     * @param {java.beans.PropertyChangeEvent} evt
                     */
                    propertyChange(evt) {
                        if ("length" === evt.getPropertyName())
                            this.adjustStrut();
                    }
                    setSymmetryController(symmetryController) {
                        this.symmetryController = symmetryController;
                        this.rendering.setOrbitSource(symmetryController.getOrbitSource());
                    }
                    /*private*/ usingWorkingPlane() {
                        return this.workingPlaneDual != null;
                    }
                    trackballRolled(rowMajor) {
                        if (this.point != null && !this.usingWorkingPlane())
                            this.zoneBall.trackballRolled(rowMajor);
                    }
                    workingPlaneDrag(ray) {
                        if (this.usingWorkingPlane()) {
                            if (this.point == null && PreviewStrut.logger_$LI$().isLoggable(java.util.logging.Level.SEVERE)) {
                                PreviewStrut.logger_$LI$().severe("No point during workingPlaneDrag!");
                                return;
                            }
                            const planeIntersection = this.intersectWorkingPlane(ray);
                            const vectorInPlane = planeIntersection.minus(this.point.getLocation().toRealVector());
                            const almostPlanarVector = new com.vzome.core.math.RealVector(vectorInPlane.x, vectorInPlane.y, vectorInPlane.z);
                            this.zoneBall.setVector(almostPlanarVector);
                        }
                    }
                    /*private*/ intersectWorkingPlane(ray) {
                        const s = ray.getOrigin();
                        const t = s.plus(ray.getDirection());
                        const e12 = Math.fround(Math.fround(s.x * t.y) - Math.fround(t.x * s.y));
                        const e23 = Math.fround(Math.fround(s.y * t.z) - Math.fround(t.y * s.z));
                        const e31 = Math.fround(Math.fround(s.z * t.x) - Math.fround(t.z * s.x));
                        const e10 = Math.fround(s.x - t.x);
                        const e20 = Math.fround(s.y - t.y);
                        const e30 = Math.fround(s.z - t.z);
                        const x_e1 = -this.workingPlaneDual[2] * e12 - this.workingPlaneDual[0] * e10 + this.workingPlaneDual[3] * e31;
                        const x_e2 = -this.workingPlaneDual[3] * e23 - this.workingPlaneDual[0] * e20 + this.workingPlaneDual[1] * e12;
                        const x_e3 = -this.workingPlaneDual[1] * e31 - this.workingPlaneDual[0] * e30 + this.workingPlaneDual[2] * e23;
                        const x_e0 = this.workingPlaneDual[1] * e10 + this.workingPlaneDual[2] * e20 + this.workingPlaneDual[3] * e30;
                        return new com.vzome.core.math.RealVector(x_e1 / x_e0, x_e2 / x_e0, x_e3 / x_e0);
                    }
                    getLengthController() {
                        return this.length;
                    }
                }
                controller.PreviewStrut = PreviewStrut;
                PreviewStrut["__class"] = "com.vzome.desktop.controller.PreviewStrut";
                PreviewStrut["__interfaces"] = ["java.util.EventListener", "java.beans.PropertyChangeListener"];
                (function (PreviewStrut) {
                    class PreviewStrut$0 {
                        constructor(__parent) {
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getRealizedModel() {
                            return this.__parent.model;
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getSelection() {
                            return null;
                        }
                        getSymmetrySystem$() {
                            return null;
                        }
                        getSymmetrySystem$java_lang_String(name) {
                            return null;
                        }
                        /**
                         *
                         * @param {string} name
                         * @return {*}
                         */
                        getSymmetrySystem(name) {
                            if (((typeof name === 'string') || name === null)) {
                                return this.getSymmetrySystem$java_lang_String(name);
                            }
                            else if (name === undefined) {
                                return this.getSymmetrySystem$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         *
                         * @return {*}
                         */
                        get4dSymmetries() {
                            return null;
                        }
                        /**
                         *
                         * @param {*} listener
                         */
                        addSelectionSummaryListener(listener) {
                        }
                    }
                    PreviewStrut.PreviewStrut$0 = PreviewStrut$0;
                    PreviewStrut$0["__interfaces"] = ["com.vzome.core.editor.api.EditorModel", "com.vzome.core.editor.api.SymmetryAware"];
                    class PreviewStrut$1 extends com.vzome.desktop.controller.ZoneVectorBall {
                        constructor(__parent) {
                            super();
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.Axis} oldZone
                         * @param {com.vzome.core.math.symmetry.Axis} newZone
                         */
                        zoneChanged(oldZone, newZone) {
                            if (this.__parent.length != null)
                                this.__parent.length.removePropertyListener(this.__parent);
                            this.__parent.setZone(newZone);
                            if (newZone == null)
                                return;
                            this.__parent.length = this.__parent.symmetryController.orbitLengths.get(newZone.getDirection());
                            this.__parent.adjustStrut();
                            this.__parent.length.addPropertyListener(this.__parent);
                        }
                    }
                    PreviewStrut.PreviewStrut$1 = PreviewStrut$1;
                })(PreviewStrut = controller.PreviewStrut || (controller.PreviewStrut = {}));
            })(controller = desktop.controller || (desktop.controller = {}));
        })(desktop = vzome.desktop || (vzome.desktop = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters2d;
            (function (exporters2d) {
                /**
                 * @author scottv
                 * @class
                 * @extends com.vzome.core.exporters2d.SnapshotExporter
                 */
                class SVGExporter extends com.vzome.core.exporters2d.SnapshotExporter {
                    /**
                     *
                     * @param {java.awt.Color} bgColor
                     */
                    outputBackground(bgColor) {
                        this.output.print("<rect fill=\'#");
                        const color = bgColor.getRGB() & 16777215;
                        this.output.print(javaemul.internal.IntegerHelper.toHexString(color));
                        this.output.println$java_lang_Object("\' x=\'1\' y=\'1\' width=\'" + this.width + "\' height=\'" + this.height + "\'/>");
                    }
                    /**
                     *
                     * @param {java.awt.geom.Rectangle2D} rect
                     * @param {number} strokeWidth
                     */
                    outputPrologue(rect, strokeWidth) {
                        this.output.println$java_lang_Object("<?xml version=\'1.0\'?>");
                        this.output.println$java_lang_Object("<svg version=\'1.1\' xmlns=\'http://www.w3.org/2000/svg\'");
                        if (strokeWidth > 0)
                            this.output.println$java_lang_Object("   stroke=\'black\' stroke-linejoin=\'round\' stroke-width=\'" + strokeWidth + "\' ");
                        this.output.println$java_lang_Object("   viewBox=\'0 0 " + this.width + " " + this.height + "\' >");
                        this.XY_FORMAT.setMaximumFractionDigits(2);
                    }
                    /**
                     *
                     * @param {com.vzome.core.exporters2d.Java2dSnapshot.LineSegment} line
                     * @param {boolean} monochrome
                     */
                    outputLine(line, monochrome) {
                        this.output.print("<path stroke=\'#");
                        let color = line.getColor().getRGB() & 16777215;
                        if (monochrome)
                            color = java.awt.Color.BLACK_$LI$().getRGB() & 16777215;
                        const hex = javaemul.internal.IntegerHelper.toHexString(color);
                        for (let i = 0; i < 6 - hex.length; i++) {
                            this.output.print('0');
                        }
                        this.output.print(hex);
                        this.output.print("\' d=\'");
                        this.renderPath(line.getPath());
                        this.output.println$java_lang_Object("\'/>");
                    }
                    /**
                     *
                     * @param {com.vzome.core.exporters2d.Java2dSnapshot.Polygon} polygon
                     * @param {boolean} doOutline
                     */
                    outputPolygon(polygon, doOutline) {
                        this.output.print("<path fill=\'#");
                        const color = polygon.getColor().getRGB() & 16777215;
                        const hex = javaemul.internal.IntegerHelper.toHexString(color);
                        for (let i = 0; i < 6 - hex.length; i++) {
                            this.output.print('0');
                        }
                        this.output.print(hex);
                        this.output.print("\' d=\'");
                        this.renderPath(polygon.getPath());
                        this.output.println$java_lang_Object("\'/>");
                    }
                    /**
                     *
                     */
                    outputPostlogue() {
                        this.output.println$();
                        this.output.println$java_lang_Object("</svg>");
                    }
                    /**
                     *
                     * @param {number} r
                     * @param {number} g
                     * @param {number} b
                     */
                    setRGBStrokeColor(r, g, b) {
                    }
                    /**
                     *
                     * @param {number} r
                     * @param {number} g
                     * @param {number} b
                     */
                    setRGBFillColor(r, g, b) {
                    }
                    /**
                     *
                     */
                    beginPath() {
                    }
                    /**
                     *
                     * @param {number} x
                     * @param {number} y
                     */
                    moveToPoint(x, y) {
                        this.output.print("M " + this.XY_FORMAT.format(x) + " " + this.XY_FORMAT.format(Math.fround(this.height - y)) + " ");
                    }
                    /**
                     *
                     * @param {number} x
                     * @param {number} y
                     */
                    addLineToPoint(x, y) {
                        this.output.print("L " + this.XY_FORMAT.format(x) + " " + this.XY_FORMAT.format(Math.fround(this.height - y)) + " ");
                    }
                    /**
                     *
                     */
                    closePath() {
                        this.output.print(" z");
                    }
                    /**
                     *
                     */
                    fillPath() {
                    }
                    /**
                     *
                     */
                    strokePath() {
                    }
                }
                exporters2d.SVGExporter = SVGExporter;
                SVGExporter["__class"] = "com.vzome.core.exporters2d.SVGExporter";
            })(exporters2d = core.exporters2d || (core.exporters2d = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters2d;
            (function (exporters2d) {
                class PDFExporter extends com.vzome.core.exporters2d.SnapshotExporter {
                    constructor() {
                        super();
                        if (this.streamStart === undefined) {
                            this.streamStart = 0;
                        }
                    }
                    /**
                     *
                     * @param {number} r
                     * @param {number} g
                     * @param {number} b
                     */
                    setRGBStrokeColor(r, g, b) {
                        this.output.print(" " + this.RGB_FORMAT.format(r) + " " + this.RGB_FORMAT.format(g) + " " + this.RGB_FORMAT.format(b) + " RG");
                    }
                    /**
                     *
                     * @param {number} r
                     * @param {number} g
                     * @param {number} b
                     */
                    setRGBFillColor(r, g, b) {
                        this.output.print(" " + this.RGB_FORMAT.format(r) + " " + this.RGB_FORMAT.format(g) + " " + this.RGB_FORMAT.format(b) + " rg");
                    }
                    /**
                     *
                     */
                    beginPath() {
                    }
                    /**
                     *
                     * @param {number} x
                     * @param {number} y
                     */
                    moveToPoint(x, y) {
                        this.output.print(" " + this.XY_FORMAT.format(x) + " " + this.XY_FORMAT.format(y) + " m");
                    }
                    /**
                     *
                     * @param {number} x
                     * @param {number} y
                     */
                    addLineToPoint(x, y) {
                        this.output.print(" " + this.XY_FORMAT.format(x) + " " + this.XY_FORMAT.format(y) + " l");
                    }
                    /**
                     *
                     */
                    closePath() {
                        this.output.print(" h");
                    }
                    /**
                     *
                     */
                    fillPath() {
                        this.output.print(" f");
                    }
                    /**
                     *
                     */
                    strokePath() {
                        this.output.print(" S\n");
                    }
                    /**
                     *
                     * @param {java.awt.geom.Rectangle2D} rect
                     * @param {number} strokeWidth
                     */
                    outputPrologue(rect, strokeWidth) {
                        this.includeFile("com/vzome/core/exporters/prologue.pdf");
                        this.streamStart = this.output.getBytesTotal();
                        if (strokeWidth > 0)
                            this.output.print(strokeWidth + " w 1 j\n");
                        this.RGB_FORMAT.setMaximumFractionDigits(3);
                        this.XY_FORMAT.setMaximumFractionDigits(2);
                    }
                    /**
                     *
                     * @param {java.awt.Color} bgColor
                     */
                    outputBackground(bgColor) {
                        const rgb = bgColor.getRGBColorComponents(null);
                        this.setRGBFillColor(rgb[0], rgb[1], rgb[2]);
                        this.beginPath();
                        this.output.print(" 0 0 " + this.width + " " + this.height + " re\n");
                        this.closePath();
                        this.fillPath();
                    }
                    /**
                     *
                     */
                    outputPostlogue() {
                        const streamLen = this.output.getBytesTotal() - this.streamStart;
                        this.output.print("endstream\n");
                        this.output.print("endobj\n");
                        const sizeOffset = this.output.getBytesTotal();
                        this.output.print("5 0 obj " + streamLen + " endobj\n");
                        const boxOffset = this.output.getBytesTotal();
                        this.output.print("6 0 obj [0 0 " + this.width + " " + this.height + "] endobj\n");
                        const startXref = this.output.getBytesTotal();
                        this.includeFile("com/vzome/core/exporters/postlogue.pdf");
                        let num = ('' + (sizeOffset));
                        for (let i = 0; i + num.length < 10; i++) {
                            this.output.print("0");
                        }
                        this.output.print(num + " 00000 n \n");
                        num = /* toString */ ('' + (boxOffset));
                        for (let i = 0; i + num.length < 10; i++) {
                            this.output.print("0");
                        }
                        this.output.print(num + " 00000 n \n");
                        this.output.print("trailer\n");
                        this.output.print("<< /Size 7 /Root 1 0 R >>\n");
                        this.output.print("startxref\n");
                        this.output.print(startXref + "\n");
                        this.output.print("%%EOF\n");
                    }
                }
                exporters2d.PDFExporter = PDFExporter;
                PDFExporter["__class"] = "com.vzome.core.exporters2d.PDFExporter";
            })(exporters2d = core.exporters2d || (core.exporters2d = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters2d;
            (function (exporters2d) {
                class PostScriptExporter extends com.vzome.core.exporters2d.SnapshotExporter {
                    /**
                     *
                     */
                    setBlackStrokeColor() {
                        this.output.print(" 0 setgray");
                    }
                    /**
                     *
                     * @param {number} r
                     * @param {number} g
                     * @param {number} b
                     */
                    setRGBStrokeColor(r, g, b) {
                        this.output.print(" " + this.RGB_FORMAT.format(r) + " " + this.RGB_FORMAT.format(g) + " " + this.RGB_FORMAT.format(b) + " setrgbcolor");
                    }
                    /**
                     *
                     * @param {number} r
                     * @param {number} g
                     * @param {number} b
                     */
                    setRGBFillColor(r, g, b) {
                        this.output.print(" " + this.RGB_FORMAT.format(r) + " " + this.RGB_FORMAT.format(g) + " " + this.RGB_FORMAT.format(b) + " setrgbcolor");
                    }
                    /**
                     *
                     */
                    beginPath() {
                        this.output.print(" newpath");
                    }
                    /**
                     *
                     * @param {number} x
                     * @param {number} y
                     */
                    moveToPoint(x, y) {
                        this.output.print(" " + this.XY_FORMAT.format(x) + " " + this.XY_FORMAT.format(y) + " moveto");
                    }
                    /**
                     *
                     * @param {number} x
                     * @param {number} y
                     */
                    addLineToPoint(x, y) {
                        this.output.print(" " + this.XY_FORMAT.format(x) + " " + this.XY_FORMAT.format(y) + " lineto");
                    }
                    /**
                     *
                     */
                    closePath() {
                        this.output.print(" closepath");
                    }
                    /**
                     *
                     */
                    fillPath() {
                        this.output.print(" fill");
                    }
                    /**
                     *
                     */
                    strokePath() {
                        this.output.print(" stroke\n");
                    }
                    /**
                     *
                     * @param {java.awt.geom.Rectangle2D} rect
                     * @param {number} strokeWidth
                     */
                    outputPrologue(rect, strokeWidth) {
                        if (strokeWidth > 0)
                            this.output.print(strokeWidth + " setlinewidth 1 setlinejoin\n");
                        this.RGB_FORMAT.setMaximumFractionDigits(3);
                        this.XY_FORMAT.setMaximumFractionDigits(3);
                    }
                    /**
                     *
                     * @param {java.awt.Color} bgColor
                     */
                    outputBackground(bgColor) {
                        const rgb = bgColor.getRGBColorComponents(null);
                        this.setRGBFillColor(rgb[0], rgb[1], rgb[2]);
                        this.beginPath();
                        this.moveToPoint(0.0, 0.0);
                        this.addLineToPoint(0.0, this.height);
                        this.addLineToPoint(this.width, this.height);
                        this.addLineToPoint(this.width, 0.0);
                        this.addLineToPoint(0.0, 0.0);
                        this.closePath();
                        this.fillPath();
                    }
                    /**
                     *
                     */
                    outputPostlogue() {
                    }
                }
                exporters2d.PostScriptExporter = PostScriptExporter;
                PostScriptExporter["__class"] = "com.vzome.core.exporters2d.PostScriptExporter";
            })(exporters2d = core.exporters2d || (core.exporters2d = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class PlyExporter extends com.vzome.core.exporters.GeometryExporter {
                    constructor() {
                        super();
                        if (this.vertexData === undefined) {
                            this.vertexData = null;
                        }
                        if (this.vertices === undefined) {
                            this.vertices = null;
                        }
                    }
                    static __static_initialize() { if (!PlyExporter.__static_initialized) {
                        PlyExporter.__static_initialized = true;
                        PlyExporter.__static_initializer_0();
                    } }
                    static FORMAT_$LI$() { PlyExporter.__static_initialize(); if (PlyExporter.FORMAT == null) {
                        PlyExporter.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
                    } return PlyExporter.FORMAT; }
                    static __static_initializer_0() {
                        if (PlyExporter.FORMAT_$LI$() != null && PlyExporter.FORMAT_$LI$() instanceof java.text.DecimalFormat) {
                            PlyExporter.FORMAT_$LI$().applyPattern("0.000000E00");
                        }
                    }
                    /**
                     *
                     * @param {java.io.File} directory
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(directory, writer, height, width) {
                        let numPanels = 0;
                        const panels = new java.lang.StringBuffer();
                        this.vertexData = (new java.util.LinkedHashMap());
                        this.vertices = new java.lang.StringBuffer();
                        const output = new java.io.PrintWriter(writer);
                        output.println$java_lang_Object("ply");
                        output.println$java_lang_Object("format ascii 1.0");
                        output.println$java_lang_Object("comment   Exported by vZome, http://vzome.com");
                        output.println$java_lang_Object("comment     All vertex data is in inches");
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    ++numPanels;
                                    const vs = (new java.util.ArrayList());
                                    for (let index = man.iterator(); index.hasNext();) {
                                        let vertex = index.next();
                                        {
                                            vs.add(this.getVertexIndex(vertex));
                                        }
                                    }
                                    panels.append(vs.size());
                                    for (let index = vs.iterator(); index.hasNext();) {
                                        let v = index.next();
                                        {
                                            panels.append(" ");
                                            panels.append(v);
                                        }
                                    }
                                    panels.append("\n");
                                }
                            }
                        }
                        output.println$java_lang_Object("element vertex " + this.vertexData.size());
                        output.println$java_lang_Object("property float x");
                        output.println$java_lang_Object("property float y");
                        output.println$java_lang_Object("property float z");
                        output.println$java_lang_Object("element face " + numPanels);
                        output.println$java_lang_Object("property list uchar int vertex_indices");
                        output.println$java_lang_Object("end_header");
                        output.print(this.vertices);
                        output.print(panels);
                        output.flush();
                    }
                    getVertexIndex(vertexVector) {
                        let obj = this.vertexData.get(vertexVector);
                        if (obj == null) {
                            const key = vertexVector;
                            const index = this.vertexData.size();
                            obj = index;
                            this.vertexData.put(key, obj);
                            this.vertices.append(this.mModel.renderVector(vertexVector).spacedString() + "\n");
                        }
                        return obj;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "ply";
                    }
                }
                PlyExporter.__static_initialized = false;
                exporters.PlyExporter = PlyExporter;
                PlyExporter["__class"] = "com.vzome.core.exporters.PlyExporter";
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var fields;
        (function (fields) {
            var sqrtphi;
            (function (sqrtphi) {
                /**
                 * Everything here is stateless, or at worst, a cache (like Shapes).
                 * An instance of this can be shared by many DocumentModels.
                 * This is why it does not have tool factories, though it does
                 * dictate what tool factories will be present.
                 *
                 * @author vorth
                 * @param {*} field
                 * @class
                 * @extends com.vzome.core.kinds.DefaultFieldApplication
                 */
                class SqrtPhiFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
                    constructor(field) {
                        super(field);
                        this.icosahedralPerspective = new SqrtPhiFieldApplication.SqrtPhiFieldApplication$0(this, new com.vzome.core.math.symmetry.IcosahedralSymmetry(this.getField()));
                        this.pentagonalPerspective = new SqrtPhiFieldApplication.SqrtPhiFieldApplication$1(this, new com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry(this.getField(), null));
                        this.H4 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
                        this.h4Builder = null;
                        const octahedralPerspective = super.getDefaultSymmetryPerspective();
                        const symm = octahedralPerspective.getSymmetry();
                        const scale = field['createPower$int'](6);
                        symm.getDirection("blue").setUnitLength(scale);
                        symm.getDirection("green").setUnitLength(scale);
                        symm.getDirection("yellow").setUnitLength(scale);
                        let x = field['createAlgebraicNumber$int_A']([0, -1, 0, 0]);
                        let y = field['createAlgebraicNumber$int_A']([-1, 0, 0, 0]);
                        let z = field.zero();
                        const unitLength = field['createPower$int'](4);
                        let norm = new com.vzome.core.algebra.AlgebraicVector(x, y, z);
                        symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("slate", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, norm, true, false, unitLength);
                        x = field['createAlgebraicNumber$int_A']([0, 1, 0, -1]);
                        y = field.one();
                        z = field.one();
                        norm = new com.vzome.core.algebra.AlgebraicVector(x, y, z);
                        symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("mauve", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, norm, true, false, unitLength);
                        x = field['createAlgebraicNumber$int_A']([1, 0, -1, 0]);
                        y = field['createAlgebraicNumber$int_A']([0, -1, 0, 0]);
                        z = field['createAlgebraicNumber$int_A']([0, -1, 0, 1]);
                        norm = new com.vzome.core.algebra.AlgebraicVector(x, y, z);
                        symm.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("ivory", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, norm, true, false, unitLength);
                        const defaultShapes = new com.vzome.core.viewing.OctahedralShapes("octahedral", "octahedra", symm);
                        octahedralPerspective.setDefaultGeometry(defaultShapes);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return "\u221a\u03c6";
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetryPerspectives() {
                        return java.util.Arrays.asList(this.pentagonalPerspective, super.getDefaultSymmetryPerspective(), this.icosahedralPerspective);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getDefaultSymmetryPerspective() {
                        return this.pentagonalPerspective;
                    }
                    /**
                     *
                     * @param {string} symmName
                     * @return {*}
                     */
                    getSymmetryPerspective(symmName) {
                        switch ((symmName)) {
                            case "pentagonal":
                                return this.pentagonalPerspective;
                            case "icosahedral":
                                return this.icosahedralPerspective;
                            default:
                                return super.getSymmetryPerspective(symmName);
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {com.vzome.core.math.symmetry.QuaternionicSymmetry}
                     */
                    getQuaternionSymmetry(name) {
                        switch ((name)) {
                            case "H_4":
                                return this.H4;
                            default:
                                return null;
                        }
                    }
                    /**
                     *
                     * @param {string} groupName
                     * @param {number} index
                     * @param {number} edgesToRender
                     * @param {com.vzome.core.algebra.AlgebraicNumber[]} edgeScales
                     * @param {*} listener
                     */
                    constructPolytope(groupName, index, edgesToRender, edgeScales, listener) {
                        switch ((groupName)) {
                            case "H4":
                                if (this.h4Builder == null) {
                                    const qsymm = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
                                    this.h4Builder = new com.vzome.core.commands.CommandUniformH4Polytope(this.getField(), qsymm, 0);
                                }
                                this.h4Builder.generate(index, edgesToRender, edgeScales, listener);
                                break;
                            default:
                                super.constructPolytope(groupName, index, edgesToRender, edgeScales, listener);
                                break;
                        }
                    }
                }
                sqrtphi.SqrtPhiFieldApplication = SqrtPhiFieldApplication;
                SqrtPhiFieldApplication["__class"] = "com.vzome.fields.sqrtphi.SqrtPhiFieldApplication";
                SqrtPhiFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D", "com.vzome.core.editor.FieldApplication"];
                (function (SqrtPhiFieldApplication) {
                    class SqrtPhiFieldApplication$0 extends com.vzome.core.kinds.IcosahedralSymmetryPerspective {
                        constructor(__parent, __arg0) {
                            super(__arg0);
                            this.__parent = __parent;
                            (() => {
                                const icosaSymm = this.getSymmetry();
                                const tinyIcosaShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "sqrtPhi/tinyIcosahedra", "tiny icosahedra", null, icosaSymm);
                                const icosahedralShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "sqrtPhi/zome", "solid Zome", icosaSymm, tinyIcosaShapes);
                                this.clearShapes();
                                this.addShapes(icosahedralShapes);
                                this.setDefaultGeometry(tinyIcosaShapes);
                            })();
                        }
                    }
                    SqrtPhiFieldApplication.SqrtPhiFieldApplication$0 = SqrtPhiFieldApplication$0;
                    SqrtPhiFieldApplication$0["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];
                    class SqrtPhiFieldApplication$1 extends com.vzome.core.kinds.AbstractSymmetryPerspective {
                        constructor(__parent, __arg0) {
                            super(__arg0);
                            this.__parent = __parent;
                            (() => {
                                const pentaSymm = this.getSymmetry();
                                pentaSymm.createStandardOrbits("blue");
                                const octahedralShapes = new com.vzome.core.viewing.OctahedralShapes("octahedral", "octahedra", pentaSymm);
                                const kostickShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "sqrtPhi/fivefold", "Kostick", pentaSymm, octahedralShapes);
                                this.setDefaultGeometry(kostickShapes);
                                this.addShapes(octahedralShapes);
                                this.axialsymm = new com.vzome.core.commands.CommandAxialSymmetry(pentaSymm);
                            })();
                            if (this.axialsymm === undefined) {
                                this.axialsymm = null;
                            }
                        }
                        /**
                         *
                         * @return {com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry}
                         */
                        getSymmetry() {
                            return super.getSymmetry();
                        }
                        /**
                         *
                         * @param {com.vzome.api.Tool.Kind} kind
                         * @param {com.vzome.core.editor.ToolsModel} tools
                         * @return {*}
                         */
                        createToolFactories(kind, tools) {
                            const result = (new java.util.ArrayList());
                            const pentaSymm = this.getSymmetry();
                            switch ((kind)) {
                                case com.vzome.api.Tool.Kind.SYMMETRY:
                                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, pentaSymm));
                                    result.add(new com.vzome.core.tools.InversionToolFactory(tools));
                                    result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, pentaSymm));
                                    break;
                                case com.vzome.api.Tool.Kind.TRANSFORM:
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, pentaSymm));
                                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, pentaSymm));
                                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                                    result.add(new com.vzome.core.tools.ProjectionToolFactory(tools));
                                    break;
                                case com.vzome.api.Tool.Kind.LINEAR_MAP:
                                    result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, pentaSymm, false));
                                    break;
                                default:
                                    break;
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {com.vzome.api.Tool.Kind} kind
                         * @param {com.vzome.core.editor.ToolsModel} tools
                         * @return {*}
                         */
                        predefineTools(kind, tools) {
                            const result = (new java.util.ArrayList());
                            const pentaSymm = this.getSymmetry();
                            switch ((kind)) {
                                case com.vzome.api.Tool.Kind.SYMMETRY:
                                    result.add(new com.vzome.core.tools.SymmetryToolFactory(tools, pentaSymm).createPredefinedTool("pentagonal antiprism around origin"));
                                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, pentaSymm).createPredefinedTool("fivefold symmetry through origin"));
                                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through red plane"));
                                    break;
                                case com.vzome.api.Tool.Kind.TRANSFORM:
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, pentaSymm).createPredefinedTool("scale down"));
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, pentaSymm).createPredefinedTool("scale up"));
                                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, pentaSymm, true).createPredefinedTool("fivefold rotation through origin"));
                                    break;
                                default:
                                    break;
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {string} action
                         * @return {*}
                         */
                        getLegacyCommand(action) {
                            switch ((action)) {
                                case "axialsymm":
                                    return this.axialsymm;
                                default:
                                    return super.getLegacyCommand(action);
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getModelResourcePath() {
                            return "org/vorthmann/zome/app/pentagonal.vZome";
                        }
                    }
                    SqrtPhiFieldApplication.SqrtPhiFieldApplication$1 = SqrtPhiFieldApplication$1;
                    SqrtPhiFieldApplication$1["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];
                })(SqrtPhiFieldApplication = sqrtphi.SqrtPhiFieldApplication || (sqrtphi.SqrtPhiFieldApplication = {}));
            })(sqrtphi = fields.sqrtphi || (fields.sqrtphi = {}));
        })(fields = vzome.fields || (vzome.fields = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                /**
                 * An exporter that produces a parametric OpenSCAD file,
                 * to support generation of STL files for struts of arbitrary length.
                 * This is based on Aaron Siegel's "zome-strut.scad" library.
                 *
                 * @author vorth
                 * @class
                 * @extends com.vzome.core.exporters.DocumentExporter
                 */
                class OpenScadExporter extends com.vzome.core.exporters.DocumentExporter {
                    /**
                     *
                     * @param {*} doc
                     * @param {java.io.File} file
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    exportDocument(doc, file, writer, height, width) {
                        const toolsModel = doc.getToolsModel();
                        this.mModel = doc.getRenderedModel();
                        const field = this.mModel.getField();
                        const tipBookmark = toolsModel.values().stream().filter((tool) => "tip vertex" === tool.getLabel()).findAny();
                        if (!tipBookmark.isPresent())
                            throw new com.vzome.core.commands.Command.Failure("You must have a bookmark named \"tip vertex\" for the strut endpoint.");
                        const tipItems = tipBookmark.get().getParameters();
                        const tipPoint = tipItems.get(0);
                        if (tipItems.size() > 1 || !(tipPoint != null && tipPoint instanceof com.vzome.core.construction.Point))
                            throw new com.vzome.core.commands.Command.Failure("The \"tip vertex\" bookmark must select a single ball.");
                        const tipVertex = tipPoint.getLocation();
                        const floatingBookmark = toolsModel.values().stream().filter((tool) => "floating panels" === tool.getLabel()).findAny();
                        let floatingVerticesSet = (new java.util.TreeSet());
                        if (!floatingBookmark.isPresent())
                            throw new com.vzome.core.commands.Command.Failure("You must have a bookmark named \"floating panels\".");
                        for (let index = floatingBookmark.get().getParameters().iterator(); index.hasNext();) {
                            let polygon = index.next();
                            {
                                if (!(polygon != null && polygon instanceof com.vzome.core.construction.Polygon))
                                    throw new com.vzome.core.commands.Command.Failure("The \"floating panels\" bookmark must select only panels.");
                                {
                                    let array = polygon.getVertices();
                                    for (let index = 0; index < array.length; index++) {
                                        let vertex = array[index];
                                        {
                                            floatingVerticesSet.add(vertex);
                                        }
                                    }
                                }
                            }
                        }
                        let bottomFaceNormal = null;
                        const bottomFaceBookmark = toolsModel.values().stream().filter((tool) => "bottom face" === tool.getLabel()).findAny();
                        if (bottomFaceBookmark.isPresent()) {
                            const bottomFaceItems = bottomFaceBookmark.get().getParameters();
                            const bottomFacePanel = bottomFaceItems.get(0);
                            if (bottomFaceItems.size() > 1 || !(bottomFacePanel != null && bottomFacePanel instanceof com.vzome.core.construction.Polygon))
                                throw new com.vzome.core.commands.Command.Failure("The \"bottom face\" bookmark must select a single panel.");
                            bottomFaceNormal = bottomFacePanel.getNormal();
                        }
                        let fixedVerticesSet = (new java.util.TreeSet());
                        let orbitName = null;
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    const panel = man;
                                    for (let index = panel.iterator(); index.hasNext();) {
                                        let vertex = index.next();
                                        {
                                            if (!floatingVerticesSet.contains(vertex))
                                                fixedVerticesSet.add(vertex);
                                        }
                                    }
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (orbitName != null)
                                        throw new com.vzome.core.commands.Command.Failure("The model must contain a single prototype strut.");
                                    orbitName = rm.getStrutOrbit().getName();
                                }
                            }
                        }
                        if (orbitName == null)
                            throw new com.vzome.core.commands.Command.Failure("The model must contain a single prototype strut.");
                        const sortedFixedVertexList = (new java.util.ArrayList(fixedVerticesSet));
                        const sortedFloatingVertexList = (new java.util.ArrayList(floatingVerticesSet));
                        fixedVerticesSet = null;
                        floatingVerticesSet = null;
                        this.output = new java.io.PrintWriter(writer);
                        let prelude = super.getBoilerplate("com/vzome/core/exporters/zome-strut-prelude.scad");
                        prelude = /* replaceAll */ prelude.replace(new RegExp("%%ORBIT%%", 'g'), orbitName);
                        this.output.println$java_lang_Object(prelude);
                        this.output.println$java_lang_Object("  irrational = " + field.getCoefficients()[1] + ";");
                        this.output.println$();
                        this.output.println$java_lang_Object("module " + orbitName + "_strut( size, scalar=1.0, offsets=0 ) {");
                        this.output.println$();
                        if (bottomFaceNormal == null) {
                            this.output.println$java_lang_Object("  // WARNING: The vZome design contained no \"bottom face\" bookmark.");
                            this.output.println$java_lang_Object("  bottom_face_normal = [ 0, 0, -1 ];");
                        }
                        else {
                            const bottomFaceDirection = this.mModel.renderVector(bottomFaceNormal).normalize();
                            this.output.println$java_lang_Object("  bottom_face_normal = [ " + bottomFaceDirection.toString$() + " ];");
                        }
                        this.output.println$();
                        const mmScaling = this.mModel.getCmScaling() * 10.0;
                        const tipVertexString = this.mModel.renderVector(tipVertex).scale(mmScaling).toString$();
                        this.output.println$java_lang_Object("  tip_vertex = [ " + tipVertexString + " ];");
                        this.output.println$();
                        this.output.println$java_lang_Object("  fixed_vertices = [ ");
                        for (let index = sortedFixedVertexList.iterator(); index.hasNext();) {
                            let vertex = index.next();
                            {
                                this.output.print("[ ");
                                this.output.print(this.mModel.renderVector(vertex).scale(mmScaling).toString$());
                                this.output.print(" ], ");
                            }
                        }
                        this.output.println$java_lang_Object(" ];");
                        this.output.println$java_lang_Object("  floating_vertices = [ ");
                        for (let index = sortedFloatingVertexList.iterator(); index.hasNext();) {
                            let vertex = index.next();
                            {
                                this.output.print("[ ");
                                this.output.print(this.mModel.renderVector(vertex).scale(mmScaling).toString$());
                                this.output.print(" ], ");
                            }
                        }
                        this.output.println$java_lang_Object(" ];");
                        this.output.println$java_lang_Object("  faces = [ ");
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const man = rm.getManifestation();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    this.output.print("[ ");
                                    const panel = man;
                                    const stack = (new java.util.Stack());
                                    for (let index = panel.iterator(); index.hasNext();) {
                                        let vertex = index.next();
                                        {
                                            stack.push(vertex);
                                        }
                                    }
                                    while ((!stack.isEmpty())) {
                                        {
                                            const vertex = stack.pop();
                                            let index = sortedFixedVertexList.indexOf(vertex);
                                            if (index < 0) {
                                                index = sortedFixedVertexList.size() + sortedFloatingVertexList.indexOf(vertex);
                                            }
                                            this.output.print(index + ", ");
                                        }
                                    }
                                    ;
                                    this.output.print("], ");
                                }
                            }
                        }
                        this.output.println$java_lang_Object(" ];");
                        this.output.println$java_lang_Object("  zome_strut( tip_vertex, fixed_vertices, floating_vertices, faces, bottom_face_normal, size, scalar, offsets );");
                        this.output.println$java_lang_Object("}");
                        this.output.flush();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "scad";
                    }
                    /**
                     *
                     * @param {java.io.File} file
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(file, writer, height, width) {
                    }
                    constructor() {
                        super();
                    }
                }
                exporters.OpenScadExporter = OpenScadExporter;
                OpenScadExporter["__class"] = "com.vzome.core.exporters.OpenScadExporter";
                OpenScadExporter["__interfaces"] = ["com.vzome.core.exporters.DocumentExporterIntf"];
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                /**
                 * Renders out to POV-Ray using #declare statements to reuse geometry.
                 * @author vorth
                 * @class
                 * @extends com.vzome.core.exporters.DocumentExporter
                 */
                class POVRayExporter extends com.vzome.core.exporters.DocumentExporter {
                    constructor() {
                        super();
                    }
                    static FORMAT_$LI$() { if (POVRayExporter.FORMAT == null) {
                        POVRayExporter.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);
                    } return POVRayExporter.FORMAT; }
                    mapViewToWorld(view, vector) {
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    needsManifestations() {
                        return false;
                    }
                    /**
                     *
                     * @param {java.io.File} povFile
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(povFile, writer, height, width) {
                        this.output = new java.io.PrintWriter(writer);
                        const lookDir = this.mScene.getLookDirectionRV();
                        const upDir = this.mScene.getUpDirectionRV();
                        POVRayExporter.FORMAT_$LI$().setMaximumFractionDigits(8);
                        this.output.println$();
                        this.output.println$();
                        this.output.println$java_lang_Object("#declare           look_dir = " + this.printTuple3d(lookDir) + ";");
                        this.output.println$();
                        this.output.println$java_lang_Object("#declare             up_dir = " + this.printTuple3d(upDir) + ";");
                        this.output.println$();
                        this.output.println$java_lang_Object("#declare viewpoint_distance = " + this.mScene.getViewDistance() + ";");
                        this.output.println$();
                        this.output.println$java_lang_Object("#declare      look_at_point = " + this.printTuple3d(this.mScene.getLookAtPointRV()) + ";");
                        this.output.println$();
                        this.output.println$java_lang_Object("#declare      field_of_view = " + this.mScene.getFieldOfView() + ";");
                        this.output.println$();
                        this.output.println$java_lang_Object("#declare      parallel_proj = " + (this.mScene.isPerspective() ? 0 : 1) + ";");
                        this.output.println$();
                        const preamble = com.vzome.xml.ResourceLoader.loadStringResource(POVRayExporter.PREAMBLE_FILE);
                        this.output.println$java_lang_Object(preamble);
                        this.output.println$();
                        for (let i = 0; i < 3; i++) {
                            {
                                const color = this.mLights.getDirectionalLightColor(i);
                                let rv = this.mLights.getDirectionalLightVector(i);
                                rv = this.mScene.mapViewToWorld(rv);
                                this.output.print("light_source { -light_distance * " + this.printTuple3d(rv));
                                this.output.print(" ");
                                this.printColor(color);
                                this.output.println$java_lang_Object(" * multiplier_light_" + (i + 1) + " }");
                                this.output.println$();
                            }
                            ;
                        }
                        this.output.print("#declare ambient_color = ");
                        this.printColor(this.mLights.getAmbientColor());
                        this.output.println$java_lang_Object(";");
                        this.output.println$();
                        this.output.println$java_lang_Object("#default { texture { finish { phong 0.3 ambient multiplier_ambient * ambient_color diffuse 0.6 } } }");
                        this.output.println$();
                        this.output.print("background { ");
                        this.printColor(this.mLights.getBackgroundColor());
                        this.output.println$java_lang_Object(" }");
                        this.output.println$();
                        const instances = new java.lang.StringBuffer();
                        const field = this.mModel.getField();
                        const embedding = this.mModel.getEmbedding();
                        let embeddingTransform = " ";
                        if (!embedding.isTrivial()) {
                            embeddingTransform = " transform embedding ";
                            this.output.print("#declare embedding = transform { matrix < ");
                            for (let i = 0; i < 3; i++) {
                                {
                                    const columnSelect = field.basisVector(3, i);
                                    const columnI = embedding.embedInR3(columnSelect);
                                    this.output.print(columnI.x);
                                    this.output.print(", ");
                                    this.output.print(columnI.y);
                                    this.output.print(", ");
                                    this.output.print(columnI.z);
                                    this.output.print(", ");
                                }
                                ;
                            }
                            this.output.println$java_lang_Object(" 0, 0, 0 > }");
                            this.output.flush();
                        }
                        let numTransforms = 0;
                        const shapes = (new java.util.HashSet());
                        const transforms = (new java.util.HashMap());
                        const colors = (new java.util.HashMap());
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                const shapeName = "S" + /* replaceAll */ rm.getShapeId().toString().replace(new RegExp("-", 'g'), "");
                                if (!shapes.contains(shapeName)) {
                                    shapes.add(shapeName);
                                    this.exportShape(shapeName, rm.getShape());
                                }
                                const transform = rm.getOrientation();
                                let transformName = transforms.get(transform);
                                if (transformName == null) {
                                    transformName = "trans" + numTransforms++;
                                    transforms.put(transform, transformName);
                                    this.exportTransform(transformName, transform);
                                }
                                let color = rm.getColor();
                                if (color == null)
                                    color = com.vzome.core.construction.Color.WHITE_$LI$();
                                let colorName = colors.get(color);
                                if (colorName == null) {
                                    colorName = this.nameColor(color);
                                    colors.put(color, colorName);
                                    this.exportColor(colorName, color);
                                }
                                instances.append("object { " + shapeName + " transform " + transformName + " translate ");
                                instances.append("(<");
                                let loc = rm.getLocationAV();
                                if (loc == null)
                                    loc = rm.getShape().getField().origin(3);
                                this.appendVector(loc, instances);
                                instances.append(">)");
                                instances.append(embeddingTransform + "transform anim texture { " + colorName + " } }");
                                instances.append(java.lang.System.getProperty("line.separator"));
                            }
                        }
                        this.output.println$java_lang_Object(instances.toString());
                        this.output.flush();
                        if (povFile == null)
                            return;
                        let filename = povFile.getName();
                        const index = filename.lastIndexOf(".pov");
                        if (index > 0) {
                            filename = filename.substring(0, index);
                        }
                        const file = new java.io.File(povFile.getParentFile(), filename + ".ini");
                        this.output = new java.io.PrintWriter(new java.io.FileWriter(file));
                        this.output.println$java_lang_Object("+W" + 600);
                        this.output.println$java_lang_Object("+H" + 600);
                        this.output.println$java_lang_Object("+A");
                        this.output.println$java_lang_Object("Input_File_Name=" + filename + ".pov");
                        this.output.println$java_lang_Object("Output_File_Name=" + filename + ".png");
                        this.output.close();
                    }
                    nameColor(color) {
                        return "color_" + /* replace */ color.toString().split(',').join('_');
                    }
                    /*private*/ printTuple3d(t) {
                        const buf = new java.lang.StringBuilder("<");
                        buf.append(POVRayExporter.FORMAT_$LI$().format(t.x));
                        buf.append(",");
                        buf.append(POVRayExporter.FORMAT_$LI$().format(t.y));
                        buf.append(",");
                        buf.append(POVRayExporter.FORMAT_$LI$().format(t.z));
                        buf.append(">");
                        return buf.toString();
                    }
                    exportColor(name, color) {
                        this.output.print("#declare " + /* replace */ name.split('.').join('_') + " = texture { pigment { ");
                        this.printColor(color);
                        this.output.println$java_lang_Object(" } };");
                    }
                    /*private*/ printColor(color) {
                        const doAlpha = color.getAlpha() < 255;
                        if (doAlpha)
                            this.output.print("color rgbf <");
                        else
                            this.output.print("color rgb <");
                        const rgb = color.getRGBColorComponents([0, 0, 0, 0]);
                        this.output.print(POVRayExporter.FORMAT_$LI$().format(rgb[0]) + ",");
                        this.output.print(POVRayExporter.FORMAT_$LI$().format(rgb[1]) + ",");
                        if (doAlpha) {
                            this.output.print(POVRayExporter.FORMAT_$LI$().format(rgb[2]) + ",");
                            this.output.print(POVRayExporter.FORMAT_$LI$().format(rgb[3]));
                        }
                        else {
                            this.output.print(POVRayExporter.FORMAT_$LI$().format(rgb[2]));
                        }
                        this.output.print(">");
                    }
                    appendVector(loc, buf) {
                        const vector = loc.toRealVector();
                        buf.append(POVRayExporter.FORMAT_$LI$().format(vector.x));
                        buf.append(", ");
                        buf.append(POVRayExporter.FORMAT_$LI$().format(vector.y));
                        buf.append(", ");
                        buf.append(POVRayExporter.FORMAT_$LI$().format(vector.z));
                    }
                    /*private*/ exportShape(shapeName, poly) {
                        this.output.print("#declare " + shapeName + " = ");
                        const vertices = poly.getVertexList();
                        this.output.println$java_lang_Object("mesh {");
                        poly.getTriangleFaces();
                        for (let index = poly.getTriangleFaces().iterator(); index.hasNext();) {
                            let face = index.next();
                            {
                                this.output.print("triangle {");
                                for (let loopIndex = 0; loopIndex < face.vertices.length; loopIndex++) {
                                    let index = face.vertices[loopIndex];
                                    {
                                        const loc = vertices.get(index);
                                        const buf = new java.lang.StringBuffer();
                                        buf.append("<");
                                        this.appendVector(loc, buf);
                                        buf.append(">");
                                        this.output.print(buf.toString());
                                    }
                                }
                                this.output.println$java_lang_Object("}");
                            }
                        }
                        this.output.println$java_lang_Object("}");
                        this.output.flush();
                    }
                    /*private*/ exportTransform(name, transform) {
                        const field = this.mModel.getField();
                        this.output.print("#declare " + name + " = transform { matrix < ");
                        const buf = new java.lang.StringBuffer();
                        for (let i = 0; i < 3; i++) {
                            {
                                const columnSelect = field.basisVector(3, i);
                                const columnI = transform.timesColumn(columnSelect);
                                this.appendVector(columnI, buf);
                                buf.append(", ");
                            }
                            ;
                        }
                        this.output.print(buf);
                        this.output.println$java_lang_Object(" 0, 0, 0 > }");
                        this.output.flush();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getFileExtension() {
                        return "pov";
                    }
                }
                POVRayExporter.PREAMBLE_FILE = "com/vzome/core/exporters/povray/preamble.pov";
                exporters.POVRayExporter = POVRayExporter;
                POVRayExporter["__class"] = "com.vzome.core.exporters.POVRayExporter";
                POVRayExporter["__interfaces"] = ["com.vzome.core.exporters.DocumentExporterIntf"];
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var exporters;
            (function (exporters) {
                class PartGeometryExporter extends com.vzome.core.exporters.VefExporter {
                    constructor() {
                        super();
                        if (this.selection === undefined) {
                            this.selection = null;
                        }
                    }
                    exportDocument(doc, file, writer, height, width) {
                        this.mModel = doc.getRenderedModel();
                        this.selection = doc.getEditorModel().getSelection();
                        this.doExport(file, writer, height, width);
                        this.selection = null;
                        this.mModel = null;
                    }
                    /**
                     *
                     * @param {java.io.File} directory
                     * @param {java.io.Writer} writer
                     * @param {number} height
                     * @param {number} width
                     */
                    doExport(directory, writer, height, width) {
                        const field = this.mModel.getField();
                        const exporter = new com.vzome.core.model.VefModelExporter(writer, field);
                        for (let index = this.mModel.iterator(); index.hasNext();) {
                            let rm = index.next();
                            {
                                exporter.exportManifestation(rm.getManifestation());
                            }
                        }
                        exporter.finish();
                        this.exportSelection(exporter);
                    }
                    /*private*/ exportSelection(exporter) {
                        let tip = null;
                        const arrayComparator = (new com.vzome.core.generic.ArrayComparator());
                        const panelVertices = (new java.util.TreeSet((((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                            return funcInst;
                        } return (arg0, arg1) => (funcInst['compare'] ? funcInst['compare'] : funcInst).call(funcInst, arg0, arg1); })(arrayComparator.getLengthFirstArrayComparator()))));
                        const vertexArrayPanelMap = (new java.util.HashMap());
                        for (let index = this.selection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (tip == null) {
                                        tip = man;
                                    }
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    const panel = man;
                                    const corners = (new java.util.ArrayList(panel.getVertexCount()));
                                    for (let index = panel.iterator(); index.hasNext();) {
                                        let vertex = index.next();
                                        {
                                            corners.add(vertex);
                                        }
                                    }
                                    const cornerArray = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(corners.size());
                                    corners.toArray(cornerArray);
                                    panelVertices.add(cornerArray);
                                    vertexArrayPanelMap.put(cornerArray, panel);
                                }
                            }
                        }
                        if (tip != null) {
                            exporter.exportSelectedManifestation(null);
                            exporter.exportSelectedManifestation(tip);
                            if (!panelVertices.isEmpty()) {
                                exporter.exportSelectedManifestation(null);
                                for (let index = panelVertices.iterator(); index.hasNext();) {
                                    let vertexArray = index.next();
                                    {
                                        const panel = vertexArrayPanelMap.get(vertexArray);
                                        exporter.exportSelectedManifestation(panel);
                                    }
                                }
                            }
                            exporter.exportSelectedManifestation(null);
                        }
                    }
                }
                exporters.PartGeometryExporter = PartGeometryExporter;
                PartGeometryExporter["__class"] = "com.vzome.core.exporters.PartGeometryExporter";
                PartGeometryExporter["__interfaces"] = ["com.vzome.core.exporters.DocumentExporterIntf"];
            })(exporters = core.exporters || (core.exporters = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    class Reflect extends com.vzome.core.zomic.program.Permute {
                        /**
                         *
                         * @param {*} visitor
                         */
                        accept(visitor) {
                            visitor.visitReflect(this.getAxis());
                        }
                        constructor() {
                            super(null);
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.Axis} axis
                         */
                        setAxis(axis) {
                            super.setAxis(axis);
                        }
                    }
                    program.Reflect = Reflect;
                    Reflect["__class"] = "com.vzome.core.zomic.program.Reflect";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    class Rotate extends com.vzome.core.zomic.program.Permute {
                        constructor(axis, steps) {
                            super(axis);
                            if (this.steps === undefined) {
                                this.steps = 0;
                            }
                            this.steps = steps;
                        }
                        /**
                         *
                         * @param {*} visitor
                         */
                        accept(visitor) {
                            visitor.visitRotate(this.getAxis(), this.steps);
                        }
                        setSteps(steps) {
                            this.steps = steps;
                        }
                    }
                    program.Rotate = Rotate;
                    Rotate["__class"] = "com.vzome.core.zomic.program.Rotate";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    class Repeat extends com.vzome.core.zomic.program.Nested {
                        constructor(repetitions) {
                            super();
                            if (this.repetitions === undefined) {
                                this.repetitions = 0;
                            }
                            this.repetitions = repetitions;
                        }
                        /**
                         *
                         * @param {*} visitor
                         */
                        accept(visitor) {
                            visitor.visitRepeat(this, this.repetitions);
                        }
                    }
                    program.Repeat = Repeat;
                    Repeat["__class"] = "com.vzome.core.zomic.program.Repeat";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    /**
                     * Description here.
                     *
                     * @author Scott Vorthmann 2003
                     * @param {number} state
                     * @class
                     * @extends com.vzome.core.zomic.program.Nested
                     */
                    class Save extends com.vzome.core.zomic.program.Nested {
                        constructor(state) {
                            super();
                            if (this.m_state === undefined) {
                                this.m_state = 0;
                            }
                            this.m_state = state;
                        }
                        /**
                         *
                         * @param {*} visitor
                         */
                        accept(visitor) {
                            visitor.visitSave(this, this.m_state);
                        }
                        setState(state) {
                            this.m_state = state;
                        }
                    }
                    program.Save = Save;
                    Save["__class"] = "com.vzome.core.zomic.program.Save";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                var program;
                (function (program) {
                    class Symmetry extends com.vzome.core.zomic.program.Nested {
                        constructor() {
                            super();
                            if (this.permute === undefined) {
                                this.permute = null;
                            }
                        }
                        /**
                         *
                         * @param {*} visitor
                         */
                        accept(visitor) {
                            visitor.visitSymmetry(this, this.permute);
                        }
                        setPermute(permute) {
                            this.permute = permute;
                        }
                        getPermute() {
                            return this.permute;
                        }
                    }
                    program.Symmetry = Symmetry;
                    Symmetry["__class"] = "com.vzome.core.zomic.program.Symmetry";
                })(program = zomic.program || (zomic.program = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var zomic;
            (function (zomic) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.math.symmetry.IcosahedralSymmetry} symm
                 * @class
                 * @extends com.vzome.core.math.symmetry.NamingConvention
                 */
                class ZomicNamingConvention extends com.vzome.core.math.symmetry.NamingConvention {
                    constructor(symm) {
                        super();
                        let dir = symm.getDirection("red");
                        const redNames = new com.vzome.core.zomic.ZomodDirectionNaming(dir, [0, 1, 2, 15, 17, 46]);
                        this.addDirectionNaming(redNames);
                        dir = symm.getDirection("yellow");
                        const yellowNames = new com.vzome.core.zomic.ZomodDirectionNaming(dir, [6, 9, 12, 0, 3, 1, 14, 5, 24, 17]);
                        this.addDirectionNaming(yellowNames);
                        dir = symm.getDirection("blue");
                        this.addDirectionNaming(new com.vzome.core.zomic.ZomodDirectionNaming(dir, [9, 12, 0, 3, 6, 1, 14, 18, 26, 52, 58, 4, 7, 2, 5]));
                        dir = symm.getDirection("olive");
                        this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
                        dir = symm.getDirection("maroon");
                        this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
                        dir = symm.getDirection("lavender");
                        this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
                        dir = symm.getDirection("rose");
                        this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
                        dir = symm.getDirection("navy");
                        this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
                        dir = symm.getDirection("turquoise");
                        this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
                        dir = symm.getDirection("coral");
                        this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
                        dir = symm.getDirection("sulfur");
                        this.addDirectionNaming(new com.vzome.core.math.symmetry.DirectionNaming(dir, dir.getName()));
                        dir = symm.getDirection("green");
                        this.addDirectionNaming(new com.vzome.core.zomic.GreenDirectionNaming(dir, redNames, yellowNames));
                        dir = symm.getDirection("orange");
                        this.addDirectionNaming(new com.vzome.core.zomic.GreenDirectionNaming(dir, redNames, yellowNames));
                        dir = symm.getDirection("purple");
                        this.addDirectionNaming(new ZomicNamingConvention.ZomicNamingConvention$0(this, dir, redNames, yellowNames));
                        dir = symm.getDirection("black");
                        this.addDirectionNaming(new com.vzome.core.zomic.BlackDirectionNaming(dir, redNames, yellowNames));
                    }
                }
                ZomicNamingConvention.SHORT = 3;
                ZomicNamingConvention.MEDIUM = 4;
                ZomicNamingConvention.LONG = 5;
                zomic.ZomicNamingConvention = ZomicNamingConvention;
                ZomicNamingConvention["__class"] = "com.vzome.core.zomic.ZomicNamingConvention";
                (function (ZomicNamingConvention) {
                    class ZomicNamingConvention$0 extends com.vzome.core.zomic.GreenDirectionNaming {
                        constructor(__parent, __arg0, __arg1, __arg2) {
                            super(__arg0, __arg1, __arg2);
                            this.__parent = __parent;
                        }
                        getName$com_vzome_core_math_symmetry_Axis(axis) {
                            let orn = axis.getOrientation();
                            const redNeighbor = this.mRedNames.getDirection().getAxis$int$int(axis.getSense(), orn);
                            const redName = this.mRedNames.getName$com_vzome_core_math_symmetry_Axis(redNeighbor);
                            const rot = redNeighbor.getRotationPermutation();
                            orn = rot.mapIndex(rot.mapIndex(orn));
                            if (axis.getSense() === com.vzome.core.math.symmetry.Symmetry.MINUS)
                                orn = rot.mapIndex(orn);
                            const yellowNeighbor = this.mYellowNames.getDirection().getAxis$int$int(axis.getSense(), orn);
                            const yellowName = this.mYellowNames.getName$com_vzome_core_math_symmetry_Axis(yellowNeighbor).substring(1);
                            return redName + yellowName;
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.Axis} axis
                         * @return {string}
                         */
                        getName(axis) {
                            if (((axis != null && axis instanceof com.vzome.core.math.symmetry.Axis) || axis === null)) {
                                return this.getName$com_vzome_core_math_symmetry_Axis(axis);
                            }
                            else if (axis === undefined) {
                                return this.getName$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                    }
                    ZomicNamingConvention.ZomicNamingConvention$0 = ZomicNamingConvention$0;
                })(ZomicNamingConvention = zomic.ZomicNamingConvention || (zomic.ZomicNamingConvention = {}));
            })(zomic = core.zomic || (core.zomic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                /**
                 * Everything here is stateless, or at worst, a cache (like Shapes).
                 * An instance of this can be shared by many DocumentModels.
                 * This is why it does not have tool factories, though it does
                 * dictate what tool factories will be present.
                 *
                 * @author vorth
                 * @param {*} field
                 * @class
                 * @extends com.vzome.core.kinds.DefaultFieldApplication
                 */
                class SnubDodecFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
                    constructor(field) {
                        super(field);
                        if (this.icosahedralPerspective === undefined) {
                            this.icosahedralPerspective = null;
                        }
                        this.h4Builder = null;
                        this.cmdTauDivide = new com.vzome.core.commands.CommandTauDivision();
                        const icosaSymm = new SnubDodecFieldApplication.SnubDodecFieldApplication$0(this, field);
                        this.icosahedralPerspective = new com.vzome.core.kinds.IcosahedralSymmetryPerspective(icosaSymm);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return this.getField().getName();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return "Snub Dodecahedron";
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetryPerspectives() {
                        return java.util.Arrays.asList(this.icosahedralPerspective, super.getDefaultSymmetryPerspective());
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getDefaultSymmetryPerspective() {
                        return this.icosahedralPerspective;
                    }
                    /**
                     *
                     * @param {string} symmName
                     * @return {*}
                     */
                    getSymmetryPerspective(symmName) {
                        switch ((symmName)) {
                            case "icosahedral":
                                return this.icosahedralPerspective;
                            default:
                                return super.getSymmetryPerspective(symmName);
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {com.vzome.core.math.symmetry.QuaternionicSymmetry}
                     */
                    getQuaternionSymmetry(name) {
                        return this.icosahedralPerspective.getQuaternionSymmetry(name);
                    }
                    /**
                     *
                     * @param {*} toolFactories
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     */
                    registerToolFactories(toolFactories, tools) {
                        super.registerToolFactories(toolFactories, tools);
                        const symm = this.icosahedralPerspective.getSymmetry();
                        toolFactories.put("AxialStretchTool", new com.vzome.core.tools.AxialStretchTool.Factory(tools, symm, false, false, false));
                        toolFactories.put("SymmetryTool", new com.vzome.core.tools.IcosahedralToolFactory(tools, symm));
                    }
                    /**
                     *
                     * @param {string} groupName
                     * @param {number} index
                     * @param {number} edgesToRender
                     * @param {com.vzome.core.algebra.AlgebraicNumber[]} edgeScales
                     * @param {*} listener
                     */
                    constructPolytope(groupName, index, edgesToRender, edgeScales, listener) {
                        switch ((groupName)) {
                            case "H4":
                                if (this.h4Builder == null) {
                                    const qsymm = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
                                    this.h4Builder = new com.vzome.core.commands.CommandUniformH4Polytope(this.getField(), qsymm, 0);
                                }
                                this.h4Builder.generate(index, edgesToRender, edgeScales, listener);
                                break;
                            default:
                                super.constructPolytope(groupName, index, edgesToRender, edgeScales, listener);
                                break;
                        }
                    }
                    /**
                     *
                     * @param {string} action
                     * @return {*}
                     */
                    getLegacyCommand(action) {
                        switch ((action)) {
                            case "tauDivide":
                                return this.cmdTauDivide;
                            default:
                                return super.getLegacyCommand(action);
                        }
                    }
                }
                kinds.SnubDodecFieldApplication = SnubDodecFieldApplication;
                SnubDodecFieldApplication["__class"] = "com.vzome.core.kinds.SnubDodecFieldApplication";
                SnubDodecFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D", "com.vzome.core.editor.FieldApplication"];
                (function (SnubDodecFieldApplication) {
                    class SnubDodecFieldApplication$0 extends com.vzome.core.math.symmetry.IcosahedralSymmetry {
                        constructor(__parent, __arg0) {
                            super(__arg0);
                            this.__parent = __parent;
                        }
                        /**
                         *
                         */
                        createOtherOrbits() {
                            super.createOtherOrbits();
                            const vSnubPentagon = this.mField.createIntegerVector([[4, -4, 0, 0, -2, 2], [-4, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 2]]);
                            const vSnubTriangle = this.mField.createIntegerVector([[0, -4, -2, 0, 0, 2], [-4, 4, 0, -2, 2, -2], [-4, 0, -2, -2, 2, 0]]);
                            const vSnubDiagonal = this.mField.createIntegerVector([[8, 0, 0, 4, -4, 0], [0, -4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]);
                            const vSnubFaceNorm = this.mField.createIntegerVector([[-1, 0, 1, -1, 1, 0], [1, 0, 0, 0, 0, 0], [1, 0, -1, 2, 0, 1]]);
                            const vSnubVertex = this.mField.createIntegerVector([[1, 0, 0, 0, 0, 0], [1, 0, -1, 1, -1, 0], [1, 0, 0, 1, -1, 1]]);
                            const scale = this.mField['createPower$int'](-3);
                            let scaleFaceNorm;
                            let scaleVertex = this.mField.one();
                            scaleFaceNorm = this.mField['createAlgebraicNumber$int_A']([-3, 2, 2, -1, 5, -3]).reciprocal();
                            scaleVertex = this.mField['createAlgebraicNumber$int_A$int']([-3, 2, 7, -4, 2, -1], 3).reciprocal();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubPentagon", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubPentagon, false, false, scale).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubTriangle", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubTriangle, false, false, scale).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubDiagonal", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubDiagonal, false, false, scale).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubFaceNormal", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubFaceNorm, false, false, scale['times$com_vzome_core_algebra_AlgebraicNumber'](scaleFaceNorm)).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("snubVertex", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vSnubVertex, true, false, scale['times$com_vzome_core_algebra_AlgebraicNumber'](scaleVertex)).withCorrection();
                        }
                    }
                    SnubDodecFieldApplication.SnubDodecFieldApplication$0 = SnubDodecFieldApplication$0;
                    SnubDodecFieldApplication$0["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "com.vzome.core.math.symmetry.Embedding"];
                })(SnubDodecFieldApplication = kinds.SnubDodecFieldApplication || (kinds.SnubDodecFieldApplication = {}));
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                /**
                 * Everything here is stateless, or at worst, a cache (like Shapes).
                 * An instance of this can be shared by many DocumentModels.
                 * This is why it does not have tool factories, though it does
                 * dictate what tool factories will be present.
                 *
                 * @author Scott Vorthmann
                 * @param {*} field
                 * @class
                 * @extends com.vzome.core.kinds.DefaultFieldApplication
                 */
                class RootTwoFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
                    constructor(field) {
                        super(field);
                        this.synestructicsSymmetry = new RootTwoFieldApplication.RootTwoFieldApplication$0(this, this.getField(), "orange");
                        this.synestructicsPerspective = new RootTwoFieldApplication.RootTwoFieldApplication$1(this, this.synestructicsSymmetry);
                        const octahedralPerspective = super.getDefaultSymmetryPerspective();
                        const symmetry = octahedralPerspective.getSymmetry();
                        symmetry.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("yellow", 0, 4, [[1, 1, 0, 1], [1, 1, 0, 1], [1, 1, 0, 1]], true);
                        symmetry.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("green", 1, 8, [[0, 1, 1, 2], [0, 1, 1, 2], [0, 1, 0, 1]], true);
                        symmetry.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("brown", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 0, 1], [1, 1, 0, 1], [2, 1, 0, 1]], true);
                        const defaultShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "rootTwoSmall", "small octahedra", "small connectors", symmetry);
                        octahedralPerspective.setDefaultGeometry(defaultShapes);
                        octahedralPerspective.addShapes(new com.vzome.core.viewing.ExportedVEFShapes(null, "rootTwoBig", "ornate", symmetry, defaultShapes));
                        const rootTwoShapes = new com.vzome.core.viewing.SchochShapes(null, "rootTwo", "Schoch solid", symmetry, defaultShapes);
                        octahedralPerspective.addShapes(rootTwoShapes);
                        octahedralPerspective.addShapes(new com.vzome.core.viewing.SchochShapes(null, "root2Lifelike", "Schoch lifelike", symmetry, rootTwoShapes));
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return "\u221a2";
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetryPerspectives() {
                        return java.util.Arrays.asList(super.getDefaultSymmetryPerspective(), this.synestructicsPerspective);
                    }
                    /**
                     *
                     * @param {string} symmName
                     * @return {*}
                     */
                    getSymmetryPerspective(symmName) {
                        switch ((symmName)) {
                            case "synestructics":
                                return this.synestructicsPerspective;
                            default:
                                return super.getSymmetryPerspective(symmName);
                        }
                    }
                }
                kinds.RootTwoFieldApplication = RootTwoFieldApplication;
                RootTwoFieldApplication["__class"] = "com.vzome.core.kinds.RootTwoFieldApplication";
                RootTwoFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D", "com.vzome.core.editor.FieldApplication"];
                (function (RootTwoFieldApplication) {
                    class RootTwoFieldApplication$0 extends com.vzome.core.math.symmetry.OctahedralSymmetry {
                        constructor(__parent, __arg0, __arg1) {
                            super(__arg0, __arg1);
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "synestructics";
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.SpecialOrbit} which
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getSpecialOrbit(which) {
                            switch ((which)) {
                                case com.vzome.core.math.symmetry.SpecialOrbit.BLUE:
                                    return this.getDirection(this.frameColor);
                                case com.vzome.core.math.symmetry.SpecialOrbit.RED:
                                    return this.getDirection("magenta");
                                case com.vzome.core.math.symmetry.SpecialOrbit.YELLOW:
                                    return this.getDirection("yellow");
                                default:
                                    return null;
                            }
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.AlgebraicVector[]}
                         */
                        getOrbitTriangle() {
                            const magentaVertex = this.getDirection("magenta").getPrototype();
                            const orangeVertex = this.getDirection(this.frameColor).getPrototype();
                            const yellowVertex = this.getDirection("yellow").getPrototype();
                            return [magentaVertex, orangeVertex, yellowVertex];
                        }
                        /**
                         *
                         */
                        createOtherOrbits() {
                            let v = new com.vzome.core.algebra.AlgebraicVector(this.mField.one(), this.mField.one(), this.mField.one());
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("yellow", 0, 4, v, true);
                            const sqrt2 = this.mField['createPower$int'](1);
                            const half = this.mField['createRational$long$long'](1, 2);
                            v = new com.vzome.core.algebra.AlgebraicVector(sqrt2, sqrt2, this.mField.zero()).scale(half);
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("magenta", 1, 8, v, true);
                            v = new com.vzome.core.algebra.AlgebraicVector(this.mField.one(), this.mField.one(), this.mField.one()['plus$com_vzome_core_algebra_AlgebraicNumber'](this.mField.one()));
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("brown", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, v, true);
                        }
                    }
                    RootTwoFieldApplication.RootTwoFieldApplication$0 = RootTwoFieldApplication$0;
                    RootTwoFieldApplication$0["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "com.vzome.core.math.symmetry.Embedding"];
                    class RootTwoFieldApplication$1 extends com.vzome.core.kinds.AbstractSymmetryPerspective {
                        constructor(__parent, __arg0) {
                            super(__arg0);
                            this.__parent = __parent;
                            (() => {
                                const defaultShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "rootTwoSmall", "small octahedra", this.symmetry, null);
                                const synestructicsShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "rootTwo", "Synestructics", this.symmetry, defaultShapes);
                                const ornateShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "rootTwoBig", "ornate", this.symmetry, defaultShapes);
                                this.setDefaultGeometry(defaultShapes);
                                this.addShapes(synestructicsShapes);
                                this.addShapes(ornateShapes);
                            })();
                        }
                        /**
                         *
                         * @param {com.vzome.api.Tool.Kind} kind
                         * @param {com.vzome.core.editor.ToolsModel} tools
                         * @return {*}
                         */
                        createToolFactories(kind, tools) {
                            const result = (new java.util.ArrayList());
                            switch ((kind)) {
                                case com.vzome.api.Tool.Kind.SYMMETRY:
                                    result.add(new com.vzome.core.tools.OctahedralToolFactory(tools, this.symmetry));
                                    result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, this.symmetry));
                                    result.add(new com.vzome.core.tools.InversionToolFactory(tools));
                                    result.add(new com.vzome.core.tools.LineReflectionToolFactory(tools));
                                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools));
                                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry));
                                    break;
                                case com.vzome.api.Tool.Kind.TRANSFORM:
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry));
                                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry));
                                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools));
                                    result.add(new com.vzome.core.tools.ProjectionToolFactory(tools));
                                    break;
                                case com.vzome.api.Tool.Kind.LINEAR_MAP:
                                    result.add(new com.vzome.core.tools.LinearMapToolFactory(tools, this.symmetry, false));
                                    break;
                                default:
                                    break;
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {com.vzome.api.Tool.Kind} kind
                         * @param {com.vzome.core.editor.ToolsModel} tools
                         * @return {*}
                         */
                        predefineTools(kind, tools) {
                            const result = (new java.util.ArrayList());
                            switch ((kind)) {
                                case com.vzome.api.Tool.Kind.SYMMETRY:
                                    result.add(new com.vzome.core.tools.OctahedralToolFactory(tools, this.symmetry).createPredefinedTool("octahedral around origin"));
                                    result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, this.symmetry).createPredefinedTool("tetrahedral around origin"));
                                    result.add(new com.vzome.core.tools.InversionToolFactory(tools).createPredefinedTool("reflection through origin"));
                                    result.add(new com.vzome.core.tools.MirrorToolFactory(tools).createPredefinedTool("reflection through XY plane"));
                                    result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry).createPredefinedTool("symmetry around green through origin"));
                                    break;
                                case com.vzome.api.Tool.Kind.TRANSFORM:
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale down"));
                                    result.add(new com.vzome.core.tools.ScalingToolFactory(tools, this.symmetry).createPredefinedTool("scale up"));
                                    result.add(new com.vzome.core.tools.RotationToolFactory(tools, this.symmetry, true).createPredefinedTool("rotate around green through origin"));
                                    result.add(new com.vzome.core.tools.TranslationToolFactory(tools).createPredefinedTool("b1 move along +X"));
                                    break;
                                default:
                                    break;
                            }
                            return result;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getModelResourcePath() {
                            return "org/vorthmann/zome/app/octahedral-vef.vZome";
                        }
                    }
                    RootTwoFieldApplication.RootTwoFieldApplication$1 = RootTwoFieldApplication$1;
                    RootTwoFieldApplication$1["__interfaces"] = ["com.vzome.core.editor.SymmetryPerspective"];
                })(RootTwoFieldApplication = kinds.RootTwoFieldApplication || (kinds.RootTwoFieldApplication = {}));
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var viewing;
            (function (viewing) {
                class SchochShapes extends com.vzome.core.viewing.ExportedVEFShapes {
                    constructor(prefsFolder, name, alias, symmetry, defaultShapes) {
                        super(prefsFolder, name, alias, symmetry, defaultShapes);
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getCmScaling() {
                        return 1.0;
                    }
                }
                SchochShapes.serialVersionUID = 1;
                viewing.SchochShapes = SchochShapes;
                SchochShapes["__class"] = "com.vzome.core.viewing.SchochShapes";
                SchochShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];
            })(viewing = core.viewing || (core.viewing = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} projection
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandImportVEFData extends com.vzome.core.commands.AbstractCommand {
                    constructor(projection) {
                        if (((projection != null && (projection.constructor != null && projection.constructor["__interfaces"] != null && projection.constructor["__interfaces"].indexOf("com.vzome.core.math.Projection") >= 0)) || projection === null)) {
                            let __args = arguments;
                            super();
                            if (this.mProjection === undefined) {
                                this.mProjection = null;
                            }
                            this.quaternionVector = null;
                            this.mProjection = projection;
                        }
                        else if (projection === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let projection = null;
                                super();
                                if (this.mProjection === undefined) {
                                    this.mProjection = null;
                                }
                                this.quaternionVector = null;
                                this.mProjection = projection;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandImportVEFData.PARAM_SIGNATURE == null) {
                        CommandImportVEFData.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Construction]];
                    } return CommandImportVEFData.PARAM_SIGNATURE; }
                    static ATTR_SIGNATURE_$LI$() { if (CommandImportVEFData.ATTR_SIGNATURE == null) {
                        CommandImportVEFData.ATTR_SIGNATURE = [[CommandImportVEFData.VEF_STRING_ATTR_NAME, String], [com.vzome.core.commands.Command.FIELD_ATTR_NAME, java.io.InputStream], [CommandImportVEFData.NO_INVERSION_ATTR_NAME, java.io.InputStream]];
                    } return CommandImportVEFData.ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandImportVEFData.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandImportVEFData.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {string} attrName
                     * @return {boolean}
                     */
                    attributeIs3D(attrName) {
                        return !("symmetry.axis.segment" === attrName);
                    }
                    /**
                     * Only called when migrating a 2.0 model file.
                     * @param {com.vzome.core.algebra.AlgebraicVector} offset
                     */
                    setQuaternion(offset) {
                        this.quaternionVector = offset;
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @return {com.vzome.core.commands.AttributeMap}
                     */
                    setXml(xml, format) {
                        const attrs = super.setXml(xml, format);
                        this.quaternionVector = format.parseRationalVector(xml, "quaternion");
                        return attrs;
                    }
                    /**
                     *
                     * @param {*} result
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     */
                    getXml(result, attributes) {
                        if (this.quaternionVector != null)
                            com.vzome.xml.DomUtils.addAttribute(result, "quaternion", this.quaternionVector.toParsableString());
                        super.getXml(result, attributes);
                    }
                    /**
                     *
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setFixedAttributes(attributes, format) {
                        if (!attributes.containsKey(CommandImportVEFData.FIELD_ATTR_NAME))
                            attributes.put(CommandImportVEFData.FIELD_ATTR_NAME, format.getField());
                        super.setFixedAttributes(attributes, format);
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        const result = new com.vzome.core.construction.ConstructionList();
                        let field = attributes.get(CommandImportVEFData.FIELD_ATTR_NAME);
                        if (field == null)
                            field = attributes.get(com.vzome.core.commands.Command.FIELD_ATTR_NAME);
                        const symmAxis = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                        const vefData = attributes.get(CommandImportVEFData.VEF_STRING_ATTR_NAME);
                        const noInversion = attributes.get(CommandImportVEFData.NO_INVERSION_ATTR_NAME);
                        let projection = this.mProjection;
                        if (projection == null) {
                            let quaternion = this.quaternionVector;
                            if (quaternion == null)
                                quaternion = (symmAxis == null) ? null : symmAxis.getOffset();
                            if (quaternion != null)
                                quaternion = quaternion.scale(field['createPower$int'](-5));
                            projection = quaternion == null ? null : new com.vzome.core.math.QuaternionProjection(field, null, quaternion);
                        }
                        if (noInversion != null && noInversion)
                            new CommandImportVEFData.VefToModelNoInversion(this, projection, field, effects).parseVEF(vefData, field);
                        else
                            new com.vzome.core.construction.VefToModel(projection, effects, field['createPower$int'](5), null).parseVEF(vefData, field);
                        return result;
                    }
                }
                CommandImportVEFData.X = 0;
                CommandImportVEFData.Y = 1;
                CommandImportVEFData.Z = 2;
                CommandImportVEFData.W = 3;
                CommandImportVEFData.VEF_STRING_ATTR_NAME = "org.vorthmann.zome.commands.CommandImportVEFData.vef.string";
                CommandImportVEFData.FIELD_ATTR_NAME = "org.vorthmann.zome.commands.CommandImportVEFData.field";
                CommandImportVEFData.NO_INVERSION_ATTR_NAME = "org.vorthmann.zome.commands.CommandImportVEFData.no.inversion";
                commands.CommandImportVEFData = CommandImportVEFData;
                CommandImportVEFData["__class"] = "com.vzome.core.commands.CommandImportVEFData";
                CommandImportVEFData["__interfaces"] = ["com.vzome.core.commands.Command"];
                (function (CommandImportVEFData) {
                    class VefToModelNoInversion extends com.vzome.core.construction.VefToModel {
                        constructor(__parent, projection, field, effects) {
                            super(projection, effects, field['createPower$int'](5), null);
                            this.__parent = __parent;
                            if (this.mProjected === undefined) {
                                this.mProjected = null;
                            }
                            this.mUsedPoints = (new java.util.HashSet());
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {com.vzome.core.algebra.AlgebraicVector} location
                         */
                        addVertex(index, location) {
                            if (this.scale != null) {
                                location = location.scale(this.scale);
                            }
                            if (this.mProjection != null)
                                location = this.mProjection.projectImage(location, this.wFirst());
                            this.mVertices[index] = new com.vzome.core.construction.FreePoint(location);
                        }
                        /**
                         *
                         * @param {number} numEdges
                         */
                        startEdges(numEdges) {
                            this.mProjected = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                                return null;
                            }
                            else {
                                let array = [];
                                for (let i = 0; i < dims[0]; i++) {
                                    array.push(allocate(dims.slice(1)));
                                }
                                return array;
                            } }; return allocate(dims); })([numEdges, 2]);
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {number} v1
                         * @param {number} v2
                         */
                        addEdge(index, v1, v2) {
                            const p1 = this.mVertices[v1];
                            const p2 = this.mVertices[v2];
                            if (p1 == null || p2 == null)
                                return;
                            const seg = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                            const pr1 = p1.getLocation().projectTo3d(this.wFirst()).negate();
                            const pr2 = p2.getLocation().projectTo3d(this.wFirst()).negate();
                            for (let i = 0; i < index; i++) {
                                {
                                    if (pr1.equals(this.mProjected[i][0]) && pr2.equals(this.mProjected[i][1]))
                                        return;
                                    if (pr2.equals(this.mProjected[i][0]) && pr1.equals(this.mProjected[i][1]))
                                        return;
                                }
                                ;
                            }
                            this.mProjected[index][0] = pr1.negate();
                            this.mProjected[index][1] = pr2.negate();
                            this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](seg);
                            this.mUsedPoints.add(p1);
                            this.mUsedPoints.add(p2);
                        }
                        /**
                         *
                         */
                        endEdges() {
                            for (let index = this.mUsedPoints.iterator(); index.hasNext();) {
                                let point = index.next();
                                {
                                    this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](point);
                                }
                            }
                        }
                    }
                    CommandImportVEFData.VefToModelNoInversion = VefToModelNoInversion;
                    VefToModelNoInversion["__class"] = "com.vzome.core.commands.CommandImportVEFData.VefToModelNoInversion";
                })(CommandImportVEFData = commands.CommandImportVEFData || (commands.CommandImportVEFData = {}));
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class PolygonFromVertices extends com.vzome.core.construction.Polygon {
                    constructor(points) {
                        if (((points != null && (points.constructor != null && points.constructor["__interfaces"] != null && points.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || points === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let vertices = points.toArray((s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(points.size()));
                                super(vertices.length === 0 ? null : vertices[0].field);
                                if (this.__com_vzome_core_construction_PolygonFromVertices_mVertices === undefined) {
                                    this.__com_vzome_core_construction_PolygonFromVertices_mVertices = null;
                                }
                                this.__com_vzome_core_construction_PolygonFromVertices_mVertices = vertices;
                                this.mapParamsToState();
                            }
                        }
                        else if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof com.vzome.core.construction.Point))) || points === null)) {
                            let __args = arguments;
                            let vertices = __args[0];
                            super(vertices.length === 0 ? null : vertices[0].field);
                            if (this.__com_vzome_core_construction_PolygonFromVertices_mVertices === undefined) {
                                this.__com_vzome_core_construction_PolygonFromVertices_mVertices = null;
                            }
                            this.__com_vzome_core_construction_PolygonFromVertices_mVertices = vertices;
                            this.mapParamsToState();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        const locs = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.__com_vzome_core_construction_PolygonFromVertices_mVertices.length);
                        for (let i = 0; i < this.__com_vzome_core_construction_PolygonFromVertices_mVertices.length; i++) {
                            locs[i] = this.__com_vzome_core_construction_PolygonFromVertices_mVertices[i].getLocation();
                        }
                        return this.setStateVariable(locs, false);
                    }
                }
                construction.PolygonFromVertices = PolygonFromVertices;
                PolygonFromVertices["__class"] = "com.vzome.core.construction.PolygonFromVertices";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Transformation} transform
                 * @param {com.vzome.core.construction.Polygon} prototype
                 * @class
                 * @extends com.vzome.core.construction.Polygon
                 */
                class TransformedPolygon extends com.vzome.core.construction.Polygon {
                    constructor(transform, prototype) {
                        super(prototype.field);
                        if (this.mTransform === undefined) {
                            this.mTransform = null;
                        }
                        if (this.mPrototype === undefined) {
                            this.mPrototype = null;
                        }
                        this.mTransform = transform;
                        this.mPrototype = prototype;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        const vertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.mPrototype.getVertexCount());
                        for (let i = 0; i < vertices.length; i++) {
                            {
                                vertices[i] = this.mTransform.transform$com_vzome_core_algebra_AlgebraicVector(this.mPrototype.getVertex(i));
                            }
                            ;
                        }
                        return this.setStateVariable(vertices, false);
                    }
                }
                construction.TransformedPolygon = TransformedPolygon;
                TransformedPolygon["__class"] = "com.vzome.core.construction.TransformedPolygon";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.algebra.Quaternion} leftQuaternion
                 * @param {com.vzome.core.algebra.Quaternion} rightQuaternion
                 * @param {com.vzome.core.construction.Polygon} prototype
                 * @class
                 * @extends com.vzome.core.construction.Polygon
                 */
                class PolygonRotated4D extends com.vzome.core.construction.Polygon {
                    constructor(leftQuaternion, rightQuaternion, prototype) {
                        super(prototype.field);
                        if (this.mLeftQuaternion === undefined) {
                            this.mLeftQuaternion = null;
                        }
                        if (this.mRightQuaternion === undefined) {
                            this.mRightQuaternion = null;
                        }
                        if (this.mPrototype === undefined) {
                            this.mPrototype = null;
                        }
                        this.mLeftQuaternion = leftQuaternion;
                        this.mRightQuaternion = rightQuaternion;
                        this.mPrototype = prototype;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mPrototype.isImpossible())
                            return this.setStateVariable(null, true);
                        const vertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.mPrototype.getVertexCount());
                        for (let i = 0; i < vertices.length; i++) {
                            {
                                let loc = this.mRightQuaternion.leftMultiply(this.mPrototype.getVertex(i));
                                loc = this.mLeftQuaternion.rightMultiply(loc);
                                vertices[i] = loc;
                            }
                            ;
                        }
                        return this.setStateVariable(vertices, false);
                    }
                }
                construction.PolygonRotated4D = PolygonRotated4D;
                PolygonRotated4D["__class"] = "com.vzome.core.construction.PolygonRotated4D";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class MatrixTransformation extends com.vzome.core.construction.Transformation {
                    constructor(matrix, center) {
                        super(center.getField());
                        this.setStateVariables(matrix, center, false);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return true;
                    }
                }
                construction.MatrixTransformation = MatrixTransformation;
                MatrixTransformation["__class"] = "com.vzome.core.construction.MatrixTransformation";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param prototype
                 * @param {com.vzome.core.construction.Plane} projectionPlane
                 * @param {com.vzome.core.construction.Line} projectionLine
                 * @class
                 * @extends com.vzome.core.construction.Transformation
                 * @author Scott Vorthmann
                 */
                class PlaneProjection extends com.vzome.core.construction.Transformation {
                    constructor(projectionPlane, projectionLine) {
                        super(projectionPlane.field);
                        if (this.projectionPlane === undefined) {
                            this.projectionPlane = null;
                        }
                        if (this.projectionVector === undefined) {
                            this.projectionVector = null;
                        }
                        this.projectionPlane = projectionPlane;
                        if (projectionLine == null)
                            this.projectionVector = projectionPlane.getNormal();
                        else
                            this.projectionVector = projectionLine.getDirection();
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.projectionPlane.isImpossible())
                            this.setStateVariables(null, null, true);
                        const loc = this.projectionPlane.getBase();
                        return this.setStateVariables(null, loc, false);
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        const line = new com.vzome.core.construction.LineFromPointAndVector(arg, this.projectionVector);
                        const point = new com.vzome.core.construction.LinePlaneIntersectionPoint(this.projectionPlane, line);
                        return point.getLocation();
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    transform$com_vzome_core_construction_Construction(c) {
                        if (c != null && c instanceof com.vzome.core.construction.Segment) {
                            if (com.vzome.core.algebra.AlgebraicVectors.areParallel(this.projectionVector, c.getOffset())) {
                                return new com.vzome.core.construction.LinePlaneIntersectionPoint(this.projectionPlane, new com.vzome.core.construction.LineExtensionOfSegment(c));
                            }
                        }
                        else if (c != null && c instanceof com.vzome.core.construction.Polygon) {
                            let p = c;
                            const points = (new java.util.ArrayList(1 + p.getVertexCount()));
                            points.add(p.getVertex(0).plus(this.projectionVector));
                            for (let i = 0; i < p.getVertexCount(); i++) {
                                {
                                    points.add(p.getVertex(i));
                                }
                                ;
                            }
                            if (com.vzome.core.algebra.AlgebraicVectors.areCoplanar(points)) {
                                p = super.transform$com_vzome_core_construction_Construction(p);
                                let min = p.getVertex(0);
                                let max = min;
                                for (let i = 1; i < p.getVertexCount(); i++) {
                                    {
                                        const v = p.getVertex(i);
                                        if (v.compareTo(min) === -1) {
                                            min = v;
                                        }
                                        if (v.compareTo(max) === 1) {
                                            max = v;
                                        }
                                    }
                                    ;
                                }
                                const p1 = new com.vzome.core.construction.FreePoint(min);
                                const p2 = new com.vzome.core.construction.FreePoint(max);
                                return new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                            }
                        }
                        return super.transform$com_vzome_core_construction_Construction(c);
                    }
                }
                construction.PlaneProjection = PlaneProjection;
                PlaneProjection["__class"] = "com.vzome.core.construction.PlaneProjection";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class Scaling extends com.vzome.core.construction.Transformation {
                    constructor(s1, s2, center, symmetry) {
                        super(s1.field);
                        if (this.s1 === undefined) {
                            this.s1 = null;
                        }
                        if (this.s2 === undefined) {
                            this.s2 = null;
                        }
                        if (this.center === undefined) {
                            this.center = null;
                        }
                        if (this.symmetry === undefined) {
                            this.symmetry = null;
                        }
                        this.mOffset = this.field.projectTo3d(center.getLocation(), true);
                        this.s1 = s1;
                        this.s2 = s2;
                        this.center = center;
                        this.symmetry = symmetry;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        const zone1 = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](this.s1.getOffset());
                        const zone2 = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](this.s2.getOffset());
                        const orbit = zone1.getDirection();
                        if (orbit !== zone2.getDirection())
                            return this.setStateVariables(null, null, true);
                        const len1 = zone1.getLength(this.s1.getOffset());
                        const len2 = zone2.getLength(this.s2.getOffset());
                        const scale = len2.dividedBy(len1);
                        const transform = new com.vzome.core.algebra.AlgebraicMatrix(this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X).scale(scale), this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y).scale(scale), this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).scale(scale));
                        return this.setStateVariables(transform, this.center.getLocation(), false);
                    }
                }
                construction.Scaling = Scaling;
                Scaling["__class"] = "com.vzome.core.construction.Scaling";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param prototype
                 * @param {*} symm
                 * @param {number} orientation
                 * @param {com.vzome.core.construction.Point} center
                 * @class
                 * @extends com.vzome.core.construction.Transformation
                 * @author Scott Vorthmann
                 */
                class SymmetryTransformation extends com.vzome.core.construction.Transformation {
                    constructor(symm, orientation, center) {
                        super(center.field);
                        if (this.mCenter === undefined) {
                            this.mCenter = null;
                        }
                        if (this.mSymmetry === undefined) {
                            this.mSymmetry = null;
                        }
                        if (this.mOrientation === undefined) {
                            this.mOrientation = 0;
                        }
                        this.mSymmetry = symm;
                        this.mOrientation = orientation;
                        this.mCenter = center;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mCenter.isImpossible())
                            return this.setStateVariables(null, null, true);
                        const loc = this.mCenter.getLocation().projectTo3d(true);
                        const matrix = this.mSymmetry.getMatrix(this.mOrientation);
                        return this.setStateVariables(matrix, loc, false);
                    }
                }
                construction.SymmetryTransformation = SymmetryTransformation;
                SymmetryTransformation["__class"] = "com.vzome.core.construction.SymmetryTransformation";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class PointToPointTranslation extends com.vzome.core.construction.Transformation {
                    constructor(p1, p2) {
                        super(p1.field);
                        this.mOffset = this.field.projectTo3d(p2.getLocation().minus(p1.getLocation()), true);
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        return arg.plus(this.mOffset);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return this.setStateVariables(null, null, false);
                    }
                }
                construction.PointToPointTranslation = PointToPointTranslation;
                PointToPointTranslation["__class"] = "com.vzome.core.construction.PointToPointTranslation";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class LineReflection extends com.vzome.core.construction.Transformation {
                    constructor(axis) {
                        super(axis.field);
                        if (this.two === undefined) {
                            this.two = null;
                        }
                        if (this.mMirrorLine === undefined) {
                            this.mMirrorLine = null;
                        }
                        if (this.mStart === undefined) {
                            this.mStart = null;
                        }
                        if (this.mEnd === undefined) {
                            this.mEnd = null;
                        }
                        this.two = this.field['createRational$long'](2);
                        this.mMirrorLine = new com.vzome.core.construction.LineExtensionOfSegment(axis);
                        this.mStart = axis.getStart();
                        this.mEnd = axis.getEnd();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return true;
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        const norm1 = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.mStart, this.mEnd, arg);
                        if (norm1.isOrigin()) {
                            return arg;
                        }
                        const norm2 = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.mStart, this.mEnd, this.mEnd.plus(norm1));
                        const line2 = new com.vzome.core.construction.LineFromPointAndVector(arg, norm2);
                        const point = new com.vzome.core.construction.LineLineIntersectionPoint(this.mMirrorLine, line2);
                        const intersection = point.getLocation();
                        const translation = intersection.minus(arg).scale(this.two);
                        return arg.plus(translation);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                construction.LineReflection = LineReflection;
                LineReflection["__class"] = "com.vzome.core.construction.LineReflection";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * This assumes that the starting basis is the usual X,Y,Z basis
                 * @param {boolean} originalScaling
                 * @param prototype
                 * @param {com.vzome.core.construction.Segment} newX
                 * @param {com.vzome.core.construction.Segment} newY
                 * @param {com.vzome.core.construction.Segment} newZ
                 * @param {com.vzome.core.construction.Point} kernel
                 * @class
                 * @extends com.vzome.core.construction.Transformation
                 * @author Scott Vorthmann
                 */
                class ChangeOfBasis extends com.vzome.core.construction.Transformation {
                    constructor(newX, newY, newZ, kernel, originalScaling) {
                        if (((newX != null && newX instanceof com.vzome.core.construction.Segment) || newX === null) && ((newY != null && newY instanceof com.vzome.core.construction.Segment) || newY === null) && ((newZ != null && newZ instanceof com.vzome.core.construction.Segment) || newZ === null) && ((kernel != null && kernel instanceof com.vzome.core.construction.Point) || kernel === null) && ((typeof originalScaling === 'boolean') || originalScaling === null)) {
                            let __args = arguments;
                            super(newX.field);
                            if (this.mOld === undefined) {
                                this.mOld = null;
                            }
                            if (this.mNew === undefined) {
                                this.mNew = null;
                            }
                            if (this.mKernel === undefined) {
                                this.mKernel = null;
                            }
                            if (this.scale === undefined) {
                                this.scale = null;
                            }
                            this.mNew = [newX, newY, newZ];
                            this.mOld = null;
                            this.mKernel = kernel;
                            if (originalScaling)
                                this.scale = this.field['createPower$int'](-5);
                            else
                                this.scale = this.field['createRational$long$long'](1, 2)['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createPower$int'](-3));
                            this.mapParamsToState();
                        }
                        else if (((newX != null && newX instanceof Array && (newX.length == 0 || newX[0] == null || (newX[0] != null && newX[0] instanceof com.vzome.core.construction.Segment))) || newX === null) && ((newY != null && newY instanceof Array && (newY.length == 0 || newY[0] == null || (newY[0] != null && newY[0] instanceof com.vzome.core.construction.Segment))) || newY === null) && ((newZ != null && newZ instanceof com.vzome.core.construction.Point) || newZ === null) && kernel === undefined && originalScaling === undefined) {
                            let __args = arguments;
                            let oldBasis = __args[0];
                            let newBasis = __args[1];
                            let kernel = __args[2];
                            super(oldBasis[0].field);
                            if (this.mOld === undefined) {
                                this.mOld = null;
                            }
                            if (this.mNew === undefined) {
                                this.mNew = null;
                            }
                            if (this.mKernel === undefined) {
                                this.mKernel = null;
                            }
                            if (this.scale === undefined) {
                                this.scale = null;
                            }
                            this.mOld = oldBasis;
                            this.mNew = newBasis;
                            this.mKernel = kernel;
                            this.scale = this.field['createRational$long'](2)['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createPower$int'](-7));
                            this.mapParamsToState();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        const loc = this.mKernel.getLocation();
                        if (this.mOld != null) {
                            const oldCommon = ChangeOfBasis.findCommonVertex(this.mOld[0], this.mOld[1]);
                            const offsets = [null, null, null];
                            for (let i = 0; i < offsets.length; i++) {
                                {
                                    offsets[i] = this.mOld[i].getOffset().scale(this.scale);
                                    if (oldCommon.equals(this.mOld[i].getEnd()))
                                        offsets[i] = offsets[i].negate();
                                }
                                ;
                            }
                            const oldMatrix = new com.vzome.core.algebra.AlgebraicMatrix(offsets);
                            const newCommon = ChangeOfBasis.findCommonVertex(this.mNew[0], this.mNew[1]);
                            for (let i = 0; i < offsets.length; i++) {
                                {
                                    offsets[i] = this.mNew[i].getOffset().scale(this.scale);
                                    if (newCommon.equals(this.mNew[i].getEnd()))
                                        offsets[i] = offsets[i].negate();
                                }
                                ;
                            }
                            const newMatrix = new com.vzome.core.algebra.AlgebraicMatrix(offsets);
                            const transform = newMatrix.times(oldMatrix.inverse());
                            return this.setStateVariables(transform, loc, false);
                        }
                        else {
                            const transform = new com.vzome.core.algebra.AlgebraicMatrix(this.mNew[0].getOffset().scale(this.scale), this.mNew[1].getOffset().scale(this.scale), this.mNew[2].getOffset().scale(this.scale));
                            return this.setStateVariables(transform, loc, false);
                        }
                    }
                    static findCommonVertex(s1, s2) {
                        let common = s1.getStart();
                        if (common.equals(s2.getStart()) || common.equals(s2.getEnd()))
                            return common;
                        else {
                            common = s1.getEnd();
                            if (common.equals(s2.getStart()) || common.equals(s2.getEnd()))
                                return common;
                            else
                                return null;
                        }
                    }
                }
                construction.ChangeOfBasis = ChangeOfBasis;
                ChangeOfBasis["__class"] = "com.vzome.core.construction.ChangeOfBasis";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class Translation extends com.vzome.core.construction.Transformation {
                    constructor(offset) {
                        super(offset.getField());
                        if (this.mOffset === undefined) {
                            this.mOffset = null;
                        }
                        this.mOffset = offset;
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        arg = arg.plus(this.mOffset);
                        return arg;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return this.setStateVariables(null, null, false);
                    }
                }
                construction.Translation = Translation;
                Translation["__class"] = "com.vzome.core.construction.Translation";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param prototype
                 * @param {com.vzome.core.construction.Plane} mirror
                 * @class
                 * @extends com.vzome.core.construction.Transformation
                 * @author Scott Vorthmann
                 */
                class PlaneReflection extends com.vzome.core.construction.Transformation {
                    constructor(mirror) {
                        super(mirror.field);
                        if (this.mMirror === undefined) {
                            this.mMirror = null;
                        }
                        if (this.mNormal === undefined) {
                            this.mNormal = null;
                        }
                        if (this.mBase === undefined) {
                            this.mBase = null;
                        }
                        if (this.mNormDotReciprocal === undefined) {
                            this.mNormDotReciprocal = null;
                        }
                        this.mMirror = mirror;
                        this.mNormal = mirror.getNormal();
                        this.mBase = mirror.getBase();
                        this.mNormDotReciprocal = this.mNormal.dot(this.mNormal).reciprocal();
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mMirror.isImpossible())
                            this.setStateVariables(null, null, true);
                        const loc = this.mMirror.getBase();
                        return this.setStateVariables(null, loc, false);
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        arg = arg.minus(this.mBase);
                        let xy = arg.dot(this.mNormal);
                        xy = xy['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createRational$long'](2));
                        arg = arg.minus(this.mNormal.scale(xy['times$com_vzome_core_algebra_AlgebraicNumber'](this.mNormDotReciprocal)));
                        return arg.plus(this.mBase);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                construction.PlaneReflection = PlaneReflection;
                PlaneReflection["__class"] = "com.vzome.core.construction.PlaneReflection";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class MoveAndRotate extends com.vzome.core.construction.Transformation {
                    constructor(rotation, start, end) {
                        super(start.getField());
                        if (this.rotation === undefined) {
                            this.rotation = null;
                        }
                        if (this.translation === undefined) {
                            this.translation = null;
                        }
                        this.rotation = new com.vzome.core.construction.MatrixTransformation(rotation, start);
                        this.translation = new com.vzome.core.construction.Translation(end.minus(start));
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return this.rotation.mapParamsToState() && this.translation.mapParamsToState();
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        return this.translation.transform$com_vzome_core_algebra_AlgebraicVector(this.rotation.transform$com_vzome_core_algebra_AlgebraicVector(arg));
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                construction.MoveAndRotate = MoveAndRotate;
                MoveAndRotate["__class"] = "com.vzome.core.construction.MoveAndRotate";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param prototype
                 * @param {com.vzome.core.construction.Plane} projectionPlane
                 * @param {com.vzome.core.construction.Point} perspectivePoint
                 * @class
                 * @extends com.vzome.core.construction.Transformation
                 * @author Scott Vorthmann
                 */
                class PerspectiveProjection extends com.vzome.core.construction.Transformation {
                    constructor(projectionPlane, perspectivePoint) {
                        super(projectionPlane.field);
                        if (this.projectionPlane === undefined) {
                            this.projectionPlane = null;
                        }
                        if (this.perspectivePoint === undefined) {
                            this.perspectivePoint = null;
                        }
                        this.projectionPlane = projectionPlane;
                        this.perspectivePoint = perspectivePoint;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.projectionPlane.isImpossible())
                            this.setStateVariables(null, null, true);
                        const loc = this.getField().origin(3);
                        return this.setStateVariables(null, loc, false);
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        const segment = new com.vzome.core.construction.SegmentJoiningPoints(this.perspectivePoint, new com.vzome.core.construction.FreePoint(arg));
                        if (segment.getOffset().isOrigin())
                            return null;
                        const line = new com.vzome.core.construction.LineExtensionOfSegment(segment);
                        const point = new com.vzome.core.construction.LinePlaneIntersectionPoint(this.projectionPlane, line);
                        return point.getLocation();
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    transform$com_vzome_core_construction_Construction(c) {
                        if (c != null && c instanceof com.vzome.core.construction.Point) {
                            const result = new com.vzome.core.construction.TransformedPoint(this, c);
                            if (result.isImpossible())
                                return null;
                            return result;
                        }
                        else if (c != null && c instanceof com.vzome.core.construction.Segment) {
                            const result = new com.vzome.core.construction.TransformedSegment(this, c);
                            if (result.isImpossible() || result.getOffset().isOrigin()) {
                                return new com.vzome.core.construction.FreePoint(c.getStart());
                            }
                            return result;
                        }
                        else if (c != null && c instanceof com.vzome.core.construction.Polygon) {
                            const p = new com.vzome.core.construction.TransformedPolygon(this, c);
                            if (p.getNormal().isOrigin()) {
                                let min = p.getVertex(0);
                                let max = min;
                                for (let i = 1; i < p.getVertexCount(); i++) {
                                    {
                                        const v = p.getVertex(i);
                                        if (v.compareTo(min) === -1) {
                                            min = v;
                                        }
                                        if (v.compareTo(max) === 1) {
                                            max = v;
                                        }
                                    }
                                    ;
                                }
                                const p1 = new com.vzome.core.construction.FreePoint(min);
                                const p2 = new com.vzome.core.construction.FreePoint(max);
                                return new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                            }
                            return p;
                        }
                        return super.transform$com_vzome_core_construction_Construction(c);
                    }
                }
                construction.PerspectiveProjection = PerspectiveProjection;
                PerspectiveProjection["__class"] = "com.vzome.core.construction.PerspectiveProjection";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param prototype
                 * @param {com.vzome.core.construction.Point} center
                 * @class
                 * @extends com.vzome.core.construction.Transformation
                 * @author Scott Vorthmann
                 */
                class PointReflection extends com.vzome.core.construction.Transformation {
                    constructor(center) {
                        super(center.field);
                        if (this.mCenter === undefined) {
                            this.mCenter = null;
                        }
                        this.mCenter = center;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mCenter.isImpossible())
                            this.setStateVariables(null, null, true);
                        const loc = this.mCenter.getLocation().projectTo3d(true);
                        return this.setStateVariables(null, loc, false);
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        arg = arg.minus(this.mOffset);
                        arg = this.mOffset.minus(arg);
                        return arg;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                construction.PointReflection = PointReflection;
                PointReflection["__class"] = "com.vzome.core.construction.PointReflection";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Line} l3
                 * @param {*} len
                 * @class
                 * @extends com.vzome.core.construction.Segment
                 */
                class SegmentOnLine extends com.vzome.core.construction.Segment {
                    constructor(l3, len) {
                        super(l3.field);
                        if (this.mLine === undefined) {
                            this.mLine = null;
                        }
                        if (this.mLength === undefined) {
                            this.mLength = null;
                        }
                        this.mLine = l3;
                        this.mLength = len;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mLine.isImpossible())
                            return this.setStateVariables(null, null, true);
                        const offset = this.getOffset().scale(this.mLength);
                        return this.setStateVariables(this.mLine.getStart(), offset, false);
                    }
                }
                construction.SegmentOnLine = SegmentOnLine;
                SegmentOnLine["__class"] = "com.vzome.core.construction.SegmentOnLine";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Transformation} transform
                 * @param {com.vzome.core.construction.Segment} prototype
                 * @class
                 * @extends com.vzome.core.construction.Segment
                 */
                class TransformedSegment extends com.vzome.core.construction.Segment {
                    constructor(transform, prototype) {
                        super(prototype.field);
                        if (this.mTransform === undefined) {
                            this.mTransform = null;
                        }
                        if (this.mPrototype === undefined) {
                            this.mPrototype = null;
                        }
                        this.mTransform = transform;
                        this.mPrototype = prototype;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mTransform.isImpossible() || this.mPrototype.isImpossible())
                            return this.setStateVariables(null, null, true);
                        const loc = this.mTransform.transform$com_vzome_core_algebra_AlgebraicVector(this.mPrototype.getStart().projectTo3d(true));
                        const end = this.mTransform.transform$com_vzome_core_algebra_AlgebraicVector(this.mPrototype.getEnd().projectTo3d(true));
                        if (end == null || loc == null)
                            return this.setStateVariables(null, null, true);
                        return this.setStateVariables(loc, end.minus(loc), false);
                    }
                }
                construction.TransformedSegment = TransformedSegment;
                TransformedSegment["__class"] = "com.vzome.core.construction.TransformedSegment";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Point} p1
                 * @param {com.vzome.core.construction.Point} p2
                 * @class
                 * @extends com.vzome.core.construction.Segment
                 */
                class SegmentJoiningPoints extends com.vzome.core.construction.Segment {
                    constructor(p1, p2) {
                        super(p1.field);
                        if (this.__com_vzome_core_construction_SegmentJoiningPoints_mStart === undefined) {
                            this.__com_vzome_core_construction_SegmentJoiningPoints_mStart = null;
                        }
                        if (this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd === undefined) {
                            this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd = null;
                        }
                        this.__com_vzome_core_construction_SegmentJoiningPoints_mStart = p1;
                        this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd = p2;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.__com_vzome_core_construction_SegmentJoiningPoints_mStart.isImpossible() || this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd.isImpossible())
                            return this.setStateVariables(null, null, true);
                        let startV = this.__com_vzome_core_construction_SegmentJoiningPoints_mStart.getLocation();
                        let endV = this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd.getLocation();
                        if (startV.dimension() === 3 || endV.dimension() === 3) {
                            startV = startV.projectTo3d(true);
                            endV = endV.projectTo3d(true);
                        }
                        const offset = endV.minus(startV);
                        return this.setStateVariables(startV, offset, false);
                    }
                }
                construction.SegmentJoiningPoints = SegmentJoiningPoints;
                SegmentJoiningPoints["__class"] = "com.vzome.core.construction.SegmentJoiningPoints";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Segment} s1
                 * @param {com.vzome.core.construction.Segment} s2
                 * @class
                 * @extends com.vzome.core.construction.Segment
                 */
                class SegmentCrossProduct extends com.vzome.core.construction.Segment {
                    constructor(s1, s2) {
                        super(s1.field);
                        if (this.seg1 === undefined) {
                            this.seg1 = null;
                        }
                        if (this.seg2 === undefined) {
                            this.seg2 = null;
                        }
                        this.seg1 = s1;
                        this.seg2 = s2;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.seg1.isImpossible() || this.seg2.isImpossible()) {
                            return this.setStateVariables(null, null, true);
                        }
                        const v2 = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.seg1.getOffset(), this.seg2.getOffset()).scale(this.field['createPower$int'](-4)).scale(this.field['createRational$long$long'](1, 2));
                        return this.setStateVariables(this.seg1.getEnd(), v2, false);
                    }
                }
                construction.SegmentCrossProduct = SegmentCrossProduct;
                SegmentCrossProduct["__class"] = "com.vzome.core.construction.SegmentCrossProduct";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.algebra.Quaternion} leftQuaternion
                 * @param {com.vzome.core.algebra.Quaternion} rightQuaternion
                 * @param {com.vzome.core.construction.Segment} prototype
                 * @class
                 * @extends com.vzome.core.construction.Segment
                 */
                class SegmentRotated4D extends com.vzome.core.construction.Segment {
                    constructor(leftQuaternion, rightQuaternion, prototype) {
                        super(prototype.field);
                        if (this.mLeftQuaternion === undefined) {
                            this.mLeftQuaternion = null;
                        }
                        if (this.mRightQuaternion === undefined) {
                            this.mRightQuaternion = null;
                        }
                        if (this.mPrototype === undefined) {
                            this.mPrototype = null;
                        }
                        this.mLeftQuaternion = leftQuaternion;
                        this.mRightQuaternion = rightQuaternion;
                        this.mPrototype = prototype;
                        this.mapParamsToState();
                    }
                    static logger_$LI$() { if (SegmentRotated4D.logger == null) {
                        SegmentRotated4D.logger = java.util.logging.Logger.getLogger("com.vzome.core.4d");
                    } return SegmentRotated4D.logger; }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mPrototype.isImpossible())
                            return this.setStateVariables(null, null, true);
                        let loc = this.mPrototype.getStart();
                        loc = loc.inflateTo4d$boolean(true);
                        loc = this.mRightQuaternion.leftMultiply(loc);
                        loc = this.mLeftQuaternion.rightMultiply(loc);
                        let end = this.mPrototype.getEnd();
                        end = end.inflateTo4d$boolean(true);
                        end = this.mRightQuaternion.leftMultiply(end);
                        end = this.mLeftQuaternion.rightMultiply(end);
                        if (SegmentRotated4D.logger_$LI$().isLoggable(java.util.logging.Level.FINER)) {
                            SegmentRotated4D.logger_$LI$().finer("------------------- SegmentRotated4D");
                            SegmentRotated4D.logger_$LI$().finer("left:    " + this.mLeftQuaternion.toString());
                            SegmentRotated4D.logger_$LI$().finer("right:   " + this.mRightQuaternion.toString());
                            SegmentRotated4D.logger_$LI$().finer("start: " + this.mPrototype.getStart().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT));
                            SegmentRotated4D.logger_$LI$().finer("end:   " + this.mPrototype.getEnd().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT));
                            SegmentRotated4D.logger_$LI$().finer("new start: " + loc.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT));
                            SegmentRotated4D.logger_$LI$().finer("new end:   " + end.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT));
                        }
                        return this.setStateVariables(loc, end.minus(loc), false);
                    }
                }
                construction.SegmentRotated4D = SegmentRotated4D;
                SegmentRotated4D["__class"] = "com.vzome.core.construction.SegmentRotated4D";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class PolygonPolygonProjectionToSegment extends com.vzome.core.construction.Segment {
                    constructor(polygon0, polygon1) {
                        super(polygon0.getField());
                        this.polygons = [null, null];
                        this.polygons[0] = polygon0;
                        this.polygons[1] = polygon1;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.polygons[0].isImpossible() || this.polygons[1].isImpossible()) {
                            return this.setStateVariables(null, null, true);
                        }
                        if (com.vzome.core.algebra.AlgebraicVectors.areParallel(this.polygons[0].getNormal(), this.polygons[1].getNormal())) {
                            return this.setStateVariables(null, null, true);
                        }
                        const intersections = (new java.util.HashSet(2));
                        for (let poly = 0; poly < 2; poly++) {
                            {
                                const edgePolygon = this.polygons[poly];
                                const planePolygon = this.polygons[(poly + 1) % 2];
                                const centroid = planePolygon.getCentroid();
                                const normal = planePolygon.getNormal();
                                const nVertices = edgePolygon.getVertexCount();
                                for (let i = 0; i < nVertices; i++) {
                                    {
                                        const lineStart = edgePolygon.getVertex(i);
                                        const lineDirection = lineStart.minus(edgePolygon.getVertex((i + 1) % nVertices));
                                        if (!lineDirection.isOrigin()) {
                                            const intersection = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(lineStart, lineDirection, centroid, normal);
                                            if (intersection != null) {
                                                intersections.add(intersection);
                                                if (intersections.size() === 2) {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    ;
                                }
                                if (intersections.size() === 2) {
                                    break;
                                }
                            }
                            ;
                        }
                        if (intersections.size() !== 2) {
                            for (let poly = 0; poly < 2; poly++) {
                                {
                                    const edgePolygon = this.polygons[poly];
                                    const planePolygon = this.polygons[(poly + 1) % 2];
                                    const centroid = planePolygon.getCentroid();
                                    const normal = planePolygon.getNormal();
                                    const lineStart = edgePolygon.getCentroid();
                                    for (let i = 0; i < edgePolygon.getVertexCount(); i++) {
                                        {
                                            const lineDirection = lineStart.minus(edgePolygon.getVertex(i));
                                            if (!lineDirection.isOrigin()) {
                                                const intersection = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(lineStart, lineDirection, centroid, normal);
                                                if (intersection != null) {
                                                    intersections.add(intersection);
                                                    if (intersections.size() === 2) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        ;
                                    }
                                    if (intersections.size() === 2) {
                                        break;
                                    }
                                }
                                ;
                            }
                        }
                        if (intersections.size() !== 2) {
                            return this.setStateVariables(null, null, true);
                        }
                        let v0 = null;
                        let v1 = null;
                        for (let index = intersections.iterator(); index.hasNext();) {
                            let v = index.next();
                            {
                                if (v0 == null) {
                                    v0 = v;
                                }
                                else {
                                    v1 = v;
                                }
                            }
                        }
                        const intersectionLine = new com.vzome.core.construction.LineExtensionOfSegment(new com.vzome.core.construction.SegmentJoiningPoints(new com.vzome.core.construction.FreePoint(v0), new com.vzome.core.construction.FreePoint(v1)));
                        const projections = (new java.util.TreeSet());
                        for (let poly = 0; poly < 2; poly++) {
                            {
                                const polygon = this.polygons[poly];
                                const v2 = v0.plus(polygon.getNormal());
                                const vProjection = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
                                for (let i = 0; i < polygon.getVertexCount(); i++) {
                                    {
                                        const vertex = polygon.getVertex(i);
                                        if (com.vzome.core.algebra.AlgebraicVectors.areCollinear$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, vertex)) {
                                            projections.add(vertex);
                                        }
                                        else {
                                            const projectionLine = new com.vzome.core.construction.LineFromPointAndVector(vertex, vProjection);
                                            const projection = new com.vzome.core.construction.LineLineIntersectionPoint(intersectionLine, projectionLine);
                                            projections.add(projection.getLocation());
                                        }
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        let start = null;
                        let offset = null;
                        let n = 0;
                        for (let index = projections.iterator(); index.hasNext();) {
                            let v = index.next();
                            {
                                if (n === 0) {
                                    start = v;
                                }
                                else if (n === projections.size() - 1) {
                                    offset = v.minus(start);
                                }
                                n++;
                            }
                        }
                        return this.setStateVariables(start, offset, (start == null || offset == null));
                    }
                }
                construction.PolygonPolygonProjectionToSegment = PolygonPolygonProjectionToSegment;
                PolygonPolygonProjectionToSegment["__class"] = "com.vzome.core.construction.PolygonPolygonProjectionToSegment";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param step
                 * @param {com.vzome.core.construction.Point} start
                 * @param {com.vzome.core.math.symmetry.Axis} axis
                 * @param {*} length
                 * @class
                 * @extends com.vzome.core.construction.Segment
                 * @author Scott Vorthmann
                 */
                class AnchoredSegment extends com.vzome.core.construction.Segment {
                    constructor(axis, length, start) {
                        super(start.field);
                        if (this.mAnchor === undefined) {
                            this.mAnchor = null;
                        }
                        if (this.mAxis === undefined) {
                            this.mAxis = null;
                        }
                        if (this.mLength === undefined) {
                            this.mLength = null;
                        }
                        this.mAnchor = start;
                        this.mAxis = axis;
                        this.mLength = length;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mAnchor.isImpossible() || this.mLength.isZero())
                            return this.setStateVariables(null, null, true);
                        const gv = this.mAnchor.getLocation().projectTo3d(true);
                        const offset = this.mAxis.normal().scale(this.mLength);
                        return this.setStateVariables(gv, offset, false);
                    }
                    getAxis() {
                        return this.mAxis;
                    }
                    getLength() {
                        return this.mLength;
                    }
                    getUnitVector() {
                        return this.mAxis.normal();
                    }
                }
                construction.AnchoredSegment = AnchoredSegment;
                AnchoredSegment["__class"] = "com.vzome.core.construction.AnchoredSegment";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandLinePlaneIntersect extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandLinePlaneIntersect.PARAM_SIGNATURE == null) {
                        CommandLinePlaneIntersect.PARAM_SIGNATURE = [["panel", com.vzome.core.construction.Polygon], ["segment", com.vzome.core.construction.Segment]];
                    } return CommandLinePlaneIntersect.PARAM_SIGNATURE; }
                    static ATTR_SIGNATURE_$LI$() { if (CommandLinePlaneIntersect.ATTR_SIGNATURE == null) {
                        CommandLinePlaneIntersect.ATTR_SIGNATURE = [];
                    } return CommandLinePlaneIntersect.ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandLinePlaneIntersect.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandLinePlaneIntersect.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        const result = new com.vzome.core.construction.ConstructionList();
                        if (parameters == null || parameters.size() !== 2)
                            throw new commands.Command.Failure("Intersection requires a panel and a strut.");
                        try {
                            let panel;
                            let segment;
                            const first = parameters.get(0);
                            if (first != null && first instanceof com.vzome.core.construction.Polygon) {
                                panel = first;
                                segment = parameters.get(1);
                            }
                            else {
                                segment = first;
                                panel = parameters.get(1);
                            }
                            const plane = new com.vzome.core.construction.PlaneExtensionOfPolygon(panel);
                            const line = new com.vzome.core.construction.LineExtensionOfSegment(segment);
                            const point = new com.vzome.core.construction.LinePlaneIntersectionPoint(plane, line);
                            result.addConstruction(point);
                            effects['constructionAdded$com_vzome_core_construction_Construction'](point);
                        }
                        catch (e) {
                            throw new commands.Command.Failure("Intersection requires a panel and a strut.");
                        }
                        return result;
                    }
                }
                commands.CommandLinePlaneIntersect = CommandLinePlaneIntersect;
                CommandLinePlaneIntersect["__class"] = "com.vzome.core.commands.CommandLinePlaneIntersect";
                CommandLinePlaneIntersect["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class CommandObliquePentagon extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandObliquePentagon.PARAM_SIGNATURE == null) {
                        CommandObliquePentagon.PARAM_SIGNATURE = [["segment1", com.vzome.core.construction.Segment], ["segment2", com.vzome.core.construction.Segment]];
                    } return CommandObliquePentagon.PARAM_SIGNATURE; }
                    static ATTR_SIGNATURE_$LI$() { if (CommandObliquePentagon.ATTR_SIGNATURE == null) {
                        CommandObliquePentagon.ATTR_SIGNATURE = [];
                    } return CommandObliquePentagon.ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandObliquePentagon.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandObliquePentagon.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        throw new commands.Command.Failure("Oblique pentagon should never be called.");
                    }
                }
                commands.CommandObliquePentagon = CommandObliquePentagon;
                CommandObliquePentagon["__class"] = "com.vzome.core.commands.CommandObliquePentagon";
                CommandObliquePentagon["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandMidpoint extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandMidpoint.PARAM_SIGNATURE == null) {
                        CommandMidpoint.PARAM_SIGNATURE = [["segment", com.vzome.core.construction.Segment]];
                    } return CommandMidpoint.PARAM_SIGNATURE; }
                    static ATTR_SIGNATURE_$LI$() { if (CommandMidpoint.ATTR_SIGNATURE == null) {
                        CommandMidpoint.ATTR_SIGNATURE = [];
                    } return CommandMidpoint.ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandMidpoint.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandMidpoint.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        const result = new com.vzome.core.construction.ConstructionList();
                        if (parameters == null || parameters.size() !== 1)
                            throw new commands.Command.Failure("Midpoint can only apply to a single strut.");
                        try {
                            const segment = parameters.get(0);
                            const midpoint = new com.vzome.core.construction.SegmentMidpoint(segment);
                            result.addConstruction(midpoint);
                            effects['constructionAdded$com_vzome_core_construction_Construction'](midpoint);
                        }
                        catch (e) {
                            throw new commands.Command.Failure("Midpoint can only apply to a strut.");
                        }
                        return result;
                    }
                }
                commands.CommandMidpoint = CommandMidpoint;
                CommandMidpoint["__class"] = "com.vzome.core.commands.CommandMidpoint";
                CommandMidpoint["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.algebra.Quaternion} leftQuaternion
                 * @param {com.vzome.core.algebra.Quaternion} rightQuaternion
                 * @param {com.vzome.core.construction.Point} prototype
                 * @class
                 * @extends com.vzome.core.construction.Point
                 */
                class PointRotated4D extends com.vzome.core.construction.Point {
                    constructor(leftQuaternion, rightQuaternion, prototype) {
                        super(prototype.field);
                        if (this.mLeftQuaternion === undefined) {
                            this.mLeftQuaternion = null;
                        }
                        if (this.mRightQuaternion === undefined) {
                            this.mRightQuaternion = null;
                        }
                        if (this.mPrototype === undefined) {
                            this.mPrototype = null;
                        }
                        this.mLeftQuaternion = leftQuaternion;
                        this.mRightQuaternion = rightQuaternion;
                        this.mPrototype = prototype;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mPrototype.isImpossible())
                            return this.setStateVariable(null, true);
                        const field = this.mPrototype.getField();
                        let loc = field.origin(4);
                        const loc3d = this.mPrototype.getLocation();
                        loc = loc3d.inflateTo4d$boolean(true);
                        loc = this.mRightQuaternion.leftMultiply(loc);
                        loc = this.mLeftQuaternion.rightMultiply(loc);
                        return this.setStateVariable(loc, false);
                    }
                }
                construction.PointRotated4D = PointRotated4D;
                PointRotated4D["__class"] = "com.vzome.core.construction.PointRotated4D";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class LineLineIntersectionPoint extends com.vzome.core.construction.Point {
                    constructor(line1, line2) {
                        super(line1.field);
                        if (this.line1 === undefined) {
                            this.line1 = null;
                        }
                        if (this.line2 === undefined) {
                            this.line2 = null;
                        }
                        this.line1 = line1;
                        this.line2 = line2;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        const p1 = this.line1.getStart();
                        const p21 = this.line1.getDirection();
                        const p3 = this.line2.getStart();
                        const p43 = this.line2.getDirection();
                        if (p1.equals(p3))
                            return this.setStateVariable(p1, false);
                        const p2 = p1.plus(p21);
                        if (p2.equals(p3))
                            return this.setStateVariable(p2, false);
                        const p4 = p3.plus(p43);
                        if (p1.equals(p4))
                            return this.setStateVariable(p1, false);
                        if (p2.equals(p4))
                            return this.setStateVariable(p2, false);
                        const p13 = p1.minus(p3);
                        const d1343 = p13.dot(p43);
                        const d4321 = p43.dot(p21);
                        const d1321 = p13.dot(p21);
                        const d4343 = p43.dot(p43);
                        const d2121 = p21.dot(p21);
                        const denom = d2121['times$com_vzome_core_algebra_AlgebraicNumber'](d4343)['minus$com_vzome_core_algebra_AlgebraicNumber'](d4321['times$com_vzome_core_algebra_AlgebraicNumber'](d4321));
                        if (denom.isZero())
                            return this.setStateVariable(null, true);
                        const numer = d1343['times$com_vzome_core_algebra_AlgebraicNumber'](d4321)['minus$com_vzome_core_algebra_AlgebraicNumber'](d1321['times$com_vzome_core_algebra_AlgebraicNumber'](d4343));
                        const mua = numer.dividedBy(denom);
                        const mub = d1343['plus$com_vzome_core_algebra_AlgebraicNumber'](d4321['times$com_vzome_core_algebra_AlgebraicNumber'](mua)).dividedBy(d4343);
                        const pa = p1.plus(p21.scale(mua));
                        const pb = p3.plus(p43.scale(mub));
                        if (!pa.equals(pb))
                            return this.setStateVariable(null, true);
                        return this.setStateVariable(pb, false);
                    }
                }
                construction.LineLineIntersectionPoint = LineLineIntersectionPoint;
                LineLineIntersectionPoint["__class"] = "com.vzome.core.construction.LineLineIntersectionPoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Transformation} transform
                 * @param {com.vzome.core.construction.Point} prototype
                 * @class
                 * @extends com.vzome.core.construction.Point
                 */
                class TransformedPoint extends com.vzome.core.construction.Point {
                    constructor(transform, prototype) {
                        super(prototype.field);
                        if (this.mTransform === undefined) {
                            this.mTransform = null;
                        }
                        if (this.mPrototype === undefined) {
                            this.mPrototype = null;
                        }
                        this.mTransform = transform;
                        this.mPrototype = prototype;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mTransform.isImpossible() || this.mPrototype.isImpossible())
                            return this.setStateVariable(null, true);
                        const loc = this.mTransform.transform$com_vzome_core_algebra_AlgebraicVector(this.mPrototype.getLocation());
                        return this.setStateVariable(loc, loc == null);
                    }
                }
                construction.TransformedPoint = TransformedPoint;
                TransformedPoint["__class"] = "com.vzome.core.construction.TransformedPoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param loc
                 * @param {com.vzome.core.construction.Segment} seg
                 * @class
                 * @extends com.vzome.core.construction.Point
                 * @author Scott Vorthmann
                 */
                class SegmentMidpoint extends com.vzome.core.construction.Point {
                    constructor(seg) {
                        super(seg.field);
                        if (this.mSegment === undefined) {
                            this.mSegment = null;
                        }
                        this.mSegment = seg;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mSegment.isImpossible())
                            return this.setStateVariable(null, true);
                        const half = this.field['createRational$long$long'](1, 2);
                        let loc = this.mSegment.getStart();
                        loc = loc.plus(this.mSegment.getOffset().scale(half));
                        return this.setStateVariable(loc, false);
                    }
                }
                construction.SegmentMidpoint = SegmentMidpoint;
                SegmentMidpoint["__class"] = "com.vzome.core.construction.SegmentMidpoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param {com.vzome.core.algebra.AlgebraicVector} loc
                 * @class
                 * @extends com.vzome.core.construction.Point
                 * @author Scott Vorthmann
                 */
                class FreePoint extends com.vzome.core.construction.Point {
                    constructor(loc) {
                        super(loc.getField());
                        this.setStateVariable(loc, false);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return true;
                    }
                }
                construction.FreePoint = FreePoint;
                FreePoint["__class"] = "com.vzome.core.construction.FreePoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Polygon} polygon
                 * @param {number} index
                 * @class
                 * @extends com.vzome.core.construction.Point
                 */
                class PolygonVertex extends com.vzome.core.construction.Point {
                    constructor(polygon, index) {
                        super(polygon.field);
                        if (this.polygon === undefined) {
                            this.polygon = null;
                        }
                        if (this.index === undefined) {
                            this.index = 0;
                        }
                        this.polygon = polygon;
                        this.index = index;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.polygon.isImpossible()) {
                            return this.setStateVariable(null, true);
                        }
                        const loc = this.polygon.getVertex(this.index);
                        return this.setStateVariable(loc, false);
                    }
                }
                construction.PolygonVertex = PolygonVertex;
                PolygonVertex["__class"] = "com.vzome.core.construction.PolygonVertex";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param loc
                 * @param {com.vzome.core.construction.Segment} seg
                 * @class
                 * @extends com.vzome.core.construction.Point
                 * @author Scott Vorthmann
                 */
                class SegmentTauDivision extends com.vzome.core.construction.Point {
                    constructor(seg) {
                        super(seg.field);
                        if (this.mSegment === undefined) {
                            this.mSegment = null;
                        }
                        if (this.shrink === undefined) {
                            this.shrink = null;
                        }
                        this.mSegment = seg;
                        this.shrink = this.field['createPower$int'](-1);
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mSegment.isImpossible())
                            return this.setStateVariable(null, true);
                        let loc = this.mSegment.getStart();
                        const off = this.mSegment.getOffset().scale(this.shrink);
                        loc = loc.plus(off);
                        return this.setStateVariable(loc, false);
                    }
                }
                construction.SegmentTauDivision = SegmentTauDivision;
                SegmentTauDivision["__class"] = "com.vzome.core.construction.SegmentTauDivision";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class LinePlaneIntersectionPoint extends com.vzome.core.construction.Point {
                    constructor(plane, line) {
                        super(line.field);
                        if (this.mPlane === undefined) {
                            this.mPlane = null;
                        }
                        if (this.mLine === undefined) {
                            this.mLine = null;
                        }
                        this.mPlane = plane;
                        this.mLine = line;
                        this.mapParamsToState();
                    }
                    /**
                     * From Vince, GA4CG, p. 196.
                     *
                     * @author Scott Vorthmann
                     * @return {boolean}
                     */
                    mapParamsToState_usingGA() {
                        if (this.mPlane.isImpossible() || this.mLine.isImpossible())
                            return this.setStateVariable(null, true);
                        const plane = this.mPlane.getHomogeneous();
                        const line = this.mLine.getHomogeneous();
                        const intersection = plane.dual().dot(line);
                        if (!intersection.exists())
                            return this.setStateVariable(null, true);
                        return this.setStateVariable(intersection.getVector(), false);
                    }
                    /**
                     * from http://astronomy.swin.edu.au/~pbourke/geometry/planeline/:
                     *
                     *
                     * The equation of a plane (points P are on the plane with normal N and point P3 on the plane) can be written as
                     *
                     * N dot (P - P3) = 0
                     *
                     * The equation of the line (points P on the line passing through points P1 and P2) can be written as
                     *
                     * P = P1 + u (P2 - P1)
                     *
                     * The intersection of these two occurs when
                     *
                     * N dot (P1 + u (P2 - P1)) = N dot P3
                     *
                     * Solving for u gives
                     *
                     * u = ( N dot (P3-P1) ) / ( N dot (P2-P1) )
                     *
                     * If the denominator is zero, the line is parallel to the plane.
                     *
                     * @author Scott Vorthmann
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mPlane.isImpossible() || this.mLine.isImpossible())
                            return this.setStateVariable(null, true);
                        const p1 = this.mLine.getStart();
                        const p1p2 = this.mLine.getDirection();
                        const n = this.mPlane.getNormal();
                        const p3 = this.mPlane.getBase();
                        const p = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(p1, p1p2, p3, n);
                        if (p == null)
                            return this.setStateVariable(null, true);
                        else
                            return this.setStateVariable(p, false);
                    }
                }
                construction.LinePlaneIntersectionPoint = LinePlaneIntersectionPoint;
                LinePlaneIntersectionPoint["__class"] = "com.vzome.core.construction.LinePlaneIntersectionPoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Point[]} points
                 * @class
                 * @extends com.vzome.core.construction.Point
                 */
                class CentroidPoint extends com.vzome.core.construction.Point {
                    constructor(points) {
                        super(points[0].field);
                        if (this.mPoints === undefined) {
                            this.mPoints = null;
                        }
                        this.mPoints = points;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        let centroid = this.mPoints[0].getLocation();
                        let num = 1;
                        for (let i = 1; i < this.mPoints.length; i++) {
                            {
                                centroid = centroid.plus(this.mPoints[i].getLocation());
                                num++;
                            }
                            ;
                        }
                        centroid = centroid.scale(this.field['createRational$long$long'](1, num));
                        return this.setStateVariable(centroid, false);
                    }
                }
                construction.CentroidPoint = CentroidPoint;
                CentroidPoint["__class"] = "com.vzome.core.construction.CentroidPoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Segment} seg
                 * @param {boolean} start
                 * @class
                 * @extends com.vzome.core.construction.Point
                 */
                class SegmentEndPoint extends com.vzome.core.construction.Point {
                    constructor(seg, start) {
                        if (((seg != null && seg instanceof com.vzome.core.construction.Segment) || seg === null) && ((typeof start === 'boolean') || start === null)) {
                            let __args = arguments;
                            super(seg.field);
                            if (this.mSegment === undefined) {
                                this.mSegment = null;
                            }
                            this.start = false;
                            this.mSegment = seg;
                            this.start = start;
                            this.mapParamsToState();
                        }
                        else if (((seg != null && seg instanceof com.vzome.core.construction.Segment) || seg === null) && start === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let start = false;
                                super(seg.field);
                                if (this.mSegment === undefined) {
                                    this.mSegment = null;
                                }
                                this.start = false;
                                this.mSegment = seg;
                                this.start = start;
                                this.mapParamsToState();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mSegment.isImpossible())
                            return this.setStateVariable(null, true);
                        const loc = this.start ? this.mSegment.getStart() : this.mSegment.getEnd();
                        return this.setStateVariable(loc, false);
                    }
                }
                construction.SegmentEndPoint = SegmentEndPoint;
                SegmentEndPoint["__class"] = "com.vzome.core.construction.SegmentEndPoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandJoinPoints extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandJoinPoints.PARAM_SIGNATURE == null) {
                        CommandJoinPoints.PARAM_SIGNATURE = [["start", com.vzome.core.construction.Point], ["end", com.vzome.core.construction.Point]];
                    } return CommandJoinPoints.PARAM_SIGNATURE; }
                    static ATTR_SIGNATURE_$LI$() { if (CommandJoinPoints.ATTR_SIGNATURE == null) {
                        CommandJoinPoints.ATTR_SIGNATURE = [];
                    } return CommandJoinPoints.ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandJoinPoints.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandJoinPoints.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    ordersSelection() {
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        const result = new com.vzome.core.construction.ConstructionList();
                        if (parameters == null || parameters.size() !== 2)
                            throw new commands.Command.Failure("parameters must be two points");
                        try {
                            const pt1 = parameters.get(0);
                            const pt2 = parameters.get(1);
                            const segment = new com.vzome.core.construction.SegmentJoiningPoints(pt1, pt2);
                            result.addConstruction(segment);
                            effects['constructionAdded$com_vzome_core_construction_Construction'](segment);
                        }
                        catch (e) {
                            throw new commands.Command.Failure("parameters must be two points");
                        }
                        return result;
                    }
                }
                commands.CommandJoinPoints = CommandJoinPoints;
                CommandJoinPoints["__class"] = "com.vzome.core.commands.CommandJoinPoints";
                CommandJoinPoints["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandTransform extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setFixedAttributes(attributes, format) {
                        if (format.getScale() !== 0)
                            attributes.put(CommandTransform.SCALE_ATTR_NAME, format.getScale());
                        super.setFixedAttributes(attributes, format);
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        return null;
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandTransform.PARAM_SIGNATURE == null) {
                        CommandTransform.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Construction]];
                    } return CommandTransform.PARAM_SIGNATURE; }
                    static ATTR_SIGNATURE_$LI$() { if (CommandTransform.ATTR_SIGNATURE == null) {
                        CommandTransform.ATTR_SIGNATURE = [[CommandTransform.SYMMETRY_CENTER_ATTR_NAME, com.vzome.core.construction.Point]];
                    } return CommandTransform.ATTR_SIGNATURE; }
                    static AXIS_ATTR_SIGNATURE_$LI$() { if (CommandTransform.AXIS_ATTR_SIGNATURE == null) {
                        CommandTransform.AXIS_ATTR_SIGNATURE = [[CommandTransform.SYMMETRY_CENTER_ATTR_NAME, com.vzome.core.construction.Point], [CommandTransform.SYMMETRY_AXIS_ATTR_NAME, com.vzome.core.construction.Segment]];
                    } return CommandTransform.AXIS_ATTR_SIGNATURE; }
                    static GROUP_ATTR_SIGNATURE_$LI$() { if (CommandTransform.GROUP_ATTR_SIGNATURE == null) {
                        CommandTransform.GROUP_ATTR_SIGNATURE = [[CommandTransform.SYMMETRY_CENTER_ATTR_NAME, com.vzome.core.construction.Point], [CommandTransform.SYMMETRY_GROUP_ATTR_NAME, "com.vzome.core.math.symmetry.Symmetry"]];
                    } return CommandTransform.GROUP_ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandTransform.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandTransform.AXIS_ATTR_SIGNATURE_$LI$();
                    }
                    transform(params, transform, effects) {
                        const output = new com.vzome.core.construction.ConstructionList();
                        effects['constructionAdded$com_vzome_core_construction_Construction'](transform);
                        for (let index = 0; index < params.length; index++) {
                            let param = params[index];
                            {
                                const result = transform.transform$com_vzome_core_construction_Construction(param);
                                if (result == null)
                                    continue;
                                effects['constructionAdded$com_vzome_core_construction_Construction'](result);
                                output.addConstruction(result);
                            }
                        }
                        return output;
                    }
                }
                CommandTransform.SYMMETRY_GROUP_ATTR_NAME = "symmetry.group";
                CommandTransform.SYMMETRY_CENTER_ATTR_NAME = "symmetry.center";
                CommandTransform.SYMMETRY_AXIS_ATTR_NAME = "symmetry.axis.segment";
                CommandTransform.SCALE_ATTR_NAME = "scale.factor";
                commands.CommandTransform = CommandTransform;
                CommandTransform["__class"] = "com.vzome.core.commands.CommandTransform";
                CommandTransform["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandBuildAnchoredSegment extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     */
                    getXml(xml, attributes) {
                        com.vzome.core.commands.XmlSymmetryFormat.serializeAxis(xml, "symm", "dir", "index", "sense", attributes.get("axis"));
                        com.vzome.core.commands.XmlSaveFormat.serializeNumber(xml, "len", attributes.get("length"));
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @return {com.vzome.core.commands.AttributeMap}
                     */
                    setXml(xml, format) {
                        const attrs = super.setXml(xml, format);
                        if (format.commandEditsCompacted()) {
                            attrs.put("axis", format.parseAxis(xml, "symm", "dir", "index", "sense"));
                            attrs.put("length", format.parseNumber(xml, "len"));
                        }
                        return attrs;
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandBuildAnchoredSegment.PARAM_SIGNATURE == null) {
                        CommandBuildAnchoredSegment.PARAM_SIGNATURE = [["start", com.vzome.core.construction.Point]];
                    } return CommandBuildAnchoredSegment.PARAM_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandBuildAnchoredSegment.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return null;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        const result = new com.vzome.core.construction.ConstructionList();
                        if (parameters == null || parameters.size() !== 1)
                            throw new commands.Command.Failure("start parameter must be a single point");
                        const c = parameters.get(0);
                        if (!(c != null && c instanceof com.vzome.core.construction.Point))
                            throw new commands.Command.Failure("start parameter must be a single point");
                        const pt1 = c;
                        const axis = attrs.get(CommandBuildAnchoredSegment.AXIS_ATTR);
                        const len = attrs.get(CommandBuildAnchoredSegment.LENGTH_ATTR);
                        const segment = new com.vzome.core.construction.AnchoredSegment(axis, len, pt1);
                        effects['constructionAdded$com_vzome_core_construction_Construction'](segment);
                        result.addConstruction(segment);
                        const pt2 = new com.vzome.core.construction.SegmentEndPoint(segment);
                        effects['constructionAdded$com_vzome_core_construction_Construction'](pt2);
                        result.addConstruction(pt2);
                        return result;
                    }
                }
                CommandBuildAnchoredSegment.AXIS_ATTR = "axis";
                CommandBuildAnchoredSegment.LENGTH_ATTR = "length";
                commands.CommandBuildAnchoredSegment = CommandBuildAnchoredSegment;
                CommandBuildAnchoredSegment["__class"] = "com.vzome.core.commands.CommandBuildAnchoredSegment";
                CommandBuildAnchoredSegment["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.math.symmetry.IcosahedralSymmetry} symmetry
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandExecuteZomicScript extends com.vzome.core.commands.AbstractCommand {
                    constructor(symmetry) {
                        if (((symmetry != null && symmetry instanceof com.vzome.core.math.symmetry.IcosahedralSymmetry) || symmetry === null)) {
                            let __args = arguments;
                            super();
                            if (this.symmetry === undefined) {
                                this.symmetry = null;
                            }
                            this.symmetry = symmetry;
                        }
                        else if (symmetry === undefined) {
                            let __args = arguments;
                            super();
                            if (this.symmetry === undefined) {
                                this.symmetry = null;
                            }
                            this.symmetry = null;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setFixedAttributes(attributes, format) {
                        super.setFixedAttributes(attributes, format);
                        this.symmetry = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME);
                        if (this.symmetry == null)
                            this.symmetry = format.parseSymmetry("icosahedral");
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandExecuteZomicScript.PARAM_SIGNATURE == null) {
                        CommandExecuteZomicScript.PARAM_SIGNATURE = [["start", com.vzome.core.construction.Point]];
                    } return CommandExecuteZomicScript.PARAM_SIGNATURE; }
                    static ATTR_SIGNATURE_$LI$() { if (CommandExecuteZomicScript.ATTR_SIGNATURE == null) {
                        CommandExecuteZomicScript.ATTR_SIGNATURE = [[CommandExecuteZomicScript.SCRIPT_ATTR, com.vzome.core.zomic.program.ZomicStatement]];
                    } return CommandExecuteZomicScript.ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandExecuteZomicScript.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandExecuteZomicScript.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        const script = attrs.get(CommandExecuteZomicScript.SCRIPT_ATTR);
                        const result = new com.vzome.core.construction.ConstructionList();
                        if (parameters.size() !== 1)
                            throw new commands.Command.Failure("start parameter must be a single connector");
                        const c = parameters.get(0);
                        if (!(c != null && c instanceof com.vzome.core.construction.Point))
                            throw new commands.Command.Failure("start parameter must be a connector");
                        const pt1 = c;
                        try {
                            this.symmetry.interpretScript(script, "zomic", pt1, this.symmetry, effects);
                        }
                        catch (e) {
                            throw new commands.Command.Failure(e.message, e);
                        }
                        return result;
                    }
                }
                CommandExecuteZomicScript.SCRIPT_ATTR = "script";
                commands.CommandExecuteZomicScript = CommandExecuteZomicScript;
                CommandExecuteZomicScript["__class"] = "com.vzome.core.commands.CommandExecuteZomicScript";
                CommandExecuteZomicScript["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandTauDivision extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandTauDivision.PARAM_SIGNATURE == null) {
                        CommandTauDivision.PARAM_SIGNATURE = [["start", com.vzome.core.construction.Point], ["end", com.vzome.core.construction.Point]];
                    } return CommandTauDivision.PARAM_SIGNATURE; }
                    static ATTR_SIGNATURE_$LI$() { if (CommandTauDivision.ATTR_SIGNATURE == null) {
                        CommandTauDivision.ATTR_SIGNATURE = [];
                    } return CommandTauDivision.ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandTauDivision.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandTauDivision.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    ordersSelection() {
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        const result = new com.vzome.core.construction.ConstructionList();
                        if (parameters == null || parameters.size() !== 2)
                            throw new commands.Command.Failure("Tau division applies to two balls.");
                        try {
                            const start = parameters.get(0);
                            const end = parameters.get(1);
                            const join = new com.vzome.core.construction.SegmentJoiningPoints(start, end);
                            const midpoint = new com.vzome.core.construction.SegmentTauDivision(join);
                            result.addConstruction(midpoint);
                            effects['constructionAdded$com_vzome_core_construction_Construction'](midpoint);
                        }
                        catch (e) {
                            throw new commands.Command.Failure("Tau division applies to two balls.");
                        }
                        return result;
                    }
                }
                commands.CommandTauDivision = CommandTauDivision;
                CommandTauDivision["__class"] = "com.vzome.core.commands.CommandTauDivision";
                CommandTauDivision["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class CommandPolygon extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandPolygon.PARAM_SIGNATURE == null) {
                        CommandPolygon.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Point]];
                    } return CommandPolygon.PARAM_SIGNATURE; }
                    static ATTR_SIGNATURE_$LI$() { if (CommandPolygon.ATTR_SIGNATURE == null) {
                        CommandPolygon.ATTR_SIGNATURE = [];
                    } return CommandPolygon.ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandPolygon.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandPolygon.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    ordersSelection() {
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        const points = (new java.util.ArrayList());
                        {
                            let array = parameters.getConstructions();
                            for (let index = 0; index < array.length; index++) {
                                let param = array[index];
                                {
                                    if (param != null && param instanceof com.vzome.core.construction.Point) {
                                        points.add(param);
                                    }
                                }
                            }
                        }
                        let errorMsg = null;
                        if (points.size() < 3) {
                            errorMsg = "A polygon requires at least three vertices.";
                        }
                        else if (points.get(0).is3d() && points.get(1).is3d() && points.get(1).is3d()) {
                            const normal = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(points.get(0).getLocation(), points.get(1).getLocation(), points.get(2).getLocation());
                            if (normal.isOrigin()) {
                                errorMsg = "First 3 points cannot be collinear.";
                            }
                            else {
                                let base = null;
                                for (let index = points.iterator(); index.hasNext();) {
                                    let point = index.next();
                                    {
                                        if (base == null) {
                                            base = point.getLocation();
                                        }
                                        else {
                                            if (!point.getLocation().minus(base).dot(normal).isZero()) {
                                                errorMsg = "Points are not coplanar.";
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (errorMsg != null && attrs.get(com.vzome.core.commands.Command.LOADING_FROM_FILE) == null) {
                            throw new commands.Command.Failure(errorMsg);
                        }
                        const poly = new com.vzome.core.construction.PolygonFromVertices(points);
                        if (errorMsg != null) {
                            poly.setFailed();
                        }
                        else {
                            effects['constructionAdded$com_vzome_core_construction_Construction'](poly);
                        }
                        const result = new com.vzome.core.construction.ConstructionList();
                        result.addConstruction(poly);
                        return result;
                    }
                }
                commands.CommandPolygon = CommandPolygon;
                CommandPolygon["__class"] = "com.vzome.core.commands.CommandPolygon";
                CommandPolygon["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandCentroid extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandCentroid.PARAM_SIGNATURE == null) {
                        CommandCentroid.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Point]];
                    } return CommandCentroid.PARAM_SIGNATURE; }
                    static ATTR_SIGNATURE_$LI$() { if (CommandCentroid.ATTR_SIGNATURE == null) {
                        CommandCentroid.ATTR_SIGNATURE = [];
                    } return CommandCentroid.ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getParameterSignature() {
                        return CommandCentroid.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandCentroid.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        const result = new com.vzome.core.construction.ConstructionList();
                        if (parameters == null || parameters.size() === 0)
                            throw new commands.Command.Failure("Select two or more balls to compute their centroid.");
                        const params = parameters.getConstructions();
                        const verticesList = (new java.util.ArrayList());
                        for (let index = 0; index < params.length; index++) {
                            let param = params[index];
                            {
                                if (param != null && param instanceof com.vzome.core.construction.Point) {
                                    verticesList.add(param);
                                }
                            }
                        }
                        if (verticesList.isEmpty())
                            throw new commands.Command.Failure("Select two or more balls to compute their centroid.");
                        const points = [];
                        const centroid = new com.vzome.core.construction.CentroidPoint(verticesList.toArray(points));
                        effects['constructionAdded$com_vzome_core_construction_Construction'](centroid);
                        result.addConstruction(centroid);
                        return result;
                    }
                }
                commands.CommandCentroid = CommandCentroid;
                CommandCentroid["__class"] = "com.vzome.core.commands.CommandCentroid";
                CommandCentroid["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Point} intersection
                 * @param {com.vzome.core.construction.Segment} normal
                 * @class
                 * @extends com.vzome.core.construction.Plane
                 */
                class PlaneFromNormalSegment extends com.vzome.core.construction.Plane {
                    constructor(intersection, normal) {
                        super(intersection.field);
                        if (this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal === undefined) {
                            this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal = null;
                        }
                        if (this.mIntersection === undefined) {
                            this.mIntersection = null;
                        }
                        this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal = normal;
                        this.mIntersection = intersection;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal.isImpossible() || this.mIntersection.isImpossible())
                            return this.setStateVariables(null, null, true);
                        return this.setStateVariables(this.mIntersection.getLocation(), this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal.getOffset(), false);
                    }
                }
                construction.PlaneFromNormalSegment = PlaneFromNormalSegment;
                PlaneFromNormalSegment["__class"] = "com.vzome.core.construction.PlaneFromNormalSegment";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Polygon} polygon
                 * @class
                 * @extends com.vzome.core.construction.Plane
                 */
                class PlaneExtensionOfPolygon extends com.vzome.core.construction.Plane {
                    constructor(polygon) {
                        super(polygon.field);
                        if (this.mPolygon === undefined) {
                            this.mPolygon = null;
                        }
                        this.mPolygon = polygon;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mPolygon.isImpossible()) {
                            return this.setStateVariables(null, null, true);
                        }
                        return this.setStateVariables(this.mPolygon.getVertex(0), this.mPolygon.getNormal(), false);
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.Trivector3dHomogeneous}
                     */
                    getHomogeneous() {
                        const v1 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mPolygon.getVertex(0), this.getField());
                        const v2 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mPolygon.getVertex(1), this.getField());
                        const v3 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mPolygon.getVertex(2), this.getField());
                        return v1.outer(v2).outer(v3);
                    }
                }
                construction.PlaneExtensionOfPolygon = PlaneExtensionOfPolygon;
                PlaneExtensionOfPolygon["__class"] = "com.vzome.core.construction.PlaneExtensionOfPolygon";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.algebra.AlgebraicVector} point
                 * @param {com.vzome.core.algebra.AlgebraicVector} normal
                 * @class
                 * @extends com.vzome.core.construction.Plane
                 */
                class PlaneFromPointAndNormal extends com.vzome.core.construction.Plane {
                    constructor(point, normal) {
                        super(point.getField());
                        if (this.normal === undefined) {
                            this.normal = null;
                        }
                        if (this.point === undefined) {
                            this.point = null;
                        }
                        this.point = point;
                        this.normal = normal;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.normal.isOrigin())
                            return this.setStateVariables(null, null, true);
                        return this.setStateVariables(this.point, this.normal, false);
                    }
                }
                construction.PlaneFromPointAndNormal = PlaneFromPointAndNormal;
                PlaneFromPointAndNormal["__class"] = "com.vzome.core.construction.PlaneFromPointAndNormal";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param step
                 * @param start
                 * @param end
                 * @param {com.vzome.core.construction.Line} l1
                 * @param {com.vzome.core.construction.Line} l2
                 * @param {com.vzome.core.construction.Point} p
                 * @class
                 * @extends com.vzome.core.construction.Line
                 * @author Scott Vorthmann
                 */
                class PerpendicularLine extends com.vzome.core.construction.Line {
                    constructor(l1, l2, p) {
                        super(l1.field);
                        if (this.mLine1 === undefined) {
                            this.mLine1 = null;
                        }
                        if (this.mLine2 === undefined) {
                            this.mLine2 = null;
                        }
                        if (this.mPoint === undefined) {
                            this.mPoint = null;
                        }
                        this.mLine1 = l1;
                        this.mLine2 = l2;
                        this.mPoint = p;
                        this.mapParamsToState();
                    }
                    /**
                     * returns true if something changed.
                     * @return
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mLine1.isImpossible() || this.mLine2.isImpossible() || this.mPoint.isImpossible()) {
                            return this.setStateVariables(null, null, true);
                        }
                        const normal = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.mLine1.getDirection(), this.mLine2.getDirection());
                        return this.setStateVariables(this.mPoint.getLocation(), normal, normal.isOrigin());
                    }
                }
                construction.PerpendicularLine = PerpendicularLine;
                PerpendicularLine["__class"] = "com.vzome.core.construction.PerpendicularLine";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Segment} seg
                 * @class
                 * @extends com.vzome.core.construction.Line
                 */
                class LineExtensionOfSegment extends com.vzome.core.construction.Line {
                    constructor(seg) {
                        super(seg.field);
                        if (this.mSegment === undefined) {
                            this.mSegment = null;
                        }
                        this.mSegment = seg;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mSegment.isImpossible())
                            return this.setStateVariables(null, null, true);
                        return this.setStateVariables(this.mSegment.getStart(), this.mSegment.getOffset(), false);
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.Bivector3dHomogeneous}
                     */
                    getHomogeneous() {
                        const v1 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mSegment.getStart(), this.getField());
                        const v2 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mSegment.getEnd(), this.getField());
                        return v1.outer(v2);
                    }
                }
                construction.LineExtensionOfSegment = LineExtensionOfSegment;
                LineExtensionOfSegment["__class"] = "com.vzome.core.construction.LineExtensionOfSegment";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.algebra.AlgebraicVector} point
                 * @param {com.vzome.core.algebra.AlgebraicVector} direction
                 * @class
                 * @extends com.vzome.core.construction.Line
                 */
                class LineFromPointAndVector extends com.vzome.core.construction.Line {
                    constructor(point, direction) {
                        super(point.getField());
                        if (this.point === undefined) {
                            this.point = null;
                        }
                        if (this.direction === undefined) {
                            this.direction = null;
                        }
                        this.point = point;
                        this.direction = direction;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.direction.isOrigin())
                            return this.setStateVariables(null, null, true);
                        return this.setStateVariables(this.point, this.direction, false);
                    }
                }
                construction.LineFromPointAndVector = LineFromPointAndVector;
                LineFromPointAndVector["__class"] = "com.vzome.core.construction.LineFromPointAndVector";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    class ChangeSelection extends com.vzome.core.editor.api.SideEffects {
                        constructor(selection) {
                            super();
                            if (this.mSelection === undefined) {
                                this.mSelection = null;
                            }
                            if (this.groupingDoneInSelection === undefined) {
                                this.groupingDoneInSelection = false;
                            }
                            this.orderedSelection = false;
                            this.selectionEffects = null;
                            this.mSelection = selection;
                            this.groupingDoneInSelection = false;
                        }
                        static logger_$LI$() { if (ChangeSelection.logger == null) {
                            ChangeSelection.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor.ChangeSelection");
                        } return ChangeSelection.logger; }
                        setOrderedSelection(orderedSelection) {
                            this.orderedSelection = orderedSelection;
                        }
                        /**
                         *
                         */
                        undo() {
                            if (this.orderedSelection) {
                                const stack = (new java.util.ArrayDeque());
                                this.selectionEffects = stack;
                                super.undo();
                                this.selectionEffects = null;
                                while ((!stack.isEmpty())) {
                                    {
                                        const se = stack.pop();
                                        se.undo();
                                    }
                                }
                                ;
                            }
                            else
                                super.undo();
                        }
                        getXmlAttributes(element) {
                        }
                        setXmlAttributes(xml, format) {
                        }
                        /**
                         *
                         * @param {*} doc
                         * @return {*}
                         */
                        getXml(doc) {
                            const result = doc.createElement(this.getXmlElementName());
                            if (this.groupingDoneInSelection)
                                com.vzome.xml.DomUtils.addAttribute(result, "grouping", "2.1.1");
                            this.getXmlAttributes(result);
                            return result;
                        }
                        adjustSelection(man, action) {
                            switch ((action)) {
                                case com.vzome.core.editor.api.ActionEnum.SELECT:
                                    this.select$com_vzome_core_model_Manifestation(man);
                                    break;
                                case com.vzome.core.editor.api.ActionEnum.DESELECT:
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                    break;
                                case com.vzome.core.editor.api.ActionEnum.IGNORE:
                                    break;
                                default:
                                    ChangeSelection.logger_$LI$().warning("unexpected action: " + /* Enum.name */ com.vzome.core.editor.api.ActionEnum[action]);
                                    break;
                            }
                        }
                        /**
                         * Any subclass can override to alter loading, or migrate (insert other edits), etc.
                         * ALWAYS DO SOME INSERT, or all trace of the command will disappear!
                         * @param {*} xml
                         * @param {com.vzome.core.commands.XmlSaveFormat} format
                         * @param {*} context
                         */
                        loadAndPerform(xml, format, context) {
                            const grouping = xml.getAttribute("grouping");
                            if (this.groupingAware() && (format.groupingDoneInSelection() || ("2.1.1" === grouping)))
                                this.groupingDoneInSelection = true;
                            this.setXmlAttributes(xml, format);
                            context.performAndRecord(this);
                        }
                        groupingAware() {
                            return false;
                        }
                        unselect$com_vzome_core_model_Manifestation(man) {
                            this.unselect$com_vzome_core_model_Manifestation$boolean(man, false);
                        }
                        unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups) {
                            if (this.groupingDoneInSelection) {
                                this.plan(new ChangeSelection.SelectManifestation(this, man, false));
                                return;
                            }
                            if (man == null) {
                                api.SideEffects.logBugAccommodation("null manifestation");
                                return;
                            }
                            if (!this.mSelection.manifestationSelected(man))
                                return;
                            const group = ignoreGroups ? null : com.vzome.core.editor.api.Selection.biggestGroup(man);
                            if (group == null)
                                this.plan(new ChangeSelection.SelectManifestation(this, man, false));
                            else
                                this.unselectGroup(group);
                        }
                        unselect(man, ignoreGroups) {
                            if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                                return this.unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups);
                            }
                            else if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                                return this.unselect$com_vzome_core_model_Manifestation(man);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        select$com_vzome_core_model_Manifestation(man) {
                            this.select$com_vzome_core_model_Manifestation$boolean(man, false);
                        }
                        recordSelected(man) {
                            if (!this.mSelection.manifestationSelected(man))
                                return;
                            this.plan(new ChangeSelection.RecordSelectedManifestation(this, man));
                        }
                        select$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups) {
                            if (this.groupingDoneInSelection) {
                                this.plan(new ChangeSelection.SelectManifestation(this, man, true));
                                return;
                            }
                            if (man == null) {
                                api.SideEffects.logBugAccommodation("null manifestation");
                                return;
                            }
                            if (this.mSelection.manifestationSelected(man))
                                return;
                            const group = ignoreGroups ? null : com.vzome.core.editor.api.Selection.biggestGroup(man);
                            if (group == null)
                                this.plan(new ChangeSelection.SelectManifestation(this, man, true));
                            else
                                this.selectGroup(group);
                        }
                        select(man, ignoreGroups) {
                            if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                                return this.select$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups);
                            }
                            else if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                                return this.select$com_vzome_core_model_Manifestation(man);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        selectGroup(group) {
                            for (let index = group.iterator(); index.hasNext();) {
                                let next = index.next();
                                {
                                    if (next != null && next instanceof com.vzome.core.model.Group)
                                        this.selectGroup(next);
                                    else
                                        this.plan(new ChangeSelection.SelectManifestation(this, next, true));
                                }
                            }
                        }
                        unselectGroup(group) {
                            for (let index = group.iterator(); index.hasNext();) {
                                let next = index.next();
                                {
                                    if (next != null && next instanceof com.vzome.core.model.Group)
                                        this.unselectGroup(next);
                                    else
                                        this.plan(new ChangeSelection.SelectManifestation(this, next, false));
                                }
                            }
                        }
                        getSelectedConnectors() {
                            return com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(this.mSelection);
                        }
                        getSelectedStruts() {
                            return com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(this.mSelection);
                        }
                        getSelectedPanels() {
                            return com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.mSelection);
                        }
                        getLastSelectedManifestation() {
                            let last = null;
                            for (let index = this.mSelection.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    last = man;
                                }
                            }
                            return last;
                        }
                        getLastSelectedConnector() {
                            let last = null;
                            for (let index = this.getSelectedConnectors().iterator(); index.hasNext();) {
                                let connector = index.next();
                                {
                                    last = connector;
                                }
                            }
                            return last;
                        }
                        getLastSelectedStrut() {
                            let last = null;
                            for (let index = this.getSelectedStruts().iterator(); index.hasNext();) {
                                let strut = index.next();
                                {
                                    last = strut;
                                }
                            }
                            return last;
                        }
                        getLastSelectedPanel() {
                            let last = null;
                            for (let index = this.getSelectedPanels().iterator(); index.hasNext();) {
                                let panel = index.next();
                                {
                                    last = panel;
                                }
                            }
                            return last;
                        }
                        unselectAll() {
                            let anySelected = false;
                            for (let index = this.mSelection.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    anySelected = true;
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                }
                            }
                            if (anySelected) {
                                this.redo();
                            }
                            return anySelected;
                        }
                        unselectConnectors() {
                            let anySelected = false;
                            for (let index = this.getSelectedConnectors().iterator(); index.hasNext();) {
                                let connector = index.next();
                                {
                                    anySelected = true;
                                    this.unselect$com_vzome_core_model_Manifestation(connector);
                                }
                            }
                            if (anySelected) {
                                this.redo();
                            }
                            return anySelected;
                        }
                        unselectStruts() {
                            let anySelected = false;
                            for (let index = this.getSelectedStruts().iterator(); index.hasNext();) {
                                let strut = index.next();
                                {
                                    anySelected = true;
                                    this.unselect$com_vzome_core_model_Manifestation(strut);
                                }
                            }
                            if (anySelected) {
                                this.redo();
                            }
                            return anySelected;
                        }
                        unselectPanels() {
                            let anySelected = false;
                            for (let index = this.getSelectedPanels().iterator(); index.hasNext();) {
                                let panel = index.next();
                                {
                                    anySelected = true;
                                    this.unselect$com_vzome_core_model_Manifestation(panel);
                                }
                            }
                            if (anySelected) {
                                this.redo();
                            }
                            return anySelected;
                        }
                    }
                    api.ChangeSelection = ChangeSelection;
                    ChangeSelection["__class"] = "com.vzome.core.editor.api.ChangeSelection";
                    (function (ChangeSelection) {
                        class SelectManifestation {
                            constructor(__parent, man, value) {
                                this.__parent = __parent;
                                if (this.mMan === undefined) {
                                    this.mMan = null;
                                }
                                if (this.mOn === undefined) {
                                    this.mOn = false;
                                }
                                this.mMan = man;
                                this.mOn = value;
                                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().finest("constructing SelectManifestation");
                            }
                            /**
                             *
                             */
                            redo() {
                                if (this.__parent.groupingDoneInSelection) {
                                    if (this.mOn)
                                        this.__parent.mSelection.selectWithGrouping(this.mMan);
                                    else
                                        this.__parent.mSelection.unselectWithGrouping(this.mMan);
                                }
                                else if (this.mOn)
                                    this.__parent.mSelection.select(this.mMan);
                                else
                                    this.__parent.mSelection.unselect(this.mMan);
                            }
                            /**
                             *
                             */
                            undo() {
                                if (this.__parent.groupingDoneInSelection) {
                                    if (this.mOn)
                                        this.__parent.mSelection.unselectWithGrouping(this.mMan);
                                    else
                                        this.__parent.mSelection.selectWithGrouping(this.mMan);
                                }
                                else if (this.mOn)
                                    this.__parent.mSelection.unselect(this.mMan);
                                else if (this.__parent.selectionEffects != null) {
                                    this.__parent.selectionEffects.push(this);
                                }
                                else
                                    this.__parent.mSelection.select(this.mMan);
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                const result = this.mOn ? doc.createElement("select") : doc.createElement("deselect");
                                if (this.mMan != null) {
                                    const man = this.mMan.getXml(doc);
                                    result.appendChild(man);
                                }
                                return result;
                            }
                        }
                        ChangeSelection.SelectManifestation = SelectManifestation;
                        SelectManifestation["__class"] = "com.vzome.core.editor.api.ChangeSelection.SelectManifestation";
                        SelectManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];
                        class RecordSelectedManifestation {
                            constructor(__parent, man) {
                                this.__parent = __parent;
                                if (this.mMan === undefined) {
                                    this.mMan = null;
                                }
                                this.mMan = man;
                                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().finest("constructing RecordSelectedManifestation");
                            }
                            /**
                             *
                             */
                            redo() {
                                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().finest("redoing RecordSelectedManifestation");
                            }
                            /**
                             *
                             */
                            undo() {
                                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().finest("undoing RecordSelectedManifestation");
                                if (this.__parent.selectionEffects == null)
                                    this.__parent.mSelection.select(this.mMan);
                                else
                                    this.__parent.selectionEffects.push(this);
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                return doc.createElement("recordSelected");
                            }
                        }
                        ChangeSelection.RecordSelectedManifestation = RecordSelectedManifestation;
                        RecordSelectedManifestation["__class"] = "com.vzome.core.editor.api.ChangeSelection.RecordSelectedManifestation";
                        RecordSelectedManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];
                    })(ChangeSelection = api.ChangeSelection || (api.ChangeSelection = {}));
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_16) {
                class TetrahedralToolFactory extends com.vzome.core.tools.OctahedralToolFactory {
                    constructor(tools, symmetry) {
                        super(tools, symmetry, TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_ID, TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_LABEL, "icosahedral" === symmetry.getName() ? TetrahedralToolFactory.TOOLTIP1 : TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_TOOLTIP2);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        if (!((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(id, "tetrahedral"))
                            id = "tetrahedral." + id;
                        return new com.vzome.core.tools.SymmetryTool(id, this.getSymmetry(), this.getToolsModel());
                    }
                }
                TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_ID = "tetrahedral";
                TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_LABEL = "Create a tetrahedral symmetry tool";
                TetrahedralToolFactory.TOOLTIP1 = "<p>Each tool produces up to 11 copies of the input<br>selection, using the rotation symmetries of a<br>tetrahedron.  To create a tool, select a ball<br>that defines the center of symmetry, and a single<br>blue or green strut, defining one of five<br>possible orientations for the symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 24 symmetries of the tetrahedron, including<br>reflections.<br></p>";
                TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_TOOLTIP2 = "<p>Each tool produces up to 11 copies of the input<br>selection, using the rotation symmetries of a<br>tetrahedron.  To create a tool, select a ball<br>that defines the center of symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 24 symmetries of the tetrahedron, including<br>reflections.<br></p>";
                tools_16.TetrahedralToolFactory = TetrahedralToolFactory;
                TetrahedralToolFactory["__class"] = "com.vzome.core.tools.TetrahedralToolFactory";
                TetrahedralToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_17) {
                /**
                 * Used for the throwaway factories used to create predefined tools.
                 * Using the symmetry name in the factory ID prevents collisions across
                 * symmetries for common tools.
                 * @param {com.vzome.core.editor.ToolsModel} tools
                 * @param {*} symmetry
                 * @param {boolean} useSymmetryName
                 * @class
                 * @extends com.vzome.core.tools.RotationToolFactory
                 */
                class AxialSymmetryToolFactory extends com.vzome.core.tools.RotationToolFactory {
                    constructor(tools, symmetry, useSymmetryName = false) {
                        super(tools, symmetry, (useSymmetryName ? symmetry.getName() + ' ' : "") + AxialSymmetryToolFactory.ID, AxialSymmetryToolFactory.__com_vzome_core_tools_AxialSymmetryToolFactory_LABEL, AxialSymmetryToolFactory.__com_vzome_core_tools_AxialSymmetryToolFactory_TOOLTIP);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.RotationTool(id, this.getSymmetry(), this.getToolsModel(), true);
                    }
                }
                AxialSymmetryToolFactory.ID = "axial symmetry";
                AxialSymmetryToolFactory.__com_vzome_core_tools_AxialSymmetryToolFactory_LABEL = "Create a rotational symmetry tool";
                AxialSymmetryToolFactory.__com_vzome_core_tools_AxialSymmetryToolFactory_TOOLTIP = "<p>Each tool creates enough copies of the selected objects to<br>create rotational symmetry around an axis.  To create a tool,<br>select a strut that defines that axis,  You can also define<br>the direction and center independently, by selecting a ball<br>for the center and a strut for the axis.  Note: not all struts<br>correspond to rotational symmetries!<br><br>Combine with a point reflection or mirror reflection tool to<br>achieve more symmetries.<br></p>";
                tools_17.AxialSymmetryToolFactory = AxialSymmetryToolFactory;
                AxialSymmetryToolFactory["__class"] = "com.vzome.core.tools.AxialSymmetryToolFactory";
                AxialSymmetryToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                /**
                 * @author David Hall
                 * @param {number} polygonSides
                 * @param {*} factory
                 * @class
                 * @extends com.vzome.core.algebra.ParameterizedField
                 */
                class PolygonField extends com.vzome.core.algebra.ParameterizedField {
                    constructor(name, polygonSides, factory) {
                        if (((typeof name === 'string') || name === null) && ((typeof polygonSides === 'number') || polygonSides === null) && ((factory != null && (factory.constructor != null && factory.constructor["__interfaces"] != null && factory.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumberFactory") >= 0)) || factory === null)) {
                            let __args = arguments;
                            super(name, PolygonField.getOrder(polygonSides), factory);
                            if (this.__isEven === undefined) {
                                this.__isEven = false;
                            }
                            if (this.goldenRatio === undefined) {
                                this.goldenRatio = null;
                            }
                            if (this.__polygonSides === undefined) {
                                this.__polygonSides = 0;
                            }
                            if (this.normalizerMatrix === undefined) {
                                this.normalizerMatrix = null;
                            }
                            this.__polygonSides = polygonSides;
                            this.validate();
                            this.initialize();
                            this.__isEven = polygonSides % 2 === 0;
                            this.goldenRatio = this.getDiagonalRatio$int(5);
                        }
                        else if (((typeof name === 'number') || name === null) && ((polygonSides != null && (polygonSides.constructor != null && polygonSides.constructor["__interfaces"] != null && polygonSides.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumberFactory") >= 0)) || polygonSides === null) && factory === undefined) {
                            let __args = arguments;
                            let polygonSides = __args[0];
                            let factory = __args[1];
                            {
                                let __args = arguments;
                                let name = PolygonField.FIELD_PREFIX + __args[1];
                                super(name, PolygonField.getOrder(polygonSides), factory);
                                if (this.__isEven === undefined) {
                                    this.__isEven = false;
                                }
                                if (this.goldenRatio === undefined) {
                                    this.goldenRatio = null;
                                }
                                if (this.__polygonSides === undefined) {
                                    this.__polygonSides = 0;
                                }
                                if (this.normalizerMatrix === undefined) {
                                    this.normalizerMatrix = null;
                                }
                                this.__polygonSides = polygonSides;
                                this.validate();
                                this.initialize();
                                this.__isEven = polygonSides % 2 === 0;
                                this.goldenRatio = this.getDiagonalRatio$int(5);
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {number} nSides
                     * @return {double[]} the coefficients of a PolygonField given the same parameter.
                     * This can be used to determine when two fields have compatible coefficients
                     * without having to generate an instance of the class.
                     */
                    static getFieldCoefficients(nSides) {
                        const order = PolygonField.getOrder(nSides);
                        const coefficients = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(order);
                        const diagLengths = PolygonField.getDiagonalLengths(nSides);
                        for (let i = 0; i < order; i++) {
                            {
                                coefficients[i] = diagLengths[i];
                            }
                            ;
                        }
                        return coefficients;
                    }
                    /**
                     *
                     * @param {number} nSides
                     * @return {double[]} an array with the unique lengths in increasing order
                     * of the diagonals of a regular N-gon having a unit edge length.
                     */
                    static getDiagonalLengths(nSides) {
                        const count = PolygonField.diagonalCount(nSides);
                        const diagLengths = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(count);
                        const unitLength = Math.sin(PolygonField.PI / nSides);
                        diagLengths[0] = 1.0;
                        for (let i = 1; i < count; i++) {
                            {
                                diagLengths[i] = Math.sin((i + 1) * PolygonField.PI / nSides) / unitLength;
                            }
                            ;
                        }
                        switch ((nSides)) {
                            case 6:
                                diagLengths[2] = 2.0;
                                diagLengths[1] = Math.sqrt(3);
                                break;
                            case 5:
                                diagLengths[1] = (1.0 + Math.sqrt(5.0)) / 2.0;
                                break;
                        }
                        return diagLengths;
                    }
                    static getOrder(nSides) {
                        return PolygonField.primaryDiagonalCount(nSides);
                    }
                    static diagonalCount(nSides) {
                        return (nSides / 2 | 0);
                    }
                    static primaryDiagonalCount(nSides) {
                        return (((n => n < 0 ? Math.ceil(n) : Math.floor(n))(PolygonField.eulerTotient(2 * nSides) / 2)) | 0);
                    }
                    static secondaryDiagonalCount(nSides) {
                        return PolygonField.diagonalCount(nSides) - PolygonField.primaryDiagonalCount(nSides);
                    }
                    static eulerTotient(n) {
                        let result = n;
                        for (let i = 2; i * i <= n; i++) {
                            {
                                if (n % i === 0)
                                    result -= (n => n < 0 ? Math.ceil(n) : Math.floor(n))(result / i);
                                while ((n % i === 0)) {
                                    {
                                        n = (n => n < 0 ? Math.ceil(n) : Math.floor(n))(n / i);
                                    }
                                }
                                ;
                            }
                            ;
                        }
                        if (n > 1) {
                            result -= (n => n < 0 ? Math.ceil(n) : Math.floor(n))(result / n);
                        }
                        return result;
                    }
                    static isPowerOfTwo(n) {
                        return (n !== 0) && ((n & -n) === n);
                    }
                    isPrime(n) {
                        return this.numberFactory.isPrime(n);
                    }
                    /*private*/ distinctPrimeFactors(n) {
                        const factors = (new java.util.ArrayList());
                        for (let prime = 2; prime <= n; prime = this.numberFactory.nextPrime(prime)) {
                            {
                                if (n % prime === 0) {
                                    factors.add(prime);
                                }
                                while ((n % prime === 0)) {
                                    {
                                        n = (n => n < 0 ? Math.ceil(n) : Math.floor(n))(n / prime);
                                    }
                                }
                                ;
                            }
                            ;
                        }
                        return factors;
                    }
                    getNormalizedMultiplicationTensor(nSides) {
                        const tensor = PolygonField.getExtendedMultiplicationTensor(nSides);
                        if (this.isPrime(nSides) || PolygonField.isPowerOfTwo(nSides)) {
                            return tensor;
                        }
                        const length = PolygonField.primaryDiagonalCount(nSides);
                        const result = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return 0;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([length, length, length]);
                        for (let i = 0; i < length; i++) {
                            {
                                for (let j = 0; j < length; j++) {
                                    {
                                        for (let k = 0; k < length; k++) {
                                            {
                                                result[i][j][k] = tensor[i][j][k];
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        const normalizerMatrix = this.getNormalizerMatrix(nSides);
                        let n = 0;
                        for (let term = length; term < PolygonField.diagonalCount(nSides); term++) {
                            {
                                for (let r = 0; r < length; r++) {
                                    {
                                        for (let c = 0; c < length; c++) {
                                            {
                                                const omit = tensor[term][r][c];
                                                if (omit !== 0) {
                                                    for (let t = 0; t < length; t++) {
                                                        {
                                                            const alt = normalizerMatrix[n][t];
                                                            if (alt !== 0) {
                                                                const adjust = omit * alt;
                                                                result[t][r][c] = ((result[t][r][c] + adjust) | 0);
                                                            }
                                                        }
                                                        ;
                                                    }
                                                }
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                                n++;
                            }
                            ;
                        }
                        return result;
                    }
                    getNormalizerMatrix(nSides) {
                        if (nSides < PolygonField.MIN_SIDES) {
                            throw new java.lang.IllegalArgumentException("nSides = " + nSides + " but must be greater than or equal to " + PolygonField.MIN_SIDES);
                        }
                        const nSecondaryDiags = PolygonField.secondaryDiagonalCount(nSides);
                        if (nSecondaryDiags === 0) {
                            return null;
                        }
                        const nPrimaryDiags = PolygonField.primaryDiagonalCount(nSides);
                        const nDiags = nPrimaryDiags + nSecondaryDiags;
                        const primeFactors = this.distinctPrimeFactors(nSides);
                        if (primeFactors.get(0) === 2) {
                            primeFactors.remove(0);
                        }
                        let nEquations = 0;
                        for (let index = primeFactors.iterator(); index.hasNext();) {
                            let prime = index.next();
                            {
                                nEquations += (nDiags / /* intValue */ (prime | 0) | 0);
                            }
                        }
                        const primaryDiags = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return null;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([nEquations, nPrimaryDiags]);
                        const secondaryDiags = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return null;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([nEquations, nSecondaryDiags]);
                        let equationRow = 0;
                        for (let index = primeFactors.iterator(); index.hasNext();) {
                            let factor = index.next();
                            {
                                const period = (nSides / factor | 0);
                                const steps = (period / 2 | 0);
                                const parity = period % 2;
                                for (let step = 0; step < steps; step++) {
                                    {
                                        let n = (step === 0 && parity === 0) ? 2 : 1;
                                        if (nSides % 2 === parity) {
                                            n *= -1;
                                        }
                                        const terms = (s => { let a = []; while (s-- > 0)
                                            a.push(0); return a; })(nDiags);
                                        terms[step] = 1;
                                        for (let mid = period - parity; mid < nDiags; mid += period) {
                                            {
                                                terms[mid + step + parity] = terms[mid - step] = n;
                                                n *= -1;
                                            }
                                            ;
                                        }
                                        primaryDiags[equationRow] = (s => { let a = []; while (s-- > 0)
                                            a.push(null); return a; })(nPrimaryDiags);
                                        secondaryDiags[equationRow] = (s => { let a = []; while (s-- > 0)
                                            a.push(null); return a; })(nSecondaryDiags);
                                        for (let t = 0; t < terms.length; t++) {
                                            {
                                                let term = terms[t];
                                                if (t < nSecondaryDiags) {
                                                    secondaryDiags[equationRow][t] = this.numberFactory.createBigRational(term, 1);
                                                }
                                                else {
                                                    term *= -1;
                                                    primaryDiags[equationRow][t - nSecondaryDiags] = this.numberFactory.createBigRational(term, 1);
                                                }
                                            }
                                            ;
                                        }
                                        equationRow++;
                                    }
                                    ;
                                }
                            }
                        }
                        const rank = com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(secondaryDiags, primaryDiags);
                        if (rank !== nSecondaryDiags) {
                            throw new java.lang.IllegalStateException("System of equations has unexpected rank: " + rank);
                        }
                        for (let r = rank; r < primaryDiags.length; r++) {
                            {
                                for (let c = 0; c < primaryDiags[0].length; c++) {
                                    {
                                        if (!primaryDiags[r][c].isZero()) {
                                            throw new java.lang.IllegalStateException("System of equations is inconsistent. Rank = " + rank);
                                        }
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        const results = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return 0;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([rank, nPrimaryDiags]);
                        for (let r = 0; r < rank; r++) {
                            {
                                for (let c = nPrimaryDiags - 1; c >= 0; c--) {
                                    {
                                        const bigTerm = primaryDiags[rank - 1 - r][nPrimaryDiags - 1 - c];
                                        results[r][c] = /* shortValue */ (javaemul.internal.DoubleHelper.valueOf(bigTerm.evaluate()) | 0);
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return results;
                    }
                    static getExtendedMultiplicationTensor(nSides) {
                        const nDiags = PolygonField.diagonalCount(nSides);
                        const tensor = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                            return 0;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([nDiags, nDiags, nDiags]);
                        for (let i = 0; i < nDiags; i++) {
                            {
                                for (let j = 0; j < nDiags; j++) {
                                    {
                                        for (let k = 0; k < nDiags; k++) {
                                            {
                                                tensor[i][j][k] = 0;
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        for (let layer = 0; layer < nDiags; layer++) {
                            {
                                const midWay = (layer / 2 | 0);
                                for (let bx = layer, by = 0; bx > midWay || bx === by; bx--, by++) {
                                    {
                                        for (let x = bx, y = by; x < nDiags && y < nDiags; x++, y++) {
                                            {
                                                tensor[layer][y][x] += 1;
                                                if (x !== y) {
                                                    tensor[layer][x][y] += 1;
                                                }
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        const box = nSides - 2;
                        const parity = (nSides + 1) % 2;
                        for (let layer = 0; layer < nDiags - parity; layer++) {
                            {
                                const base = box - layer;
                                for (let xb = base, yb = 0; xb >= 0; xb--, yb++) {
                                    {
                                        let x = xb;
                                        let y = yb;
                                        while ((x < nDiags && y < nDiags)) {
                                            {
                                                tensor[layer][y][x] += 1;
                                                x++;
                                                y++;
                                            }
                                        }
                                        ;
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return tensor;
                    }
                    static subscriptString(i) {
                        return /* replace */ /* replace */ /* replace */ /* replace */ /* replace */ /* replace */ /* replace */ /* replace */ /* replace */ /* replace */ /* replace */ /* replace */ /* toString */ ('' + (i)).split("0").join("\u2080").split("1").join("\u2081").split("2").join("\u2082").split("3").join("\u2083").split("4").join("\u2084").split("5").join("\u2085").split("6").join("\u2086").split("7").join("\u2087").split("8").join("\u2088").split("9").join("\u2089").split("+").join("\u208a").split("-").join("\u208b");
                    }
                    /**
                     *
                     * u = units numerator
                     * U = units denominator
                     * p = phis numerator
                     * P = phis denominator
                     * ____ = 0,1
                     * COMBO ... see comments inline below
                     * Remapping the 4 element pairs array [u,U, p,P]
                     * looks like this based on polygonSides:
                     * 5  [  u, U,   p, P] // unchanged
                     * 10  [ COMBO,  ____,   p, P    ... // the two units elements combine all of the input pairs
                     * 15  [  u, U,  -p,-P,   ____,   p, P    ...
                     * 20  [  u, U,   ____,  -p,-P,   ____,   p, P    ...
                     * 25  [  u, U,   ____,   ____,  -p,-P,   ____,   p, P    ...
                     * 30  [  u, U,   ____,   ____,   ____,  -p,-P,   ____,   p, P    ...
                     * 35  [  u, U,   ____,   ____,   ____,   ____,  -p,-P,   ____,   p, P    ...
                     * 40  [  u, U,   ____,   ____,   ____,   ____,   ____,  -p,-P,   ____,   p, P    ...
                     * 45  [  u, U,   ____,   ____,   ____,   ____,   ____,   ____,  -p,-P,   ____,   p, P    ...
                     * index   0  1    2  3    4  5    6  7    8  9   10 11   12 13   14 15   16 17   18 19
                     * @param {long[]} pairs
                     * @return {long[]}
                     */
                    convertGoldenNumberPairs(pairs) {
                        if (this.__polygonSides % 5 === 0 && pairs.length === 4 && this.getOrder() > 2) {
                            const u = pairs[0];
                            const U = pairs[1];
                            const p = pairs[2];
                            const P = pairs[3];
                            const remapped = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(2 * this.getOrder());
                            for (let den = 1; den < remapped.length; den += 2) {
                                {
                                    remapped[den] = 1;
                                }
                                ;
                            }
                            const i = ((this.__polygonSides / 5 | 0)) * 2;
                            remapped[i - 4] = -p;
                            remapped[i - 3] = P;
                            remapped[i + 0] = p;
                            remapped[i + 1] = P;
                            if (this.__polygonSides === 10) {
                                remapped[0] = PolygonField.safeSubtract((u * P), (U * p));
                                remapped[1] = U * P;
                            }
                            else {
                                remapped[0] = u;
                                remapped[1] = U;
                            }
                            return remapped;
                        }
                        return pairs;
                    }
                    /**
                     * @param {number} j
                     * @param {number} k
                     * @return {number} a long that equals j - k
                     * @throws ArithmeticException if the subtraction causes an integer overflow
                     */
                    static safeSubtract(j, k) {
                        const result = j - k;
                        if ((k > 0 && result >= j) || (k < 0 && result <= j)) {
                            throw new java.lang.ArithmeticException("Arithmetic Overflow: " + j + " - " + k + " = " + result + ". Result exceeds the size of a long.");
                        }
                        return result;
                    }
                    diagonalCount() {
                        return PolygonField.diagonalCount(this.polygonSides());
                    }
                    /**
                     *
                     * @return {double[]}
                     */
                    getCoefficients() {
                        return PolygonField.getFieldCoefficients(this.polygonSides());
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getAffineScalar() {
                        return this.getUnitDiagonal(2);
                    }
                    validate() {
                        if (this.polygonSides() < PolygonField.MIN_SIDES) {
                            const msg = "polygon sides = " + this.polygonSides() + ". It must be at least " + PolygonField.MIN_SIDES + ".";
                            throw new java.lang.IllegalArgumentException(msg);
                        }
                    }
                    /**
                     *
                     */
                    initializeLabels() {
                        const nSides = this.polygonSides();
                        if (this.irrationalLabels.length !== PolygonField.diagonalCount(nSides)) {
                            const unitLabels = this.irrationalLabels[0];
                            this.irrationalLabels = (function (dims) { let allocate = function (dims) { if (dims.length === 0) {
                                return null;
                            }
                            else {
                                let array = [];
                                for (let i = 0; i < dims[0]; i++) {
                                    array.push(allocate(dims.slice(1)));
                                }
                                return array;
                            } }; return allocate(dims); })([PolygonField.diagonalCount(nSides), unitLabels.length]);
                            this.irrationalLabels[0] = unitLabels;
                        }
                        switch ((this.polygonSides())) {
                            case 4:
                                this.irrationalLabels[1] = ["\u221a2", "sqrtTwo"];
                                break;
                            case 5:
                                this.irrationalLabels[1] = ["\u03c6", "phi"];
                                break;
                            case 6:
                                this.irrationalLabels[1] = ["\u221a3", "sqrtThree"];
                                this.irrationalLabels[2] = ["\u03b2", "beta"];
                                break;
                            case 7:
                                this.irrationalLabels[1] = ["\u03c1", "rho"];
                                this.irrationalLabels[2] = ["\u03c3", "sigma"];
                                break;
                            case 9:
                                this.irrationalLabels[1] = ["\u03b1", "alpha"];
                                this.irrationalLabels[2] = ["\u03b2", "beta"];
                                this.irrationalLabels[3] = ["\u03b3", "gamma"];
                                break;
                            case 11:
                                this.irrationalLabels[1] = ["\u03b8", "theta"];
                                this.irrationalLabels[2] = ["\u03ba", "kappa"];
                                this.irrationalLabels[3] = ["\u03bb", "lambda"];
                                this.irrationalLabels[4] = ["\u03bc", "mu"];
                                break;
                            case 13:
                                this.irrationalLabels[1] = ["\u03b1", "alpha"];
                                this.irrationalLabels[2] = ["\u03b2", "beta"];
                                this.irrationalLabels[3] = ["\u03b3", "gamma"];
                                this.irrationalLabels[4] = ["\u03b4", "delta"];
                                this.irrationalLabels[5] = ["\u03b5", "epsilon"];
                                break;
                            default:
                                const alphabet = "abcdefghijklmnopqrstuvwxyz";
                                const length = this.irrationalLabels.length;
                                if (length - 1 <= alphabet.length) {
                                    for (let i = 1; i < length; i++) {
                                        {
                                            const name = alphabet.substring(i - 1, i);
                                            this.irrationalLabels[i] = [name, "d[" + i + "]"];
                                        }
                                        ;
                                    }
                                }
                                else {
                                    for (let i = 1; i < this.irrationalLabels.length; i++) {
                                        {
                                            this.irrationalLabels[i] = ["d" + PolygonField.subscriptString(i), "d[" + i + "]"];
                                        }
                                        ;
                                    }
                                }
                                break;
                        }
                    }
                    /**
                     * getUnitTerm(n) expects n < getOrder().
                     * This method handles normalized diagonal lengths
                     * where getOrder() <= n < diagonalCount()
                     * In these cases, the resulting AlgebraicNumber will not have just the nth term set to 1,
                     * but rather, will have the normalized equivalent.
                     * For example, since a normalized PolygonField(6) is of order 2, but diagonalCount() == 3,
                     * PolygonField(6).getUnitTerm(2) would return an AlgebraicNumber with terms of {2,0} rather than {0,0,1}.
                     * @param {number} n
                     * @return {*}
                     */
                    getUnitDiagonal(n) {
                        if (n >= this.getOrder() && n < this.diagonalCount()) {
                            const terms = this.zero().toTrailingDivisor();
                            const row = n - this.getOrder();
                            for (let i = 0; i < this.getOrder(); i++) {
                                {
                                    const term = this.normalizerMatrix[row][i];
                                    if (term !== 0) {
                                        terms[i] = term;
                                    }
                                }
                                ;
                            }
                            return this.createAlgebraicNumberFromTD(terms);
                        }
                        return super.getUnitTerm(n);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getGoldenRatio() {
                        return this.goldenRatio;
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {*}
                     */
                    getNumberByName(name) {
                        switch ((name)) {
                            case "\u221a2":
                            case "root2":
                            case "sqrt2":
                                return this.getRoot2();
                            case "\u221a3":
                            case "root3":
                            case "sqrt3":
                                return this.getRoot3();
                            case "\u221a5":
                            case "root5":
                            case "sqrt5":
                                return super.getNumberByName("root5");
                            case "\u221a6":
                            case "root6":
                            case "sqrt6":
                                return this.getRoot6();
                            case "\u221a7":
                            case "root7":
                            case "sqrt7":
                                return this.getRoot7();
                            case "\u221a8":
                            case "root8":
                            case "sqrt8":
                                return super.getNumberByName("root8");
                            case "\u221a10":
                            case "root10":
                            case "sqrt10":
                                return this.getRoot10();
                            case "rho":
                                return this.getDiagonalRatio$int(7);
                            case "sigma":
                                return this.getDiagonalRatio$int$int(7, 3);
                            case "alpha":
                                return this.getDiagonalRatio$int$int((this.__polygonSides % 9 === 0 ? 9 : 13), 2);
                            case "beta":
                                return this.getDiagonalRatio$int$int((this.__polygonSides % 9 === 0 ? 9 : 13), 3);
                            case "gamma":
                                return this.getDiagonalRatio$int$int((this.__polygonSides % 9 === 0 ? 9 : 13), 4);
                            case "delta":
                                return this.getDiagonalRatio$int$int(13, 5);
                            case "epsilon":
                                return this.getDiagonalRatio$int$int(13, 6);
                            case "theta":
                                return this.getDiagonalRatio$int$int(11, 2);
                            case "kappa":
                                return this.getDiagonalRatio$int$int(11, 3);
                            case "lambda":
                                return this.getDiagonalRatio$int$int(11, 4);
                            case "mu":
                                return this.getDiagonalRatio$int$int(11, 5);
                        }
                        return super.getNumberByName(name);
                    }
                    /*private*/ getRoot2() {
                        return this.getDiagonalRatio$int(4);
                    }
                    /*private*/ getRoot3() {
                        return this.getDiagonalRatio$int(6);
                    }
                    /*private*/ getRoot6() {
                        const r3 = this.getNumberByName("root3");
                        if (r3 != null) {
                            const r2 = this.getNumberByName("root2");
                            return r2 == null ? null : r2['times$com_vzome_core_algebra_AlgebraicNumber'](r3);
                        }
                        return null;
                    }
                    /*private*/ getRoot7() {
                        if (this.__polygonSides % 14 === 0) {
                            const n = (this.__polygonSides / 14 | 0);
                            const d0 = this.getUnitDiagonal((1 * n) - 1).negate();
                            const d1 = this.getUnitDiagonal((2 * n) - 1);
                            const d2 = this.getUnitDiagonal((3 * n) - 1);
                            const d3 = this.getUnitDiagonal((4 * n) - 1);
                            const d4 = this.getUnitDiagonal((5 * n) - 1);
                            const d5 = this.getUnitDiagonal((6 * n) - 1);
                            const cotA = d4.dividedBy(d1);
                            const cotB = d2.dividedBy(d3);
                            const cotC = d0.dividedBy(d5);
                            return cotA['plus$com_vzome_core_algebra_AlgebraicNumber'](cotB)['plus$com_vzome_core_algebra_AlgebraicNumber'](cotC);
                        }
                        return null;
                    }
                    /*private*/ getRoot10() {
                        const r5 = this.getNumberByName("root5");
                        if (r5 != null) {
                            const r2 = this.getNumberByName("root2");
                            return r2 == null ? null : r2['times$com_vzome_core_algebra_AlgebraicNumber'](r5);
                        }
                        return null;
                    }
                    /*private*/ getDiagonalRatio$int(divisor) {
                        return this.getDiagonalRatio$int$int(divisor, 2);
                    }
                    getDiagonalRatio$int$int(divisor, step) {
                        if (this.__polygonSides % divisor === 0 && step > 1 && step * 2 <= this.__polygonSides) {
                            const n = (this.__polygonSides / divisor | 0);
                            const denominator = this.getUnitDiagonal(n - 1);
                            const numerator = this.getUnitDiagonal((step * n) - 1);
                            return numerator.dividedBy(denominator);
                        }
                        return null;
                    }
                    getDiagonalRatio(divisor, step) {
                        if (((typeof divisor === 'number') || divisor === null) && ((typeof step === 'number') || step === null)) {
                            return this.getDiagonalRatio$int$int(divisor, step);
                        }
                        else if (((typeof divisor === 'number') || divisor === null) && step === undefined) {
                            return this.getDiagonalRatio$int(divisor);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     */
                    initializeCoefficients() {
                        const temp = this.getCoefficients();
                        for (let i = 0; i < this.coefficients.length; i++) {
                            {
                                this.coefficients[i] = temp[i];
                            }
                            ;
                        }
                    }
                    /**
                     *
                     */
                    initializeMultiplicationTensor() {
                        this.multiplicationTensor = this.getNormalizedMultiplicationTensor(this.polygonSides());
                    }
                    /**
                     *
                     */
                    initializeNormalizer() {
                        this.normalizerMatrix = this.getNormalizerMatrix(this.polygonSides());
                    }
                    polygonSides() {
                        return this.__polygonSides;
                    }
                    isEven() {
                        return this.__isEven;
                    }
                    isOdd() {
                        return !this.__isEven;
                    }
                }
                PolygonField.PI = 3.141592653589793;
                PolygonField.FIELD_PREFIX = "polygon";
                PolygonField.MIN_SIDES = 4;
                algebra.PolygonField = PolygonField;
                PolygonField["__class"] = "com.vzome.core.algebra.PolygonField";
                PolygonField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                /**
                 * @author David Hall
                 * @param {*} factory
                 * @class
                 * @extends com.vzome.core.algebra.ParameterizedField
                 */
                class SnubDodecahedronField extends com.vzome.core.algebra.ParameterizedField {
                    constructor(factory) {
                        super(SnubDodecahedronField.FIELD_NAME, 6, factory);
                        this.initialize();
                    }
                    /**
                     *
                     * @return {double[]} the coefficients of this AlgebraicField class.
                     * This can be used to determine when two fields have compatible coefficients
                     * without having to generate an instance of the class.
                     */
                    static getFieldCoefficients() {
                        const PHI_VALUE = (1.0 + Math.sqrt(5.0)) / 2.0;
                        const XI_VALUE = 1.7155614996973678;
                        return [1.0, PHI_VALUE, XI_VALUE, PHI_VALUE * XI_VALUE, XI_VALUE * XI_VALUE, PHI_VALUE * XI_VALUE * XI_VALUE];
                    }
                    /**
                     *
                     * @return {double[]}
                     */
                    getCoefficients() {
                        return SnubDodecahedronField.getFieldCoefficients();
                    }
                    /**
                     *
                     */
                    initializeCoefficients() {
                        const temp = this.getCoefficients();
                        let i = 0;
                        for (let index = 0; index < temp.length; index++) {
                            let coefficient = temp[index];
                            {
                                this.coefficients[i++] = coefficient;
                            }
                        }
                    }
                    /**
                     *
                     */
                    initializeMultiplicationTensor() {
                        const mm = [[[1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0]], [[0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 2], [0, 0, 1, 1, 0, 0], [0, 0, 1, 2, 0, 0]], [[0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 2, 0], [0, 1, 0, 0, 0, 2], [0, 0, 2, 0, 0, 1], [0, 0, 0, 2, 1, 1]], [[0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 2], [1, 1, 0, 0, 2, 2], [0, 0, 0, 2, 1, 1], [0, 0, 2, 2, 1, 2]], [[0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 2, 0], [0, 1, 0, 0, 0, 2]], [[0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 2], [1, 1, 0, 0, 2, 2]]];
                        this.multiplicationTensor = mm;
                    }
                    /**
                     *
                     */
                    initializeLabels() {
                        this.irrationalLabels[1] = ["\u03c6", "phi"];
                        this.irrationalLabels[2] = ["\u03be", "xi"];
                        this.irrationalLabels[3] = ["\u03c6\u03be", "phi*xi"];
                        this.irrationalLabels[4] = ["\u03be\u00b2", "xi^2"];
                        this.irrationalLabels[5] = ["\u03c6\u03be\u00b2", "phi*xi^2"];
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getNumMultipliers() {
                        return 2;
                    }
                    /**
                     * scalar for an affine pentagon
                     * @return {*}
                     */
                    getAffineScalar() {
                        return this.getGoldenRatio();
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getGoldenRatio() {
                        return this.getUnitTerm(1);
                    }
                }
                SnubDodecahedronField.FIELD_NAME = "snubDodecahedron";
                algebra.SnubDodecahedronField = SnubDodecahedronField;
                SnubDodecahedronField["__class"] = "com.vzome.core.algebra.SnubDodecahedronField";
                SnubDodecahedronField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                /**
                 * @author David Hall
                 * @param {*} factory
                 * @class
                 * @extends com.vzome.core.algebra.ParameterizedField
                 */
                class SnubCubeField extends com.vzome.core.algebra.ParameterizedField {
                    constructor(factory) {
                        super(SnubCubeField.FIELD_NAME, 3, factory);
                        this.initialize();
                    }
                    /**
                     *
                     * @param radicand
                     * @return {double[]} the coefficients of a SnubCubeField.
                     * This can be used to determine when two fields have compatible coefficients
                     * without having to generate an instance of the class.
                     */
                    static getFieldCoefficients() {
                        const tribonacciConstant = (1.0 + /* cbrt */ Math.pow(19.0 - (3.0 * Math.sqrt(33)), 1 / 3) + /* cbrt */ Math.pow(19.0 + (3.0 * Math.sqrt(33)), 1 / 3)) / 3.0;
                        return [1.0, tribonacciConstant, tribonacciConstant * tribonacciConstant];
                    }
                    /**
                     *
                     * @return {double[]}
                     */
                    getCoefficients() {
                        return SnubCubeField.getFieldCoefficients();
                    }
                    /**
                     *
                     */
                    initializeCoefficients() {
                        const temp = this.getCoefficients();
                        let i = 0;
                        for (let index = 0; index < temp.length; index++) {
                            let coefficient = temp[index];
                            {
                                this.coefficients[i++] = coefficient;
                            }
                        }
                    }
                    /**
                     *
                     */
                    initializeMultiplicationTensor() {
                        const mm = [[[1, 0, 0], [0, 0, 1], [0, 1, 1]], [[0, 1, 0], [1, 0, 1], [0, 1, 2]], [[0, 0, 1], [0, 1, 1], [1, 1, 2]]];
                        this.multiplicationTensor = mm;
                    }
                    /**
                     *
                     */
                    initializeLabels() {
                        this.irrationalLabels[1] = ["\u03c8", "psi"];
                        this.irrationalLabels[2] = ["\u03c8\u00b2", "psi^2"];
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getNumMultipliers() {
                        return 1;
                    }
                }
                SnubCubeField.FIELD_NAME = "snubCube";
                algebra.SnubCubeField = SnubCubeField;
                SnubCubeField["__class"] = "com.vzome.core.algebra.SnubCubeField";
                SnubCubeField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class PlasticPhiField extends com.vzome.core.algebra.ParameterizedField {
                    constructor(factory) {
                        super(PlasticPhiField.FIELD_NAME, 6, factory);
                        this.initialize();
                    }
                    /**
                     * @return {double[]} the coefficients of a PlasticPhiField.
                     * This can be used to determine when two fields have compatible coefficients
                     * without having to generate an instance of the class.
                     */
                    static getFieldCoefficients() {
                        const plasticNumber = 1.32471795724475;
                        const phi = (1.0 + Math.sqrt(5)) / 2.0;
                        return [1.0, phi, plasticNumber, plasticNumber * phi, plasticNumber * plasticNumber, plasticNumber * plasticNumber * phi];
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getNumMultipliers() {
                        return 2;
                    }
                    /**
                     *
                     * @return {double[]}
                     */
                    getCoefficients() {
                        return PlasticPhiField.getFieldCoefficients();
                    }
                    /**
                     *
                     */
                    initializeCoefficients() {
                        const temp = this.getCoefficients();
                        let i = 0;
                        for (let index = 0; index < temp.length; index++) {
                            let coefficient = temp[index];
                            {
                                this.coefficients[i++] = coefficient;
                            }
                        }
                    }
                    /**
                     *
                     */
                    initializeMultiplicationTensor() {
                        const tensor = [[[1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0]], [[0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0]], [[0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1]], [[0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1], [0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1]], [[0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 1]], [[0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1]]];
                        this.multiplicationTensor = tensor;
                    }
                    /**
                     *
                     */
                    initializeLabels() {
                        const upperRho = "\u03a1";
                        const lowerPhi = "\u03c6";
                        this.irrationalLabels[1] = [lowerPhi, "phi"];
                        this.irrationalLabels[2] = [upperRho, "P"];
                        this.irrationalLabels[3] = [upperRho + "\u03c6", "Pphi"];
                        this.irrationalLabels[4] = [upperRho + "\u00b2", "P^2"];
                        this.irrationalLabels[5] = [upperRho + "\u00b2\u03c6", "P^2phi"];
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getGoldenRatio() {
                        return this.getUnitTerm(1);
                    }
                }
                PlasticPhiField.FIELD_NAME = "plasticPhi";
                algebra.PlasticPhiField = PlasticPhiField;
                PlasticPhiField["__class"] = "com.vzome.core.algebra.PlasticPhiField";
                PlasticPhiField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class EdPeggField extends com.vzome.core.algebra.ParameterizedField {
                    constructor(factory) {
                        super(EdPeggField.FIELD_NAME, 3, factory);
                        this.initialize();
                    }
                    /**
                     *
                     * @return {double[]} the coefficients of an EdPeggField.
                     * This can be used to determine when two fields have compatible coefficients
                     * without having to generate an instance of the class.
                     */
                    static getFieldCoefficients() {
                        const a = 1.76929235423863;
                        return [1.0, a, a * a];
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getNumMultipliers() {
                        return 1;
                    }
                    /**
                     *
                     * @return {double[]}
                     */
                    getCoefficients() {
                        return EdPeggField.getFieldCoefficients();
                    }
                    /**
                     *
                     */
                    initializeCoefficients() {
                        const temp = this.getCoefficients();
                        let i = 0;
                        for (let index = 0; index < temp.length; index++) {
                            let coefficient = temp[index];
                            {
                                this.coefficients[i++] = coefficient;
                            }
                        }
                    }
                    /**
                     *
                     */
                    initializeMultiplicationTensor() {
                        const mt = [[[1, 0, 0], [0, 0, 2], [0, 2, 0]], [[0, 1, 0], [1, 0, 2], [0, 2, 2]], [[0, 0, 1], [0, 1, 0], [1, 0, 2]]];
                        this.multiplicationTensor = mt;
                    }
                    /**
                     *
                     */
                    initializeLabels() {
                        this.irrationalLabels[1] = ["\u03b5", "epsilon"];
                        this.irrationalLabels[2] = ["\u03b5\u00b2", "epsilon^2"];
                    }
                }
                EdPeggField.FIELD_NAME = "edPegg";
                algebra.EdPeggField = EdPeggField;
                EdPeggField["__class"] = "com.vzome.core.algebra.EdPeggField";
                EdPeggField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class SuperGoldenField extends com.vzome.core.algebra.ParameterizedField {
                    constructor(factory) {
                        super(SuperGoldenField.FIELD_NAME, 3, factory);
                        this.initialize();
                    }
                    /**
                     *
                     * @return {double[]} the coefficients of a SuperGoldenField.
                     * This can be used to determine when two fields have compatible coefficients
                     * without having to generate an instance of the class.
                     */
                    static getFieldCoefficients() {
                        const narayanaCowNumber = 1.465571231876768;
                        return [1.0, narayanaCowNumber, narayanaCowNumber * narayanaCowNumber];
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getNumMultipliers() {
                        return 1;
                    }
                    /**
                     *
                     * @return {double[]}
                     */
                    getCoefficients() {
                        return SuperGoldenField.getFieldCoefficients();
                    }
                    /**
                     *
                     */
                    initializeCoefficients() {
                        const temp = this.getCoefficients();
                        let i = 0;
                        for (let index = 0; index < temp.length; index++) {
                            let coefficient = temp[index];
                            {
                                this.coefficients[i++] = coefficient;
                            }
                        }
                    }
                    /**
                     *
                     */
                    initializeMultiplicationTensor() {
                        const mt = [[[1, 0, 0], [0, 0, 1], [0, 1, 1]], [[0, 1, 0], [1, 0, 0], [0, 0, 1]], [[0, 0, 1], [0, 1, 1], [1, 1, 1]]];
                        this.multiplicationTensor = mt;
                    }
                    /**
                     *
                     */
                    initializeLabels() {
                        this.irrationalLabels[1] = ["\u03c8", "psi"];
                        this.irrationalLabels[2] = ["\u03c8\u00b2", "psi^2"];
                    }
                }
                SuperGoldenField.FIELD_NAME = "superGolden";
                algebra.SuperGoldenField = SuperGoldenField;
                SuperGoldenField["__class"] = "com.vzome.core.algebra.SuperGoldenField";
                SuperGoldenField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                /**
                 * @author David Hall
                 * @param {*} factory
                 * @class
                 * @extends com.vzome.core.algebra.ParameterizedField
                 */
                class PlasticNumberField extends com.vzome.core.algebra.ParameterizedField {
                    constructor(factory) {
                        super(PlasticNumberField.FIELD_NAME, 3, factory);
                        this.initialize();
                    }
                    /**
                     *
                     * @return {double[]} the coefficients of a PlasticNumberField.
                     * This can be used to determine when two fields have compatible coefficients
                     * without having to generate an instance of the class.
                     */
                    static getFieldCoefficients() {
                        const plasticNumber = 1.32471795724475;
                        return [1.0, plasticNumber, plasticNumber * plasticNumber];
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getNumMultipliers() {
                        return 1;
                    }
                    /**
                     *
                     * @return {double[]}
                     */
                    getCoefficients() {
                        return PlasticNumberField.getFieldCoefficients();
                    }
                    /**
                     *
                     */
                    initializeCoefficients() {
                        const temp = this.getCoefficients();
                        let i = 0;
                        for (let index = 0; index < temp.length; index++) {
                            let coefficient = temp[index];
                            {
                                this.coefficients[i++] = coefficient;
                            }
                        }
                    }
                    /**
                     *
                     */
                    initializeMultiplicationTensor() {
                        const tensor = [[[1, 0, 0], [0, 0, 1], [0, 1, 0]], [[0, 1, 0], [1, 0, 1], [0, 1, 1]], [[0, 0, 1], [0, 1, 0], [1, 0, 1]]];
                        this.multiplicationTensor = tensor;
                    }
                    /**
                     *
                     */
                    initializeLabels() {
                        const upperRho = "\u03a1";
                        this.irrationalLabels[1] = [upperRho, "P"];
                        this.irrationalLabels[2] = [upperRho + "\u00b2", "P^2"];
                    }
                }
                PlasticNumberField.FIELD_NAME = "plasticNumber";
                algebra.PlasticNumberField = PlasticNumberField;
                PlasticNumberField["__class"] = "com.vzome.core.algebra.PlasticNumberField";
                PlasticNumberField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var fields;
        (function (fields) {
            var sqrtphi;
            (function (sqrtphi) {
                /**
                 * @author David Hall
                 * @param {*} factory
                 * @class
                 * @extends com.vzome.core.algebra.ParameterizedField
                 */
                class SqrtPhiField extends com.vzome.core.algebra.ParameterizedField {
                    constructor(factory) {
                        super(SqrtPhiField.FIELD_NAME, 4, factory);
                        this.initialize();
                    }
                    static PHI_VALUE_$LI$() { if (SqrtPhiField.PHI_VALUE == null) {
                        SqrtPhiField.PHI_VALUE = (1.0 + Math.sqrt(5.0)) / 2.0;
                    } return SqrtPhiField.PHI_VALUE; }
                    static SQRT_PHI_VALUE_$LI$() { if (SqrtPhiField.SQRT_PHI_VALUE == null) {
                        SqrtPhiField.SQRT_PHI_VALUE = Math.sqrt(SqrtPhiField.PHI_VALUE_$LI$());
                    } return SqrtPhiField.SQRT_PHI_VALUE; }
                    /**
                     *
                     * @return {double[]} the coefficients of a SqrtPhiField.
                     * This can be used to determine when two fields have compatible coefficients
                     * without having to generate an instance of the class.
                     */
                    static getFieldCoefficients() {
                        return [1.0, SqrtPhiField.SQRT_PHI_VALUE_$LI$(), SqrtPhiField.PHI_VALUE_$LI$(), SqrtPhiField.PHI_VALUE_$LI$() * SqrtPhiField.SQRT_PHI_VALUE_$LI$()];
                    }
                    /**
                     *
                     * @return {number}
                     */
                    getNumMultipliers() {
                        return 1;
                    }
                    /**
                     *
                     * @return {double[]}
                     */
                    getCoefficients() {
                        return SqrtPhiField.getFieldCoefficients();
                    }
                    /**
                     *
                     */
                    initializeCoefficients() {
                        const temp = this.getCoefficients();
                        let i = 0;
                        for (let index = 0; index < temp.length; index++) {
                            let coefficient = temp[index];
                            {
                                this.coefficients[i++] = coefficient;
                            }
                        }
                    }
                    /**
                     *
                     */
                    initializeMultiplicationTensor() {
                        const tensor = [[[1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 1]], [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], [[0, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 2]], [[0, 0, 0, 1], [0, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]];
                        this.multiplicationTensor = tensor;
                    }
                    /**
                     *
                     */
                    initializeLabels() {
                        this.irrationalLabels[1] = ["\u221a\u03c6", "sqrt(phi)"];
                        this.irrationalLabels[2] = ["\u03c6", "phi"];
                        this.irrationalLabels[3] = ["\u03c6\u221a\u03c6", "phi*sqrt(phi)"];
                    }
                    /**
                     *
                     * @param {long[]} pairs
                     * @return {long[]}
                     */
                    convertGoldenNumberPairs(pairs) {
                        return (pairs.length === 4) ? [pairs[0], pairs[1], 0, 1, pairs[2], pairs[3], 0, 1] : pairs;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getGoldenRatio() {
                        return this.getUnitTerm(2);
                    }
                }
                SqrtPhiField.FIELD_NAME = "sqrtPhi";
                sqrtphi.SqrtPhiField = SqrtPhiField;
                SqrtPhiField["__class"] = "com.vzome.fields.sqrtphi.SqrtPhiField";
                SqrtPhiField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
            })(sqrtphi = fields.sqrtphi || (fields.sqrtphi = {}));
        })(fields = vzome.fields || (vzome.fields = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class CommandVanOss600Cell extends com.vzome.core.commands.CommandImportVEFData {
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        try {
                            const input = this.constructor.getClassLoader().getResourceAsStream("com/vzome/core/commands/600cell.vef");
                            const out = new java.io.ByteArrayOutputStream();
                            const buf = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(1024);
                            let num;
                            while (((num = input.read(buf, 0, 1024)) > 0)) {
                                out.write(buf, 0, num);
                            }
                            ;
                            const vefData = new String(out.toByteArray());
                            const result = new com.vzome.core.construction.ConstructionList();
                            let field = attributes.get(com.vzome.core.commands.CommandImportVEFData.FIELD_ATTR_NAME);
                            if (field == null)
                                field = attributes.get(com.vzome.core.commands.Command.FIELD_ATTR_NAME);
                            new CommandVanOss600Cell.VefToModel(this, null, effects).parseVEF(vefData, field);
                            return result;
                        }
                        catch (exc) {
                            throw new com.vzome.core.commands.Command.Failure(exc);
                        }
                    }
                    constructor() {
                        super();
                    }
                }
                commands.CommandVanOss600Cell = CommandVanOss600Cell;
                CommandVanOss600Cell["__class"] = "com.vzome.core.commands.CommandVanOss600Cell";
                CommandVanOss600Cell["__interfaces"] = ["com.vzome.core.commands.Command"];
                (function (CommandVanOss600Cell) {
                    class VefToModel extends com.vzome.core.math.VefParser {
                        constructor(__parent, quaternion, effects) {
                            super();
                            this.__parent = __parent;
                            if (this.mProjection === undefined) {
                                this.mProjection = null;
                            }
                            if (this.mVertices === undefined) {
                                this.mVertices = null;
                            }
                            if (this.mEffects === undefined) {
                                this.mEffects = null;
                            }
                            if (this.mLocations === undefined) {
                                this.mLocations = null;
                            }
                            this.mEffects = effects;
                        }
                        /**
                         *
                         * @param {number} numVertices
                         */
                        startVertices(numVertices) {
                            this.mVertices = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(numVertices);
                            this.mLocations = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(numVertices);
                            this.mProjection = null;
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {com.vzome.core.algebra.AlgebraicVector} location
                         */
                        addVertex(index, location) {
                            this.mLocations[index] = location;
                        }
                        /**
                         *
                         */
                        endVertices() {
                            const field = this.getField();
                            const half = field['createRational$long$long'](1, 2);
                            const quarter = field['createRational$long$long'](1, 4);
                            const centroid = this.mLocations[0].plus(this.mLocations[48]).plus(this.mLocations[50]).plus(this.mLocations[64]).scale(quarter);
                            const edgeCenter = this.mLocations[0].plus(this.mLocations[48]).scale(half);
                            const vertex = this.mLocations[50];
                            const edgeToVertex = vertex.minus(edgeCenter);
                            const edgeToCenter = centroid.minus(edgeCenter);
                            const symmCenter1 = edgeCenter.plus(edgeToCenter.scale(field['createAlgebraicNumber$int$int$int$int'](0, 3, 5, 0)));
                            const symmCenter2 = edgeCenter.plus(edgeToVertex.scale(field['createAlgebraicNumber$int$int$int$int'](0, 2, 5, 0)));
                            const direction = symmCenter2.minus(symmCenter1);
                            const target = symmCenter1.plus(direction.scale(field['createAlgebraicNumber$int$int$int$int'](0, 1, 1, 0)));
                            this.mProjection = new com.vzome.core.math.QuaternionProjection(field, null, target);
                            const power5 = field['createPower$int'](5);
                            for (let i = 0; i < this.mLocations.length; i++) {
                                {
                                    let location = this.mLocations[i].scale(power5);
                                    location = this.mProjection.projectImage(location, this.wFirst());
                                    this.mVertices[i] = new com.vzome.core.construction.FreePoint(location);
                                    this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](this.mVertices[i]);
                                }
                                ;
                            }
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {number} v1
                         * @param {number} v2
                         */
                        addEdge(index, v1, v2) {
                            const p1 = this.mVertices[v1];
                            const p2 = this.mVertices[v2];
                            if (p1 == null || p2 == null) {
                                console.info("skipping " + v1 + " " + v2);
                                return;
                            }
                            const seg = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                            this.mEffects['constructionAdded$com_vzome_core_construction_Construction'](seg);
                        }
                        /**
                         *
                         * @param {number} numEdges
                         */
                        startEdges(numEdges) {
                        }
                        /**
                         *
                         * @param {number} numFaces
                         */
                        startFaces(numFaces) {
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {int[]} verts
                         */
                        addFace(index, verts) {
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {number} vertex
                         */
                        addBall(index, vertex) {
                        }
                        /**
                         *
                         * @param {number} numVertices
                         */
                        startBalls(numVertices) {
                        }
                    }
                    CommandVanOss600Cell.VefToModel = VefToModel;
                    VefToModel["__class"] = "com.vzome.core.commands.CommandVanOss600Cell.VefToModel";
                })(CommandVanOss600Cell = commands.CommandVanOss600Cell || (commands.CommandVanOss600Cell = {}));
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} field
                 * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} qsymm
                 * @param {number} index
                 * @class
                 * @extends com.vzome.core.commands.CommandTransform
                 */
                class CommandUniformH4Polytope extends com.vzome.core.commands.CommandTransform {
                    constructor(field, qsymm, index) {
                        if (((field != null && (field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((qsymm != null && qsymm instanceof com.vzome.core.math.symmetry.QuaternionicSymmetry) || qsymm === null) && ((typeof index === 'number') || index === null)) {
                            let __args = arguments;
                            super();
                            if (this.mRoots === undefined) {
                                this.mRoots = null;
                            }
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            if (this.symm === undefined) {
                                this.symm = null;
                            }
                            this.h4Symms = (new java.util.HashMap());
                            this.mPolytopeIndex = -1;
                            this.quaternionVector = null;
                            this.mPolytopeIndex = index;
                            this.field = field;
                            this.symm = new CommandUniformH4Polytope.H4Symmetry(field);
                            this.mRoots = qsymm.getRoots();
                        }
                        else if (field === undefined && qsymm === undefined && index === undefined) {
                            let __args = arguments;
                            super();
                            if (this.mRoots === undefined) {
                                this.mRoots = null;
                            }
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            if (this.symm === undefined) {
                                this.symm = null;
                            }
                            this.h4Symms = (new java.util.HashMap());
                            this.mPolytopeIndex = -1;
                            this.quaternionVector = null;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setFixedAttributes(attributes, format) {
                        super.setFixedAttributes(attributes, format);
                        this.field = format.getField();
                        this.symm = this.h4Symms.get(this.field.getName());
                        if (this.symm == null) {
                            this.symm = new CommandUniformH4Polytope.H4Symmetry(this.field);
                            this.h4Symms.put(this.field.getName(), this.symm);
                        }
                        this.mRoots = format.getQuaternionicSymmetry("H_4").getRoots();
                    }
                    static logger_$LI$() { if (CommandUniformH4Polytope.logger == null) {
                        CommandUniformH4Polytope.logger = java.util.logging.Logger.getLogger("com.vzome.core.commands.h4polytope");
                    } return CommandUniformH4Polytope.logger; }
                    /**
                     * Only called when migrating a 2.0 model file.
                     * @param {com.vzome.core.algebra.AlgebraicVector} offset
                     */
                    setQuaternion(offset) {
                        this.quaternionVector = offset;
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @return {com.vzome.core.commands.AttributeMap}
                     */
                    setXml(xml, format) {
                        const attrs = super.setXml(xml, format);
                        this.quaternionVector = format.parseRationalVector(xml, "quaternion");
                        return attrs;
                    }
                    /**
                     *
                     * @param {*} result
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     */
                    getXml(result, attributes) {
                        if (this.quaternionVector != null)
                            com.vzome.xml.DomUtils.addAttribute(result, "quaternion", this.quaternionVector.toParsableString());
                        super.getXml(result, attributes);
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return com.vzome.core.commands.CommandTransform.GROUP_ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {string} attrName
                     * @return {boolean}
                     */
                    attributeIs3D(attrName) {
                        if ("symmetry.axis.segment" === attrName)
                            return false;
                        else
                            return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        const SCALE_DOWN_5 = this.field['createPower$int'](-5);
                        let proj = new com.vzome.core.math.Projection.Default(this.field);
                        let leftQuat = null;
                        let rightQuat = null;
                        if (parameters.size() === 0) {
                            rightQuat = this.quaternionVector;
                            const symmAxis = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                            if (rightQuat == null)
                                rightQuat = (symmAxis == null) ? null : symmAxis.getOffset();
                            if (rightQuat != null)
                                rightQuat = rightQuat.scale(SCALE_DOWN_5);
                        }
                        else {
                            let numSegs = 0;
                            for (let index = parameters.iterator(); index.hasNext();) {
                                let cons = index.next();
                                {
                                    if (cons != null && cons instanceof com.vzome.core.construction.Segment) {
                                        const seg = cons;
                                        if (++numSegs === 1)
                                            rightQuat = seg.getOffset().scale(SCALE_DOWN_5);
                                        else if (numSegs === 2)
                                            leftQuat = seg.getOffset().scale(SCALE_DOWN_5);
                                        else
                                            throw new com.vzome.core.commands.Command.Failure("Too many struts to specify quaternion multiplication.");
                                    }
                                }
                            }
                        }
                        if (rightQuat != null)
                            proj = new com.vzome.core.math.QuaternionProjection(this.field, leftQuat, rightQuat);
                        if (this.mPolytopeIndex < 0) {
                            const indexObj = attributes.get(CommandUniformH4Polytope.POLYTOPE_INDEX_ATTR_NAME);
                            this.mPolytopeIndex = indexObj;
                        }
                        else
                            attributes.put(CommandUniformH4Polytope.POLYTOPE_INDEX_ATTR_NAME, this.mPolytopeIndex);
                        this.generate(this.mPolytopeIndex, this.mPolytopeIndex, null, new CommandUniformH4Polytope.ConstructionChangesAdapter(effects, proj, this.field['createPower$int'](5)));
                        return new com.vzome.core.construction.ConstructionList();
                    }
                    generate(index, renderEdges, edgeScales, listener) {
                        const reflections = [null, null, null, null];
                        let prototype = this.symm.getPrototype(index);
                        if (edgeScales != null) {
                            prototype = this.field.origin(4);
                            for (let b = 0; b < 4; b++) {
                                {
                                    const mask = 1 << b;
                                    const test = index & mask;
                                    if (test !== 0) {
                                        const contribution = this.symm.getCoRoot(b).scale(edgeScales[b]);
                                        prototype = prototype.plus(contribution);
                                    }
                                }
                                ;
                            }
                        }
                        for (let mirror = 0; mirror < 4; mirror++) {
                            if ((renderEdges & (1 << mirror)) !== 0)
                                reflections[mirror] = this.symm.reflect(mirror, prototype);
                            ;
                        }
                        for (let index1 = 0; index1 < this.mRoots.length; index1++) {
                            let outerRoot = this.mRoots[index1];
                            {
                                for (let index2 = 0; index2 < this.mRoots.length; index2++) {
                                    let innerRoot = this.mRoots[index2];
                                    {
                                        let vertex = outerRoot.rightMultiply(prototype);
                                        vertex = innerRoot.leftMultiply(vertex);
                                        const p1 = listener.addVertex(vertex);
                                        for (let mirror = 0; mirror < 4; mirror++) {
                                            {
                                                if (reflections[mirror] != null) {
                                                    let other = outerRoot.rightMultiply(reflections[mirror]);
                                                    other = innerRoot.leftMultiply(other);
                                                    if (!other.equals(vertex)) {
                                                        const p2 = listener.addVertex(other);
                                                        listener.addEdge(p1, p2);
                                                    }
                                                }
                                            }
                                            ;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                CommandUniformH4Polytope.POLYTOPE_INDEX_ATTR_NAME = "polytope.index";
                commands.CommandUniformH4Polytope = CommandUniformH4Polytope;
                CommandUniformH4Polytope["__class"] = "com.vzome.core.commands.CommandUniformH4Polytope";
                CommandUniformH4Polytope["__interfaces"] = ["com.vzome.core.commands.Command"];
                (function (CommandUniformH4Polytope) {
                    class H4Symmetry {
                        constructor(field) {
                            this.mPrototypes = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(15);
                            this.mMirrors = [null, null, null, null];
                            this.coRoots = [null, null, null, null];
                            const ONE = field['createRational$long'](1);
                            const NEG_ONE = field['createRational$long'](-1);
                            const TWO = field['createRational$long'](2);
                            const A = field['createAlgebraicNumber$int$int$int$int'](1, -1, 1, 0);
                            const B = field['createAlgebraicNumber$int$int$int$int'](0, 1, 1, 0);
                            let temp = field.origin(4);
                            temp.setComponent(1, A.dividedBy(TWO));
                            temp.setComponent(2, ONE.dividedBy(TWO));
                            temp.setComponent(3, B.dividedBy(TWO));
                            this.mMirrors[3] = new com.vzome.core.algebra.Quaternion(field, temp);
                            temp = field.origin(4);
                            temp.setComponent(3, NEG_ONE);
                            this.mMirrors[2] = new com.vzome.core.algebra.Quaternion(field, temp);
                            temp = field.origin(4);
                            temp.setComponent(1, ONE.dividedBy(TWO));
                            temp.setComponent(2, NEG_ONE.dividedBy(TWO));
                            temp.setComponent(3, ONE.dividedBy(TWO));
                            temp.setComponent(0, NEG_ONE.dividedBy(TWO));
                            this.mMirrors[1] = new com.vzome.core.algebra.Quaternion(field, temp);
                            temp = field.origin(4);
                            temp.setComponent(0, ONE);
                            this.mMirrors[0] = new com.vzome.core.algebra.Quaternion(field, temp);
                            const B2 = field['createAlgebraicNumber$int$int$int$int'](0, 2, 1, 0);
                            this.coRoots[3] = field.origin(4);
                            this.coRoots[3].setComponent(1, B2);
                            this.coRoots[3].setComponent(2, B2);
                            this.coRoots[2] = field.origin(4);
                            this.coRoots[2].setComponent(1, B2['plus$com_vzome_core_algebra_AlgebraicNumber'](ONE));
                            this.coRoots[2].setComponent(2, B['plus$com_vzome_core_algebra_AlgebraicNumber'](TWO));
                            this.coRoots[2].setComponent(3, A);
                            this.coRoots[1] = field.origin(4);
                            this.coRoots[1].setComponent(1, B2);
                            this.coRoots[1].setComponent(2, TWO);
                            this.coRoots[0] = field.origin(4);
                            this.coRoots[0].setComponent(1, B);
                            this.coRoots[0].setComponent(2, ONE);
                            this.coRoots[0].setComponent(0, A.negate());
                            if (com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                for (let i = 0; i < 4; i++) {
                                    {
                                        const buf = new java.lang.StringBuffer();
                                        this.coRoots[i].getVectorExpression$java_lang_StringBuffer$int(buf, com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT);
                                        com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().fine(buf.toString());
                                    }
                                    ;
                                }
                            const origin = field.origin(4);
                            for (let index = 1; index <= 15; index++) {
                                {
                                    let vertex = origin;
                                    for (let b = 0; b < 4; b++) {
                                        {
                                            const mask = 1 << b;
                                            const test = index & mask;
                                            if (test !== 0) {
                                                vertex = vertex.plus(this.coRoots[b]);
                                            }
                                        }
                                        ;
                                    }
                                    this.mPrototypes[index - 1] = vertex;
                                }
                                ;
                            }
                        }
                        getPrototype(index) {
                            return this.mPrototypes[index - 1];
                        }
                        reflect(mirror, prototype) {
                            return this.mMirrors[mirror].reflect(prototype);
                        }
                        getCoRoot(i) {
                            return this.coRoots[i];
                        }
                    }
                    CommandUniformH4Polytope.H4Symmetry = H4Symmetry;
                    H4Symmetry["__class"] = "com.vzome.core.commands.CommandUniformH4Polytope.H4Symmetry";
                    class ConstructionChangesAdapter {
                        constructor(effects, proj, scale) {
                            this.vertices = (new java.util.HashMap());
                            if (this.effects === undefined) {
                                this.effects = null;
                            }
                            if (this.proj === undefined) {
                                this.proj = null;
                            }
                            if (this.scale === undefined) {
                                this.scale = null;
                            }
                            this.edges = (new java.util.HashSet());
                            this.effects = effects;
                            this.proj = proj;
                            this.scale = scale;
                        }
                        /**
                         *
                         * @param {*} v1
                         * @param {*} v2
                         * @return {*}
                         */
                        addEdge(v1, v2) {
                            const p1 = v1;
                            const p2 = v2;
                            const edge = new CommandUniformH4Polytope.Edge(p1.getIndex(), p2.getIndex());
                            if (this.edges.contains(edge))
                                return null;
                            this.edges.add(edge);
                            this.effects['constructionAdded$com_vzome_core_construction_Construction'](new com.vzome.core.construction.SegmentJoiningPoints(p1, p2));
                            return edge;
                        }
                        /**
                         *
                         * @param {java.lang.Object[]} vertices
                         * @return {*}
                         */
                        addFace(vertices) {
                            return null;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vertex
                         * @return {*}
                         */
                        addVertex(vertex) {
                            let p = this.vertices.get(vertex);
                            if (p == null) {
                                let projected = vertex;
                                com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().finer("before   : ");
                                this.printGoldenVector(projected);
                                if (this.proj != null)
                                    projected = this.proj.projectImage(projected, true);
                                com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().finer("projected: ");
                                this.printGoldenVector(projected);
                                projected = projected.scale(this.scale);
                                com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().finer("scaled   : ");
                                this.printGoldenVector(projected);
                                p = new com.vzome.core.construction.FreePoint(projected);
                                p.setIndex(this.vertices.size());
                                this.effects['constructionAdded$com_vzome_core_construction_Construction'](p);
                                this.vertices.put(vertex, p);
                            }
                            return p;
                        }
                        printGoldenVector(gv) {
                            if (com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().isLoggable(java.util.logging.Level.FINER)) {
                                const buf = new java.lang.StringBuffer();
                                gv.getVectorExpression$java_lang_StringBuffer$int(buf, com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT);
                                com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().finer(buf.toString());
                            }
                        }
                    }
                    CommandUniformH4Polytope.ConstructionChangesAdapter = ConstructionChangesAdapter;
                    ConstructionChangesAdapter["__class"] = "com.vzome.core.commands.CommandUniformH4Polytope.ConstructionChangesAdapter";
                    ConstructionChangesAdapter["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];
                    class Edge {
                        constructor(p1, p2) {
                            if (this.p1 === undefined) {
                                this.p1 = 0;
                            }
                            if (this.p2 === undefined) {
                                this.p2 = 0;
                            }
                            this.p1 = p1;
                            this.p2 = p2;
                        }
                        /**
                         *
                         * @param {*} obj
                         * @return {boolean}
                         */
                        equals(obj) {
                            if (!(obj != null && obj instanceof com.vzome.core.commands.CommandUniformH4Polytope.Edge))
                                return false;
                            const that = obj;
                            if (this.p1 === that.p1 && this.p2 === that.p2)
                                return true;
                            if (this.p1 === that.p2 && this.p2 === that.p1)
                                return true;
                            return false;
                        }
                        /**
                         *
                         * @return {number}
                         */
                        hashCode() {
                            return this.p1 ^ this.p2;
                        }
                    }
                    CommandUniformH4Polytope.Edge = Edge;
                    Edge["__class"] = "com.vzome.core.commands.CommandUniformH4Polytope.Edge";
                })(CommandUniformH4Polytope = commands.CommandUniformH4Polytope || (commands.CommandUniformH4Polytope = {}));
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} symmetry
                 * @class
                 * @extends com.vzome.core.commands.CommandTransform
                 */
                class CommandSymmetry extends com.vzome.core.commands.CommandTransform {
                    constructor(symmetry) {
                        if (((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null)) {
                            let __args = arguments;
                            super();
                            if (this.mSymmetry === undefined) {
                                this.mSymmetry = null;
                            }
                            this.mSymmetry = symmetry;
                        }
                        else if (symmetry === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let symmetry = null;
                                super();
                                if (this.mSymmetry === undefined) {
                                    this.mSymmetry = null;
                                }
                                this.mSymmetry = symmetry;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return com.vzome.core.commands.CommandTransform.GROUP_ATTR_SIGNATURE_$LI$();
                    }
                    setSymmetry(attributes) {
                        if (this.mSymmetry == null)
                            this.mSymmetry = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME);
                        else if (!attributes.containsKey(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME))
                            attributes.put(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME, this.mSymmetry);
                        if (this.mSymmetry == null)
                            throw new java.lang.IllegalStateException("null symmetry no longer supported");
                        const center = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME);
                        return center;
                    }
                    /**
                     *
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setFixedAttributes(attributes, format) {
                        if (!attributes.containsKey(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME)) {
                            const icosahedralSymmetry = format.parseSymmetry("icosahedral");
                            attributes.put(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME, icosahedralSymmetry);
                        }
                        super.setFixedAttributes(attributes, format);
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        const center = this.setSymmetry(attributes);
                        const params = parameters.getConstructions();
                        const output = new com.vzome.core.construction.ConstructionList();
                        for (let index = 0; index < params.length; index++) {
                            let param = params[index];
                            {
                                output.addConstruction(param);
                            }
                        }
                        for (let i = 1; i < this.mSymmetry.getChiralOrder(); i++) {
                            {
                                const transform = new com.vzome.core.construction.SymmetryTransformation(this.mSymmetry, i, center);
                                output.addAll(this.transform(params, transform, effects));
                            }
                            ;
                        }
                        return output;
                    }
                }
                commands.CommandSymmetry = CommandSymmetry;
                CommandSymmetry["__class"] = "com.vzome.core.commands.CommandSymmetry";
                CommandSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} left
                 * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} right
                 * @class
                 * @extends com.vzome.core.commands.CommandTransform
                 */
                class CommandQuaternionSymmetry extends com.vzome.core.commands.CommandTransform {
                    constructor(left, right) {
                        if (((left != null && left instanceof com.vzome.core.math.symmetry.QuaternionicSymmetry) || left === null) && ((right != null && right instanceof com.vzome.core.math.symmetry.QuaternionicSymmetry) || right === null)) {
                            let __args = arguments;
                            super();
                            if (this.mLeft === undefined) {
                                this.mLeft = null;
                            }
                            if (this.mRight === undefined) {
                                this.mRight = null;
                            }
                            this.mLeft = left;
                            this.mRight = right;
                        }
                        else if (left === undefined && right === undefined) {
                            let __args = arguments;
                            super();
                            if (this.mLeft === undefined) {
                                this.mLeft = null;
                            }
                            if (this.mRight === undefined) {
                                this.mRight = null;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setFixedAttributes(attributes, format) {
                        super.setFixedAttributes(attributes, format);
                        if (!attributes.containsKey(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$())) {
                            this.mLeft = format.getQuaternionicSymmetry("H_4");
                            attributes.put(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$(), this.mLeft);
                        }
                        if (!attributes.containsKey(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME)) {
                            this.mRight = format.getQuaternionicSymmetry("H_4");
                            attributes.put(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME, this.mRight);
                        }
                    }
                    static LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$() { if (CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME == null) {
                        CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME = com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME;
                    } return CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return com.vzome.core.commands.CommandTransform.GROUP_ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        if (this.mLeft == null)
                            this.mLeft = attributes.get(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$());
                        else if (!attributes.containsKey(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$()))
                            attributes.put(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$(), this.mLeft);
                        if (this.mRight == null)
                            this.mRight = attributes.get(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME);
                        else if (!attributes.containsKey(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME))
                            attributes.put(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME, this.mRight);
                        const leftRoots = this.mLeft.getRoots();
                        const rightRoots = this.mRight.getRoots();
                        const params = parameters.getConstructions();
                        const output = new com.vzome.core.construction.ConstructionList();
                        for (let index = 0; index < params.length; index++) {
                            let param = params[index];
                            {
                                output.addConstruction(param);
                            }
                        }
                        for (let index = 0; index < leftRoots.length; index++) {
                            let leftRoot = leftRoots[index];
                            {
                                for (let index1 = 0; index1 < rightRoots.length; index1++) {
                                    let rightRoot = rightRoots[index1];
                                    {
                                        for (let index2 = 0; index2 < params.length; index2++) {
                                            let param = params[index2];
                                            {
                                                let result = null;
                                                if (param != null && param instanceof com.vzome.core.construction.Point) {
                                                    result = new com.vzome.core.construction.PointRotated4D(leftRoot, rightRoot, param);
                                                }
                                                else if (param != null && param instanceof com.vzome.core.construction.Segment) {
                                                    result = new com.vzome.core.construction.SegmentRotated4D(leftRoot, rightRoot, param);
                                                }
                                                else if (param != null && param instanceof com.vzome.core.construction.Polygon) {
                                                    result = new com.vzome.core.construction.PolygonRotated4D(leftRoot, rightRoot, param);
                                                }
                                                else {
                                                }
                                                if (result == null)
                                                    continue;
                                                effects['constructionAdded$com_vzome_core_construction_Construction'](result);
                                                output.addConstruction(result);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return output;
                    }
                }
                CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME = "right.symmetry.group";
                commands.CommandQuaternionSymmetry = CommandQuaternionSymmetry;
                CommandQuaternionSymmetry["__class"] = "com.vzome.core.commands.CommandQuaternionSymmetry";
                CommandQuaternionSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.CommandTransform
                 */
                class CommandTranslate extends com.vzome.core.commands.CommandTransform {
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        const norm = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                        if (norm == null) {
                            throw new com.vzome.core.commands.Command.Failure("no symmetry axis provided");
                        }
                        const params = parameters.getConstructions();
                        const field = norm.getField();
                        const offset = field.projectTo3d(norm.getOffset(), true);
                        const transform = new com.vzome.core.construction.Translation(offset);
                        return this.transform(params, transform, effects);
                    }
                    constructor() {
                        super();
                    }
                }
                commands.CommandTranslate = CommandTranslate;
                CommandTranslate["__class"] = "com.vzome.core.commands.CommandTranslate";
                CommandTranslate["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.CommandTransform
                 */
                class CommandCentralSymmetry extends com.vzome.core.commands.CommandTransform {
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return com.vzome.core.commands.CommandTransform.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        const output = new com.vzome.core.construction.ConstructionList();
                        const center = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME);
                        const params = parameters.getConstructions();
                        for (let index = 0; index < params.length; index++) {
                            let param = params[index];
                            {
                                output.addConstruction(param);
                            }
                        }
                        const transform = new com.vzome.core.construction.PointReflection(center);
                        effects['constructionAdded$com_vzome_core_construction_Construction'](transform);
                        return this.transform(params, transform, effects);
                    }
                    constructor() {
                        super();
                    }
                }
                commands.CommandCentralSymmetry = CommandCentralSymmetry;
                CommandCentralSymmetry["__class"] = "com.vzome.core.commands.CommandCentralSymmetry";
                CommandCentralSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.CommandTransform
                 */
                class CommandMirrorSymmetry extends com.vzome.core.commands.CommandTransform {
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        const center = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME);
                        const norm = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                        if (norm == null) {
                            throw new com.vzome.core.commands.Command.Failure("no symmetry axis provided");
                        }
                        const params = parameters.getConstructions();
                        const mirror = new com.vzome.core.construction.PlaneFromNormalSegment(center, norm);
                        effects['constructionAdded$com_vzome_core_construction_Construction'](mirror);
                        const transform = new com.vzome.core.construction.PlaneReflection(mirror);
                        return this.transform(params, transform, effects);
                    }
                    constructor() {
                        super();
                    }
                }
                commands.CommandMirrorSymmetry = CommandMirrorSymmetry;
                CommandMirrorSymmetry["__class"] = "com.vzome.core.commands.CommandMirrorSymmetry";
                CommandMirrorSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ValidateSelection extends com.vzome.core.editor.api.ChangeSelection {
                    /**
                     *
                     */
                    perform() {
                        if (this.mSelection.size() === 0)
                            throw new com.vzome.core.commands.Command.Failure("selection is empty");
                    }
                    constructor(editor) {
                        super(editor.getSelection());
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ValidateSelection";
                    }
                }
                edits.ValidateSelection = ValidateSelection;
                ValidateSelection["__class"] = "com.vzome.core.edits.ValidateSelection";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class InvertSelection extends com.vzome.core.editor.api.ChangeSelection {
                    constructor(editor) {
                        super(editor.getSelection());
                        if (this.mManifestations === undefined) {
                            this.mManifestations = null;
                        }
                        this.mManifestations = editor.getRealizedModel();
                    }
                    /**
                     *
                     */
                    perform() {
                        for (let index = this.mManifestations.iterator(); index.hasNext();) {
                            let m = index.next();
                            {
                                if (m.isRendered()) {
                                    if (this.mSelection.manifestationSelected(m))
                                        this.unselect$com_vzome_core_model_Manifestation(m);
                                    else
                                        this.select$com_vzome_core_model_Manifestation(m);
                                }
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "InvertSelection";
                    }
                }
                edits.InvertSelection = InvertSelection;
                InvertSelection["__class"] = "com.vzome.core.edits.InvertSelection";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * Used by CommandEdit.
                 * @param {*} editor
                 * @param {*} m
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeSelection
                 */
                class SelectManifestation extends com.vzome.core.editor.api.ChangeSelection {
                    constructor(editor, m) {
                        if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && ((m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || m === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                super(editor.getSelection());
                                if (this.mManifestation === undefined) {
                                    this.mManifestation = null;
                                }
                                if (this.construction === undefined) {
                                    this.construction = null;
                                }
                                if (this.mRealized === undefined) {
                                    this.mRealized = null;
                                }
                                if (this.mReplace === undefined) {
                                    this.mReplace = false;
                                }
                                this.mRealized = editor.getRealizedModel();
                            }
                            (() => {
                                this.mManifestation = m;
                                if (this.mManifestation != null) {
                                    this.construction = this.mManifestation.toConstruction();
                                }
                            })();
                        }
                        else if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && m === undefined) {
                            let __args = arguments;
                            super(editor.getSelection());
                            if (this.mManifestation === undefined) {
                                this.mManifestation = null;
                            }
                            if (this.construction === undefined) {
                                this.construction = null;
                            }
                            if (this.mRealized === undefined) {
                                this.mRealized = null;
                            }
                            if (this.mReplace === undefined) {
                                this.mReplace = false;
                            }
                            this.mRealized = editor.getRealizedModel();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    configure(props) {
                        const mode = props.get("mode");
                        this.mReplace = "replace" === mode;
                        this.mManifestation = props.get("picked");
                        if (this.mManifestation != null) {
                            this.construction = this.mManifestation.toConstruction();
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.mReplace) {
                            for (let index = this.mSelection.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    this.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                                }
                            }
                            this.select$com_vzome_core_model_Manifestation(this.mManifestation);
                        }
                        else if (this.mSelection.manifestationSelected(this.mManifestation))
                            this.unselect$com_vzome_core_model_Manifestation(this.mManifestation);
                        else
                            this.select$com_vzome_core_model_Manifestation(this.mManifestation);
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} result
                     */
                    getXmlAttributes(result) {
                        if (this.construction != null && this.construction instanceof com.vzome.core.construction.Point)
                            com.vzome.core.commands.XmlSaveFormat.serializePoint(result, "point", this.construction);
                        else if (this.construction != null && this.construction instanceof com.vzome.core.construction.Segment)
                            com.vzome.core.commands.XmlSaveFormat.serializeSegment(result, "startSegment", "endSegment", this.construction);
                        else if (this.construction != null && this.construction instanceof com.vzome.core.construction.Polygon)
                            com.vzome.core.commands.XmlSaveFormat.serializePolygon(result, "polygonVertex", this.construction);
                        if (this.mReplace)
                            com.vzome.xml.DomUtils.addAttribute(result, "replace", "true");
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        if (format.rationalVectors()) {
                            this.construction = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "point");
                            if (this.construction == null)
                                this.construction = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "startSegment", "endSegment");
                            if (this.construction == null) {
                                const kid = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element$java_lang_String(xml, "polygon");
                                if (kid != null)
                                    this.construction = format.parsePolygon$org_w3c_dom_Element$java_lang_String(kid, "vertex");
                                else
                                    this.construction = format.parsePolygon$org_w3c_dom_Element$java_lang_String(xml, "polygonVertex");
                            }
                        }
                        else {
                            const attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                            this.construction = attrs.get("manifestation");
                            const replaceVal = attrs.get("replace");
                            if (replaceVal != null && replaceVal)
                                this.mReplace = true;
                        }
                        this.mManifestation = this.mRealized.getManifestation(this.construction);
                        if (this.mManifestation == null && format.rationalVectors() && (this.construction != null && this.construction instanceof com.vzome.core.construction.Polygon)) {
                            this.construction = format.parsePolygonReversed(xml, "polygonVertex");
                            this.mManifestation = this.mRealized.getManifestation(this.construction);
                            if (this.mManifestation != null)
                                com.vzome.core.editor.api.SideEffects.logBugAccommodation("reverse-oriented polygon");
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SelectManifestation";
                    }
                }
                edits.SelectManifestation = SelectManifestation;
                SelectManifestation["__class"] = "com.vzome.core.edits.SelectManifestation";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * This constructor is only used during deserialization, so it prepares for setXmlAttributes().
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeSelection
                 * @author David Hall
                 */
                class AdjustSelectionByOrbitLength extends com.vzome.core.editor.api.ChangeSelection {
                    constructor(editor) {
                        super(editor.getSelection());
                        if (this.orbit === undefined) {
                            this.orbit = null;
                        }
                        if (this.length === undefined) {
                            this.length = null;
                        }
                        if (this.symmetry === undefined) {
                            this.symmetry = null;
                        }
                        this.strutAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                        this.panelAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                        if (this.editor === undefined) {
                            this.editor = null;
                        }
                        this.symmetry = editor['getSymmetrySystem$']();
                        this.editor = editor;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        const mode = props.get("mode");
                        const strut = props.get("picked");
                        this.orbit = props.get("orbit");
                        this.length = props.get("length");
                        if (mode != null)
                            switch ((mode)) {
                                case "selectSimilarStruts":
                                    this.strutAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                                    break;
                                case "selectSimilarPanels":
                                    this.panelAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                                    break;
                                case "deselectSimilarStruts":
                                    this.strutAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                    break;
                                case "deselectSimilarPanels":
                                    this.panelAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                    break;
                            }
                        if (strut != null) {
                            const offset = strut.getOffset();
                            const zone = this.symmetry.getAxis(offset);
                            this.orbit = zone.getOrbit();
                            this.length = zone.getLength(offset);
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        const whichManifestationSet = (this.strutAction === com.vzome.core.editor.api.ActionEnum.SELECT || this.panelAction === com.vzome.core.editor.api.ActionEnum.SELECT) ? this.editor.getRealizedModel() : this.mSelection;
                        for (let index = whichManifestationSet.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man.isRendered()) {
                                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                        const offset = man.getOffset();
                                        const zone = this.symmetry.getAxis(offset);
                                        if (zone.getOrbit() === this.orbit) {
                                            if (this.length == null || /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                                return o1.equals(o2);
                                            }
                                            else {
                                                return o1 === o2;
                                            } })(this.length, zone.getLength(offset))) {
                                                this.adjustSelection(man, this.strutAction);
                                            }
                                        }
                                    }
                                    else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                        const zone = this.symmetry.getAxis(man['getNormal$']());
                                        if (zone.getOrbit() === this.orbit) {
                                            this.adjustSelection(man, this.panelAction);
                                        }
                                    }
                                }
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "AdjustSelectionByOrbitLength";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.symmetry != null) {
                            com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetry.getName());
                        }
                        if (this.orbit != null) {
                            com.vzome.xml.DomUtils.addAttribute(element, "orbit", this.orbit.getName());
                        }
                        if (this.length != null) {
                            com.vzome.core.commands.XmlSaveFormat.serializeNumber(element, "length", this.length);
                        }
                        element.setAttribute("struts", /* Enum.name */ com.vzome.core.editor.api.ActionEnum[this.strutAction]);
                        element.setAttribute("panels", /* Enum.name */ com.vzome.core.editor.api.ActionEnum[this.panelAction]);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.symmetry = this.editor['getSymmetrySystem$java_lang_String'](xml.getAttribute("symmetry"));
                        this.length = format.parseNumber(xml, "length");
                        this.orbit = this.symmetry.getOrbits().getDirection(xml.getAttribute("orbit"));
                        if (xml.getLocalName() === ("SelectSimilarSize")) {
                            this.strutAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                            this.panelAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                        }
                        else {
                            this.strutAction = /* Enum.valueOf */ com.vzome.core.editor.api.ActionEnum[xml.getAttribute("struts")];
                            this.panelAction = /* Enum.valueOf */ com.vzome.core.editor.api.ActionEnum[xml.getAttribute("panels")];
                        }
                    }
                }
                edits.AdjustSelectionByOrbitLength = AdjustSelectionByOrbitLength;
                AdjustSelectionByOrbitLength["__class"] = "com.vzome.core.edits.AdjustSelectionByOrbitLength";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * This class is designed to be a generalized replacement for the legacy DeselectByClass
                 * It allows balls, struts and/or panels to be selected, deselected or ignored by class
                 * It can be used in place of DeselectByClass including the ability to parse the legacy XML.
                 * DeselectByClass has been renamed as AdjustSelectionByClass and modified with the additional functionality.
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeSelection
                 */
                class AdjustSelectionByClass extends com.vzome.core.editor.api.ChangeSelection {
                    constructor(editor) {
                        super(editor.getSelection());
                        this.ballAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                        this.strutAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                        this.panelAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                        if (this.editor === undefined) {
                            this.editor = null;
                        }
                        this.originLast = true;
                        this.editor = editor;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        const mode = props.get("mode");
                        if (mode != null)
                            switch ((mode)) {
                                case "selectBalls":
                                    this.ballAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                                    break;
                                case "selectStruts":
                                    this.strutAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                                    break;
                                case "selectPanels":
                                    this.panelAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                                    break;
                                case "deselectBalls":
                                case "unselectBalls":
                                    this.ballAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                    break;
                                case "deselectStruts":
                                    this.strutAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                    break;
                                case "deselectPanels":
                                    this.panelAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                    break;
                                case "unselectStruts":
                                case "unselectStrutsAndPanels":
                                    this.strutAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                    this.panelAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                    break;
                            }
                    }
                    /**
                     *
                     */
                    perform() {
                        const whichManifestationSet = (this.ballAction === com.vzome.core.editor.api.ActionEnum.SELECT || this.strutAction === com.vzome.core.editor.api.ActionEnum.SELECT || this.panelAction === com.vzome.core.editor.api.ActionEnum.SELECT) ? this.editor.getRealizedModel() : this.mSelection;
                        let originBall = null;
                        for (let index = whichManifestationSet.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man.isRendered()) {
                                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        if (this.originLast && originBall == null && this.ballAction === com.vzome.core.editor.api.ActionEnum.SELECT && man.getLocation().isOrigin()) {
                                            originBall = man;
                                        }
                                        else {
                                            this.adjustSelection(man, this.ballAction);
                                        }
                                    }
                                    else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                        this.adjustSelection(man, this.strutAction);
                                    }
                                    else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                        this.adjustSelection(man, this.panelAction);
                                    }
                                }
                            }
                        }
                        if (originBall != null) {
                            const ignoreGroups = true;
                            if (this.mSelection.manifestationSelected(originBall)) {
                                this.unselect$com_vzome_core_model_Manifestation$boolean(originBall, ignoreGroups);
                                this.redo();
                            }
                            this.select$com_vzome_core_model_Manifestation$boolean(originBall, ignoreGroups);
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("balls", /* Enum.name */ com.vzome.core.editor.api.ActionEnum[this.ballAction]);
                        element.setAttribute("struts", /* Enum.name */ com.vzome.core.editor.api.ActionEnum[this.strutAction]);
                        element.setAttribute("panels", /* Enum.name */ com.vzome.core.editor.api.ActionEnum[this.panelAction]);
                        if (this.originLast) {
                            element.setAttribute("originLast", "true");
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        if (xml.getLocalName() === ("DeselectByClass")) {
                            if (xml.getAttribute("class") === ("balls")) {
                                this.ballAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                this.strutAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                                this.panelAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                            }
                            else {
                                this.ballAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                                this.strutAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                this.panelAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                            }
                        }
                        else {
                            this.ballAction = /* Enum.valueOf */ com.vzome.core.editor.api.ActionEnum[xml.getAttribute("balls")];
                            this.strutAction = /* Enum.valueOf */ com.vzome.core.editor.api.ActionEnum[xml.getAttribute("struts")];
                            this.panelAction = /* Enum.valueOf */ com.vzome.core.editor.api.ActionEnum[xml.getAttribute("panels")];
                        }
                        const mode = xml.getAttribute("originLast");
                        this.originLast = "true" === mode;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "AdjustSelectionByClass";
                    }
                }
                edits.AdjustSelectionByClass = AdjustSelectionByClass;
                AdjustSelectionByClass["__class"] = "com.vzome.core.edits.AdjustSelectionByClass";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectAll extends com.vzome.core.editor.api.ChangeSelection {
                    constructor(editor) {
                        super(editor.getSelection());
                        if (this.realizedModel === undefined) {
                            this.realizedModel = null;
                        }
                        this.originLast = true;
                        this.realizedModel = editor.getRealizedModel();
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.originLast) {
                            let originBall = null;
                            const ignoreGroups = true;
                            for (let index = this.realizedModel.iterator(); index.hasNext();) {
                                let m = index.next();
                                {
                                    if (m.isRendered()) {
                                        if (originBall == null && (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) && m.getLocation().isOrigin()) {
                                            originBall = m;
                                        }
                                        else if (!this.mSelection.manifestationSelected(m)) {
                                            this.select$com_vzome_core_model_Manifestation$boolean(m, ignoreGroups);
                                        }
                                    }
                                }
                            }
                            if (originBall != null) {
                                if (this.mSelection.manifestationSelected(originBall)) {
                                    this.unselect$com_vzome_core_model_Manifestation$boolean(originBall, ignoreGroups);
                                    this.redo();
                                }
                                this.select$com_vzome_core_model_Manifestation$boolean(originBall, ignoreGroups);
                            }
                        }
                        else {
                            for (let index = this.realizedModel.iterator(); index.hasNext();) {
                                let m = index.next();
                                {
                                    if (m.isRendered()) {
                                        if (!this.mSelection.manifestationSelected(m))
                                            this.select$com_vzome_core_model_Manifestation$boolean(m, true);
                                    }
                                }
                            }
                        }
                        super.perform();
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        const mode = xml.getAttribute("originLast");
                        this.originLast = "true" === mode;
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.originLast)
                            element.setAttribute("originLast", "true");
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SelectAll";
                    }
                }
                edits.SelectAll = SelectAll;
                SelectAll["__class"] = "com.vzome.core.edits.SelectAll";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectNeighbors extends com.vzome.core.editor.api.ChangeSelection {
                    constructor(editor) {
                        super(editor.getSelection());
                        if (this.editor === undefined) {
                            this.editor = null;
                        }
                        this.withPanels = false;
                        this.editor = editor;
                    }
                    perform() {
                        const model = this.editor.getRealizedModel();
                        const panels = (new java.util.LinkedHashSet());
                        const struts = (new java.util.LinkedHashSet());
                        const balls = (new java.util.LinkedHashSet());
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))
                                    struts.add(man);
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))
                                    balls.add(man);
                                else if (this.withPanels && (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)))
                                    panels.add(man);
                            }
                        }
                        for (let index = balls.iterator(); index.hasNext();) {
                            let ball = index.next();
                            {
                                const loc = ball.getLocation();
                                for (let index = model.iterator(); index.hasNext();) {
                                    let man = index.next();
                                    {
                                        if (!man.isRendered())
                                            continue;
                                        if ((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) && !struts.contains(man)) {
                                            const strut = man;
                                            if (loc.equals(strut.getLocation()) || loc.equals(strut.getEnd()))
                                                this.select$com_vzome_core_model_Manifestation(strut);
                                        }
                                        else if (this.withPanels && (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) && !panels.contains(man)) {
                                            const panel = man;
                                            for (let index = panel.iterator(); index.hasNext();) {
                                                let vertex = index.next();
                                                {
                                                    if (loc.equals(vertex)) {
                                                        this.select$com_vzome_core_model_Manifestation(panel);
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let index = struts.iterator(); index.hasNext();) {
                            let strut = index.next();
                            {
                                const loc = strut.getLocation();
                                const end = strut.getEnd();
                                for (let index = model.iterator(); index.hasNext();) {
                                    let man = index.next();
                                    {
                                        if (!man.isRendered())
                                            continue;
                                        if ((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) && !balls.contains(man)) {
                                            const bloc = man.getLocation();
                                            if (bloc.equals(loc) || bloc.equals(end))
                                                this.select$com_vzome_core_model_Manifestation(man);
                                        }
                                    }
                                }
                            }
                        }
                        if (this.withPanels) {
                            for (let index = panels.iterator(); index.hasNext();) {
                                let panel = index.next();
                                {
                                    for (let index = panel.iterator(); index.hasNext();) {
                                        let loc = index.next();
                                        {
                                            for (let index = model.iterator(); index.hasNext();) {
                                                let man = index.next();
                                                {
                                                    if (man.isRendered()) {
                                                        if ((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) && !balls.contains(man)) {
                                                            const bloc = man.getLocation();
                                                            if (bloc.equals(loc)) {
                                                                this.select$com_vzome_core_model_Manifestation(man);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        super.perform();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SelectNeighbors";
                    }
                }
                edits.SelectNeighbors = SelectNeighbors;
                SelectNeighbors["__class"] = "com.vzome.core.edits.SelectNeighbors";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class DeselectAll extends com.vzome.core.editor.api.ChangeSelection {
                    /**
                     *
                     */
                    perform() {
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                            }
                        }
                        super.perform();
                    }
                    constructor(editor) {
                        super(editor.getSelection());
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "DeselectAll";
                    }
                }
                edits.DeselectAll = DeselectAll;
                DeselectAll["__class"] = "com.vzome.core.edits.DeselectAll";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    class ChangeManifestations extends com.vzome.core.editor.api.ChangeSelection {
                        constructor(editorModel) {
                            super(editorModel.getSelection());
                            if (this.mManifestations === undefined) {
                                this.mManifestations = null;
                            }
                            this.mManifestations = editorModel.getRealizedModel();
                            this.mManifestations.clearPerEditManifestations();
                        }
                        /**
                         *
                         */
                        redo() {
                            this.mManifestations.clearPerEditManifestations();
                            super.redo();
                        }
                        /**
                         *
                         */
                        undo() {
                            this.mManifestations.clearPerEditManifestations();
                            super.undo();
                        }
                        getManifestation(c) {
                            return this.mManifestations.getManifestation(c);
                        }
                        manifestConstruction(c) {
                            const sig = c.getSignature();
                            const m = this.mManifestations.findConstruction(c);
                            if (m == null)
                                return null;
                            const made = this.mManifestations.findPerEditManifestation(sig);
                            if (made != null)
                                return made;
                            if (m.isUnnecessary()) {
                                this.mManifestations.addPerEditManifestation(sig, m);
                                this.plan(new ChangeManifestations.ManifestConstruction(this, c, m, true));
                            }
                            else {
                                if (!m.isRendered())
                                    this.plan(new ChangeManifestations.RenderManifestation(this, m, true));
                            }
                            return m;
                        }
                        unmanifestConstruction(c) {
                            const m = this.mManifestations.removeConstruction(c);
                            if (m == null)
                                return null;
                            this.plan(new ChangeManifestations.ManifestConstruction(this, c, m, false));
                            return m;
                        }
                        deleteManifestation(man) {
                            this.plan(new ChangeManifestations.DeleteManifestation(this, man));
                        }
                        showManifestation(m) {
                            this.plan(new ChangeManifestations.RenderManifestation(this, m, true));
                        }
                        hideManifestation(m) {
                            this.plan(new ChangeManifestations.RenderManifestation(this, m, false));
                        }
                        colorManifestation(m, color) {
                            this.plan(new ChangeManifestations.ColorManifestation(this, m, color));
                        }
                        labelManifestation(m, label) {
                            this.plan(new ChangeManifestations.LabelManifestation(this, m, label));
                        }
                        hideConnectors() {
                            for (let index = com.vzome.core.editor.api.Manifestations.getVisibleConnectors(this.mManifestations).iterator(); index.hasNext();) {
                                let connector = index.next();
                                this.hideManifestation(connector);
                            }
                        }
                        showConnectors() {
                            for (let index = com.vzome.core.editor.api.Manifestations.getHiddenConnectors(this.mManifestations).iterator(); index.hasNext();) {
                                let connector = index.next();
                                this.showManifestation(connector);
                            }
                        }
                        hideStruts() {
                            for (let index = com.vzome.core.editor.api.Manifestations.getVisibleStruts(this.mManifestations).iterator(); index.hasNext();) {
                                let strut = index.next();
                                this.hideManifestation(strut);
                            }
                        }
                        showStruts() {
                            for (let index = com.vzome.core.editor.api.Manifestations.getHiddenStruts(this.mManifestations).iterator(); index.hasNext();) {
                                let strut = index.next();
                                this.showManifestation(strut);
                            }
                        }
                        hidePanels() {
                            for (let index = com.vzome.core.editor.api.Manifestations.getVisiblePanels(this.mManifestations).iterator(); index.hasNext();) {
                                let panel = index.next();
                                this.hideManifestation(panel);
                            }
                        }
                        showPanels() {
                            for (let index = com.vzome.core.editor.api.Manifestations.getHiddenPanels(this.mManifestations).iterator(); index.hasNext();) {
                                let panel = index.next();
                                this.showManifestation(panel);
                            }
                        }
                        showsManifestation(man) {
                            for (const iterator = this.getEffects(); iterator.hasNext();) {
                                {
                                    const effect = iterator.next();
                                    if (effect != null && effect instanceof com.vzome.core.editor.api.ChangeManifestations.ManifestConstruction) {
                                        const show = effect;
                                        if (show.showsManifestation(man))
                                            return true;
                                    }
                                    else if (effect != null && effect instanceof com.vzome.core.editor.api.ChangeManifestations.RenderManifestation) {
                                        const show = effect;
                                        if (show.showsManifestation(man))
                                            return true;
                                    }
                                }
                                ;
                            }
                            return false;
                        }
                        getRenderedSelection() {
                            return com.vzome.core.editor.api.Manifestations.visibleManifestations$java_lang_Iterable$java_util_function_Predicate(this.mSelection, (man) => { return com.vzome.core.editor.api.Manifestations.Filters.isRendered(man); });
                        }
                        getConnectors() {
                            return com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(this.mManifestations);
                        }
                        getStruts() {
                            return com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(this.mManifestations);
                        }
                        getPanels() {
                            return com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.mManifestations);
                        }
                        getVisibleConnectors$() {
                            return com.vzome.core.editor.api.Manifestations.getVisibleConnectors(this.mManifestations);
                        }
                        getVisibleStruts$() {
                            return com.vzome.core.editor.api.Manifestations.getVisibleStruts(this.mManifestations);
                        }
                        getVisiblePanels$() {
                            return com.vzome.core.editor.api.Manifestations.getVisiblePanels(this.mManifestations);
                        }
                        getVisibleConnectors$java_util_function_Predicate(postFilter) {
                            return com.vzome.core.editor.api.Manifestations.getVisibleConnectors(this.mManifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        getVisibleConnectors(postFilter) {
                            if (((typeof postFilter === 'function' && postFilter.length === 1) || postFilter === null)) {
                                return this.getVisibleConnectors$java_util_function_Predicate(postFilter);
                            }
                            else if (postFilter === undefined) {
                                return this.getVisibleConnectors$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        getVisibleStruts$java_util_function_Predicate(postFilter) {
                            return com.vzome.core.editor.api.Manifestations.getVisibleStruts(this.mManifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        getVisibleStruts(postFilter) {
                            if (((typeof postFilter === 'function' && postFilter.length === 1) || postFilter === null)) {
                                return this.getVisibleStruts$java_util_function_Predicate(postFilter);
                            }
                            else if (postFilter === undefined) {
                                return this.getVisibleStruts$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        getVisiblePanels$java_util_function_Predicate(postFilter) {
                            return com.vzome.core.editor.api.Manifestations.getVisiblePanels(this.mManifestations, (((funcInst) => { if (funcInst == null || typeof funcInst == 'function') {
                                return funcInst;
                            } return (arg0) => (funcInst['test'] ? funcInst['test'] : funcInst).call(funcInst, arg0); })(postFilter)));
                        }
                        getVisiblePanels(postFilter) {
                            if (((typeof postFilter === 'function' && postFilter.length === 1) || postFilter === null)) {
                                return this.getVisiblePanels$java_util_function_Predicate(postFilter);
                            }
                            else if (postFilter === undefined) {
                                return this.getVisiblePanels$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                    }
                    api.ChangeManifestations = ChangeManifestations;
                    ChangeManifestations["__class"] = "com.vzome.core.editor.api.ChangeManifestations";
                    (function (ChangeManifestations) {
                        class ManifestConstruction {
                            constructor(__parent, construction, manifestation, showing) {
                                this.__parent = __parent;
                                if (this.mManifestation === undefined) {
                                    this.mManifestation = null;
                                }
                                if (this.mConstruction === undefined) {
                                    this.mConstruction = null;
                                }
                                if (this.mShowing === undefined) {
                                    this.mShowing = false;
                                }
                                this.mConstruction = construction;
                                this.mManifestation = manifestation;
                                this.mShowing = showing;
                            }
                            /**
                             *
                             */
                            redo() {
                                if (this.mShowing) {
                                    if (this.mManifestation.isUnnecessary()) {
                                        this.mManifestation.addConstruction(this.mConstruction);
                                        this.__parent.mManifestations.add(this.mManifestation);
                                    }
                                    this.__parent.mManifestations.show(this.mManifestation);
                                }
                                else {
                                    this.mManifestation.removeConstruction(this.mConstruction);
                                    if (this.mManifestation.isUnnecessary()) {
                                        this.__parent.mManifestations.hide(this.mManifestation);
                                        this.__parent.mManifestations.remove(this.mManifestation);
                                    }
                                }
                            }
                            /**
                             *
                             */
                            undo() {
                                if (this.mShowing) {
                                    this.mManifestation.removeConstruction(this.mConstruction);
                                    if (this.mManifestation.isUnnecessary()) {
                                        this.__parent.mManifestations.hide(this.mManifestation);
                                        this.__parent.mManifestations.remove(this.mManifestation);
                                    }
                                }
                                else {
                                    if (this.mManifestation.isUnnecessary())
                                        this.__parent.mManifestations.add(this.mManifestation);
                                    this.__parent.mManifestations.show(this.mManifestation);
                                    this.mManifestation.addConstruction(this.mConstruction);
                                }
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                const result = this.mShowing ? doc.createElement("mshow") : doc.createElement("mhide");
                                const man = this.mConstruction.getXml(doc);
                                result.appendChild(man);
                                return result;
                            }
                            showsManifestation(man) {
                                return this.mShowing && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(this.mManifestation, man);
                            }
                        }
                        ChangeManifestations.ManifestConstruction = ManifestConstruction;
                        ManifestConstruction["__class"] = "com.vzome.core.editor.api.ChangeManifestations.ManifestConstruction";
                        ManifestConstruction["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];
                        class RenderManifestation {
                            constructor(__parent, manifestation, showing) {
                                this.__parent = __parent;
                                if (this.mManifestation === undefined) {
                                    this.mManifestation = null;
                                }
                                if (this.mShowing === undefined) {
                                    this.mShowing = false;
                                }
                                this.mManifestation = manifestation;
                                this.mShowing = showing;
                            }
                            /**
                             *
                             */
                            redo() {
                                this.mManifestation.setHidden(!this.mShowing);
                                if (this.mShowing)
                                    this.__parent.mManifestations.show(this.mManifestation);
                                else
                                    this.__parent.mManifestations.hide(this.mManifestation);
                            }
                            /**
                             *
                             */
                            undo() {
                                this.mManifestation.setHidden(this.mShowing);
                                if (this.mShowing)
                                    this.__parent.mManifestations.hide(this.mManifestation);
                                else
                                    this.__parent.mManifestations.show(this.mManifestation);
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                const result = this.mShowing ? doc.createElement("show") : doc.createElement("hide");
                                const man = this.mManifestation.getXml(doc);
                                result.appendChild(man);
                                return result;
                            }
                            showsManifestation(man) {
                                return this.mShowing && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(this.mManifestation, man);
                            }
                        }
                        ChangeManifestations.RenderManifestation = RenderManifestation;
                        RenderManifestation["__class"] = "com.vzome.core.editor.api.ChangeManifestations.RenderManifestation";
                        RenderManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];
                        class DeleteManifestation {
                            constructor(__parent, manifestation) {
                                this.__parent = __parent;
                                if (this.mManifestation === undefined) {
                                    this.mManifestation = null;
                                }
                                this.mManifestation = manifestation;
                            }
                            /**
                             *
                             */
                            redo() {
                                this.mManifestation.setHidden(true);
                                this.__parent.mManifestations.hide(this.mManifestation);
                                this.__parent.mManifestations.remove(this.mManifestation);
                            }
                            /**
                             *
                             */
                            undo() {
                                this.__parent.mManifestations.add(this.mManifestation);
                                this.__parent.mManifestations.show(this.mManifestation);
                                this.mManifestation.setHidden(false);
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                const result = doc.createElement("delete");
                                const man = this.mManifestation.getXml(doc);
                                result.appendChild(man);
                                return result;
                            }
                        }
                        ChangeManifestations.DeleteManifestation = DeleteManifestation;
                        DeleteManifestation["__class"] = "com.vzome.core.editor.api.ChangeManifestations.DeleteManifestation";
                        DeleteManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];
                        class ColorManifestation {
                            constructor(__parent, manifestation, color) {
                                this.__parent = __parent;
                                if (this.mManifestation === undefined) {
                                    this.mManifestation = null;
                                }
                                if (this.oldColor === undefined) {
                                    this.oldColor = null;
                                }
                                if (this.newColor === undefined) {
                                    this.newColor = null;
                                }
                                this.mManifestation = manifestation;
                                this.newColor = color;
                                this.oldColor = manifestation.getColor();
                            }
                            /**
                             *
                             */
                            redo() {
                                this.__parent.mManifestations.setColor(this.mManifestation, this.newColor);
                            }
                            /**
                             *
                             */
                            undo() {
                                this.__parent.mManifestations.setColor(this.mManifestation, this.oldColor);
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                const result = doc.createElement("color");
                                com.vzome.xml.DomUtils.addAttribute(result, "rgb", this.newColor.toString());
                                const man = this.mManifestation.getXml(doc);
                                result.appendChild(man);
                                return result;
                            }
                        }
                        ChangeManifestations.ColorManifestation = ColorManifestation;
                        ColorManifestation["__class"] = "com.vzome.core.editor.api.ChangeManifestations.ColorManifestation";
                        ColorManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];
                        class LabelManifestation {
                            constructor(__parent, m, label) {
                                this.__parent = __parent;
                                if (this.mManifestation === undefined) {
                                    this.mManifestation = null;
                                }
                                if (this.oldLabel === undefined) {
                                    this.oldLabel = null;
                                }
                                if (this.newLabel === undefined) {
                                    this.newLabel = null;
                                }
                                this.mManifestation = m;
                                this.newLabel = label;
                                this.oldLabel = m.getLabel();
                            }
                            /**
                             *
                             */
                            undo() {
                                this.__parent.mManifestations.setLabel(this.mManifestation, this.oldLabel);
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                const result = doc.createElement("label");
                                com.vzome.xml.DomUtils.addAttribute(result, "text", this.newLabel);
                                const man = this.mManifestation.getXml(doc);
                                result.appendChild(man);
                                return result;
                            }
                            /**
                             *
                             */
                            redo() {
                                this.__parent.mManifestations.setLabel(this.mManifestation, this.newLabel);
                            }
                        }
                        ChangeManifestations.LabelManifestation = LabelManifestation;
                        LabelManifestation["__class"] = "com.vzome.core.editor.api.ChangeManifestations.LabelManifestation";
                        LabelManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];
                    })(ChangeManifestations = api.ChangeManifestations || (api.ChangeManifestations = {}));
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} symmetry
                 * @class
                 * @extends com.vzome.core.commands.CommandSymmetry
                 */
                class CommandTetrahedralSymmetry extends com.vzome.core.commands.CommandSymmetry {
                    constructor(symmetry = null) {
                        super(symmetry);
                    }
                    static ATTR_SIGNATURE_$LI$() { if (CommandTetrahedralSymmetry.ATTR_SIGNATURE == null) {
                        CommandTetrahedralSymmetry.ATTR_SIGNATURE = [[com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME, com.vzome.core.construction.Point], [com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME, "com.vzome.core.math.symmetry.Symmetry"], [CommandTetrahedralSymmetry.SUBGROUP_ATTR_NAME, [].constructor]];
                    } return CommandTetrahedralSymmetry.ATTR_SIGNATURE; }
                    /**
                     *
                     * @return {java.lang.Object[][]}
                     */
                    getAttributeSignature() {
                        return CommandTetrahedralSymmetry.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        const center = this.setSymmetry(attributes);
                        const closure = this.mSymmetry.subgroup(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL);
                        const params = parameters.getConstructions();
                        const output = new com.vzome.core.construction.ConstructionList();
                        for (let index = 0; index < params.length; index++) {
                            let param = params[index];
                            {
                                output.addConstruction(param);
                            }
                        }
                        for (let i = 1; i < closure.length; i++) {
                            {
                                const transform = new com.vzome.core.construction.SymmetryTransformation(this.mSymmetry, closure[i], center);
                                output.addAll(this.transform(params, transform, effects));
                            }
                            ;
                        }
                        return output;
                    }
                }
                CommandTetrahedralSymmetry.SUBGROUP_ATTR_NAME = "symmetry.permutations";
                commands.CommandTetrahedralSymmetry = CommandTetrahedralSymmetry;
                CommandTetrahedralSymmetry["__class"] = "com.vzome.core.commands.CommandTetrahedralSymmetry";
                CommandTetrahedralSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.CommandSymmetry
                 */
                class CommandRotate extends com.vzome.core.commands.CommandSymmetry {
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        const center = this.setSymmetry(attributes);
                        const norm = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                        if (norm == null) {
                            throw new com.vzome.core.commands.Command.Failure("no symmetry axis provided");
                        }
                        const params = parameters.getConstructions();
                        const output = new com.vzome.core.construction.ConstructionList();
                        let vector = norm.getOffset();
                        vector = norm.getField().projectTo3d(vector, true);
                        const axis = this.mSymmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
                        const rotation = axis.getRotation();
                        const transform = new com.vzome.core.construction.SymmetryTransformation(this.mSymmetry, rotation, center);
                        effects['constructionAdded$com_vzome_core_construction_Construction'](transform);
                        output.addAll(this.transform(params, transform, effects));
                        return output;
                    }
                    constructor() {
                        super();
                    }
                }
                commands.CommandRotate = CommandRotate;
                CommandRotate["__class"] = "com.vzome.core.commands.CommandRotate";
                CommandRotate["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} symmetry
                 * @class
                 * @extends com.vzome.core.commands.CommandSymmetry
                 */
                class CommandAxialSymmetry extends com.vzome.core.commands.CommandSymmetry {
                    constructor(symmetry = null) {
                        super(symmetry);
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        this.setSymmetry(attributes);
                        const norm = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                        if (norm == null) {
                            throw new com.vzome.core.commands.Command.Failure("no symmetry axis provided");
                        }
                        const output = new com.vzome.core.construction.ConstructionList();
                        let vector = norm.getOffset();
                        vector = norm.getField().projectTo3d(vector, true);
                        const axis = this.mSymmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
                        const rotation = axis.getRotationPermutation();
                        if (rotation == null) {
                            throw new com.vzome.core.commands.Command.Failure("symmetry axis does not support axial symmetry");
                        }
                        const order = rotation.getOrder();
                        const rotate = new com.vzome.core.commands.CommandRotate();
                        for (let i = 1; i < order; i++) {
                            {
                                for (let index = parameters.iterator(); index.hasNext();) {
                                    let param = index.next();
                                    {
                                        output.addConstruction(param);
                                    }
                                }
                                parameters = rotate.apply(parameters, attributes, effects);
                            }
                            ;
                        }
                        for (let index = parameters.iterator(); index.hasNext();) {
                            let param = index.next();
                            {
                                output.addConstruction(param);
                            }
                        }
                        return output;
                    }
                }
                commands.CommandAxialSymmetry = CommandAxialSymmetry;
                CommandAxialSymmetry["__class"] = "com.vzome.core.commands.CommandAxialSymmetry";
                CommandAxialSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class PanelPanelIntersection extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        let panel0 = null;
                        let panel1 = null;
                        let nPanels = 0;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    switch ((nPanels++)) {
                                        case 0:
                                            panel0 = man;
                                            break;
                                        case 1:
                                            panel1 = man;
                                            break;
                                        default:
                                            break;
                                    }
                                }
                            }
                        }
                        if (nPanels !== 2) {
                            let msg;
                            switch ((nPanels)) {
                                case 0:
                                    msg = "No panels are selected.";
                                    break;
                                case 1:
                                    msg = "One panel is selected.";
                                    break;
                                default:
                                    msg = nPanels + " panels are selected.";
                                    break;
                            }
                            this.fail(msg + " Two are required.");
                        }
                        if (com.vzome.core.algebra.AlgebraicVectors.areParallel(panel0['getNormal$'](), panel1['getNormal$']())) {
                            const vertices = (new java.util.ArrayList());
                            {
                                let array = [panel0, panel1];
                                for (let index = 0; index < array.length; index++) {
                                    let panel = array[index];
                                    {
                                        for (let index1 = panel.iterator(); index1.hasNext();) {
                                            let v = index1.next();
                                            {
                                                vertices.add(v);
                                            }
                                        }
                                    }
                                }
                            }
                            this.fail("Panels are " + (com.vzome.core.algebra.AlgebraicVectors.areCoplanar(vertices) ? "coplanar" : "parallel") + ".");
                        }
                        this.redo();
                        const segment = new com.vzome.core.construction.PolygonPolygonProjectionToSegment(PanelPanelIntersection.polygonFromPanel(panel0), PanelPanelIntersection.polygonFromPanel(panel1));
                        const start = new com.vzome.core.construction.FreePoint(segment.getStart());
                        const end = new com.vzome.core.construction.FreePoint(segment.getEnd());
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(start));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(end));
                        this.redo();
                    }
                    /*private*/ static polygonFromPanel(panel) {
                        const vertices = (new java.util.ArrayList(panel.getVertexCount()));
                        for (let index = panel.iterator(); index.hasNext();) {
                            let vector = index.next();
                            {
                                vertices.add(new com.vzome.core.construction.FreePoint(vector));
                            }
                        }
                        return new com.vzome.core.construction.PolygonFromVertices(vertices);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return /* getSimpleName */ (c => typeof c === 'string' ? c.substring(c.lastIndexOf('.') + 1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))(this.constructor);
                    }
                }
                edits.PanelPanelIntersection = PanelPanelIntersection;
                PanelPanelIntersection["__class"] = "com.vzome.core.edits.PanelPanelIntersection";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class GhostSymmetry24Cell extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        if (this.proj === undefined) {
                            this.proj = null;
                        }
                        if (this.symmAxis === undefined) {
                            this.symmAxis = null;
                        }
                        if (this.symm === undefined) {
                            this.symm = null;
                        }
                        this.symm = editor['getSymmetrySystem$']().getSymmetry();
                        this.field = this.symm.getField();
                        this.symmAxis = editor.getSymmetrySegment();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "GhostSymmetry24Cell";
                    }
                    /**
                     *
                     * @param {*} result
                     */
                    getXmlAttributes(result) {
                        if (this.symmAxis != null)
                            com.vzome.core.commands.XmlSaveFormat.serializeSegment(result, "start", "end", this.symmAxis);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.symmAxis = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "start", "end");
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.symmAxis == null)
                            this.proj = new com.vzome.core.math.Projection.Default(this.field);
                        else
                            this.proj = new com.vzome.core.math.QuaternionProjection(this.field, null, this.symmAxis.getOffset().scale(this.field['createPower$int'](-5)));
                        const blue = this.symm.getDirection("blue");
                        const green = this.symm.getDirection("green");
                        for (let k = 0; k < 12; k++) {
                            {
                                const A1 = blue.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, (k + 2) % 12).normal();
                                const A2 = green.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, (5 * k + 2) % 12).normal();
                                const B1 = green.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, (k + 2) % 12).normal();
                                const B2 = blue.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, (5 * k + 5) % 12).normal();
                                let projected = this.symm.getField().origin(4);
                                projected.setComponent(0, A2.getComponent(0));
                                projected.setComponent(1, A2.getComponent(1));
                                projected.setComponent(2, A1.getComponent(0));
                                projected.setComponent(3, A1.getComponent(1));
                                if (this.proj != null)
                                    projected = this.proj.projectImage(projected, true);
                                let p = new com.vzome.core.construction.FreePoint(projected.scale(this.field['createPower$int'](5)));
                                p.setIndex(k);
                                this.manifestConstruction(p);
                                projected = this.symm.getField().origin(4);
                                projected.setComponent(0, B2.getComponent(0));
                                projected.setComponent(1, B2.getComponent(1));
                                projected.setComponent(2, B1.getComponent(0));
                                projected.setComponent(3, B1.getComponent(1));
                                if (this.proj != null)
                                    projected = this.proj.projectImage(projected, true);
                                p = new com.vzome.core.construction.FreePoint(projected.scale(this.field['createPower$int'](5)));
                                p.setIndex(12 + k);
                                this.manifestConstruction(p);
                            }
                            ;
                        }
                        this.redo();
                    }
                }
                edits.GhostSymmetry24Cell = GhostSymmetry24Cell;
                GhostSymmetry24Cell["__class"] = "com.vzome.core.edits.GhostSymmetry24Cell";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class JoinPoints extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        this.joinMode = JoinPoints.JoinModeEnum.CLOSED_LOOP;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        const mode = props.get("mode");
                        if (mode != null)
                            this.joinMode = /* Enum.valueOf */ JoinPoints.JoinModeEnum[mode];
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.joinMode === JoinPoints.JoinModeEnum.CLOSED_LOOP) {
                        }
                        else {
                            element.setAttribute(JoinPoints.ATTRNAME_CLOSEDLOOP, "false");
                            if (this.joinMode !== JoinPoints.JoinModeEnum.CHAIN_BALLS)
                                element.setAttribute(JoinPoints.ATTRNAME_JOINMODE, /* Enum.name */ com.vzome.core.edits.JoinPoints.JoinModeEnum[this.joinMode]);
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        let attr = xml.getAttribute(JoinPoints.ATTRNAME_JOINMODE);
                        if (attr != null && !(attr.length === 0)) {
                            this.joinMode = /* Enum.valueOf */ JoinPoints.JoinModeEnum[attr];
                        }
                        else {
                            attr = xml.getAttribute(JoinPoints.ATTRNAME_CLOSEDLOOP);
                            if (attr != null && !(attr.length === 0)) {
                                this.joinMode = javaemul.internal.BooleanHelper.parseBoolean(attr) ? JoinPoints.JoinModeEnum.CLOSED_LOOP : JoinPoints.JoinModeEnum.CHAIN_BALLS;
                            }
                            else {
                                this.joinMode = JoinPoints.JoinModeEnum.CLOSED_LOOP;
                            }
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        const inputs = (new java.util.ArrayList());
                        if (this.joinMode !== JoinPoints.JoinModeEnum.ALL_POSSIBLE)
                            this.setOrderedSelection(true);
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    inputs.add(man.getFirstConstruction());
                                }
                                this.unselect$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        this.redo();
                        const last = inputs.size() - 1;
                        if (last > 0) {
                            const points = inputs.toArray([]);
                            switch ((this.joinMode)) {
                                case com.vzome.core.edits.JoinPoints.JoinModeEnum.CHAIN_BALLS:
                                    for (let i = 0; i < last; i++) {
                                        {
                                            this.addSegment(points, i, i + 1);
                                        }
                                        ;
                                    }
                                    break;
                                case com.vzome.core.edits.JoinPoints.JoinModeEnum.CLOSED_LOOP:
                                    for (let i = 0; i < last; i++) {
                                        {
                                            this.addSegment(points, i, i + 1);
                                        }
                                        ;
                                    }
                                    if (last > 1) {
                                        this.addSegment(points, last, 0);
                                    }
                                    break;
                                case com.vzome.core.edits.JoinPoints.JoinModeEnum.ALL_TO_FIRST:
                                    for (let i = 1; i <= last; i++) {
                                        {
                                            this.addSegment(points, 0, i);
                                        }
                                        ;
                                    }
                                    break;
                                case com.vzome.core.edits.JoinPoints.JoinModeEnum.ALL_TO_LAST:
                                    for (let i = 0; i < last; i++) {
                                        {
                                            this.addSegment(points, i, last);
                                        }
                                        ;
                                    }
                                    break;
                                case com.vzome.core.edits.JoinPoints.JoinModeEnum.ALL_POSSIBLE:
                                    for (let start = 0; start < last; start++) {
                                        {
                                            for (let end = start + 1; end <= last; end++) {
                                                {
                                                    this.addSegment(points, start, end);
                                                }
                                                ;
                                            }
                                        }
                                        ;
                                    }
                                    break;
                                default:
                                    throw new com.vzome.core.commands.Command.Failure("Unsupported JoinModeEnum: " + /* Enum.name */ com.vzome.core.edits.JoinPoints.JoinModeEnum[this.joinMode]);
                            }
                            this.redo();
                        }
                    }
                    addSegment(points, start, end) {
                        if ((start !== end) && !(points[start].getLocation().equals(points[end].getLocation()))) {
                            const segment = new com.vzome.core.construction.SegmentJoiningPoints(points[start], points[end]);
                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "JoinPoints";
                    }
                }
                JoinPoints.ATTRNAME_CLOSEDLOOP = "closedLoop";
                JoinPoints.ATTRNAME_JOINMODE = "joinMode";
                edits.JoinPoints = JoinPoints;
                JoinPoints["__class"] = "com.vzome.core.edits.JoinPoints";
                (function (JoinPoints) {
                    let JoinModeEnum;
                    (function (JoinModeEnum) {
                        JoinModeEnum[JoinModeEnum["CHAIN_BALLS"] = 0] = "CHAIN_BALLS";
                        JoinModeEnum[JoinModeEnum["CLOSED_LOOP"] = 1] = "CLOSED_LOOP";
                        JoinModeEnum[JoinModeEnum["ALL_TO_FIRST"] = 2] = "ALL_TO_FIRST";
                        JoinModeEnum[JoinModeEnum["ALL_TO_LAST"] = 3] = "ALL_TO_LAST";
                        JoinModeEnum[JoinModeEnum["ALL_POSSIBLE"] = 4] = "ALL_POSSIBLE";
                    })(JoinModeEnum = JoinPoints.JoinModeEnum || (JoinPoints.JoinModeEnum = {}));
                })(JoinPoints = edits.JoinPoints || (edits.JoinPoints = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ShowNormals extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        const SCALE_DOWN = this.mManifestations.getField()['createAlgebraicNumber$int$int$int$int'](1, 0, 2, -3);
                        this.unselectConnectors();
                        this.unselectStruts();
                        for (let index = com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.mSelection).iterator(); index.hasNext();) {
                            let panel = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(panel);
                                const centroid = panel.getCentroid();
                                const tip = centroid.plus(panel['getNormal$']().scale(SCALE_DOWN));
                                const p1 = new com.vzome.core.construction.FreePoint(centroid);
                                const p2 = new com.vzome.core.construction.FreePoint(tip);
                                const s = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p1));
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p2));
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(s));
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return ShowNormals.NAME;
                    }
                }
                ShowNormals.NAME = "ShowNormals";
                edits.ShowNormals = ShowNormals;
                ShowNormals["__class"] = "com.vzome.core.edits.ShowNormals";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class JoinPointPair extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.start === undefined) {
                            this.start = null;
                        }
                        if (this.end === undefined) {
                            this.end = null;
                        }
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        this.start = props.get("start");
                        this.end = props.get("end");
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        com.vzome.core.commands.XmlSaveFormat.serializePoint(element, "start", this.start);
                        com.vzome.core.commands.XmlSaveFormat.serializePoint(element, "end", this.end);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.start = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "start");
                        this.end = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "end");
                    }
                    /**
                     *
                     */
                    perform() {
                        if ((this.start !== this.end) && !(this.start.getLocation().equals(this.end.getLocation()))) {
                            const segment = new com.vzome.core.construction.SegmentJoiningPoints(this.start, this.end);
                            this.manifestConstruction(segment);
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "JoinPointPair";
                    }
                }
                edits.JoinPointPair = JoinPointPair;
                JoinPointPair["__class"] = "com.vzome.core.edits.JoinPointPair";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class Label extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editorModel) {
                        super(editorModel);
                        if (this.target === undefined) {
                            this.target = null;
                        }
                        if (this.label === undefined) {
                            this.label = null;
                        }
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        this.target = props.get("picked");
                        this.label = props.get("text");
                    }
                    /**
                     *
                     */
                    perform() {
                        this.labelManifestation(this.target, this.label);
                        super.perform();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "Label";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        const construction = this.target.getFirstConstruction();
                        if (construction != null && construction instanceof com.vzome.core.construction.Point)
                            com.vzome.core.commands.XmlSaveFormat.serializePoint(element, "point", construction);
                        else if (construction != null && construction instanceof com.vzome.core.construction.Segment)
                            com.vzome.core.commands.XmlSaveFormat.serializeSegment(element, "startSegment", "endSegment", construction);
                        else if (construction != null && construction instanceof com.vzome.core.construction.Polygon)
                            com.vzome.core.commands.XmlSaveFormat.serializePolygon(element, "polygonVertex", construction);
                        element.setAttribute("text", this.label);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.label = xml.getAttribute("text");
                        let construction = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "point");
                        if (construction == null)
                            construction = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "startSegment", "endSegment");
                        if (construction == null)
                            construction = format.parsePolygon$org_w3c_dom_Element$java_lang_String(xml, "polygonVertex");
                        if (construction != null)
                            this.target = this.getManifestation(construction);
                    }
                }
                edits.Label = Label;
                Label["__class"] = "com.vzome.core.edits.Label";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ShowPoint extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.point === undefined) {
                            this.point = null;
                        }
                        if (this.parameters === undefined) {
                            this.parameters = null;
                        }
                        this.parameters = editor;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        switch (props.get("mode")) {
                            case "origin":
                                const origin = this.mManifestations.getField().origin(3);
                                this.point = new com.vzome.core.construction.FreePoint(origin);
                                break;
                            case "symmCenter":
                                this.point = this.parameters.getCenterPoint();
                                break;
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        this.manifestConstruction(this.point);
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    getXmlAttributes(xml) {
                        com.vzome.core.commands.XmlSaveFormat.serializePoint(xml, "point", this.point);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        if (format.commandEditsCompacted())
                            this.point = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "point");
                        else {
                            const attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                            this.point = attrs.get("point");
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ShowPoint";
                    }
                }
                edits.ShowPoint = ShowPoint;
                ShowPoint["__class"] = "com.vzome.core.edits.ShowPoint";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * This is only used when opening legacy files.  The UI and controllers now use the generic Polytope4d.
                 * @author Scott Vorthmann
                 * @param {*} editorModel
                 * @param {com.vzome.core.construction.Segment} symmAxis
                 * @param {number} index
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class B4Polytope extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editorModel, symmAxis, index) {
                        if (((editorModel != null && (editorModel.constructor != null && editorModel.constructor["__interfaces"] != null && editorModel.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editorModel === null) && ((symmAxis != null && symmAxis instanceof com.vzome.core.construction.Segment) || symmAxis === null) && ((typeof index === 'number') || index === null)) {
                            let __args = arguments;
                            super(editorModel);
                            if (this.index === undefined) {
                                this.index = 0;
                            }
                            if (this.proj === undefined) {
                                this.proj = null;
                            }
                            if (this.symmAxis === undefined) {
                                this.symmAxis = null;
                            }
                            if (this.field === undefined) {
                                this.field = null;
                            }
                            this.field = this.mManifestations.getField();
                            this.index = index;
                            this.symmAxis = symmAxis;
                        }
                        else if (((editorModel != null && (editorModel.constructor != null && editorModel.constructor["__interfaces"] != null && editorModel.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editorModel === null) && symmAxis === undefined && index === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let symmAxis = null;
                                let index = 0;
                                super(editorModel);
                                if (this.index === undefined) {
                                    this.index = 0;
                                }
                                if (this.proj === undefined) {
                                    this.proj = null;
                                }
                                if (this.symmAxis === undefined) {
                                    this.symmAxis = null;
                                }
                                if (this.field === undefined) {
                                    this.field = null;
                                }
                                this.field = this.mManifestations.getField();
                                this.index = index;
                                this.symmAxis = symmAxis;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "B4Polytope";
                    }
                    /**
                     *
                     * @param {*} result
                     */
                    getXmlAttributes(result) {
                        com.vzome.xml.DomUtils.addAttribute(result, "dynkin", com.vzome.xml.DomUtils.byteToBinary(this.index));
                        if (this.symmAxis != null)
                            com.vzome.core.commands.XmlSaveFormat.serializeSegment(result, "start", "end", this.symmAxis);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        const binary = xml.getAttribute("dynkin");
                        this.index = javaemul.internal.IntegerHelper.parseInt(binary, 2);
                        if (format.commandEditsCompacted())
                            this.symmAxis = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "start", "end");
                        else {
                            const attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                            this.symmAxis = attrs.get("rotation");
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.symmAxis == null)
                            this.proj = new com.vzome.core.math.Projection.Default(this.field);
                        else {
                            const scale = this.field['createPower$int'](-5);
                            this.proj = new com.vzome.core.math.QuaternionProjection(this.field, null, this.symmAxis.getOffset().scale(scale));
                        }
                        const edgeScales = [null, null, null, null];
                        for (let i = 0; i < edgeScales.length; i++) {
                            {
                                edgeScales[i] = this.field.one();
                            }
                            ;
                        }
                        const group = new com.vzome.core.math.symmetry.B4Group(this.field);
                        com.vzome.core.math.symmetry.WythoffConstruction.constructPolytope(group, this.index, this.index, edgeScales, group, new B4Polytope.WythoffListener(this, this.field));
                        this.redo();
                    }
                }
                edits.B4Polytope = B4Polytope;
                B4Polytope["__class"] = "com.vzome.core.edits.B4Polytope";
                (function (B4Polytope) {
                    class WythoffListener {
                        constructor(__parent, field) {
                            this.__parent = __parent;
                            this.numVertices = 0;
                            if (this.scale === undefined) {
                                this.scale = null;
                            }
                            this.scale = field['createPower$int'](5);
                        }
                        /**
                         *
                         * @param {*} p1
                         * @param {*} p2
                         * @return {*}
                         */
                        addEdge(p1, p2) {
                            const edge = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                            this.__parent.manifestConstruction(edge);
                            return edge;
                        }
                        /**
                         *
                         * @param {java.lang.Object[]} vertices
                         * @return {*}
                         */
                        addFace(vertices) {
                            return null;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vertex
                         * @return {*}
                         */
                        addVertex(vertex) {
                            let projected = vertex;
                            if (this.__parent.proj != null)
                                projected = this.__parent.proj.projectImage(vertex, true);
                            const p = new com.vzome.core.construction.FreePoint(projected.scale(this.scale));
                            p.setIndex(this.numVertices++);
                            this.__parent.manifestConstruction(p);
                            return p;
                        }
                    }
                    B4Polytope.WythoffListener = WythoffListener;
                    WythoffListener["__class"] = "com.vzome.core.edits.B4Polytope.WythoffListener";
                    WythoffListener["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];
                })(B4Polytope = edits.B4Polytope || (edits.B4Polytope = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class CrossProduct extends com.vzome.core.editor.api.ChangeManifestations {
                    /**
                     *
                     */
                    perform() {
                        let p1 = null;
                        let p2 = null;
                        let s1 = null;
                        let success = false;
                        this.setOrderedSelection(true);
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (success) {
                                    this.recordSelected(man);
                                }
                                else {
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        const nextPoint = man.getFirstConstruction();
                                        if (p1 == null) {
                                            p1 = nextPoint;
                                        }
                                        else if (s1 == null) {
                                            p2 = nextPoint;
                                            s1 = new com.vzome.core.construction.SegmentJoiningPoints(p1, nextPoint);
                                        }
                                        else if (!success) {
                                            let segment = new com.vzome.core.construction.SegmentJoiningPoints(p2, nextPoint);
                                            segment = new com.vzome.core.construction.SegmentCrossProduct(s1, segment);
                                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                                            const endpt = new com.vzome.core.construction.SegmentEndPoint(segment);
                                            this.manifestConstruction(endpt);
                                            success = true;
                                        }
                                        else
                                            this.recordSelected(man);
                                    }
                                }
                            }
                        }
                        if (!success)
                            throw new com.vzome.core.commands.Command.Failure("cross-product requires three selected vertices");
                        this.redo();
                    }
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "CrossProduct";
                    }
                }
                edits.CrossProduct = CrossProduct;
                CrossProduct["__class"] = "com.vzome.core.edits.CrossProduct";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ShowHidden extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        for (let index = this.mManifestations.iterator(); index.hasNext();) {
                            let m = index.next();
                            {
                                if (m.isHidden()) {
                                    this.showManifestation(m);
                                    this.select$com_vzome_core_model_Manifestation(m);
                                }
                                else if (this.mSelection.manifestationSelected(m))
                                    this.unselect$com_vzome_core_model_Manifestation(m);
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ShowHidden";
                    }
                }
                edits.ShowHidden = ShowHidden;
                ShowHidden["__class"] = "com.vzome.core.edits.ShowHidden";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class HeptagonSubdivision extends com.vzome.core.editor.api.ChangeManifestations {
                    /**
                     *
                     */
                    perform() {
                        let p1 = null;
                        this.setOrderedSelection(true);
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    const nextPoint = man.getFirstConstruction();
                                    if (p1 == null)
                                        p1 = nextPoint;
                                    else {
                                        const segment = new com.vzome.core.construction.SegmentJoiningPoints(p1, nextPoint);
                                        const field = segment.getField();
                                        const scaleFactor = field.getAffineScalar().reciprocal();
                                        const offset = segment.getOffset();
                                        const off2 = offset.scale(scaleFactor);
                                        const off1 = off2.scale(scaleFactor);
                                        const v1 = p1.getLocation().plus(off1);
                                        const firstPoint = new com.vzome.core.construction.FreePoint(v1);
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(firstPoint));
                                        const v2 = v1.plus(off2);
                                        const secondPoint = new com.vzome.core.construction.FreePoint(v2);
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(secondPoint));
                                        break;
                                    }
                                }
                            }
                        }
                        this.redo();
                    }
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "HeptagonSubdivision";
                    }
                }
                edits.HeptagonSubdivision = HeptagonSubdivision;
                HeptagonSubdivision["__class"] = "com.vzome.core.edits.HeptagonSubdivision";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class PolarZonohedron extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.symmetry === undefined) {
                            this.symmetry = null;
                        }
                        if (this.editor === undefined) {
                            this.editor = null;
                        }
                        this.editor = editor;
                        this.symmetry = editor['getSymmetrySystem$']();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "PolarZonohedron";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.symmetry != null) {
                            com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetry.getName());
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.symmetry = this.editor['getSymmetrySystem$java_lang_String'](xml.getAttribute("symmetry"));
                    }
                    /**
                     *
                     */
                    perform() {
                        const errorMsg = new java.lang.StringBuilder();
                        errorMsg.append("The Polar Zonohedron command requires either of the following selections:\n\n1) Two non-collinear struts with a common end point.\n   The first strut must have more than 2-fold rotational symmetry.\n   The second strut will be rotated around the first.\n\n2) Any three or more struts having a common end point.\n");
                        const struts = (new java.util.ArrayList());
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    struts.add(man);
                                }
                                this.unselect$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        if (struts.size() < 2) {
                            errorMsg.append(struts.size() === 1 ? "\nonly one strut is selected." : "\nno struts are selected.");
                            this.fail(errorMsg.toString());
                        }
                        const common = struts.size() === 2 ? this.useRotationalSymmetry(struts, errorMsg) : this.useRadialSelection(struts);
                        if (common == null) {
                            this.fail(errorMsg.append("\nselected struts do not have a common end point").toString());
                        }
                        const L1 = 0;
                        const L2 = 1;
                        const layers = struts.size();
                        const offsets = (new java.util.ArrayList(layers));
                        const vertices = [null, null];
                        vertices[L1] = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(layers);
                        for (let i = 0; i < layers; i++) {
                            {
                                const strut = struts.get(i);
                                const start = strut.getLocation();
                                const end = strut.getEnd();
                                const offset = strut.getOffset();
                                if (start.equals(common)) {
                                    vertices[L1][i] = end;
                                    offsets.add(offset);
                                }
                                else {
                                    vertices[L1][i] = start;
                                    offsets.add(offset.negate());
                                }
                            }
                            ;
                        }
                        for (let layer = 1; layer < layers; layer++) {
                            {
                                vertices[L2] = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(layers);
                                for (let i = 0; i < layers; i++) {
                                    {
                                        const off = (i + layer) % layers;
                                        const offset = offsets.get(off);
                                        const v1 = vertices[L1][i];
                                        const v2 = v1.plus(offset);
                                        const v3 = vertices[L1][(i + 1) % layers];
                                        const v0 = v3.minus(offset);
                                        vertices[L2][i] = v2;
                                        const p0 = new com.vzome.core.construction.FreePoint(v0);
                                        const p1 = new com.vzome.core.construction.FreePoint(v1);
                                        const p2 = new com.vzome.core.construction.FreePoint(v2);
                                        const p3 = new com.vzome.core.construction.FreePoint(v3);
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p0));
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p1));
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p2));
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p3));
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p1, p2)));
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p2, p3)));
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p0, p1, p2, p3])));
                                    }
                                    ;
                                }
                                vertices[L1] = vertices[L2];
                            }
                            ;
                        }
                        this.redo();
                    }
                    static getCommonEndpoint(strut1, strut2) {
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(strut1, strut2)) {
                            throw new java.lang.IllegalArgumentException("Identical struts have both end points in common.");
                        }
                        const start1 = strut1.getLocation();
                        const end1 = strut1.getEnd();
                        const start2 = strut2.getLocation();
                        const end2 = strut2.getEnd();
                        if (start1.equals(start2) || start1.equals(end2))
                            return start1;
                        if (end1.equals(start2) || end1.equals(end2))
                            return end1;
                        return null;
                    }
                    /*private*/ useRotationalSymmetry(struts, errorMsg) {
                        const axisStrut = struts.get(0);
                        const axisSegment = axisStrut.getFirstConstruction();
                        let v1 = axisSegment.getOffset();
                        v1 = axisSegment.getField().projectTo3d(v1, true);
                        const axis1 = this.symmetry.getAxis(v1);
                        if (axis1 == null) {
                            this.fail(errorMsg.append("\nfirst selected strut is not an axis of rotational symmetry").toString());
                        }
                        const perm = axis1.getRotationPermutation();
                        if (perm == null) {
                            this.fail(errorMsg.append("\nfirst selected strut is not an axis of rotation").toString());
                        }
                        let rotation = perm.mapIndex(0);
                        const order = perm.getOrder();
                        if (order <= 2) {
                            this.fail(errorMsg.append("\nfirst selected strut has " + order + "-fold symmetry").toString());
                        }
                        const spokeStrut = struts.get(1);
                        const spokeSegment = spokeStrut.getFirstConstruction();
                        let v2 = spokeSegment.getOffset();
                        if (v1.equals(v2) || v1.equals(v2.negate())) {
                            this.fail(errorMsg.append("\nselected struts are collinear").toString());
                        }
                        const common = PolarZonohedron.getCommonEndpoint(axisStrut, spokeStrut);
                        if (common == null) {
                            this.fail(errorMsg.append("\nselected struts do not have a common end point").toString());
                        }
                        let s1 = axisSegment.getStart();
                        let e1 = axisSegment.getEnd();
                        const center = new com.vzome.core.construction.SegmentEndPoint(axisSegment, common.equals(e1));
                        let s2 = spokeSegment.getStart();
                        let e2 = spokeSegment.getEnd();
                        if (common.equals(s1)) {
                            if (common.equals(e2)) {
                                v2 = v2.negate();
                                e2 = s2;
                                s2 = common;
                            }
                        }
                        else {
                            v1 = v1.negate();
                            e1 = s1;
                            s1 = common;
                            if (common.equals(e2)) {
                                v2 = v2.negate();
                                e2 = s2;
                                s2 = common;
                            }
                        }
                        this.redo();
                        struts.remove(axisStrut);
                        this.select$com_vzome_core_model_Manifestation(spokeStrut);
                        const p0 = new com.vzome.core.construction.FreePoint(s2);
                        const p1 = new com.vzome.core.construction.FreePoint(e2);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p0));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p1));
                        for (let i = 0; i < order - 1; i++) {
                            {
                                const transform = new com.vzome.core.construction.SymmetryTransformation(this.symmetry.getSymmetry(), rotation, center);
                                rotation = perm.mapIndex(rotation);
                                const ball = this.manifestConstruction(new com.vzome.core.construction.TransformedPoint(transform, p1));
                                const strut = this.manifestConstruction(new com.vzome.core.construction.TransformedSegment(transform, spokeSegment));
                                struts.add(strut);
                                this.select$com_vzome_core_model_Manifestation(ball);
                                this.select$com_vzome_core_model_Manifestation(strut);
                            }
                            ;
                        }
                        this.redo();
                        return common;
                    }
                    /*private*/ useRadialSelection(struts) {
                        const first = struts.get(0);
                        const common = PolarZonohedron.getCommonEndpoint(first, struts.get(1));
                        if (common == null) {
                            return null;
                        }
                        for (let i = 1; i < struts.size(); i++) {
                            {
                                if (!common.equals(PolarZonohedron.getCommonEndpoint(first, struts.get(i)))) {
                                    return null;
                                }
                            }
                            ;
                        }
                        this.redo();
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.FreePoint(common)));
                        for (let index = struts.iterator(); index.hasNext();) {
                            let strut = index.next();
                            {
                                this.select$com_vzome_core_model_Manifestation(strut);
                                const start = strut.getLocation();
                                if (common.equals(start)) {
                                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.FreePoint(strut.getEnd())));
                                }
                                else {
                                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.FreePoint(start)));
                                }
                            }
                        }
                        this.redo();
                        return common;
                    }
                }
                edits.PolarZonohedron = PolarZonohedron;
                PolarZonohedron["__class"] = "com.vzome.core.edits.PolarZonohedron";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class TransformSelection extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor, transform) {
                        super(editor);
                        if (this.transform === undefined) {
                            this.transform = null;
                        }
                        this.transform = transform;
                    }
                    /**
                     *
                     */
                    perform() {
                        const inputs = (new java.util.ArrayList());
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                inputs.add(man);
                            }
                        }
                        this.redo();
                        for (let index = inputs.iterator(); index.hasNext();) {
                            let m = index.next();
                            {
                                if (!m.isRendered())
                                    continue;
                                const c = m.getFirstConstruction();
                                const result = this.transform.transform$com_vzome_core_construction_Construction(c);
                                this.select$com_vzome_core_model_Manifestation$boolean(this.manifestConstruction(result), true);
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "TransformSelection";
                    }
                }
                edits.TransformSelection = TransformSelection;
                TransformSelection["__class"] = "com.vzome.core.edits.TransformSelection";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * This is a modern replacement for CommandQuaternionSymmetry, which is a legacy command.
                 * It duplicates the math from that command, but one key change: only parameter objects that lie
                 * in the W=0 plane are transformed.  This makes it safe and predictable to use
                 * on objects produced by Polytope4d, which retain their 4D coordinates.
                 *
                 * As with CommandQuaternionSymmetry, all transformed vertices are projected to the W=0 plane
                 * before being added to the model.
                 *
                 * @author vorth
                 * @param {*} editor
                 * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} left
                 * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} right
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class Symmetry4d extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor, left, right) {
                        if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && ((left != null && left instanceof com.vzome.core.math.symmetry.QuaternionicSymmetry) || left === null) && ((right != null && right instanceof com.vzome.core.math.symmetry.QuaternionicSymmetry) || right === null)) {
                            let __args = arguments;
                            super(editor);
                            if (this.left === undefined) {
                                this.left = null;
                            }
                            if (this.right === undefined) {
                                this.right = null;
                            }
                            this.left = left;
                            this.right = right;
                        }
                        else if (((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && left === undefined && right === undefined) {
                            let __args = arguments;
                            super(editor);
                            if (this.left === undefined) {
                                this.left = null;
                            }
                            if (this.right === undefined) {
                                this.right = null;
                            }
                            this.left = editor.get4dSymmetries().getQuaternionSymmetry("H_4");
                            this.right = this.left;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {*} parameters
                     */
                    configure(parameters) {
                        this.left = parameters.get("left");
                        this.right = parameters.get("right");
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "Symmetry4d";
                    }
                    /*private*/ static inW0hyperplane(v) {
                        if (v.dimension() > 3)
                            return v.getComponent(com.vzome.core.algebra.AlgebraicVector.W4).isZero();
                        else
                            return true;
                    }
                    /**
                     *
                     */
                    perform() {
                        const params = (new java.util.ArrayList());
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                const cs = man.getConstructions();
                                let useThis = null;
                                if (!cs.hasNext())
                                    throw new com.vzome.core.commands.Command.Failure("No construction for this manifestation");
                                for (const iterator = man.getConstructions(); iterator.hasNext();) {
                                    {
                                        const construction = iterator.next();
                                        if (construction != null && construction instanceof com.vzome.core.construction.Point) {
                                            const p = construction;
                                            if (!Symmetry4d.inW0hyperplane(p.getLocation()))
                                                throw new com.vzome.core.commands.Command.Failure("Some ball is not in the W=0 hyperplane.");
                                        }
                                        else if (construction != null && construction instanceof com.vzome.core.construction.Segment) {
                                            const s = construction;
                                            if (!Symmetry4d.inW0hyperplane(s.getStart()))
                                                throw new com.vzome.core.commands.Command.Failure("Some strut end is not in the W=0 hyperplane.");
                                            if (!Symmetry4d.inW0hyperplane(s.getEnd()))
                                                throw new com.vzome.core.commands.Command.Failure("Some strut end is not in the W=0 hyperplane.");
                                        }
                                        else if (construction != null && construction instanceof com.vzome.core.construction.Polygon) {
                                            const p = construction;
                                            for (let i = 0; i < p.getVertexCount(); i++) {
                                                {
                                                    if (!Symmetry4d.inW0hyperplane(p.getVertex(i))) {
                                                        throw new com.vzome.core.commands.Command.Failure("Some panel vertex is not in the W=0 hyperplane.");
                                                    }
                                                }
                                                ;
                                            }
                                        }
                                        else {
                                            throw new com.vzome.core.commands.Command.Failure("Unknown construction type.");
                                        }
                                        useThis = construction;
                                    }
                                    ;
                                }
                                if (useThis != null)
                                    params.add(useThis);
                            }
                        }
                        this.redo();
                        const leftRoots = this.left.getRoots();
                        const rightRoots = this.right.getRoots();
                        for (let index = 0; index < leftRoots.length; index++) {
                            let leftRoot = leftRoots[index];
                            {
                                for (let index1 = 0; index1 < rightRoots.length; index1++) {
                                    let rightRoot = rightRoots[index1];
                                    {
                                        for (let index2 = params.iterator(); index2.hasNext();) {
                                            let construction = index2.next();
                                            {
                                                let result = null;
                                                if (construction != null && construction instanceof com.vzome.core.construction.Point) {
                                                    result = new com.vzome.core.construction.PointRotated4D(leftRoot, rightRoot, construction);
                                                }
                                                else if (construction != null && construction instanceof com.vzome.core.construction.Segment) {
                                                    result = new com.vzome.core.construction.SegmentRotated4D(leftRoot, rightRoot, construction);
                                                }
                                                else if (construction != null && construction instanceof com.vzome.core.construction.Polygon) {
                                                    result = new com.vzome.core.construction.PolygonRotated4D(leftRoot, rightRoot, construction);
                                                }
                                                else {
                                                }
                                                if (result == null)
                                                    continue;
                                                this.manifestConstruction(result);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        this.redo();
                    }
                    rotateAndProject(loc3d, leftQuaternion, rightQuaternion) {
                        let loc = loc3d.inflateTo4d$boolean(true);
                        loc = rightQuaternion.leftMultiply(loc);
                        loc = leftQuaternion.rightMultiply(loc);
                        loc = loc.projectTo3d(true);
                        return new com.vzome.core.construction.FreePoint(loc);
                    }
                }
                edits.Symmetry4d = Symmetry4d;
                Symmetry4d["__class"] = "com.vzome.core.edits.Symmetry4d";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * @param {*} editorModel
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class AffineHeptagon extends com.vzome.core.editor.api.ChangeManifestations {
                    /**
                     *
                     */
                    perform() {
                        const errorMsg = "Affine heptagon command requires two selected struts with a common vertex.";
                        let strut1 = null;
                        let strut2 = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (strut1 == null) {
                                        strut1 = man;
                                    }
                                    else if (strut2 == null) {
                                        strut2 = man;
                                    }
                                    else {
                                        this.fail(errorMsg);
                                    }
                                }
                            }
                        }
                        if (strut1 == null || strut2 == null) {
                            this.fail(errorMsg);
                        }
                        const field = strut1.getLocation().getField();
                        this.redo();
                        const s1 = strut1.getFirstConstruction();
                        const s2 = strut2.getFirstConstruction();
                        this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s1, true));
                        this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s1, false));
                        this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s2, true));
                        this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s2, false));
                        this.redo();
                        let offset1 = s1.getOffset();
                        let offset2 = s2.getOffset();
                        let v0 = null;
                        let v1 = null;
                        let v2 = null;
                        {
                            const s1s = s1.getStart();
                            const s1e = s1.getEnd();
                            const s2s = s2.getStart();
                            const s2e = s2.getEnd();
                            if (s1s.equals(s2s)) {
                                v0 = s1s;
                                v1 = s1e;
                                v2 = s2e;
                            }
                            else if (s1e.equals(s2s)) {
                                v0 = s1e;
                                v1 = s1s;
                                v2 = s2e;
                                offset1 = offset1.negate();
                            }
                            else if (s1e.equals(s2e)) {
                                v0 = s1e;
                                v1 = s1s;
                                v2 = s2s;
                                offset2 = offset2.negate();
                                offset1 = offset1.negate();
                            }
                            else if (s1s.equals(s2e)) {
                                v0 = s1s;
                                v1 = s1e;
                                v2 = s2s;
                                offset2 = offset2.negate();
                            }
                            else {
                                this.fail(errorMsg);
                            }
                        }
                        ;
                        let c0 = null;
                        let c1 = null;
                        let c2 = null;
                        let p1 = null;
                        let p2 = null;
                        for (let index = this.mManifestations.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    const loc = man.getLocation();
                                    if (loc.equals(v0)) {
                                        c0 = man;
                                    }
                                    else if (loc.equals(v1)) {
                                        c1 = man;
                                        p1 = man.getFirstConstruction();
                                    }
                                    else if (loc.equals(v2)) {
                                        c2 = man;
                                        p2 = man.getFirstConstruction();
                                    }
                                }
                            }
                        }
                        const sigma = field['createAlgebraicNumber$int_A']([0, 0, 1]);
                        const rho = field['createAlgebraicNumber$int_A']([0, 1, 0]);
                        const p3 = new com.vzome.core.construction.TransformedPoint(new com.vzome.core.construction.Translation(offset1.scale(sigma)), p2);
                        const p4 = new com.vzome.core.construction.TransformedPoint(new com.vzome.core.construction.Translation(offset2.scale(sigma)), p1);
                        const p5 = new com.vzome.core.construction.TransformedPoint(new com.vzome.core.construction.Translation(offset1.scale(rho)), p4);
                        const p6 = new com.vzome.core.construction.TransformedPoint(new com.vzome.core.construction.Translation(offset2.scale(rho)), p3);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p1, p3)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p3, p5)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p5, p6)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p6, p4)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p4, p2)));
                        this.select$com_vzome_core_model_Manifestation(c0);
                        this.select$com_vzome_core_model_Manifestation(c1);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p3));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p5));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p6));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p4));
                        this.select$com_vzome_core_model_Manifestation(c2);
                        this.redo();
                    }
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "AffineHeptagon";
                    }
                }
                edits.AffineHeptagon = AffineHeptagon;
                AffineHeptagon["__class"] = "com.vzome.core.edits.AffineHeptagon";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class Polytope4d extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.index === undefined) {
                            this.index = 0;
                        }
                        if (this.field === undefined) {
                            this.field = null;
                        }
                        if (this.proj === undefined) {
                            this.proj = null;
                        }
                        if (this.quaternion === undefined) {
                            this.quaternion = null;
                        }
                        if (this.groupName === undefined) {
                            this.groupName = null;
                        }
                        this.edgesToRender = 15;
                        this.edgeScales = [null, null, null, null];
                        if (this.renderGroupName === undefined) {
                            this.renderGroupName = null;
                        }
                        if (this.symmetries === undefined) {
                            this.symmetries = null;
                        }
                        this.symmetries = editor.get4dSymmetries();
                        this.field = editor.getRealizedModel().getField();
                        for (let i = 0; i < this.edgeScales.length; i++) {
                            {
                                this.edgeScales[i] = this.field.one();
                            }
                            ;
                        }
                    }
                    /**
                     *
                     * @param {*} params
                     */
                    configure(params) {
                        this.groupName = params.get("groupName");
                        this.renderGroupName = params.get("renderGroupName");
                        this.index = (params.get("index") | 0);
                        this.edgesToRender = (params.get("edgesToRender") | 0);
                        this.edgeScales = params.get("edgeScales");
                        this.quaternion = params.get("quaternion");
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "Polytope4d";
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    getXmlAttributes(xml) {
                        if (this.quaternion != null)
                            com.vzome.xml.DomUtils.addAttribute(xml, "quaternion", this.quaternion.toParsableString());
                        com.vzome.xml.DomUtils.addAttribute(xml, "group", this.groupName);
                        com.vzome.xml.DomUtils.addAttribute(xml, "wythoff", com.vzome.xml.DomUtils.byteToBinary(this.index));
                        if (this.edgesToRender !== 15)
                            com.vzome.xml.DomUtils.addAttribute(xml, "renderEdges", com.vzome.xml.DomUtils.byteToBinary(this.edgesToRender));
                        if (!(this.renderGroupName === this.groupName))
                            com.vzome.xml.DomUtils.addAttribute(xml, "renderGroup", this.renderGroupName);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        const binary = xml.getAttribute("wythoff");
                        this.index = javaemul.internal.IntegerHelper.parseInt(binary, 2);
                        const renderString = xml.getAttribute("renderEdges");
                        this.edgesToRender = (renderString == null || /* isEmpty */ (renderString.length === 0)) ? this.index : javaemul.internal.IntegerHelper.parseInt(renderString, 2);
                        this.groupName = xml.getAttribute("group");
                        const rgString = xml.getAttribute("renderGroup");
                        this.renderGroupName = (rgString == null || /* isEmpty */ (rgString.length === 0)) ? this.groupName : rgString;
                        let quatString = xml.getAttribute("quaternion");
                        if (quatString != null && !("" === quatString)) {
                            if ( /* contains */(quatString.indexOf("+") != -1)) {
                                quatString = /* replace */ quatString.split(',').join(' ');
                                quatString = /* replace */ quatString.split('(').join(' ');
                                quatString = /* replace */ quatString.split(')').join(' ');
                                quatString = /* replace */ quatString.split('+').join(' ');
                                const irrat = this.field['getIrrational$int'](0).charAt(0);
                                quatString = /* replace */ quatString.split(irrat).join(' ');
                                quatString = quatString + " 0 0 0";
                            }
                            this.quaternion = this.field.parseVector(quatString);
                        }
                        else {
                            let segment = null;
                            if (format.commandEditsCompacted())
                                segment = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "start", "end");
                            else {
                                const attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                                segment = attrs.get("rotation");
                            }
                            if (segment != null)
                                this.quaternion = segment.getOffset().inflateTo4d$();
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.quaternion == null)
                            this.proj = new com.vzome.core.math.Projection.Default(this.field);
                        else
                            this.proj = new com.vzome.core.math.QuaternionProjection(this.field, null, this.quaternion.scale(this.field['createPower$int'](-5)));
                        this.symmetries.constructPolytope(this.groupName, this.index, this.edgesToRender, this.edgeScales, new Polytope4d.WythoffListener(this));
                        this.redo();
                    }
                    static getSupportedGroups() {
                        return ["A4", "B4/C4", "D4", "F4", "H4"];
                    }
                }
                edits.Polytope4d = Polytope4d;
                Polytope4d["__class"] = "com.vzome.core.edits.Polytope4d";
                (function (Polytope4d) {
                    class WythoffListener {
                        constructor(__parent) {
                            this.__parent = __parent;
                            this.numVertices = 0;
                            this.vertices = (new java.util.HashMap());
                        }
                        /**
                         *
                         * @param {*} p1
                         * @param {*} p2
                         * @return {*}
                         */
                        addEdge(p1, p2) {
                            const edge = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                            this.__parent.manifestConstruction(edge);
                            return edge;
                        }
                        /**
                         *
                         * @param {java.lang.Object[]} vertices
                         * @return {*}
                         */
                        addFace(vertices) {
                            return null;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vertex
                         * @return {*}
                         */
                        addVertex(vertex) {
                            let p = this.vertices.get(vertex.toString());
                            if (p == null) {
                                let projected = vertex;
                                if (this.__parent.proj != null)
                                    projected = this.__parent.proj.projectImage(vertex, true);
                                projected = projected.scale(this.__parent.field['createPower$int'](5));
                                p = new com.vzome.core.construction.FreePoint(projected);
                                p.setIndex(this.numVertices++);
                                this.__parent.manifestConstruction(p);
                                this.vertices.put(vertex.toString(), p);
                            }
                            return p;
                        }
                    }
                    Polytope4d.WythoffListener = WythoffListener;
                    WythoffListener["__class"] = "com.vzome.core.edits.Polytope4d.WythoffListener";
                    WythoffListener["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];
                })(Polytope4d = edits.Polytope4d || (edits.Polytope4d = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ShowVertices extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    const s = man.getFirstConstruction();
                                    const start = new com.vzome.core.construction.SegmentEndPoint(s, true);
                                    this.manifestConstruction(start);
                                    const end = new com.vzome.core.construction.SegmentEndPoint(s, false);
                                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(end));
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    const polygon = man.getFirstConstruction();
                                    for (let i = 0; i < polygon.getVertexCount(); i++) {
                                        {
                                            const v = new com.vzome.core.construction.PolygonVertex(polygon, i);
                                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(v));
                                        }
                                        ;
                                    }
                                }
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return ShowVertices.NAME;
                    }
                }
                ShowVertices.NAME = "ShowVertices";
                edits.ShowVertices = ShowVertices;
                ShowVertices["__class"] = "com.vzome.core.edits.ShowVertices";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class JoinSkewLines extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        const errorMsg = new java.lang.StringBuilder();
                        errorMsg.append("This command requires two non-parallel struts.\n");
                        let s0 = null;
                        let s1 = null;
                        let qty = 0;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    switch ((qty)) {
                                        case 0:
                                            s0 = man;
                                            break;
                                        case 1:
                                            s1 = man;
                                            break;
                                        default:
                                            errorMsg.append("\ntoo many struts are selected.");
                                            this.fail(errorMsg.toString());
                                    }
                                    qty++;
                                }
                                this.unselect$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        if (qty < 2) {
                            errorMsg.append(qty === 1 ? "\nonly one strut is selected." : "\nno struts are selected.");
                            this.fail(errorMsg.toString());
                        }
                        const u = s0.getOffset();
                        const v = s1.getOffset();
                        const p0 = s0.getLocation();
                        const q0 = s1.getLocation();
                        const uuA = u.dot(u);
                        const uvB = u.dot(v);
                        const vvC = v.dot(v);
                        const denD = uuA['times$com_vzome_core_algebra_AlgebraicNumber'](vvC)['minus$com_vzome_core_algebra_AlgebraicNumber'](uvB['times$com_vzome_core_algebra_AlgebraicNumber'](uvB));
                        if (denD.isZero()) {
                            errorMsg.append("\nstruts are parallel.");
                            this.fail(errorMsg.toString());
                        }
                        this.redo();
                        const w = p0.minus(q0);
                        const uwD = u.dot(w);
                        const vwE = v.dot(w);
                        const sc = (uvB['times$com_vzome_core_algebra_AlgebraicNumber'](vwE)['minus$com_vzome_core_algebra_AlgebraicNumber'](vvC['times$com_vzome_core_algebra_AlgebraicNumber'](uwD))).dividedBy(denD);
                        const tc = (uuA['times$com_vzome_core_algebra_AlgebraicNumber'](vwE)['minus$com_vzome_core_algebra_AlgebraicNumber'](uvB['times$com_vzome_core_algebra_AlgebraicNumber'](uwD))).dividedBy(denD);
                        const w0 = p0.plus(u.scale(sc));
                        const pw0 = new com.vzome.core.construction.FreePoint(w0);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(pw0));
                        const w1 = q0.plus(v.scale(tc));
                        if (!w1.equals(w0)) {
                            const pw1 = new com.vzome.core.construction.FreePoint(w1);
                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(pw1));
                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(pw0, pw1)));
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return JoinSkewLines.NAME;
                    }
                }
                JoinSkewLines.NAME = "JoinSkewLines";
                edits.JoinSkewLines = JoinSkewLines;
                JoinSkewLines["__class"] = "com.vzome.core.edits.JoinSkewLines";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class NewCentroid extends com.vzome.core.editor.api.ChangeManifestations {
                    /**
                     *
                     */
                    perform() {
                        const verticesList = (new java.util.ArrayList());
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                const construction = man.toConstruction();
                                if (construction != null && construction instanceof com.vzome.core.construction.Point) {
                                    const nextPoint = construction;
                                    verticesList.add(nextPoint);
                                }
                            }
                        }
                        if (verticesList.size() < 2)
                            throw new com.vzome.core.commands.Command.Failure("Select at least two balls to compute the centroid.");
                        const points = [];
                        const centroid = new com.vzome.core.construction.CentroidPoint(verticesList.toArray(points));
                        this.manifestConstruction(centroid);
                        this.redo();
                    }
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "NewCentroid";
                    }
                }
                edits.NewCentroid = NewCentroid;
                NewCentroid["__class"] = "com.vzome.core.edits.NewCentroid";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class LinePlaneIntersect extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    /**
                     *
                     */
                    perform() {
                        let panel = null;
                        let strut = null;
                        let p0 = null;
                        let p1 = null;
                        let p2 = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if ((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) && (p2 == null)) {
                                    const nextPoint = man.getFirstConstruction();
                                    if (p0 == null)
                                        p0 = nextPoint;
                                    else if (p1 == null)
                                        p1 = nextPoint;
                                    else if (p2 == null)
                                        p2 = nextPoint;
                                }
                                else if ((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) && (strut == null)) {
                                    strut = man;
                                }
                                else if ((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) && panel == null) {
                                    panel = man;
                                }
                            }
                        }
                        if (strut == null) {
                            return;
                        }
                        let point = null;
                        let plane = null;
                        const line = new com.vzome.core.construction.LineFromPointAndVector(strut.getLocation(), strut.getZoneVector());
                        if (p2 != null && panel == null) {
                            const points = [p0, p1, p2];
                            const polygon = new com.vzome.core.construction.PolygonFromVertices(points);
                            plane = new com.vzome.core.construction.PlaneExtensionOfPolygon(polygon);
                        }
                        else if (strut != null && panel != null) {
                            plane = new com.vzome.core.construction.PlaneFromPointAndNormal(panel.getFirstVertex(), panel.getZoneVector());
                        }
                        if (plane != null && !plane.isImpossible()) {
                            point = new com.vzome.core.construction.LinePlaneIntersectionPoint(plane, line);
                            if (!point.isImpossible())
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(point));
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "LinePlaneIntersect";
                    }
                }
                edits.LinePlaneIntersect = LinePlaneIntersect;
                LinePlaneIntersect["__class"] = "com.vzome.core.edits.LinePlaneIntersect";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectByBoundary extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     * @param {string} message
                     */
                    fail(message) {
                        const errorMsg = new java.lang.StringBuilder();
                        const usage = this.usage();
                        if (usage != null) {
                            errorMsg.append(usage);
                        }
                        if (message != null) {
                            if (errorMsg.length() > 0) {
                                errorMsg.append("\n");
                            }
                            errorMsg.append(message);
                        }
                        super.fail(errorMsg.toString());
                    }
                    /**
                     *
                     */
                    perform() {
                        const errMsg = this.setBoundary();
                        if (errMsg != null) {
                            this.fail(errMsg);
                        }
                        this.unselectAll();
                        this.selectBoundedManifestations();
                        this.redo();
                    }
                    selectBoundedManifestations() {
                        for (let index = this.getConnectors().iterator(); index.hasNext();) {
                            let connector = index.next();
                            {
                                if (this.boundaryContains$com_vzome_core_model_Connector(connector)) {
                                    this.select$com_vzome_core_model_Manifestation(connector);
                                }
                            }
                        }
                        for (let index = this.getStruts().iterator(); index.hasNext();) {
                            let strut = index.next();
                            {
                                if (this.boundaryContains$com_vzome_core_model_Strut(strut)) {
                                    this.select$com_vzome_core_model_Manifestation(strut);
                                }
                            }
                        }
                        for (let index = this.getPanels().iterator(); index.hasNext();) {
                            let panel = index.next();
                            {
                                if (this.boundaryContains$com_vzome_core_model_Panel(panel)) {
                                    this.select$com_vzome_core_model_Manifestation(panel);
                                }
                            }
                        }
                    }
                    boundaryContains$com_vzome_core_model_Connector(connector) {
                        return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(connector.getLocation());
                    }
                    boundaryContains(connector) {
                        if (((connector != null && (connector.constructor != null && connector.constructor["__interfaces"] != null && connector.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || connector === null)) {
                            return this.boundaryContains$com_vzome_core_model_Connector(connector);
                        }
                        else if (((connector != null && (connector.constructor != null && connector.constructor["__interfaces"] != null && connector.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || connector === null)) {
                            return this.boundaryContains$com_vzome_core_model_Strut(connector);
                        }
                        else if (((connector != null && (connector.constructor != null && connector.constructor["__interfaces"] != null && connector.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || connector === null)) {
                            return this.boundaryContains$com_vzome_core_model_Panel(connector);
                        }
                        else if (((connector != null && connector instanceof com.vzome.core.algebra.AlgebraicVector) || connector === null)) {
                            return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(connector);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /*private*/ boundaryContains$com_vzome_core_model_Strut(strut) {
                        return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(strut.getLocation()) && this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(strut.getEnd());
                    }
                    /*private*/ boundaryContains$com_vzome_core_model_Panel(panel) {
                        for (let index = panel.iterator(); index.hasNext();) {
                            let vertex = index.next();
                            {
                                if (!this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(vertex)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    boundaryContains$com_vzome_core_algebra_AlgebraicVector(v) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
                }
                edits.SelectByBoundary = SelectByBoundary;
                SelectByBoundary["__class"] = "com.vzome.core.edits.SelectByBoundary";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class RealizeMetaParts extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        let scale = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                const rm = man.getRenderedObject();
                                if (rm != null) {
                                    const shape = rm.getShape();
                                    if (scale == null) {
                                        const field = shape.getField();
                                        scale = field['createPower$int'](5);
                                    }
                                    const orientation = rm.getOrientation();
                                    const vertexList = shape.getVertexList();
                                    for (let index = shape.getVertexList().iterator(); index.hasNext();) {
                                        let vertex = index.next();
                                        {
                                            const vertexPt = this.transformVertex(vertex, man.getLocation(), scale, orientation);
                                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(vertexPt));
                                        }
                                    }
                                    for (let index = shape.getFaceSet().iterator(); index.hasNext();) {
                                        let face = index.next();
                                        {
                                            const vertices = (s => { let a = []; while (s-- > 0)
                                                a.push(null); return a; })(face.size());
                                            for (let i = 0; i < vertices.length; i++) {
                                                {
                                                    const vertexIndex = face.getVertex(i);
                                                    const vertex = vertexList.get(vertexIndex);
                                                    vertices[i] = this.transformVertex(vertex, man.getLocation(), scale, orientation);
                                                }
                                                ;
                                            }
                                            const polygon = new com.vzome.core.construction.PolygonFromVertices(vertices);
                                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(polygon));
                                        }
                                    }
                                }
                            }
                        }
                        this.redo();
                    }
                    /*private*/ transformVertex(vertex, offset, scale, orientation) {
                        if (orientation != null)
                            vertex = orientation.timesColumn(vertex);
                        if (offset != null)
                            vertex = vertex.plus(offset);
                        return new com.vzome.core.construction.FreePoint(vertex.scale(scale));
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return RealizeMetaParts.NAME;
                    }
                }
                RealizeMetaParts.NAME = "realizeMetaParts";
                edits.RealizeMetaParts = RealizeMetaParts;
                RealizeMetaParts["__class"] = "com.vzome.core.edits.RealizeMetaParts";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * called from the main menu and when opening a file
                 * @param symmetry
                 * @param selection
                 * @param model
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 * @author David Hall
                 */
                class SelectParallelStruts extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.symmetry === undefined) {
                            this.symmetry = null;
                        }
                        if (this.orbit === undefined) {
                            this.orbit = null;
                        }
                        if (this.axis === undefined) {
                            this.axis = null;
                        }
                        if (this.editor === undefined) {
                            this.editor = null;
                        }
                        this.editor = editor;
                        this.symmetry = editor['getSymmetrySystem$']();
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        const strut = props.get("picked");
                        if (strut != null) {
                            this.axis = this.symmetry.getAxis(strut.getOffset());
                            this.orbit = this.axis.getOrbit();
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.orbit == null || this.axis == null) {
                            const lastStrut = this.getLastSelectedStrut();
                            if (lastStrut != null) {
                                const offset = lastStrut.getOffset();
                                this.orbit = this.symmetry.getAxis(offset).getOrbit();
                                this.axis = this.orbit.getAxis$com_vzome_core_algebra_AlgebraicVector(offset);
                            }
                        }
                        if (this.orbit == null || this.axis == null) {
                            throw new com.vzome.core.commands.Command.Failure("select a reference strut.");
                        }
                        this.unselectAll();
                        const oppositeAxis = this.symmetry.getSymmetry().getPrincipalReflection() == null ? this.orbit.getAxis$int$int(((this.axis.getSense() + 1) % 2), this.axis.getOrientation()) : this.orbit.getAxis$int$int$boolean(this.axis.getSense(), this.axis.getOrientation(), !this.axis.isOutbound());
                        for (let index = this.getStruts().iterator(); index.hasNext();) {
                            let strut = index.next();
                            {
                                const strutAxis = this.symmetry.getAxis(strut.getOffset());
                                if (strutAxis != null && strutAxis.getOrbit().equals(this.orbit)) {
                                    if (strutAxis.equals(this.axis) || strutAxis.equals(oppositeAxis)) {
                                        this.select$com_vzome_core_model_Manifestation(strut);
                                    }
                                }
                            }
                        }
                        super.perform();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SelectParallelStruts";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.symmetry != null)
                            com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetry.getName());
                        if (this.orbit != null)
                            com.vzome.xml.DomUtils.addAttribute(element, "orbit", this.orbit.getName());
                        if (this.axis != null)
                            com.vzome.core.commands.XmlSymmetryFormat.serializeAxis(element, "symm", "dir", "index", "sense", this.axis);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.symmetry = this.editor['getSymmetrySystem$java_lang_String'](xml.getAttribute("symmetry"));
                        this.orbit = this.symmetry.getOrbits().getDirection(xml.getAttribute("orbit"));
                        this.axis = format.parseAxis(xml, "symm", "dir", "index", "sense");
                    }
                }
                edits.SelectParallelStruts = SelectParallelStruts;
                SelectParallelStruts["__class"] = "com.vzome.core.edits.SelectParallelStruts";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ConvexHull extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    getSelectedVertexSet(unselectAll) {
                        const vertexSet = (new java.util.HashSet());
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    vertexSet.add(man.getLocation());
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    vertexSet.add(man.getLocation());
                                    vertexSet.add(man.getEnd());
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    for (let index = man.iterator(); index.hasNext();) {
                                        let vertex = index.next();
                                        {
                                            vertexSet.add(vertex);
                                        }
                                    }
                                }
                                if (unselectAll) {
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                }
                            }
                        }
                        return vertexSet;
                    }
                }
                edits.ConvexHull = ConvexHull;
                ConvexHull["__class"] = "com.vzome.core.edits.ConvexHull";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ReplaceWithShape extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.vef === undefined) {
                            this.vef = null;
                        }
                        if (this.shape === undefined) {
                            this.shape = null;
                        }
                        if (this.ballOrStrut === undefined) {
                            this.ballOrStrut = null;
                        }
                        if (this.symmetryShapes === undefined) {
                            this.symmetryShapes = null;
                        }
                        if (this.editor === undefined) {
                            this.editor = null;
                        }
                        this.editor = editor;
                    }
                    /*private*/ replace(man, renderedObject, shape) {
                        if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))
                            return;
                        if (renderedObject != null) {
                            const orientation = renderedObject.getOrientation();
                            const vertexList = shape.getVertexList();
                            for (let index = shape.getFaceSet().iterator(); index.hasNext();) {
                                let face = index.next();
                                {
                                    const vertices = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(face.size());
                                    for (let i = 0; i < vertices.length; i++) {
                                        {
                                            const vertexIndex = face.getVertex(i);
                                            const vertex = vertexList.get(vertexIndex);
                                            vertices[i] = ReplaceWithShape.transformVertex(vertex, renderedObject.getLocationAV(), orientation);
                                        }
                                        ;
                                    }
                                    const polygon = new com.vzome.core.construction.PolygonFromVertices(vertices);
                                    const panel = this.manifestConstruction(polygon);
                                    this.select$com_vzome_core_model_Manifestation(panel);
                                }
                            }
                        }
                        this.deleteManifestation(man);
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.symmetryShapes != null) {
                            const tokens = this.symmetryShapes.split(":");
                            const symmetrySystem = this.editor['getSymmetrySystem$java_lang_String'](tokens[0]);
                            const shapes = symmetrySystem.getStyle$java_lang_String(tokens[1]);
                            const model = new com.vzome.core.render.RenderedModel(symmetrySystem.getSymmetry().getField(), new ReplaceWithShape.ReplaceWithShape$0(this, symmetrySystem, shapes));
                            if (this.ballOrStrut != null) {
                                for (let index = this.mSelection.iterator(); index.hasNext();) {
                                    let man = index.next();
                                    {
                                        this.unselect$com_vzome_core_model_Manifestation(man);
                                    }
                                }
                                this.redo();
                                const rm = model.render(this.ballOrStrut);
                                this.replace(this.ballOrStrut, rm, rm.getShape());
                            }
                            else
                                for (let index = this.mSelection.iterator(); index.hasNext();) {
                                    let man = index.next();
                                    {
                                        this.unselect$com_vzome_core_model_Manifestation(man);
                                        const rm = model.render(man);
                                        this.replace(man, rm, rm.getShape());
                                    }
                                }
                        }
                        else {
                            for (let index = this.mSelection.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                }
                            }
                            this.redo();
                            this.replace(this.ballOrStrut, this.ballOrStrut.getRenderedObject(), this.shape);
                        }
                        super.perform();
                    }
                    /*private*/ static transformVertex(vertex, offset, orientation) {
                        if (orientation != null)
                            vertex = orientation.timesColumn(vertex);
                        if (offset != null)
                            vertex = vertex.plus(offset);
                        return new com.vzome.core.construction.FreePoint(vertex);
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        const m = props.get("picked");
                        if (m != null) {
                            this.symmetryShapes = m.getRenderedObject().getSymmetryShapes();
                            this.ballOrStrut = m;
                        }
                        else
                            this.symmetryShapes = props.get("mode");
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.ballOrStrut != null) {
                            const construction = this.ballOrStrut.getFirstConstruction();
                            if (construction != null && construction instanceof com.vzome.core.construction.Point)
                                com.vzome.core.commands.XmlSaveFormat.serializePoint(element, "point", construction);
                            else
                                com.vzome.core.commands.XmlSaveFormat.serializeSegment(element, "startSegment", "endSegment", construction);
                        }
                        if (this.shape != null) {
                            if (this.vef == null) {
                                this.vef = com.vzome.core.algebra.VefVectorExporter.exportPolyhedron(this.shape);
                            }
                            const textNode = element.getOwnerDocument().createTextNode(com.vzome.core.commands.XmlSaveFormat.escapeNewlines(this.vef));
                            element.appendChild(textNode);
                        }
                        else {
                            element.setAttribute("shapes", this.symmetryShapes);
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        const attr = xml.getAttribute("shapes");
                        if (attr != null && !(attr.length === 0)) {
                            this.symmetryShapes = attr;
                        }
                        else {
                            this.vef = xml.getTextContent();
                            this.shape = com.vzome.core.math.VefToPolyhedron.importPolyhedron(format.getField(), this.vef);
                        }
                        let construction = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "point");
                        if (construction == null)
                            construction = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "startSegment", "endSegment");
                        if (construction != null)
                            this.ballOrStrut = this.getManifestation(construction);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return ReplaceWithShape.NAME;
                    }
                }
                ReplaceWithShape.NAME = "ReplaceWithShape";
                edits.ReplaceWithShape = ReplaceWithShape;
                ReplaceWithShape["__class"] = "com.vzome.core.edits.ReplaceWithShape";
                (function (ReplaceWithShape) {
                    class ReplaceWithShape$0 {
                        constructor(__parent, symmetrySystem, shapes) {
                            this.symmetrySystem = symmetrySystem;
                            this.shapes = shapes;
                            this.__parent = __parent;
                        }
                        /* Default method injected from com.vzome.core.editor.api.OrbitSource */
                        getOrientations$() {
                            return this.getOrientations(false);
                        }
                        /* Default method injected from com.vzome.core.editor.api.OrbitSource */
                        getEmbedding() {
                            const symmetry = this.getSymmetry();
                            const field = symmetry.getField();
                            const embedding = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(16);
                            for (let i = 0; i < 3; i++) {
                                {
                                    const columnSelect = field.basisVector(3, i);
                                    const colRV = symmetry.embedInR3(columnSelect);
                                    embedding[i * 4 + 0] = colRV.x;
                                    embedding[i * 4 + 1] = colRV.y;
                                    embedding[i * 4 + 2] = colRV.z;
                                    embedding[i * 4 + 3] = 0.0;
                                }
                                ;
                            }
                            embedding[12] = 0.0;
                            embedding[13] = 0.0;
                            embedding[14] = 0.0;
                            embedding[15] = 1.0;
                            return embedding;
                        }
                        /* Default method injected from com.vzome.core.editor.api.OrbitSource */
                        getZone(orbit, orientation) {
                            return this.getSymmetry().getDirection(orbit).getAxis(com.vzome.core.math.symmetry.Symmetry.PLUS, orientation);
                        }
                        /* Default method injected from com.vzome.core.editor.api.OrbitSource */
                        getOrientations(rowMajor) {
                            if (((typeof rowMajor === 'boolean') || rowMajor === null)) {
                                let __args = arguments;
                                return (() => {
                                    const symmetry = this.getSymmetry();
                                    const field = symmetry.getField();
                                    const order = symmetry.getChiralOrder();
                                    const orientations = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(order);
                                    for (let orientation = 0; orientation < order; orientation++) {
                                        {
                                            if (rowMajor) {
                                                orientations[orientation] = symmetry.getMatrix(orientation).getRowMajorRealElements();
                                                continue;
                                            }
                                            const asFloats = (s => { let a = []; while (s-- > 0)
                                                a.push(0); return a; })(16);
                                            const transform = symmetry.getMatrix(orientation);
                                            for (let i = 0; i < 3; i++) {
                                                {
                                                    const columnSelect = field.basisVector(3, i);
                                                    const columnI = transform.timesColumn(columnSelect);
                                                    const colRV = columnI.toRealVector();
                                                    asFloats[i * 4 + 0] = colRV.x;
                                                    asFloats[i * 4 + 1] = colRV.y;
                                                    asFloats[i * 4 + 2] = colRV.z;
                                                    asFloats[i * 4 + 3] = 0.0;
                                                }
                                                ;
                                            }
                                            asFloats[12] = 0.0;
                                            asFloats[13] = 0.0;
                                            asFloats[14] = 0.0;
                                            asFloats[15] = 1.0;
                                            orientations[orientation] = asFloats;
                                        }
                                        ;
                                    }
                                    return orientations;
                                })();
                            }
                            else if (rowMajor === undefined) {
                                return this.getOrientations$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getSymmetry() {
                            return this.symmetrySystem.getSymmetry();
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getShapes() {
                            return this.shapes;
                        }
                        /**
                         *
                         * @return {com.vzome.core.math.symmetry.OrbitSet}
                         */
                        getOrbits() {
                            return this.symmetrySystem.getOrbits();
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.Direction} orbit
                         * @return {com.vzome.core.construction.Color}
                         */
                        getColor(orbit) {
                            return this.symmetrySystem.getColor(orbit);
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getAxis(vector) {
                            return this.symmetrySystem.getAxis(vector);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return this.symmetrySystem.getName();
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @return {com.vzome.core.construction.Color}
                         */
                        getVectorColor(vector) {
                            return this.symmetrySystem.getVectorColor(vector);
                        }
                    }
                    ReplaceWithShape.ReplaceWithShape$0 = ReplaceWithShape$0;
                    ReplaceWithShape$0["__interfaces"] = ["com.vzome.core.editor.api.OrbitSource"];
                })(ReplaceWithShape = edits.ReplaceWithShape || (edits.ReplaceWithShape = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class AffinePentagon extends com.vzome.core.editor.api.ChangeManifestations {
                    /**
                     *
                     */
                    perform() {
                        const errorMsg = "Affine pentagon command requires two selected struts with a common vertex.";
                        let strut1 = null;
                        let strut2 = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (strut1 == null) {
                                        strut1 = man;
                                    }
                                    else if (strut2 == null) {
                                        strut2 = man;
                                    }
                                }
                            }
                        }
                        this.redo();
                        if (strut1 == null || strut2 == null) {
                            this.fail(errorMsg);
                        }
                        const field = strut1.getLocation().getField();
                        const s1 = strut1.getFirstConstruction();
                        const s2 = strut2.getFirstConstruction();
                        this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s1, true));
                        this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s1, false));
                        this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s2, true));
                        this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s2, false));
                        this.redo();
                        let offset1 = s1.getOffset();
                        let offset2 = s2.getOffset();
                        let v1 = null;
                        let v2 = null;
                        {
                            const s1s = s1.getStart();
                            const s1e = s1.getEnd();
                            const s2s = s2.getStart();
                            const s2e = s2.getEnd();
                            if (s1s.equals(s2s)) {
                                v1 = s1e;
                                v2 = s2e;
                            }
                            else if (s1e.equals(s2s)) {
                                v1 = s1s;
                                v2 = s2e;
                                offset1 = offset1.negate();
                            }
                            else if (s1e.equals(s2e)) {
                                v1 = s1s;
                                v2 = s2s;
                                offset2 = offset2.negate();
                                offset1 = offset1.negate();
                            }
                            else if (s1s.equals(s2e)) {
                                v1 = s1e;
                                v2 = s2s;
                                offset2 = offset2.negate();
                            }
                            else {
                                this.fail(errorMsg);
                            }
                        }
                        ;
                        let p1 = null;
                        let p2 = null;
                        for (let index = this.mManifestations.iterator(); index.hasNext();) {
                            let m = index.next();
                            {
                                if (m != null && (m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    const loc = m.getLocation();
                                    if (loc.equals(v1))
                                        p1 = m.getFirstConstruction();
                                    else if (loc.equals(v2))
                                        p2 = m.getFirstConstruction();
                                }
                            }
                        }
                        const phi = field['createPower$int'](1);
                        let transform = new com.vzome.core.construction.Translation(offset1.scale(phi));
                        const p3 = new com.vzome.core.construction.TransformedPoint(transform, p2);
                        this.manifestConstruction(p3);
                        transform = new com.vzome.core.construction.Translation(offset2.scale(phi));
                        const p4 = new com.vzome.core.construction.TransformedPoint(transform, p1);
                        this.manifestConstruction(p4);
                        let segment = new com.vzome.core.construction.SegmentJoiningPoints(p1, p3);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                        segment = new com.vzome.core.construction.SegmentJoiningPoints(p2, p4);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                        segment = new com.vzome.core.construction.SegmentJoiningPoints(p3, p4);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                        this.redo();
                    }
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "AffinePentagon";
                    }
                }
                edits.AffinePentagon = AffinePentagon;
                AffinePentagon["__class"] = "com.vzome.core.edits.AffinePentagon";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class Validate2Manifold extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    showStrut(strut) {
                        const a = new com.vzome.core.construction.FreePoint(strut.getLocation());
                        this.manifestConstruction(a);
                        const b = new com.vzome.core.construction.FreePoint(strut.getEnd());
                        this.manifestConstruction(b);
                        const segment = new com.vzome.core.construction.SegmentJoiningPoints(a, b);
                        this.manifestConstruction(segment);
                    }
                    /**
                     *
                     */
                    perform() {
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            super.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                        }
                        this.hideConnectors();
                        this.hideStruts();
                        this.redo();
                        const edges = new Validate2Manifold.Edges();
                        for (let index = com.vzome.core.editor.api.Manifestations.getVisiblePanels(this.mManifestations).iterator(); index.hasNext();) {
                            let panel = index.next();
                            {
                                let v0 = null;
                                let prev = null;
                                for (let index = panel.iterator(); index.hasNext();) {
                                    let vertex = index.next();
                                    {
                                        if (v0 == null) {
                                            v0 = vertex;
                                            prev = vertex;
                                        }
                                        else {
                                            const strut = new com.vzome.core.model.StrutImpl(prev, vertex);
                                            edges.addStrut(strut, panel);
                                            prev = vertex;
                                        }
                                    }
                                }
                                const strut = new com.vzome.core.model.StrutImpl(prev, v0);
                                edges.addStrut(strut, panel);
                            }
                        }
                        let invalid = false;
                        for (let index = edges.entrySet().iterator(); index.hasNext();) {
                            let entry = index.next();
                            {
                                if (entry.getValue().size() !== 2) {
                                    this.showStrut(entry.getKey());
                                    invalid = true;
                                }
                            }
                        }
                        if (invalid) {
                            this.hidePanels();
                            this.redo();
                            return;
                        }
                        for (let index = edges.entrySet().iterator(); index.hasNext();) {
                            let entry = index.next();
                            {
                                const strut = entry.getKey();
                                const v1 = strut.getLocation();
                                const v2 = strut.getEnd();
                                const oriented = ((v1, v2) => {
                                    return (p) => {
                                        let prev = null;
                                        for (let index = p.iterator(); index.hasNext();) {
                                            let v = index.next();
                                            {
                                                if (v.equals(v2) && prev != null)
                                                    return v1.equals(prev);
                                                prev = v;
                                            }
                                        }
                                        return v1.equals(prev);
                                    };
                                })(v1, v2);
                                const panels = [null, null];
                                entry.getValue().toArray(panels);
                                const c1 = (target => (typeof target === 'function') ? target(panels[0]) : target.apply(panels[0]))(oriented);
                                const c2 = (target => (typeof target === 'function') ? target(panels[1]) : target.apply(panels[1]))(oriented);
                                if (c1 === c2) {
                                    invalid = true;
                                    this.showStrut(strut);
                                }
                            }
                        }
                        if (invalid) {
                            this.redo();
                            return;
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "Validate2Manifold";
                    }
                }
                edits.Validate2Manifold = Validate2Manifold;
                Validate2Manifold["__class"] = "com.vzome.core.edits.Validate2Manifold";
                (function (Validate2Manifold) {
                    class Edges extends java.util.HashMap {
                        addStrut(strut, panel) {
                            let existing = this.get(strut);
                            if (existing == null) {
                                existing = (new java.util.HashSet());
                                this.put(strut, existing);
                            }
                            existing.add(panel);
                        }
                        constructor() {
                            super();
                        }
                    }
                    Validate2Manifold.Edges = Edges;
                    Edges["__class"] = "com.vzome.core.edits.Validate2Manifold.Edges";
                    Edges["__interfaces"] = ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"];
                })(Validate2Manifold = edits.Validate2Manifold || (edits.Validate2Manifold = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class PanelCentroids extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     */
                    perform() {
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    const panel = man;
                                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.FreePoint(panel.getCentroid())));
                                }
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "PanelCentroids";
                    }
                }
                edits.PanelCentroids = PanelCentroids;
                PanelCentroids["__class"] = "com.vzome.core.edits.PanelCentroids";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class StrutCreation extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(anchor, axis, len, editor) {
                        if (((anchor != null && anchor instanceof com.vzome.core.construction.Point) || anchor === null) && ((axis != null && axis instanceof com.vzome.core.math.symmetry.Axis) || axis === null) && ((len != null && (len.constructor != null && len.constructor["__interfaces"] != null && len.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || len === null) && ((editor != null && (editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null)) {
                            let __args = arguments;
                            super(editor);
                            if (this.mAnchor === undefined) {
                                this.mAnchor = null;
                            }
                            if (this.mAxis === undefined) {
                                this.mAxis = null;
                            }
                            if (this.mLength === undefined) {
                                this.mLength = null;
                            }
                            this.mAnchor = anchor;
                            this.mAxis = axis;
                            this.mLength = len;
                        }
                        else if (((anchor != null && (anchor.constructor != null && anchor.constructor["__interfaces"] != null && anchor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || anchor === null) && axis === undefined && len === undefined && editor === undefined) {
                            let __args = arguments;
                            let editor = __args[0];
                            {
                                let __args = arguments;
                                let anchor = null;
                                let axis = null;
                                let len = null;
                                super(editor);
                                if (this.mAnchor === undefined) {
                                    this.mAnchor = null;
                                }
                                if (this.mAxis === undefined) {
                                    this.mAxis = null;
                                }
                                if (this.mLength === undefined) {
                                    this.mLength = null;
                                }
                                this.mAnchor = anchor;
                                this.mAxis = axis;
                                this.mLength = len;
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {*} params
                     */
                    configure(params) {
                        this.mAnchor = params.get("anchor");
                        this.mAxis = params.get("zone");
                        this.mLength = params.get("length");
                    }
                    /**
                     *
                     */
                    perform() {
                        const segment = new com.vzome.core.construction.AnchoredSegment(this.mAxis, this.mLength, this.mAnchor);
                        this.manifestConstruction(segment);
                        const point = new com.vzome.core.construction.SegmentEndPoint(segment);
                        this.manifestConstruction(point);
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    getXmlAttributes(xml) {
                        com.vzome.core.commands.XmlSaveFormat.serializePoint(xml, "anchor", this.mAnchor);
                        com.vzome.core.commands.XmlSymmetryFormat.serializeAxis(xml, "symm", "dir", "index", "sense", this.mAxis);
                        com.vzome.core.commands.XmlSaveFormat.serializeNumber(xml, "len", this.mLength);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        if (format.rationalVectors()) {
                            this.mAnchor = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "anchor");
                            this.mAxis = format.parseAxis(xml, "symm", "dir", "index", "sense");
                            this.mLength = format.parseNumber(xml, "len");
                        }
                        else {
                            const attrs = format.loadCommandAttributes$org_w3c_dom_Element$boolean(xml, true);
                            this.mAnchor = attrs.get("anchor");
                            this.mAxis = attrs.get("axis");
                            this.mLength = attrs.get("len");
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "StrutCreation";
                    }
                }
                edits.StrutCreation = StrutCreation;
                StrutCreation["__class"] = "com.vzome.core.edits.StrutCreation";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class StrutIntersection extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        let s1 = null;
                        let s2 = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))
                                    if (s1 == null)
                                        s1 = man;
                                    else if (s2 == null)
                                        s2 = man;
                                    else
                                        throw new com.vzome.core.commands.Command.Failure("only two struts are allowed");
                            }
                        }
                        if (s1 == null || s2 == null)
                            throw new com.vzome.core.commands.Command.Failure("two struts are required");
                        const l1 = new com.vzome.core.construction.LineFromPointAndVector(s1.getLocation(), s1.getZoneVector());
                        const l2 = new com.vzome.core.construction.LineFromPointAndVector(s2.getLocation(), s2.getZoneVector());
                        const point = new com.vzome.core.construction.LineLineIntersectionPoint(l1, l2);
                        if (point.isImpossible())
                            throw new com.vzome.core.commands.Command.Failure("lines are parallel or non-intersecting");
                        const ball = this.manifestConstruction(point);
                        this.select$com_vzome_core_model_Manifestation(ball);
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "StrutIntersection";
                    }
                }
                edits.StrutIntersection = StrutIntersection;
                StrutIntersection["__class"] = "com.vzome.core.edits.StrutIntersection";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * Work in progress, to help someone create correctly oriented surfaces for vZome part export,
                 * or for StL 3D printing export.
                 *
                 * @author Scott Vorthmann
                 * @param {*} singlePanel
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class ReversePanel extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(singlePanel, editor) {
                        super(editor);
                        if (this.panel === undefined) {
                            this.panel = null;
                        }
                        if (singlePanel != null)
                            this.panel = singlePanel;
                        else
                            this.panel = null;
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.panel != null) {
                            if (this.mSelection.manifestationSelected(this.panel))
                                this.unselect$com_vzome_core_model_Manifestation(this.panel);
                            const polygon = this.panel.getFirstConstruction();
                            this.unmanifestConstruction(polygon);
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ReversePanel";
                    }
                }
                edits.ReversePanel = ReversePanel;
                ReversePanel["__class"] = "com.vzome.core.edits.ReversePanel";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class DodecagonSymmetry extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.center === undefined) {
                            this.center = null;
                        }
                        if (this.symmetry === undefined) {
                            this.symmetry = null;
                        }
                        this.center = editor.getCenterPoint();
                        this.symmetry = editor['getSymmetrySystem$']().getSymmetry();
                    }
                    /**
                     *
                     */
                    perform() {
                        const transform = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, 1, this.center);
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                let c = man.getFirstConstruction();
                                for (let i = 0; i < 11; i++) {
                                    {
                                        c = transform.transform$com_vzome_core_construction_Construction(c);
                                        if (c == null)
                                            continue;
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(c));
                                    }
                                    ;
                                }
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "DodecagonSymmetry";
                    }
                }
                edits.DodecagonSymmetry = DodecagonSymmetry;
                DodecagonSymmetry["__class"] = "com.vzome.core.edits.DodecagonSymmetry";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class RunZomicScript extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.programText === undefined) {
                            this.programText = null;
                        }
                        if (this.origin === undefined) {
                            this.origin = null;
                        }
                        if (this.symm === undefined) {
                            this.symm = null;
                        }
                        this.origin = editor.getCenterPoint();
                        this.symm = editor['getSymmetrySystem$']().getSymmetry();
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        this.programText = props.get("script");
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "RunZomicScript";
                    }
                    getScriptDialect() {
                        return "zomic";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setTextContent(com.vzome.core.commands.XmlSaveFormat.escapeNewlines(this.programText));
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.programText = xml.getTextContent();
                        this.symm = format.parseSymmetry("icosahedral");
                    }
                    /**
                     *
                     */
                    perform() {
                        let offset = null;
                        let pointFound = false;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    const nextPoint = man.getFirstConstruction();
                                    if (!pointFound) {
                                        pointFound = true;
                                        offset = nextPoint;
                                    }
                                    else {
                                        offset = null;
                                    }
                                }
                            }
                        }
                        if (offset == null)
                            offset = this.origin;
                        try {
                            this.symm.interpretScript(this.programText, this.getScriptDialect(), offset, this.symm, new com.vzome.core.editor.api.ManifestConstructions(this));
                        }
                        catch (e) {
                            throw new com.vzome.core.commands.Command.Failure(e.message, e);
                        }
                        this.redo();
                    }
                }
                edits.RunZomicScript = RunZomicScript;
                RunZomicScript["__class"] = "com.vzome.core.edits.RunZomicScript";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class PanelPerimeters extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     */
                    perform() {
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (!(man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))) {
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                }
                            }
                        }
                        this.redo();
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                    const panel = man;
                                    const polygon = panel.getFirstConstruction();
                                    const vertices = polygon.getVertices();
                                    const first = new com.vzome.core.construction.FreePoint(vertices[0]);
                                    let start = first;
                                    for (let i = 1; i < vertices.length; i++) {
                                        {
                                            const end = new com.vzome.core.construction.FreePoint(vertices[i]);
                                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(start));
                                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, end)));
                                            start = end;
                                        }
                                        ;
                                    }
                                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(start));
                                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, first)));
                                }
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "PanelPerimeters";
                    }
                }
                edits.PanelPerimeters = PanelPerimeters;
                PanelPerimeters["__class"] = "com.vzome.core.edits.PanelPerimeters";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class MapToColor extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.colorMapper === undefined) {
                            this.colorMapper = null;
                        }
                        if (this.editor === undefined) {
                            this.editor = null;
                        }
                        this.editor = editor;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        const colorMapperName = props.get("mode");
                        const symmetry = this.editor['getSymmetrySystem$']();
                        if (colorMapperName != null)
                            this.colorMapper = com.vzome.core.edits.ManifestationColorMappers.getColorMapper$java_lang_String$com_vzome_core_editor_api_OrbitSource(colorMapperName, symmetry);
                    }
                    /**
                     * Either configure() or setXmlAttributes() is always called before perform()
                     */
                    perform() {
                        if (this.colorMapper.requiresOrderedSelection()) {
                            this.setOrderedSelection(true);
                        }
                        this.colorMapper.initialize(this.getRenderedSelection());
                        for (let index = this.getRenderedSelection().iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                const newColor = this.colorMapper.apply$com_vzome_core_model_Manifestation(man);
                                this.plan(new MapToColor.ColorMapManifestation(this, man, newColor));
                                this.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} result
                     */
                    getXmlAttributes(result) {
                        result.setAttribute(MapToColor.COLORMAPPER_ATTR_NAME, this.colorMapper.getName());
                        this.colorMapper.getXmlAttributes(result);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        const symmetry = this.editor['getSymmetrySystem$java_lang_String'](xml.getAttribute("symmetry"));
                        const colorMapperName = xml.getAttribute(MapToColor.COLORMAPPER_ATTR_NAME);
                        this.colorMapper = com.vzome.core.edits.ManifestationColorMappers.getColorMapper$java_lang_String$com_vzome_core_editor_api_OrbitSource(colorMapperName, symmetry);
                        this.colorMapper.setXmlAttributes(xml);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "MapToColor";
                    }
                }
                MapToColor.COLORMAPPER_ATTR_NAME = "colorMapper";
                edits.MapToColor = MapToColor;
                MapToColor["__class"] = "com.vzome.core.edits.MapToColor";
                (function (MapToColor) {
                    class ColorMapManifestation {
                        constructor(__parent, manifestation, color) {
                            this.__parent = __parent;
                            if (this.mManifestation === undefined) {
                                this.mManifestation = null;
                            }
                            if (this.oldColor === undefined) {
                                this.oldColor = null;
                            }
                            if (this.newColor === undefined) {
                                this.newColor = null;
                            }
                            this.mManifestation = manifestation;
                            this.newColor = color;
                            this.oldColor = manifestation.getColor();
                        }
                        /**
                         *
                         */
                        redo() {
                            this.__parent.mManifestations.setColor(this.mManifestation, this.newColor);
                        }
                        /**
                         *
                         */
                        undo() {
                            this.__parent.mManifestations.setColor(this.mManifestation, this.oldColor);
                        }
                        /**
                         *
                         * @param {*} doc
                         * @return {*}
                         */
                        getXml(doc) {
                            const result = doc.createElement("color");
                            com.vzome.xml.DomUtils.addAttribute(result, "rgb", this.newColor.toString());
                            const man = this.mManifestation.getXml(doc);
                            result.appendChild(man);
                            return result;
                        }
                    }
                    MapToColor.ColorMapManifestation = ColorMapManifestation;
                    ColorMapManifestation["__class"] = "com.vzome.core.edits.MapToColor.ColorMapManifestation";
                    ColorMapManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffect"];
                })(MapToColor = edits.MapToColor || (edits.MapToColor = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ColorManifestations extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editorModel) {
                        super(editorModel);
                        if (this.color === undefined) {
                            this.color = null;
                        }
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        const mode = props.get("mode");
                        if (mode != null)
                            this.initialize(new com.vzome.core.construction.Color(mode));
                    }
                    /*private*/ initialize(color) {
                        this.color = color;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let m = index.next();
                            {
                                if (m.isRendered())
                                    this.colorManifestation(m, color);
                                this.unselect$com_vzome_core_model_Manifestation$boolean(m, true);
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} result
                     */
                    getXmlAttributes(result) {
                        result.setAttribute("red", "" + this.color.getRed());
                        result.setAttribute("green", "" + this.color.getGreen());
                        result.setAttribute("blue", "" + this.color.getBlue());
                        const alpha = this.color.getAlpha();
                        if (alpha < 255)
                            result.setAttribute("alpha", "" + alpha);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        if (format.loadToRender()) {
                            const red = xml.getAttribute("red");
                            const green = xml.getAttribute("green");
                            const blue = xml.getAttribute("blue");
                            const alphaStr = xml.getAttribute("alpha");
                            const alpha = (alphaStr == null || /* isEmpty */ (alphaStr.length === 0)) ? 255 : javaemul.internal.IntegerHelper.parseInt(alphaStr);
                            this.initialize(new com.vzome.core.construction.Color(javaemul.internal.IntegerHelper.parseInt(red), javaemul.internal.IntegerHelper.parseInt(green), javaemul.internal.IntegerHelper.parseInt(blue), alpha));
                        }
                        else
                            this.initialize(null);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "setItemColor";
                    }
                }
                edits.ColorManifestations = ColorManifestations;
                ColorManifestations["__class"] = "com.vzome.core.edits.ColorManifestations";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ImportMesh extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.meshData === undefined) {
                            this.meshData = null;
                        }
                        if (this.scale === undefined) {
                            this.scale = null;
                        }
                        if (this.projection === undefined) {
                            this.projection = null;
                        }
                        if (this.editor === undefined) {
                            this.editor = null;
                        }
                        this.editor = editor;
                    }
                    /**
                     *
                     * @param {*} params
                     */
                    configure(params) {
                        const field = this.mManifestations.getField();
                        this.meshData = params.get("vef");
                        this.projection = params.get("projection");
                        this.scale = params.get("scale");
                        if (this.scale == null) {
                            this.scale = field.one();
                        }
                        const mode = params.getOrDefault("mode", "");
                        switch ((mode)) {
                            case "":
                                break;
                            case "clipboard":
                                if (this.meshData != null && !((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(this.meshData, "vZome VEF") && !((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(this.meshData, "{"))
                                    this.meshData = null;
                                break;
                            case "Quaternion":
                                break;
                            default:
                                this.setProjection(mode, field);
                                break;
                        }
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return this.meshData == null;
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.scale != null)
                            com.vzome.xml.DomUtils.addAttribute(element, "scale", this.scale.toString(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                        if (this.projection != null) {
                            const name = this.projection.getProjectionName();
                            if (!("" === name)) {
                                com.vzome.xml.DomUtils.addAttribute(element, "projection", this.projection.getProjectionName());
                                this.projection.getXmlAttributes(element);
                            }
                        }
                        const textNode = element.getOwnerDocument().createTextNode(com.vzome.core.commands.XmlSaveFormat.escapeNewlines(this.meshData));
                        element.appendChild(textNode);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        const field = format.getField();
                        this.scale = format.parseRationalNumber(xml, "scale");
                        if (this.scale == null) {
                            this.scale = field.one();
                        }
                        this.meshData = xml.getTextContent();
                        const projectionName = xml.getAttribute("projection");
                        if ("" === projectionName) {
                            const quaternion = format.parseRationalVector(xml, "quaternion");
                            this.projection = quaternion == null ? null : new com.vzome.core.math.QuaternionProjection(field, null, quaternion);
                        }
                        else {
                            this.setProjection(projectionName, field);
                        }
                        if (this.projection != null) {
                            this.projection.setXmlAttributes(xml);
                        }
                    }
                    setProjection(projectionName, field) {
                        switch ((projectionName)) {
                            case "Quaternion":
                                this.projection = new com.vzome.core.math.QuaternionProjection(field, null, null);
                                break;
                            case "SixCube":
                                this.projection = new com.vzome.core.math.SixCubeProjection(field);
                                break;
                            case "Tetrahedral":
                                this.projection = new com.vzome.core.math.TetrahedralProjection(field);
                                break;
                            case "Perspective":
                                this.projection = new com.vzome.core.math.PerspectiveProjection(field, null);
                                break;
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.meshData == null)
                            return;
                        let offset = null;
                        let pointFound = false;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    const nextPoint = man.getFirstConstruction();
                                    if (!pointFound) {
                                        pointFound = true;
                                        offset = nextPoint.getLocation();
                                    }
                                    else {
                                        offset = null;
                                        break;
                                    }
                                }
                                if (this.deselectInputs())
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        const field = this.mManifestations.getField();
                        const events = new com.vzome.core.editor.api.ManifestConstructions(this);
                        const registry = new ImportMesh.ImportMesh$0(this, field);
                        if (this.projection == null)
                            this.projection = new com.vzome.core.math.Projection.Default(field);
                        try {
                            this.parseMeshData(offset, events, registry);
                        }
                        catch (e) {
                            throw new com.vzome.core.commands.Command.Failure("Incorrect content for this import:\n" + e.message);
                        }
                        this.redo();
                    }
                    deselectInputs() {
                        return true;
                    }
                }
                edits.ImportMesh = ImportMesh;
                ImportMesh["__class"] = "com.vzome.core.edits.ImportMesh";
                (function (ImportMesh) {
                    class ImportMesh$0 {
                        constructor(__parent, field) {
                            this.field = field;
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @param {string} name
                         * @return {*}
                         */
                        getField(name) {
                            if (this.field.supportsSubfield(name))
                                return this.field;
                            else {
                                return null;
                            }
                        }
                    }
                    ImportMesh.ImportMesh$0 = ImportMesh$0;
                    ImportMesh$0["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField.Registry"];
                })(ImportMesh = edits.ImportMesh || (edits.ImportMesh = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class Delete extends com.vzome.core.editor.api.ChangeManifestations {
                    /**
                     *
                     */
                    perform() {
                        const inputs = (new java.util.ArrayList());
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                inputs.add(man);
                                this.unselect$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        this.redo();
                        for (let index = inputs.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.deleteManifestation(man);
                            }
                        }
                        super.perform();
                    }
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "Delete";
                    }
                }
                edits.Delete = Delete;
                Delete["__class"] = "com.vzome.core.edits.Delete";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class AffineTransformAll extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editorModel) {
                        super(editorModel);
                        if (this.center === undefined) {
                            this.center = null;
                        }
                        this.center = editorModel.getCenterPoint();
                    }
                    /**
                     *
                     */
                    perform() {
                        let s1 = null;
                        let s2 = null;
                        let s3 = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (s1 == null)
                                        s1 = man.getFirstConstruction();
                                    else if (s2 == null)
                                        s2 = man.getFirstConstruction();
                                    else if (s3 == null)
                                        s3 = man.getFirstConstruction();
                                }
                            }
                        }
                        if (s3 == null || s2 == null || s1 == null)
                            throw new com.vzome.core.commands.Command.Failure("three struts required");
                        this.redo();
                        const transform = new com.vzome.core.construction.ChangeOfBasis(s1, s2, s3, this.center, true);
                        for (let index = this.mManifestations.iterator(); index.hasNext();) {
                            let m = index.next();
                            {
                                if (!m.isRendered())
                                    continue;
                                const c = m.getFirstConstruction();
                                const result = transform.transform$com_vzome_core_construction_Construction(c);
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(result));
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "AffineTransformAll";
                    }
                }
                edits.AffineTransformAll = AffineTransformAll;
                AffineTransformAll["__class"] = "com.vzome.core.edits.AffineTransformAll";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class Parallelepiped extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "Parallelepiped";
                    }
                    /**
                     *
                     */
                    perform() {
                        const errorMsg = "Parallelepiped command requires three selected struts with a common vertex.";
                        let strut1 = null;
                        let strut2 = null;
                        let strut3 = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (strut1 == null) {
                                        strut1 = (man);
                                    }
                                    else if (strut2 == null) {
                                        strut2 = (man);
                                    }
                                    else if (strut3 == null) {
                                        strut3 = (man);
                                    }
                                    else
                                        this.fail(errorMsg);
                                }
                                else
                                    this.fail(errorMsg);
                            }
                        }
                        if (strut1 == null || strut2 == null || strut3 == null) {
                            this.fail(errorMsg);
                        }
                        const s1 = (strut1.getFirstConstruction());
                        const s2 = (strut2.getFirstConstruction());
                        const s3 = (strut3.getFirstConstruction());
                        let offset1 = s1.getOffset();
                        let offset2 = s2.getOffset();
                        let offset3 = s3.getOffset();
                        let v0 = null;
                        let v1 = null;
                        let v2 = null;
                        let v3 = null;
                        {
                            const s1s = s1.getStart();
                            const s1e = s1.getEnd();
                            const s2s = s2.getStart();
                            const s2e = s2.getEnd();
                            if (s1s.equals(s2s)) {
                                v1 = s1e;
                                v2 = s2e;
                                v0 = s2s;
                            }
                            else if (s1e.equals(s2s)) {
                                v1 = s1s;
                                v2 = s2e;
                                v0 = s2s;
                                offset1 = offset1.negate();
                            }
                            else if (s1e.equals(s2e)) {
                                v1 = s1s;
                                v2 = s2s;
                                v0 = s2e;
                                offset2 = offset2.negate();
                                offset1 = offset1.negate();
                            }
                            else if (s1s.equals(s2e)) {
                                v1 = s1e;
                                v2 = s2s;
                                v0 = s2e;
                                offset2 = offset2.negate();
                            }
                            else {
                                this.fail(errorMsg);
                            }
                            const s3s = s3.getStart();
                            const s3e = s3.getEnd();
                            if (s3s.equals(v0)) {
                                v3 = s3e;
                            }
                            else if (s3e.equals(v0)) {
                                v3 = s3s;
                                offset3 = offset3.negate();
                            }
                            else {
                                this.fail(errorMsg);
                            }
                        }
                        ;
                        this.redo();
                        const p0 = new com.vzome.core.construction.FreePoint(v0);
                        const p1 = new com.vzome.core.construction.FreePoint(v1);
                        const p2 = new com.vzome.core.construction.FreePoint(v2);
                        const p3 = new com.vzome.core.construction.FreePoint(v3);
                        this.manifestConstruction(p0);
                        this.manifestConstruction(p1);
                        this.manifestConstruction(p2);
                        this.manifestConstruction(p3);
                        this.redo();
                        const v4 = v2.plus(offset3);
                        const p4 = new com.vzome.core.construction.FreePoint(v4);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p4));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p2, p4)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p3, p4)));
                        const v5 = v3.plus(offset1);
                        const p5 = new com.vzome.core.construction.FreePoint(v5);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p5));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p1, p5)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p3, p5)));
                        const v6 = v1.plus(offset2);
                        const p6 = new com.vzome.core.construction.FreePoint(v6);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p6));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p1, p6)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p2, p6)));
                        const v7 = v4.plus(offset1);
                        const p7 = new com.vzome.core.construction.FreePoint(v7);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p7));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p4, p7)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p5, p7)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p6, p7)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p0, p3, p4, p2])));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p0, p1, p5, p3])));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p0, p2, p6, p1])));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p7, p4, p3, p5])));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p7, p6, p2, p4])));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p7, p5, p1, p6])));
                        this.redo();
                    }
                }
                edits.Parallelepiped = Parallelepiped;
                Parallelepiped["__class"] = "com.vzome.core.edits.Parallelepiped";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class SelectAutomaticStruts extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.symmetry === undefined) {
                            this.symmetry = null;
                        }
                        if (this.editor === undefined) {
                            this.editor = null;
                        }
                        this.editor = editor;
                        this.symmetry = editor['getSymmetrySystem$']();
                    }
                    /**
                     *
                     */
                    perform() {
                        this.unselectAll();
                        for (let index = this.getVisibleStruts$java_util_function_Predicate((strut) => { return this.isAutomaticStrut(strut); }).iterator(); index.hasNext();) {
                            let strut = index.next();
                            {
                                this.select$com_vzome_core_model_Manifestation(strut);
                            }
                        }
                        super.perform();
                    }
                    /*private*/ isAutomaticStrut(strut) {
                        return this.symmetry.getAxis(strut.getOffset()).getOrbit().isAutomatic();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SelectAutomaticStruts";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.symmetry != null) {
                            com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetry.getName());
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.symmetry = this.editor['getSymmetrySystem$java_lang_String'](xml.getAttribute("symmetry"));
                    }
                }
                edits.SelectAutomaticStruts = SelectAutomaticStruts;
                SelectAutomaticStruts["__class"] = "com.vzome.core.edits.SelectAutomaticStruts";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class SelectCollinear extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        this.vector1 = null;
                        this.vector2 = null;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        const strut = props.get("picked");
                        if (strut != null) {
                            this.vector1 = strut.getLocation();
                            this.vector2 = strut.getEnd();
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.vector1 == null || this.vector2 == null) {
                            const lastStrut = this.getLastSelectedStrut();
                            if (lastStrut != null) {
                                this.vector1 = lastStrut.getLocation();
                                this.vector2 = lastStrut.getEnd();
                            }
                            else {
                                for (let index = this.getSelectedConnectors().iterator(); index.hasNext();) {
                                    let ball = index.next();
                                    {
                                        this.vector1 = this.vector2;
                                        this.vector2 = ball.getLocation();
                                    }
                                }
                            }
                        }
                        if (this.vector1 == null || this.vector2 == null) {
                            throw new com.vzome.core.commands.Command.Failure("select a strut or two balls as a reference.");
                        }
                        this.unselectAll();
                        const balls = (new java.util.TreeSet());
                        for (let index = this.getVisibleConnectors$java_util_function_Predicate((ball) => { return this.isCollinearWith(ball); }).iterator(); index.hasNext();) {
                            let ball = index.next();
                            {
                                balls.add(ball);
                            }
                        }
                        const struts = (new java.util.TreeSet());
                        for (let index = this.getVisibleStruts$().iterator(); index.hasNext();) {
                            let strut = index.next();
                            {
                                if (this.isCollinearWith$com_vzome_core_model_Strut(strut)) {
                                    struts.add(strut);
                                }
                            }
                        }
                        for (let index = struts.iterator(); index.hasNext();) {
                            let strut = index.next();
                            {
                                this.select$com_vzome_core_model_Manifestation(strut);
                            }
                        }
                        for (let index = balls.iterator(); index.hasNext();) {
                            let ball = index.next();
                            {
                                this.select$com_vzome_core_model_Manifestation(ball);
                            }
                        }
                        const level = java.util.logging.Level.FINER;
                        if (com.vzome.core.editor.api.ChangeSelection.logger_$LI$().isLoggable(level)) {
                            const sb = new java.lang.StringBuilder("Selected:\n");
                            const indent = "  ";
                            for (let index = struts.iterator(); index.hasNext();) {
                                let strut = index.next();
                                {
                                    sb.append(indent).append(strut.toString()).append("\n");
                                }
                            }
                            for (let index = balls.iterator(); index.hasNext();) {
                                let ball = index.next();
                                {
                                    sb.append(indent).append(ball.toString()).append("\n");
                                }
                            }
                            com.vzome.core.editor.api.ChangeSelection.logger_$LI$().log(level, sb.toString());
                        }
                        super.perform();
                    }
                    isCollinearWith$com_vzome_core_model_Connector(ball) {
                        return this.isCollinear(ball.getLocation());
                    }
                    isCollinearWith(ball) {
                        if (((ball != null && (ball.constructor != null && ball.constructor["__interfaces"] != null && ball.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || ball === null)) {
                            return this.isCollinearWith$com_vzome_core_model_Connector(ball);
                        }
                        else if (((ball != null && (ball.constructor != null && ball.constructor["__interfaces"] != null && ball.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || ball === null)) {
                            return this.isCollinearWith$com_vzome_core_model_Strut(ball);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /*private*/ isCollinearWith$com_vzome_core_model_Strut(strut) {
                        return this.isCollinear(strut.getLocation()) && this.isCollinear(strut.getEnd());
                    }
                    /*private*/ isCollinear(vec) {
                        return com.vzome.core.algebra.AlgebraicVectors.areCollinear$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(vec, this.vector1, this.vector2);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SelectCollinear";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        com.vzome.xml.DomUtils.addAttribute(element, "vector1", this.vector1.toParsableString());
                        com.vzome.xml.DomUtils.addAttribute(element, "vector2", this.vector2.toParsableString());
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.vector1 = format.parseRationalVector(xml, "vector1");
                        this.vector2 = format.parseRationalVector(xml, "vector2");
                    }
                }
                edits.SelectCollinear = SelectCollinear;
                SelectCollinear["__class"] = "com.vzome.core.edits.SelectCollinear";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor_5) {
                /**
                 * Just a mechanism to incorporate the legacy edit mechanism into the new undo/redo.
                 *
                 * @author Scott Vorthmann 2006
                 * @param {com.vzome.core.commands.AbstractCommand} cmd
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class CommandEdit extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(cmd, editor) {
                        super(editor);
                        if (this.mEditorModel === undefined) {
                            this.mEditorModel = null;
                        }
                        if (this.mCommand === undefined) {
                            this.mCommand = null;
                        }
                        if (this.mAttrs === undefined) {
                            this.mAttrs = null;
                        }
                        this.mEditorModel = editor;
                        this.mCommand = cmd;
                    }
                    static logger_$LI$() { if (CommandEdit.logger == null) {
                        CommandEdit.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor.CommandEdit");
                    } return CommandEdit.logger; }
                    static loadAndPerformLgger_$LI$() { if (CommandEdit.loadAndPerformLgger == null) {
                        CommandEdit.loadAndPerformLgger = java.util.logging.Logger.getLogger("com.vzome.core.editor.CommandEdit.loadAndPerform");
                    } return CommandEdit.loadAndPerformLgger; }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        const cmdName = (c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])(this.mCommand.constructor);
                        const lastDot = cmdName.lastIndexOf('.');
                        return cmdName.substring(lastDot + 1 + "Command".length);
                    }
                    /**
                     *
                     * @param {*} result
                     */
                    getXmlAttributes(result) {
                        this.mCommand.getXml(result, this.mAttrs);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.mAttrs = this.mCommand.setXml(xml, format);
                        this.mAttrs.put(com.vzome.core.commands.Command.LOADING_FROM_FILE, javaemul.internal.BooleanHelper.TRUE);
                    }
                    /**
                     *
                     */
                    perform() {
                        const isHide = (this.mCommand != null && this.mCommand instanceof com.vzome.core.commands.CommandHide);
                        if (CommandEdit.logger_$LI$().isLoggable(java.util.logging.Level.FINER)) {
                            CommandEdit.logger_$LI$().finer("------------------- CommandEdit");
                        }
                        if (this.mCommand.ordersSelection())
                            this.setOrderedSelection(true);
                        const constrsBefore = new com.vzome.core.construction.ConstructionList();
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (CommandEdit.logger_$LI$().isLoggable(java.util.logging.Level.FINER)) {
                                    CommandEdit.logger_$LI$().finer("----------- manifestation: " + man.toString());
                                    for (const iterator = man.getConstructions(); iterator.hasNext();) {
                                        {
                                            const c = iterator.next();
                                            CommandEdit.logger_$LI$().finer("   " + c.toString());
                                        }
                                        ;
                                    }
                                }
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (isHide)
                                    this.hideManifestation(man);
                                else {
                                    const construction = man.getFirstConstruction();
                                    constrsBefore.add(construction);
                                }
                            }
                        }
                        this.redo();
                        if (isHide)
                            return;
                        if (this.mAttrs == null)
                            this.mAttrs = new com.vzome.core.commands.AttributeMap();
                        const symmAxis = this.mEditorModel.getSymmetrySegment();
                        if (symmAxis != null)
                            this.mAttrs.put(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME, symmAxis);
                        this.mAttrs.put(com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME, this.mEditorModel.getCenterPoint());
                        this.mAttrs.put(com.vzome.core.commands.Command.FIELD_ATTR_NAME, this.mManifestations.getField());
                        const news = new CommandEdit.NewConstructions();
                        let selectionAfter = null;
                        const signature = this.mCommand.getParameterSignature();
                        const actualsLen = constrsBefore.size();
                        if ((signature.length === actualsLen) || (signature.length === 1 && /* equals */ ((o1, o2) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(signature[0][0], com.vzome.core.commands.Command.GENERIC_PARAM_NAME))) {
                            try {
                                selectionAfter = this.mCommand.apply(constrsBefore, this.mAttrs, news);
                            }
                            catch (f) {
                                this.undo();
                                throw f;
                            }
                        }
                        else if (signature.length > actualsLen) {
                            this.fail("Too few objects in the selection.");
                        }
                        else if (signature.length === 1) {
                            let partial;
                            selectionAfter = new com.vzome.core.construction.ConstructionList();
                            for (let i = 0; i < actualsLen; i++) {
                                {
                                    const param = constrsBefore.get(i);
                                    const formalClass = signature[0][1];
                                    if ((formalClass === com.vzome.core.construction.Point && (param != null && param instanceof com.vzome.core.construction.Point)) || (formalClass === com.vzome.core.construction.Segment && (param != null && param instanceof com.vzome.core.construction.Segment))) {
                                        const single = new com.vzome.core.construction.ConstructionList();
                                        single.addConstruction(param);
                                        partial = this.mCommand.apply(single, this.mAttrs, news);
                                        selectionAfter.addAll(partial);
                                    }
                                    else
                                        selectionAfter.add(param);
                                }
                                ;
                            }
                        }
                        else
                            this.fail("Too many objects in the selection.");
                        for (let index = news.iterator(); index.hasNext();) {
                            let c = index.next();
                            {
                                this.manifestConstruction(c);
                            }
                        }
                        for (let index = selectionAfter.iterator(); index.hasNext();) {
                            let cons = index.next();
                            {
                                if (cons.failed()) {
                                    CommandEdit.logBugAccommodation("failed construction");
                                    this.mEditorModel.addFailedConstruction(cons);
                                    continue;
                                }
                                const man = this.manifestConstruction(cons);
                                if (man != null)
                                    this.select$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        let cmdName = null;
                        if (format.selectionsNotSaved())
                            cmdName = xml.getLocalName();
                        else if (format.commandEditsCompacted())
                            cmdName = "Command" + xml.getLocalName();
                        else
                            cmdName = xml.getAttribute("command");
                        if (cmdName === ("CommandIcosahedralSymmetry"))
                            cmdName = "CommandSymmetry";
                        this.mCommand = context.createLegacyCommand(cmdName);
                        if (format.selectionsNotSaved()) {
                            const selectedBefore = (new java.util.LinkedHashSet());
                            context.performAndRecord(new com.vzome.core.editor.BeginBlock(null));
                            this.mAttrs = new com.vzome.core.commands.AttributeMap();
                            const nodes = xml.getChildNodes();
                            for (let j = 0; j < nodes.getLength(); j++) {
                                {
                                    const kid2 = nodes.item(j);
                                    if (kid2 != null && (kid2.constructor != null && kid2.constructor["__interfaces"] != null && kid2.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) {
                                        const attrOrParam = kid2;
                                        const apName = attrOrParam.getLocalName();
                                        if (apName === ("attr")) {
                                            let attrName = attrOrParam.getAttribute("name");
                                            if ( /* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(attrName, ".symmetry.center"))
                                                attrName = com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME;
                                            else if (attrName === ("reflection.mirror.normal.segment"))
                                                attrName = com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME;
                                            const val = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element(attrOrParam);
                                            let valName = val.getLocalName();
                                            if (valName === ("FreePoint"))
                                                valName = "point";
                                            let value = format.parseAlgebraicObject(valName, val);
                                            if (value === com.vzome.core.commands.XmlSaveFormat.NOT_AN_ATTRIBUTE_$LI$())
                                                value = format.parseConstruction$java_lang_String$org_w3c_dom_Element(valName, val);
                                            if (attrName === com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME) {
                                                const c = new com.vzome.core.construction.FreePoint(value.getLocation().projectTo3d(true));
                                                context.performAndRecord(new com.vzome.core.edits.SymmetryCenterChange(this.mEditorModel, c));
                                            }
                                            else if (attrName === com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME) {
                                                context.performAndRecord(new com.vzome.core.edits.SymmetryAxisChange(this.mEditorModel, value));
                                                if (!this.mCommand.attributeIs3D(attrName)) {
                                                    const vector = value.getOffset();
                                                    this.mCommand.setQuaternion(vector);
                                                }
                                            }
                                            else
                                                this.mAttrs.put(attrName, value);
                                        }
                                        else {
                                            const c = format.parseConstruction$java_lang_String$org_w3c_dom_Element(apName, attrOrParam);
                                            if (c != null) {
                                                if (this.mEditorModel.hasFailedConstruction(c)) {
                                                    CommandEdit.logBugAccommodation("skip selecting a failed construction");
                                                    continue;
                                                }
                                                const m = this.getManifestation(c);
                                                if (m == null || m.isUnnecessary()) {
                                                    CommandEdit.loadAndPerformLgger_$LI$().severe("CommandEdit parameter: " + attrOrParam.toString());
                                                    throw new com.vzome.core.commands.Command.Failure("no manifestation to be selected.");
                                                }
                                                if (!selectedBefore.contains(m))
                                                    selectedBefore.add(m);
                                            }
                                        }
                                    }
                                }
                                ;
                            }
                            if (selectedBefore.size() > (this.mManifestations.size() / 2 | 0)) {
                                const toUnselect = (new java.util.ArrayList());
                                for (let index = this.mManifestations.iterator(); index.hasNext();) {
                                    let m = index.next();
                                    {
                                        if (!selectedBefore.contains(m))
                                            toUnselect.add(m);
                                    }
                                }
                                let edit = new com.vzome.core.edits.SelectAll(this.mEditorModel);
                                context.performAndRecord(edit);
                                for (let index = toUnselect.iterator(); index.hasNext();) {
                                    let m = index.next();
                                    {
                                        edit = new com.vzome.core.edits.SelectManifestation(this.mEditorModel, m);
                                        context.performAndRecord(edit);
                                    }
                                }
                            }
                            else {
                                let edit = new com.vzome.core.edits.DeselectAll(this.mEditorModel);
                                context.performAndRecord(edit);
                                for (let index = selectedBefore.iterator(); index.hasNext();) {
                                    let m = index.next();
                                    {
                                        edit = new com.vzome.core.edits.SelectManifestation(this.mEditorModel, m);
                                        context.performAndRecord(edit);
                                    }
                                }
                            }
                            context.performAndRecord(new com.vzome.core.editor.EndBlock(null));
                            this.redo();
                            if (this.mCommand != null && this.mCommand instanceof com.vzome.core.commands.CommandObliquePentagon) {
                                const edit = new com.vzome.core.edits.AffinePentagon(this.mEditorModel);
                                context.performAndRecord(edit);
                                return;
                            }
                            this.mCommand.setFixedAttributes(this.mAttrs, format);
                            this.mAttrs.put(com.vzome.core.commands.Command.LOADING_FROM_FILE, javaemul.internal.BooleanHelper.TRUE);
                            context.performAndRecord(this);
                        }
                        else
                            super.loadAndPerform(xml, format, context);
                    }
                }
                editor_5.CommandEdit = CommandEdit;
                CommandEdit["__class"] = "com.vzome.core.editor.CommandEdit";
                (function (CommandEdit) {
                    class NewConstructions extends java.util.ArrayList {
                        constructionAdded$com_vzome_core_construction_Construction(c) {
                            this.add(c);
                        }
                        constructionAdded$com_vzome_core_construction_Construction$com_vzome_core_construction_Color(c, color) {
                            this.add(c);
                        }
                        /**
                         *
                         * @param {com.vzome.core.construction.Construction} c
                         * @param {com.vzome.core.construction.Color} color
                         */
                        constructionAdded(c, color) {
                            if (((c != null && c instanceof com.vzome.core.construction.Construction) || c === null) && ((color != null && color instanceof com.vzome.core.construction.Color) || color === null)) {
                                return this.constructionAdded$com_vzome_core_construction_Construction$com_vzome_core_construction_Color(c, color);
                            }
                            else if (((c != null && c instanceof com.vzome.core.construction.Construction) || c === null) && color === undefined) {
                                return this.constructionAdded$com_vzome_core_construction_Construction(c);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    CommandEdit.NewConstructions = NewConstructions;
                    NewConstructions["__class"] = "com.vzome.core.editor.CommandEdit.NewConstructions";
                    NewConstructions["__interfaces"] = ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "com.vzome.core.construction.ConstructionChanges", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
                })(CommandEdit = editor_5.CommandEdit || (editor_5.CommandEdit = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class Tool extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(id, tools) {
                        super(tools.getEditorModel());
                        if (this.id === undefined) {
                            this.id = null;
                        }
                        if (this.tools === undefined) {
                            this.tools = null;
                        }
                        this.parameters = (new java.util.ArrayList());
                        if (this.category === undefined) {
                            this.category = null;
                        }
                        if (this.predefined === undefined) {
                            this.predefined = false;
                        }
                        if (this.hidden === undefined) {
                            this.hidden = false;
                        }
                        if (this.label === undefined) {
                            this.label = null;
                        }
                        if (this.selectInputs === undefined) {
                            this.selectInputs = false;
                        }
                        if (this.deleteInputs === undefined) {
                            this.deleteInputs = false;
                        }
                        if (this.copyColors === undefined) {
                            this.copyColors = false;
                        }
                        this.pcs = new java.beans.PropertyChangeSupport(this);
                        this.tools = tools;
                        this.id = id;
                        this.selectInputs = true;
                        this.deleteInputs = false;
                        this.copyColors = true;
                    }
                    isSelectInputs() {
                        return this.selectInputs;
                    }
                    isDeleteInputs() {
                        return this.deleteInputs;
                    }
                    isCopyColors() {
                        return this.copyColors;
                    }
                    setInputBehaviors(selectInputs, deleteInputs) {
                        this.selectInputs = selectInputs;
                        this.deleteInputs = deleteInputs;
                    }
                    setCopyColors(value) {
                        this.copyColors = value;
                    }
                    addPropertyChangeListener(listener) {
                        this.pcs.addPropertyChangeListener$java_beans_PropertyChangeListener(listener);
                    }
                    setCategory(category) {
                        this.category = category;
                    }
                    addParameter(c) {
                        this.parameters.add(c);
                    }
                    getParameters() {
                        return this.parameters;
                    }
                    setPredefined(value) {
                        this.predefined = value;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return false;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return true;
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     */
                    perform() {
                        const error = this.checkSelection(true);
                        if (error != null)
                            throw new com.vzome.core.commands.Command.Failure(error);
                        this.tools.put(this.getId(), this);
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("name", this.id);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getId() {
                        return this.id;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return this.category;
                    }
                    /**
                     *
                     * @param {boolean} selectInputs
                     * @param {boolean} deleteInputs
                     * @param {boolean} createOutputs
                     * @param {boolean} selectOutputs
                     * @param {boolean} copyColors
                     */
                    apply(selectInputs, deleteInputs, createOutputs, selectOutputs, copyColors) {
                        this.tools.applyTool(this, selectInputs, deleteInputs, createOutputs, selectOutputs, copyColors);
                    }
                    /**
                     *
                     */
                    selectParameters() {
                        this.tools.selectToolParameters(this);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isPredefined() {
                        return this.predefined;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return this.label;
                    }
                    /**
                     *
                     * @param {string} label
                     */
                    setLabel(label) {
                        this.label = label;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isHidden() {
                        return this.hidden;
                    }
                    /**
                     *
                     * @param {boolean} hidden
                     */
                    setHidden(hidden) {
                        this.hidden = hidden;
                        this.tools.hideTool(this);
                    }
                }
                editor.Tool = Tool;
                Tool["__class"] = "com.vzome.core.editor.Tool";
                Tool["__interfaces"] = ["com.vzome.api.Tool"];
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class ApplyTool extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(tools, tool, selectInputs, deleteInputs, createOutputs, selectOutputs, redundantOutputs, copyColors) {
                        super(tools.getEditorModel());
                        if (this.tool === undefined) {
                            this.tool = null;
                        }
                        if (this.selectInputs === undefined) {
                            this.selectInputs = false;
                        }
                        if (this.deselectOutputs === undefined) {
                            this.deselectOutputs = false;
                        }
                        if (this.justSelect === undefined) {
                            this.justSelect = false;
                        }
                        if (this.hideInputs === undefined) {
                            this.hideInputs = false;
                        }
                        if (this.deleteInputs === undefined) {
                            this.deleteInputs = false;
                        }
                        if (this.redundantOutputs === undefined) {
                            this.redundantOutputs = false;
                        }
                        if (this.copyColors === undefined) {
                            this.copyColors = false;
                        }
                        if (this.tools === undefined) {
                            this.tools = null;
                        }
                        this.tools = tools;
                        this.tool = tool;
                        this.selectInputs = selectInputs;
                        this.deleteInputs = deleteInputs;
                        this.copyColors = copyColors;
                        this.hideInputs = false;
                        this.deselectOutputs = !selectOutputs;
                        this.justSelect = !createOutputs;
                        this.redundantOutputs = redundantOutputs;
                    }
                    static logger_$LI$() { if (ApplyTool.logger == null) {
                        ApplyTool.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor.ApplyTool");
                    } return ApplyTool.logger; }
                    /**
                     *
                     */
                    perform() {
                        if (ApplyTool.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                            ApplyTool.logger_$LI$().fine("performing ApplyTool " + this.tool.getId() + " :: " + this.tool.getCategory());
                        const inputs = (new java.util.ArrayList());
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (this.deleteInputs && this.tool.needsInput()) {
                                    super.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                                    super.deleteManifestation(man);
                                    if (ApplyTool.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))
                                        ApplyTool.logger_$LI$().finest("ApplyTool - unselect and delete " + man.toString());
                                }
                                else if (this.hideInputs && this.tool.needsInput()) {
                                    super.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                                    super.hideManifestation(man);
                                    if (ApplyTool.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))
                                        ApplyTool.logger_$LI$().finest("ApplyTool - unselect and hide " + man.toString());
                                }
                                else if (!this.selectInputs) {
                                    super.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                                    if (ApplyTool.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))
                                        ApplyTool.logger_$LI$().finest("ApplyTool - unselect " + man.toString());
                                }
                                if (this.tool.needsInput())
                                    inputs.add(man);
                            }
                        }
                        this.redo();
                        this.tool.prepare(this);
                        if (this.tool.needsInput()) {
                            for (let index = inputs.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    const c = man.toConstruction();
                                    c.setColor(this.copyColors ? man.getColor() : null);
                                    this.tool.performEdit(c, this);
                                }
                            }
                        }
                        else {
                            for (let index = this.mManifestations.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    this.tool.performSelect(man, this);
                                }
                            }
                        }
                        this.tool.complete(this);
                        this.redo();
                        super.perform();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        if (this.redundantOutputs)
                            return "ApplyTool";
                        else
                            return "ToolApplied";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("name", this.tool.getId());
                        if (this.selectInputs)
                            element.setAttribute("selectInputs", "true");
                        if (this.deselectOutputs)
                            element.setAttribute("deselectOutputs", "true");
                        if (this.justSelect)
                            element.setAttribute("justSelect", "true");
                        if (this.hideInputs)
                            element.setAttribute("hideInputs", "true");
                        if (this.deleteInputs)
                            element.setAttribute("deleteInputs", "true");
                        element.setAttribute("copyColors", javaemul.internal.BooleanHelper.toString(this.copyColors));
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        const toolName = element.getAttribute("name");
                        this.tool = this.tools.get(toolName);
                        this.selectInputs = this.isAttributeTrue(element, "selectInputs");
                        this.deselectOutputs = this.isAttributeTrue(element, "deselectOutputs");
                        this.justSelect = this.isAttributeTrue(element, "justSelect");
                        this.hideInputs = this.isAttributeTrue(element, "hideInputs");
                        this.deleteInputs = this.isAttributeTrue(element, "deleteInputs");
                        const value = element.getAttribute("copyColors");
                        this.copyColors = value == null || !(value === ("false"));
                    }
                    /*private*/ isAttributeTrue(element, name) {
                        const value = element.getAttribute(name);
                        return value != null && (value === ("true"));
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.Construction} c
                     * @return {*}
                     */
                    manifestConstruction(c) {
                        let m = this.getManifestation(c);
                        const preExistsNotHidden = (m != null && m.isRendered());
                        if (this.justSelect) {
                            if (preExistsNotHidden)
                                super.select$com_vzome_core_model_Manifestation$boolean(m, false);
                        }
                        else if (this.redundantOutputs || !preExistsNotHidden) {
                            m = super.manifestConstruction(c);
                            if (!this.deselectOutputs)
                                super.select$com_vzome_core_model_Manifestation$boolean(m, true);
                        }
                        return m;
                    }
                    select(man, ignoreGroups) {
                        if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                            super.select(man, ignoreGroups);
                        }
                        else if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                            return this.select$com_vzome_core_model_Manifestation(man);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    select$com_vzome_core_model_Manifestation(m) {
                        if (this.tool.needsInput())
                            throw new java.lang.UnsupportedOperationException("select is not supported within Tool.performEdit");
                        if (!m.isRendered())
                            super.showManifestation(m);
                        super.select$com_vzome_core_model_Manifestation$boolean(m, true);
                    }
                    unselect(man, ignoreGroups) {
                        if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                            super.unselect(man, ignoreGroups);
                        }
                        else if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                            return this.unselect$com_vzome_core_model_Manifestation(man);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    unselect$com_vzome_core_model_Manifestation(man) {
                        throw new java.lang.UnsupportedOperationException("unselect is not supported within Tool.performEdit");
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    showManifestation(m) {
                        throw new java.lang.UnsupportedOperationException("showManifestation is not supported within Tool.performEdit");
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    hideManifestation(m) {
                        throw new java.lang.UnsupportedOperationException("hideManifestation is not supported within Tool.performEdit");
                    }
                }
                editor.ApplyTool = ApplyTool;
                ApplyTool["__class"] = "com.vzome.core.editor.ApplyTool";
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class SelectToolParameters extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(tools, tool) {
                        super(tools.getEditorModel());
                        if (this.tool === undefined) {
                            this.tool = null;
                        }
                        if (this.tools === undefined) {
                            this.tools = null;
                        }
                        this.tools = tools;
                        this.tool = tool;
                    }
                    /**
                     *
                     */
                    perform() {
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            super.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                        }
                        this.redo();
                        for (let index = this.tool.getParameters().iterator(); index.hasNext();) {
                            let con = index.next();
                            {
                                const man = this.manifestConstruction(con);
                                this.select$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SelectToolParameters";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("name", this.tool.getId());
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        const toolName = element.getAttribute("name");
                        this.tool = this.tools.get(toolName);
                    }
                }
                editor.SelectToolParameters = SelectToolParameters;
                SelectToolParameters["__class"] = "com.vzome.core.editor.SelectToolParameters";
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectByDiameter extends com.vzome.core.edits.SelectByBoundary {
                    constructor(editor) {
                        super(editor);
                        if (this.center === undefined) {
                            this.center = null;
                        }
                        if (this.maxRadiusSquared === undefined) {
                            this.maxRadiusSquared = null;
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return SelectByDiameter.NAME;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    usage() {
                        return "This command requires two connectors which define the\ndiameter of a sphere centered at their midpoint.\n\nAll parts that are completely within the sphere will be selected.\n";
                    }
                    adjustBoundary(vectors) {
                        switch ((vectors.size())) {
                            case 1:
                                return null;
                            case 2:
                                this.center = com.vzome.core.algebra.AlgebraicVectors.calculateCentroid(vectors);
                                const v1 = vectors.get(0).minus(this.center);
                                this.maxRadiusSquared = v1.dot(v1);
                                return null;
                        }
                        return "Too many connectors are selected.";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    setBoundary() {
                        this.center = null;
                        this.maxRadiusSquared = null;
                        const vectors = (new java.util.ArrayList());
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    vectors.add(man.getLocation());
                                    const errMsg = this.adjustBoundary(vectors);
                                    if (errMsg != null) {
                                        return errMsg;
                                    }
                                }
                            }
                        }
                        if (vectors.isEmpty()) {
                            return "No connectors are selected.";
                        }
                        if (this.center == null || this.maxRadiusSquared == null) {
                            const n = vectors.size();
                            return n === 1 ? "Only one connector is selected." : "Only " + n + " connectors are selected.";
                        }
                        return null;
                    }
                    boundaryContains$com_vzome_core_algebra_AlgebraicVector(v) {
                        v = v.minus(this.center);
                        const vSq = v.dot(v);
                        return vSq.compareTo(this.maxRadiusSquared) <= 0;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v
                     * @return {boolean}
                     */
                    boundaryContains(v) {
                        if (((v != null && v instanceof com.vzome.core.algebra.AlgebraicVector) || v === null)) {
                            return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v);
                        }
                        else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || v === null)) {
                            return super.boundaryContains(v);
                        }
                        else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Strut(v);
                        }
                        else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Panel(v);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                SelectByDiameter.NAME = "SelectByDiameter";
                edits.SelectByDiameter = SelectByDiameter;
                SelectByDiameter["__class"] = "com.vzome.core.edits.SelectByDiameter";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectByPlane extends com.vzome.core.edits.SelectByBoundary {
                    constructor(editor) {
                        super(editor);
                        if (this.plane === undefined) {
                            this.plane = null;
                        }
                        if (this.anchor === undefined) {
                            this.anchor = null;
                        }
                        if (this.desiredOrientation === undefined) {
                            this.desiredOrientation = 0;
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return SelectByPlane.NAME;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    usage() {
                        return "This command requires four selected connectors.\n\nThe first three connectors must not be collinear,\nso that they define a plane.\nThe fourth connector must lie outside of that plane,\nand defines which half space you wish to select.\n\nAll parts that are completely within that half-space will be selected.\n";
                    }
                    /**
                     *
                     */
                    perform() {
                        this.setOrderedSelection(true);
                        super.perform();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    setBoundary() {
                        let p1 = null;
                        let p2 = null;
                        let p3 = null;
                        let p4 = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (p1 == null) {
                                        p1 = man.getLocation();
                                        continue;
                                    }
                                    if (p2 == null) {
                                        p2 = man.getLocation();
                                        continue;
                                    }
                                    if (p3 == null) {
                                        p3 = man.getLocation();
                                        continue;
                                    }
                                    if (p4 == null) {
                                        p4 = man.getLocation();
                                        continue;
                                    }
                                    else {
                                        return "You have selected more than four connectors.";
                                    }
                                }
                            }
                        }
                        if (p4 == null)
                            return "You have selected fewer than four connectors.";
                        const v1 = new com.vzome.core.algebra.Vector3d(p2.minus(p1));
                        const v2 = new com.vzome.core.algebra.Vector3d(p3.minus(p1));
                        this.plane = v1.outer(v2);
                        this.anchor = p1;
                        this.desiredOrientation = this.orient(p4);
                        if (this.desiredOrientation === 0) {
                            return "Your last selected connector lies in the plane of the other three.";
                        }
                        return null;
                    }
                    /*private*/ orient(point) {
                        const diff = point.minus(this.anchor);
                        const v = new com.vzome.core.algebra.Vector3d(diff);
                        const volume = this.plane.outer(v);
                        if (volume.isZero())
                            return 0;
                        else {
                            const volD = volume.evaluate();
                            return (volD > 0.0) ? 1 : -1;
                        }
                    }
                    boundaryContains$com_vzome_core_algebra_AlgebraicVector(v) {
                        const orientation = this.orient(v);
                        return (orientation === 0) || (orientation === this.desiredOrientation);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v
                     * @return {boolean}
                     */
                    boundaryContains(v) {
                        if (((v != null && v instanceof com.vzome.core.algebra.AlgebraicVector) || v === null)) {
                            return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v);
                        }
                        else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || v === null)) {
                            return super.boundaryContains(v);
                        }
                        else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Strut(v);
                        }
                        else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Panel(v);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                SelectByPlane.NAME = "SelectByPlane";
                edits.SelectByPlane = SelectByPlane;
                SelectByPlane["__class"] = "com.vzome.core.edits.SelectByPlane";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectCoplanar extends com.vzome.core.edits.SelectByBoundary {
                    constructor(editor) {
                        super(editor);
                        this.pickedVectors = (new java.util.ArrayList());
                        this.vectors = (new java.util.HashSet());
                        this.pointOnPlane = null;
                        this.normal = null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    usage() {
                        return "Select any combination of connectors, struts or panels to specify\n3 or more points that are all coplanar, but not simply collinear.\n\nAll parts that are completely on the corresponding plane will be selected.\n";
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        const panel = props.get("picked");
                        if (panel != null) {
                            for (let index = panel.iterator(); index.hasNext();) {
                                let v = index.next();
                                {
                                    this.pickedVectors.add(v);
                                }
                            }
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    setBoundary() {
                        if (this.pickedVectors.isEmpty()) {
                            for (let index = this.mSelection.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        this.vectors.add(man.getLocation());
                                    }
                                    else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                        this.vectors.add(man.getLocation());
                                        this.vectors.add(man.getEnd());
                                    }
                                    else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                        for (let index = man.iterator(); index.hasNext();) {
                                            let v = index.next();
                                            {
                                                this.vectors.add(v);
                                            }
                                        }
                                    }
                                    else {
                                        throw new java.lang.IllegalStateException("Unknown manifestation: " + /* getSimpleName */ (c => typeof c === 'string' ? c.substring(c.lastIndexOf('.') + 1) : c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))(man.constructor));
                                    }
                                }
                            }
                            if (this.vectors.size() < 3) {
                                return "Additional connectors, struts or panels must be selected to define a plane.";
                            }
                            if (com.vzome.core.algebra.AlgebraicVectors.areCollinear$java_util_Collection(this.vectors)) {
                                return "Selected items are collinear. Select another non-collinear ball to specify the plane.";
                            }
                            if (!com.vzome.core.algebra.AlgebraicVectors.areCoplanar(this.vectors)) {
                                return "Selected items are not coplanar.";
                            }
                        }
                        else {
                            this.vectors.addAll(this.pickedVectors);
                            this.unselectAll();
                            this.redo();
                        }
                        for (let index = this.vectors.iterator(); index.hasNext();) {
                            let v = index.next();
                            {
                                this.pointOnPlane = v;
                                break;
                            }
                        }
                        this.normal = com.vzome.core.algebra.AlgebraicVectors.getNormal$java_util_Collection(this.vectors);
                        return null;
                    }
                    boundaryContains$com_vzome_core_algebra_AlgebraicVector(v) {
                        return this.vectors.contains(v) || this.pointOnPlane.minus(v).dot(this.normal).isZero();
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v
                     * @return {boolean}
                     */
                    boundaryContains(v) {
                        if (((v != null && v instanceof com.vzome.core.algebra.AlgebraicVector) || v === null)) {
                            return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v);
                        }
                        else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || v === null)) {
                            return super.boundaryContains(v);
                        }
                        else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Strut(v);
                        }
                        else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Panel(v);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return SelectCoplanar.NAME;
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (!this.pickedVectors.isEmpty()) {
                            com.vzome.xml.DomUtils.addAttribute(element, "nPickedVectors", /* toString */ ('' + (this.pickedVectors.size())));
                            for (let i = 0; i < this.pickedVectors.size(); i++) {
                                {
                                    com.vzome.xml.DomUtils.addAttribute(element, "vector" + i, this.pickedVectors.get(i).toParsableString());
                                }
                                ;
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        const nPickedVectors = xml.getAttribute("nPickedVectors");
                        if (nPickedVectors != null && !(nPickedVectors.length === 0)) {
                            const nPicked = javaemul.internal.IntegerHelper.parseInt(nPickedVectors);
                            for (let i = 0; i < nPicked; i++) {
                                {
                                    this.pickedVectors.add(format.parseRationalVector(xml, "vector" + i));
                                }
                                ;
                            }
                        }
                    }
                }
                SelectCoplanar.NAME = "SelectCoplanar";
                edits.SelectCoplanar = SelectCoplanar;
                SelectCoplanar["__class"] = "com.vzome.core.edits.SelectCoplanar";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ConvexHull3d extends com.vzome.core.edits.ConvexHull {
                    constructor(editorModel) {
                        super(editorModel);
                        this.mode = null;
                        this.generateStruts = true;
                        this.generatePanels = true;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return ConvexHull3d.NAME;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return (this.generateStruts || this.generatePanels) ? super.isNoOp() : true;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        this.setMode(props.get("mode"));
                    }
                    /*private*/ setMode(newMode) {
                        this.mode = "";
                        this.generateStruts = true;
                        this.generatePanels = true;
                        if (newMode != null)
                            switch ((newMode)) {
                                case "":
                                    this.mode = newMode;
                                    this.generateStruts = true;
                                    this.generatePanels = true;
                                    break;
                                case "noPanels":
                                    this.mode = newMode;
                                    this.generateStruts = true;
                                    this.generatePanels = false;
                                    break;
                                case "onlyPanels":
                                    this.mode = newMode;
                                    this.generateStruts = false;
                                    this.generatePanels = true;
                                    break;
                                default:
                                    if (com.vzome.core.editor.api.ChangeSelection.logger_$LI$().isLoggable(java.util.logging.Level.WARNING)) {
                                        com.vzome.core.editor.api.ChangeSelection.logger_$LI$().warning(ConvexHull3d.NAME + ": Ignoring unknown mode: \"" + newMode + "\".");
                                    }
                                    break;
                            }
                    }
                    /**
                     *
                     */
                    perform() {
                        const hull3d = new com.vzome.core.math.convexhull.QuickHull3D();
                        hull3d.build$java_util_Collection(this.getSelectedVertexSet(true));
                        this.redo();
                        const vertices = hull3d.getVertices$();
                        const pointMap = (new java.util.HashMap(vertices.length));
                        for (let index = 0; index < vertices.length; index++) {
                            let vertex = vertices[index];
                            {
                                const point = new com.vzome.core.construction.FreePoint(vertex);
                                pointMap.put(vertex, point);
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(point));
                            }
                        }
                        const faces = hull3d.getFaces$();
                        for (let index = 0; index < faces.length; index++) {
                            let face = faces[index];
                            {
                                const points = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(face.length);
                                let startIndex = face[face.length - 1];
                                let start = pointMap.get(vertices[startIndex]);
                                for (let i = 0; i < face.length; i++) {
                                    {
                                        const endIndex = startIndex;
                                        startIndex = face[i];
                                        const end = points[i] = pointMap.get(vertices[startIndex]);
                                        if (this.generateStruts && (startIndex < endIndex)) {
                                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, end)));
                                        }
                                        start = end;
                                    }
                                    ;
                                }
                                if (this.generatePanels) {
                                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices(points)));
                                }
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.mode != null) {
                            element.setAttribute("mode", this.mode);
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.setMode(xml.getAttribute("mode"));
                    }
                }
                ConvexHull3d.NAME = "ConvexHull3d";
                edits.ConvexHull3d = ConvexHull3d;
                ConvexHull3d["__class"] = "com.vzome.core.edits.ConvexHull3d";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ConvexHull2d extends com.vzome.core.edits.ConvexHull {
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return ConvexHull2d.NAME;
                    }
                    /**
                     *
                     */
                    perform() {
                        const hull2d = com.vzome.core.math.convexhull.GrahamScan2D.buildHull(this.getSelectedVertexSet(true));
                        this.redo();
                        const vertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(hull2d.length);
                        let p = 0;
                        const pointMap = (new java.util.HashMap(hull2d.length));
                        for (let index = 0; index < hull2d.length; index++) {
                            let vertex = hull2d[index];
                            {
                                const point = new com.vzome.core.construction.FreePoint(vertex);
                                pointMap.put(vertex, point);
                                vertices[p++] = point;
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(point));
                            }
                        }
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices(vertices)));
                        let start = pointMap.get(hull2d[0]);
                        for (let i = 1; i < hull2d.length; i++) {
                            {
                                const end = pointMap.get(hull2d[i]);
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, end)));
                                start = end;
                            }
                            ;
                        }
                        const end = pointMap.get(hull2d[0]);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, end)));
                        this.redo();
                    }
                }
                ConvexHull2d.NAME = "ConvexHull2d";
                edits.ConvexHull2d = ConvexHull2d;
                ConvexHull2d["__class"] = "com.vzome.core.edits.ConvexHull2d";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class StrutMove extends com.vzome.core.edits.StrutCreation {
                    constructor(editor) {
                        super(editor);
                        if (this.oldStrut === undefined) {
                            this.oldStrut = null;
                        }
                    }
                    /**
                     *
                     * @param {*} params
                     */
                    configure(params) {
                        super.configure(params);
                        this.oldStrut = params.get("oldStrut");
                    }
                    /**
                     *
                     */
                    perform() {
                        this.deleteManifestation(this.oldStrut);
                        this.manifestConstruction(this.mAnchor);
                        super.redo();
                        super.perform();
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    getXmlAttributes(xml) {
                        com.vzome.core.commands.XmlSaveFormat.serializeSegment(xml, "startSegment", "endSegment", this.oldStrut.getFirstConstruction());
                        super.getXmlAttributes(xml);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        const construction = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "startSegment", "endSegment");
                        if (construction != null)
                            this.oldStrut = this.getManifestation(construction);
                        super.setXmlAttributes(xml, format);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "StrutMove";
                    }
                }
                edits.StrutMove = StrutMove;
                StrutMove["__class"] = "com.vzome.core.edits.StrutMove";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class LoadVEF extends com.vzome.core.edits.ImportMesh {
                    constructor(editor) {
                        super(editor);
                    }
                    deselectInputs() {
                        return false;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} offset
                     * @param {com.vzome.core.editor.api.ManifestConstructions} events
                     * @param {*} registry
                     */
                    parseMeshData(offset, events, registry) {
                        const v2m = new com.vzome.core.construction.VefToModel(this.projection, events, this.scale, offset);
                        v2m.parseVEF(this.meshData, this.mManifestations.getField());
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "LoadVEF";
                    }
                }
                edits.LoadVEF = LoadVEF;
                LoadVEF["__class"] = "com.vzome.core.edits.LoadVEF";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_18) {
                class TransformationTool extends com.vzome.core.editor.Tool {
                    constructor(id, tools) {
                        super(id, tools);
                        if (this.transforms === undefined) {
                            this.transforms = null;
                        }
                        if (this.originPoint === undefined) {
                            this.originPoint = null;
                        }
                        this.originPoint = tools.getOriginPoint();
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    prepare(applyTool) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    complete(applyTool) {
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    needsInput() {
                        return true;
                    }
                    /**
                     *
                     * @param {*} that
                     * @return {boolean}
                     */
                    equals(that) {
                        if (this === that) {
                            return true;
                        }
                        if (that == null) {
                            return false;
                        }
                        if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(that.constructor, this.constructor)) {
                            return false;
                        }
                        const other = that;
                        if (this.originPoint == null) {
                            if (other.originPoint != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.originPoint, other.originPoint)) {
                            return false;
                        }
                        if (!java.util.Arrays.equals(this.transforms, other.transforms)) {
                            return false;
                        }
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.Construction} c
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performEdit(c, applyTool) {
                        for (let index = 0; index < this.transforms.length; index++) {
                            let transform = this.transforms[index];
                            {
                                const result = transform.transform$com_vzome_core_construction_Construction(c);
                                if (result == null)
                                    continue;
                                const color = c.getColor();
                                result.setColor(color);
                                const m = applyTool.manifestConstruction(result);
                                if (m != null)
                                    if (color != null)
                                        applyTool.colorManifestation(m, c.getColor());
                            }
                        }
                        applyTool.redo();
                    }
                    /**
                     *
                     * @param {*} man
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performSelect(man, applyTool) {
                    }
                    unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups) {
                        const c = man.getFirstConstruction();
                        this.addParameter(c);
                        super.unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups);
                    }
                    /**
                     *
                     * @param {*} man
                     * @param {boolean} ignoreGroups
                     */
                    unselect(man, ignoreGroups) {
                        if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                            return this.unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups);
                        }
                        else if (((man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                            return this.unselect$com_vzome_core_model_Manifestation(man);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    isAutomatic() {
                        return /* contains */ (this.getId().indexOf(".auto/") != -1);
                    }
                }
                tools_18.TransformationTool = TransformationTool;
                TransformationTool["__class"] = "com.vzome.core.tools.TransformationTool";
                TransformationTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_19) {
                class PlaneSelectionTool extends com.vzome.core.editor.Tool {
                    constructor(id, tools) {
                        super(id, tools);
                        if (this.plane === undefined) {
                            this.plane = null;
                        }
                        if (this.anchor === undefined) {
                            this.anchor = null;
                        }
                        this.halfSpace = true;
                        this.boundaryOpen = false;
                        this.above = true;
                        this.includeBalls = true;
                        this.includeStruts = true;
                        this.includePanels = true;
                        this.includePartials = false;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return true;
                    }
                    /**
                     *
                     */
                    perform() {
                        let p1 = null;
                        let p2 = null;
                        let p3 = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (p1 == null) {
                                        p1 = man.getLocation();
                                        continue;
                                    }
                                    if (p2 == null) {
                                        p2 = man.getLocation();
                                        continue;
                                    }
                                    if (p3 == null) {
                                        p3 = man.getLocation();
                                        continue;
                                    }
                                    else {
                                        throw new com.vzome.core.commands.Command.Failure("half-space selection tool requires exactly three balls");
                                    }
                                }
                            }
                        }
                        if (p3 == null)
                            throw new com.vzome.core.commands.Command.Failure("half-space selection tool requires exactly three balls");
                        const v1 = new com.vzome.core.algebra.Vector3d(p2.minus(p1));
                        const v2 = new com.vzome.core.algebra.Vector3d(p3.minus(p1));
                        this.plane = v1.outer(v2);
                        this.anchor = p1;
                        super.perform();
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    prepare(applyTool) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    complete(applyTool) {
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    needsInput() {
                        return false;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.Construction} c
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performEdit(c, applyTool) {
                    }
                    /**
                     *
                     * @param {*} man
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performSelect(man, applyTool) {
                        if (man.isHidden())
                            return;
                        if (!man.isRendered())
                            return;
                        if (this.includePanels && (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)))
                            return;
                        if (this.includeBalls && (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))) {
                            const c = man;
                            const orientation = this.orient(c.getLocation());
                            if (!this.boundaryOpen && orientation === 0)
                                applyTool.select$com_vzome_core_model_Manifestation(man);
                            else if (this.halfSpace && this.above && orientation > 0)
                                applyTool.select$com_vzome_core_model_Manifestation(man);
                            else if (this.halfSpace && !this.above && orientation < 0)
                                applyTool.select$com_vzome_core_model_Manifestation(man);
                        }
                        else if (this.includeStruts && (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))) {
                            const o1 = this.orient(man.getLocation());
                            const o2 = this.orient(man.getEnd());
                            if (this.includePartials) {
                                if (!this.boundaryOpen && (o1 === 0 || o2 === 0))
                                    applyTool.select$com_vzome_core_model_Manifestation(man);
                                else if (this.halfSpace) {
                                    if (this.above && (o1 > 0 || o2 > 0))
                                        applyTool.select$com_vzome_core_model_Manifestation(man);
                                    else if (!this.above && (o1 < 0 || o2 < 0))
                                        applyTool.select$com_vzome_core_model_Manifestation(man);
                                }
                            }
                            else {
                                if (!this.halfSpace && o1 === 0 && o2 === 0)
                                    applyTool.select$com_vzome_core_model_Manifestation(man);
                                else if (this.halfSpace) {
                                    if (this.boundaryOpen) {
                                        if (this.above && (o1 > 0 && o2 > 0))
                                            applyTool.select$com_vzome_core_model_Manifestation(man);
                                        else if (!this.above && (o1 < 0 && o2 < 0))
                                            applyTool.select$com_vzome_core_model_Manifestation(man);
                                    }
                                    else {
                                        if (this.above && (o1 >= 0 && o2 >= 0))
                                            applyTool.select$com_vzome_core_model_Manifestation(man);
                                        else if (!this.above && (o1 <= 0 && o2 <= 0))
                                            applyTool.select$com_vzome_core_model_Manifestation(man);
                                    }
                                }
                            }
                        }
                        applyTool.redo();
                    }
                    /*private*/ orient(point) {
                        const diff = point.minus(this.anchor);
                        const v = new com.vzome.core.algebra.Vector3d(diff);
                        const volume = this.plane.outer(v);
                        if (volume.isZero())
                            return 0;
                        else {
                            const volD = volume.evaluate();
                            return (volD > 0.0) ? 1 : -1;
                        }
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "PlaneSelectionTool";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("name", this.getId());
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        super.setXmlAttributes(element, format);
                        this.includeBalls = !("false" === element.getAttribute("balls"));
                        this.includeStruts = !("false" === element.getAttribute("struts"));
                        this.includePanels = "true" === element.getAttribute("panels");
                        this.includePartials = "any" === element.getAttribute("vertices");
                        this.boundaryOpen = "true" === element.getAttribute("open");
                        const halfSpace = element.getAttribute("halfSpace");
                        if ("above" === halfSpace) {
                            this.halfSpace = true;
                            this.above = true;
                        }
                        else if ("below" === halfSpace) {
                            this.halfSpace = true;
                            this.above = false;
                        }
                        else {
                            this.halfSpace = false;
                            this.boundaryOpen = false;
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return "plane";
                    }
                    getDefaultName() {
                        return "plane";
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        return null;
                    }
                }
                tools_19.PlaneSelectionTool = PlaneSelectionTool;
                PlaneSelectionTool["__class"] = "com.vzome.core.tools.PlaneSelectionTool";
                PlaneSelectionTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_20) {
                class BookmarkTool extends com.vzome.core.editor.Tool {
                    constructor(id, tools) {
                        super(id, tools);
                        this.bookmarkedConstructions = (new java.util.ArrayList());
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return true;
                    }
                    /**
                     *
                     */
                    perform() {
                        const duper = new com.vzome.core.editor.Duplicator(null, null);
                        if (this.mSelection.size() === 0)
                            this.bookmarkedConstructions.add(new com.vzome.core.construction.FreePoint(this.mManifestations.getField().origin(3)));
                        else
                            for (let index = this.mSelection.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    const result = duper.duplicateConstruction(man);
                                    this.bookmarkedConstructions.add(result);
                                    this.addParameter(result);
                                }
                            }
                        super.perform();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    needsInput() {
                        return false;
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} edit
                     */
                    prepare(edit) {
                        if (this.bookmarkedConstructions.isEmpty()) {
                            edit.manifestConstruction(new com.vzome.core.construction.FreePoint(this.mManifestations.getField().origin(3)));
                        }
                        else
                            for (let index = this.bookmarkedConstructions.iterator(); index.hasNext();) {
                                let con = index.next();
                                {
                                    edit.manifestConstruction(con);
                                }
                            }
                        edit.redo();
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    complete(applyTool) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.Construction} c
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performEdit(c, applyTool) {
                    }
                    /**
                     *
                     * @param {*} man
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performSelect(man, applyTool) {
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "BookmarkTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return BookmarkTool.ID;
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        return null;
                    }
                }
                BookmarkTool.ID = "bookmark";
                BookmarkTool.LABEL = "Create a selection bookmark";
                BookmarkTool.TOOLTIP = "<p>A selection bookmark lets you re-create<br>any selection at a later time.</p>";
                tools_20.BookmarkTool = BookmarkTool;
                BookmarkTool["__class"] = "com.vzome.core.tools.BookmarkTool";
                BookmarkTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_21) {
                class ModuleTool extends com.vzome.core.editor.Tool {
                    constructor(id, tools) {
                        super(id, tools);
                        if (this.name === undefined) {
                            this.name = null;
                        }
                        this.bookmarkedSelection = (new java.util.ArrayList());
                        this.mSelection.copy(this.bookmarkedSelection);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    prepare(applyTool) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    complete(applyTool) {
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    needsInput() {
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.Construction} c
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performEdit(c, applyTool) {
                        if (!(c != null && c instanceof com.vzome.core.construction.Point))
                            return;
                        const p = c;
                        const loc = p.getLocation();
                        const duper = new com.vzome.core.editor.Duplicator(applyTool, loc);
                        for (let index = this.bookmarkedSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                duper.duplicateManifestation(man);
                            }
                        }
                        applyTool.redo();
                    }
                    /**
                     *
                     * @param {*} man
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performSelect(man, applyTool) {
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ModuleTool";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("name", this.name);
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        this.name = element.getAttribute("name");
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return ModuleTool.ID;
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        return null;
                    }
                }
                ModuleTool.ID = "module";
                ModuleTool.LABEL = "Create a module tool";
                ModuleTool.TOOLTIP = "<p>Each tool duplicates the original module.<br></p>";
                tools_21.ModuleTool = ModuleTool;
                ModuleTool["__class"] = "com.vzome.core.tools.ModuleTool";
                ModuleTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectByRadius extends com.vzome.core.edits.SelectByDiameter {
                    constructor(editor) {
                        super(editor);
                        if (this.minRadiusSquared === undefined) {
                            this.minRadiusSquared = null;
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return SelectByRadius.NAME;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    usage() {
                        return "This command requires either two or three selected connectors.\n\nThe first connector marks the center of a sphere.\nThe second connector defines its radius.\nAn optional third connector defines the radius of\n a second sphere with the same center.\n\nAll parts that are completely within the larger sphere will be selected.\n\nIf a second sphere is defined then any parts\n     within the smaller sphere, even partially, will be excluded.\n";
                    }
                    /**
                     *
                     */
                    perform() {
                        this.setOrderedSelection(true);
                        super.perform();
                    }
                    /**
                     *
                     * @param {*} vectors
                     * @return {string}
                     */
                    adjustBoundary(vectors) {
                        const v = vectors.get(vectors.size() - 1);
                        switch ((vectors.size())) {
                            case 1:
                                this.center = v;
                                this.maxRadiusSquared = null;
                                this.minRadiusSquared = null;
                                return null;
                            case 2:
                                const v2 = v.minus(this.center);
                                this.maxRadiusSquared = v2.dot(v2);
                                return null;
                            case 3:
                                const v3 = v.minus(this.center);
                                this.minRadiusSquared = v3.dot(v3);
                                if (this.maxRadiusSquared.compareTo(this.minRadiusSquared) < 0) {
                                    const temp = this.maxRadiusSquared;
                                    this.maxRadiusSquared = this.minRadiusSquared;
                                    this.minRadiusSquared = temp;
                                }
                                return null;
                        }
                        return super.adjustBoundary(vectors);
                    }
                    boundaryContains$com_vzome_core_algebra_AlgebraicVector(v) {
                        if (super.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v)) {
                            if (this.minRadiusSquared != null) {
                                const v1 = v.minus(this.center);
                                return v1.dot(v1).compareTo(this.minRadiusSquared) >= 0;
                            }
                            return true;
                        }
                        return false;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v
                     * @return {boolean}
                     */
                    boundaryContains(v) {
                        if (((v != null && v instanceof com.vzome.core.algebra.AlgebraicVector) || v === null)) {
                            return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v);
                        }
                        else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || v === null)) {
                            return super.boundaryContains(v);
                        }
                        else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Strut(v);
                        }
                        else if (((v != null && (v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Panel(v);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                SelectByRadius.NAME = "SelectByRadius";
                edits.SelectByRadius = SelectByRadius;
                SelectByRadius["__class"] = "com.vzome.core.edits.SelectByRadius";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_22) {
                class InversionTool extends com.vzome.core.tools.TransformationTool {
                    constructor(toolName, tools) {
                        super(toolName, tools);
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let center = null;
                        if (!this.isAutomatic())
                            for (let index = this.mSelection.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    if (prepareTool)
                                        this.unselect$com_vzome_core_model_Manifestation(man);
                                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        if (center != null)
                                            return "more than one center selected";
                                        center = man.getFirstConstruction();
                                    }
                                    else if (!prepareTool)
                                        return "panel or strut selected";
                                }
                            }
                        if (center == null) {
                            if (prepareTool) {
                                center = this.originPoint;
                                this.addParameter(center);
                            }
                            else
                                return "No symmetry center selected";
                        }
                        if (prepareTool) {
                            this.transforms = [null];
                            this.transforms[0] = new com.vzome.core.construction.PointReflection(center);
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "InversionTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return InversionTool.ID;
                    }
                }
                InversionTool.ID = "point reflection";
                InversionTool.LABEL = "Create a point reflection tool";
                InversionTool.TOOLTIP = "<p>Each tool duplicates the selection by reflecting<br>each point through the defined center.  To create a<br>tool, select a single ball that defines that center.<br></p>";
                tools_22.InversionTool = InversionTool;
                InversionTool["__class"] = "com.vzome.core.tools.InversionTool";
                InversionTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_23) {
                class AxialStretchTool extends com.vzome.core.tools.TransformationTool {
                    constructor(id, symmetry, tools, stretch, red, first, category) {
                        super(id, tools);
                        if (this.symmetry === undefined) {
                            this.symmetry = null;
                        }
                        if (this.stretch === undefined) {
                            this.stretch = false;
                        }
                        if (this.red === undefined) {
                            this.red = false;
                        }
                        if (this.first === undefined) {
                            this.first = false;
                        }
                        if (this.__com_vzome_core_tools_AxialStretchTool_category === undefined) {
                            this.__com_vzome_core_tools_AxialStretchTool_category = null;
                        }
                        this.symmetry = symmetry;
                        this.stretch = stretch;
                        this.red = red;
                        this.first = first;
                        this.__com_vzome_core_tools_AxialStretchTool_category = category;
                        this.setInputBehaviors(false, true);
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let center = null;
                        let axis = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (prepareTool)
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (center != null)
                                        return "Only one ball may be selected";
                                    center = man.getFirstConstruction();
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (axis != null)
                                        return "Only one strut may be selected";
                                    axis = man.getFirstConstruction();
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    return "Panels are not supported.";
                                }
                            }
                        }
                        if (center == null)
                            return "Exactly one ball must be selected.";
                        if (axis == null)
                            return "Exactly one strut must be selected.";
                        const zone = this.symmetry.getAxis$com_vzome_core_algebra_AlgebraicVector(axis.getOffset());
                        if (zone == null)
                            return "Selected alignment strut is not an appropriate axis.";
                        let o0;
                        let o1;
                        let o2;
                        let n0;
                        let n1;
                        let n2;
                        switch ((zone.getDirection().getName())) {
                            case "yellow":
                                {
                                    if (this.red)
                                        return "A red axis strut must be selected.";
                                    const blueOrbit = this.symmetry.getDirection("blue");
                                    const blueScale = blueOrbit.getUnitLength();
                                    o0 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 2).normal().scale(blueScale);
                                    o1 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 54).normal().scale(blueScale);
                                    o2 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 36).normal().scale(blueScale);
                                    const redOrbit = this.symmetry.getDirection("red");
                                    const redScale = redOrbit.getUnitLength();
                                    n0 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 2).normal().scale(redScale);
                                    n1 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 46).normal().scale(redScale);
                                    n2 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 16).normal().scale(redScale);
                                    break;
                                }
                                ;
                            case "red":
                                {
                                    if (!this.red)
                                        return "A yellow axis strut must be selected.";
                                    const blueOrbit = this.symmetry.getDirection("blue");
                                    const blueScale = blueOrbit.getUnitLength();
                                    const redOrbit = this.symmetry.getDirection("red");
                                    let redScale = redOrbit.getUnitLength();
                                    if (this.first) {
                                        o0 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 56).normal().scale(blueScale);
                                        o1 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 38).normal().scale(blueScale);
                                        o2 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 40).normal().scale(blueScale);
                                        n0 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 46).normal().scale(redScale);
                                        n1 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1).normal().scale(redScale);
                                        n2 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 2).normal().scale(redScale);
                                    }
                                    else {
                                        o0 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 37).normal().scale(blueScale);
                                        o1 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 25).normal().scale(blueScale);
                                        o2 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 45).normal().scale(blueScale);
                                        n0 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 37).normal().scale(blueScale);
                                        n1 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 25).normal().scale(blueScale);
                                        redScale = redScale['times$com_vzome_core_algebra_AlgebraicNumber'](this.symmetry.getField()['createPower$int'](-1));
                                        n2 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 45).normal().scale(redScale);
                                    }
                                    break;
                                }
                                ;
                            default:
                                return "Selected alignment strut is not an appropriate axis.";
                        }
                        if (prepareTool) {
                            const orientation = this.symmetry.getMatrix(zone.getOrientation());
                            const inverse = orientation.inverse();
                            let oldBasis = new com.vzome.core.algebra.AlgebraicMatrix(o0, o1, o2);
                            let newBasis = new com.vzome.core.algebra.AlgebraicMatrix(n0, n1, n2);
                            if (this.stretch) {
                                const temp = oldBasis;
                                oldBasis = newBasis;
                                newBasis = temp;
                            }
                            const matrix = orientation.times(newBasis.times(oldBasis.inverse()).times(inverse));
                            this.transforms = [null];
                            this.transforms[0] = new com.vzome.core.construction.MatrixTransformation(matrix, center.getLocation());
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "AxialStretchTool";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        super.getXmlAttributes(element);
                        if (this.stretch)
                            element.setAttribute("stretch", "true");
                        element.setAttribute("orbit", this.red ? "red" : "yellow");
                        if (!this.first)
                            element.setAttribute("first", "false");
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        let value = element.getAttribute("stretch");
                        this.stretch = value != null && (value === ("true"));
                        value = element.getAttribute("orbit");
                        this.red = value === ("red");
                        value = element.getAttribute("first");
                        this.first = value == null || !(value === ("false"));
                        this.__com_vzome_core_tools_AxialStretchTool_category = AxialStretchTool.Factory.getCategory(this.red, this.stretch, this.first);
                        this.symmetry = format.parseSymmetry("icosahedral");
                        super.setXmlAttributes(element, format);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return this.__com_vzome_core_tools_AxialStretchTool_category;
                    }
                }
                AxialStretchTool.TOOLTIP_REDSQUASH1 = "<p>Each tool applies a \"squash\" transformation to the<br>selected objects, compressing along a red axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>red strut as the direction of the compression.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the mapping that transforms the central,<br>blue dodecahedron into the compressed form in the next<br>layer outward.<br><br>By default, the input selection will be removed, and replaced<br>with the squashed equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                AxialStretchTool.TOOLTIP_REDSTRETCH1 = "<p>Each tool applies a \"stretch\" transformation to the<br>selected objects, stretching along a red axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>red strut as the direction of the stretch.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the inverse of the mapping that transforms<br>the central, blue dodecahedron into the compressed form in<br>the next layer outward.<br><br>By default, the input selection will be removed, and replaced<br>with the stretched equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                AxialStretchTool.TOOLTIP_YELLOWSQUASH = "<p>Each tool applies a \"squash\" transformation to the<br>selected objects, compressing along a yellow axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>yellow strut as the direction of the compression.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the mapping that transforms the central,<br>blue dodecahedron into the compressed form along a yellow axis.<br><br>By default, the input selection will be removed, and replaced<br>with the squashed equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                AxialStretchTool.TOOLTIP_YELLOWSTRETCH = "<p>Each tool applies a \"stretch\" transformation to the<br>selected objects, stretching along a yellow axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>yellow strut as the direction of the stretch.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the inverse of the mapping that transforms<br>the central, blue dodecahedron into the compressed form along<br>a yellow axis.<br><br>By default, the input selection will be removed, and replaced<br>with the stretched equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                AxialStretchTool.TOOLTIP_REDSQUASH2 = "<p>Each tool applies a \"squash\" transformation to the<br>selected objects, compressing along a red axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>red strut as the direction of the compression.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the mapping that transforms the central,<br>blue dodecahedron into the compressed form in the second<br>layer outward along a red axis.<br><br>By default, the input selection will be removed, and replaced<br>with the squashed equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                AxialStretchTool.TOOLTIP_REDSTRETCH2 = "<p>Each tool applies a \"stretch\" transformation to the<br>selected objects, stretching along a red axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>red strut as the direction of the stretch.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the inverse of the mapping that transforms<br>the central, blue dodecahedron into the compressed form in<br>the second layer outward along a red axis.<br><br>By default, the input selection will be removed, and replaced<br>with the stretched equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                tools_23.AxialStretchTool = AxialStretchTool;
                AxialStretchTool["__class"] = "com.vzome.core.tools.AxialStretchTool";
                AxialStretchTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (AxialStretchTool) {
                    class Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools, symmetry, red, stretch, first) {
                            super(tools, symmetry, Factory.getCategory(red, stretch, first), Factory.getLabel(red, stretch, first), Factory.getToolTip(red, stretch, first));
                            if (this.red === undefined) {
                                this.red = false;
                            }
                            if (this.stretch === undefined) {
                                this.stretch = false;
                            }
                            if (this.first === undefined) {
                                this.first = false;
                            }
                            this.red = red;
                            this.stretch = stretch;
                            this.first = first;
                        }
                        static getCategory(red, stretch, first) {
                            if (red)
                                if (first)
                                    return stretch ? "redstretch1" : "redsquash1";
                                else
                                    return stretch ? "redstretch2" : "redsquash2";
                            else
                                return stretch ? "yellowstretch" : "yellowsquash";
                        }
                        static getLabel(red, stretch, first) {
                            let label;
                            if (red)
                                if (first)
                                    label = stretch ? "weak red stretch" : "weak red squash";
                                else
                                    label = stretch ? "strong red stretch" : "strong red squash";
                            else
                                label = stretch ? "yellow stretch" : "yellow squash";
                            return "Create a " + label + " tool";
                        }
                        static getToolTip(red, stretch, first) {
                            if (red)
                                if (first)
                                    return stretch ? com.vzome.core.tools.AxialStretchTool.TOOLTIP_REDSTRETCH1 : com.vzome.core.tools.AxialStretchTool.TOOLTIP_REDSQUASH1;
                                else
                                    return stretch ? com.vzome.core.tools.AxialStretchTool.TOOLTIP_REDSTRETCH2 : com.vzome.core.tools.AxialStretchTool.TOOLTIP_REDSQUASH2;
                            else
                                return stretch ? com.vzome.core.tools.AxialStretchTool.TOOLTIP_YELLOWSTRETCH : com.vzome.core.tools.AxialStretchTool.TOOLTIP_YELLOWSQUASH;
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            return (total === 2 && balls === 1 && struts === 1);
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            const category = Factory.getCategory(this.red, this.stretch, this.first);
                            return new com.vzome.core.tools.AxialStretchTool(id, this.getSymmetry(), this.getToolsModel(), this.stretch, this.red, this.first, category);
                        }
                        /**
                         *
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createTool() {
                            const result = super.createTool();
                            result.setCopyColors(false);
                            return result;
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            const symmetry = this.getSymmetry();
                            for (let index = selection.iterator(); index.hasNext();) {
                                let man = index.next();
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    const axisStrut = man;
                                    let vector = axisStrut.getOffset();
                                    vector = symmetry.getField().projectTo3d(vector, true);
                                    const axis = symmetry.getAxis$com_vzome_core_algebra_AlgebraicVector(vector);
                                    if (axis == null)
                                        return false;
                                    const orbitName = axis.getDirection().getName();
                                    if (this.red)
                                        return orbitName === ("red");
                                    else
                                        return orbitName === ("yellow");
                                }
                            }
                            return true;
                        }
                    }
                    AxialStretchTool.Factory = Factory;
                    Factory["__class"] = "com.vzome.core.tools.AxialStretchTool.Factory";
                    Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(AxialStretchTool = tools_23.AxialStretchTool || (tools_23.AxialStretchTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_24) {
                class SymmetryTool extends com.vzome.core.tools.TransformationTool {
                    constructor(id, symmetry, tools) {
                        super(id, tools);
                        if (this.symmetry === undefined) {
                            this.symmetry = null;
                        }
                        this.symmetry = symmetry;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        const prime = 31;
                        let result = 1;
                        result = prime * result + ((this.symmetry == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.symmetry));
                        return result;
                    }
                    /**
                     *
                     * @param {*} that
                     * @return {boolean}
                     */
                    equals(that) {
                        if (this === that) {
                            return true;
                        }
                        if (!super.equals(that)) {
                            return false;
                        }
                        if (this.constructor !== that.constructor) {
                            return false;
                        }
                        const other = that;
                        if (this.symmetry == null) {
                            if (other.symmetry != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.symmetry, other.symmetry)) {
                            return false;
                        }
                        return true;
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let center = null;
                        let axis = null;
                        let correct = true;
                        let hasPanels = false;
                        if (!this.isAutomatic())
                            for (let index = this.mSelection.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    if (prepareTool)
                                        this.unselect$com_vzome_core_model_Manifestation(man);
                                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        if (center != null)
                                            return "No unique symmetry center selected";
                                        center = man.getFirstConstruction();
                                    }
                                    else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                        if (axis != null)
                                            correct = false;
                                        else
                                            axis = man;
                                    }
                                    else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                        hasPanels = true;
                                    }
                                }
                            }
                        if (center == null) {
                            if (prepareTool) {
                                center = this.originPoint;
                                this.addParameter(center);
                            }
                            else
                                return "No symmetry center selected";
                        }
                        if (hasPanels) {
                            if (!prepareTool)
                                return "panels are selected";
                        }
                        let closure = this.symmetry.subgroup(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL);
                        switch ((this.symmetry.getName())) {
                            case "icosahedral":
                                if (!prepareTool && (axis != null) && (this.getCategory() === ("icosahedral")))
                                    return "No struts needed for icosahedral symmetry.";
                                switch ((this.getCategory())) {
                                    case "tetrahedral":
                                        if (!correct)
                                            return "no unique alignment strut selected.";
                                        if (axis == null) {
                                            if (!prepareTool)
                                                return "no aligment strut selected.";
                                        }
                                        else {
                                            const icosa = this.symmetry;
                                            const zone = icosa.getAxis$com_vzome_core_algebra_AlgebraicVector(axis.getOffset());
                                            if (zone == null)
                                                return "selected alignment strut is not a tetrahedral axis.";
                                            const allowYellow = prepareTool;
                                            closure = icosa.subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis$boolean(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL, zone, allowYellow);
                                            if (closure == null)
                                                return "selected alignment strut is not a tetrahedral axis.";
                                        }
                                        if (prepareTool) {
                                            const order = closure.length;
                                            this.transforms = (s => { let a = []; while (s-- > 0)
                                                a.push(null); return a; })(order - 1);
                                            for (let i = 0; i < order - 1; i++) {
                                                this.transforms[i] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, closure[i + 1], center);
                                            }
                                        }
                                        break;
                                    case "octahedral":
                                        let orientation = null;
                                        if (!correct)
                                            return "no unique alignment strut selected.";
                                        if (axis == null) {
                                            if (!prepareTool)
                                                return "no aligment strut selected.";
                                        }
                                        else {
                                            const icosa = this.symmetry;
                                            const zone = icosa.getAxis$com_vzome_core_algebra_AlgebraicVector(axis.getOffset());
                                            if (zone == null)
                                                return "selected alignment strut is not an octahedral axis.";
                                            let blueIndex = 0;
                                            switch ((zone.getDirection().getName())) {
                                                case "green":
                                                    blueIndex = icosa.blueTetrahedralFromGreen(zone.getOrientation());
                                                    break;
                                                case "blue":
                                                    blueIndex = zone.getOrientation();
                                                    break;
                                                default:
                                                    return "selected alignment strut is not an octahedral axis.";
                                            }
                                            orientation = this.symmetry.getMatrix(blueIndex);
                                        }
                                        if (prepareTool) {
                                            const inverse = orientation.inverse();
                                            const octa = (this.symmetry != null && this.symmetry instanceof com.vzome.core.math.symmetry.OctahedralSymmetry) ? this.symmetry : new com.vzome.core.math.symmetry.OctahedralSymmetry(this.symmetry.getField());
                                            const order = octa.getChiralOrder();
                                            this.transforms = (s => { let a = []; while (s-- > 0)
                                                a.push(null); return a; })(order - 1);
                                            for (let i = 0; i < order - 1; i++) {
                                                {
                                                    let matrix = octa.getMatrix(i + 1);
                                                    matrix = orientation.times(matrix.times(inverse));
                                                    this.transforms[i] = new com.vzome.core.construction.MatrixTransformation(matrix, center.getLocation());
                                                }
                                                ;
                                            }
                                        }
                                        break;
                                    default:
                                        if (prepareTool)
                                            this.prepareFullSymmetry(center);
                                        break;
                                }
                                break;
                            case "synestructics":
                            case "octahedral":
                                if (prepareTool) {
                                    if (this.getCategory() === ("tetrahedral")) {
                                        const order = closure.length;
                                        this.transforms = (s => { let a = []; while (s-- > 0)
                                            a.push(null); return a; })(order - 1);
                                        for (let i = 0; i < order - 1; i++) {
                                            this.transforms[i] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, closure[i + 1], center);
                                        }
                                    }
                                    else {
                                        this.prepareFullSymmetry(center);
                                    }
                                }
                                else {
                                    if (axis != null)
                                        return "No struts needed for symmetry";
                                }
                                break;
                            default:
                                if (prepareTool)
                                    this.prepareFullSymmetry(center);
                                break;
                        }
                        return null;
                    }
                    /*private*/ prepareFullSymmetry(center) {
                        const order = this.symmetry.getChiralOrder();
                        this.transforms = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(order - 1);
                        for (let i = 0; i < order - 1; i++) {
                            this.transforms[i] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, i + 1, center);
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SymmetryTool";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("symmetry", this.symmetry.getName());
                        super.getXmlAttributes(element);
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        const symmName = element.getAttribute("symmetry");
                        this.symmetry = format.parseSymmetry(symmName);
                        super.setXmlAttributes(element, format);
                    }
                }
                SymmetryTool.ID = "symmetry";
                SymmetryTool.LABEL = "Create a general symmetry tool";
                SymmetryTool.TOOLTIP = "<p>General symmetry tool.<br></p>";
                tools_24.SymmetryTool = SymmetryTool;
                SymmetryTool["__class"] = "com.vzome.core.tools.SymmetryTool";
                SymmetryTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_25) {
                class LinearMapTool extends com.vzome.core.tools.TransformationTool {
                    constructor(name, tools, originalScaling) {
                        super(name, tools);
                        if (this.originalScaling === undefined) {
                            this.originalScaling = false;
                        }
                        this.originalScaling = originalScaling;
                        this.setInputBehaviors(false, true);
                    }
                    checkSelection(prepareTool) {
                        const oldBasis = [null, null, null];
                        const newBasis = [null, null, null];
                        let index = 0;
                        let correct = true;
                        let center = null;
                        for (let index1 = this.mSelection.iterator(); index1.hasNext();) {
                            let man = index1.next();
                            {
                                if (prepareTool)
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (center != null) {
                                        correct = false;
                                        break;
                                    }
                                    center = man.getFirstConstruction();
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (index >= 6) {
                                        correct = false;
                                        break;
                                    }
                                    if ((index / 3 | 0) === 0) {
                                        oldBasis[index % 3] = man.getFirstConstruction();
                                    }
                                    else {
                                        newBasis[index % 3] = man.getFirstConstruction();
                                    }
                                    ++index;
                                }
                            }
                        }
                        correct = correct && ((index === 3) || (index === 6));
                        if (!correct)
                            return "linear map tool requires three adjacent, non-parallel struts (or two sets of three) and a single (optional) center ball";
                        if (prepareTool) {
                            if (center == null)
                                center = this.originPoint;
                            this.transforms = [null];
                            if (index === 6)
                                this.transforms[0] = new com.vzome.core.construction.ChangeOfBasis(oldBasis, newBasis, center);
                            else
                                this.transforms[0] = new com.vzome.core.construction.ChangeOfBasis(oldBasis[0], oldBasis[1], oldBasis[2], center, this.originalScaling);
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "LinearTransformTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return LinearMapTool.CATEGORY;
                    }
                }
                LinearMapTool.CATEGORY = "linear map";
                LinearMapTool.LABEL = "Create a linear map tool";
                LinearMapTool.TOOLTIP = "<p><b>For experts and Linear Algebra students...</b><br><br>Each tool applies a linear transformation to the selected<br>objects, possibly rotating, stretching, and compressing.  To<br>create a tool, select a ball as the center of the mapping,<br>three struts (in order) to define the input basis, and three<br>more struts to define the output basis.<br><br>You can omit the input basis if it would consist of three<br>identical blue struts at right angles; the three struts you<br>select will be interpreted as the output basis.<br><br>By default, the input selection will be removed, and replaced<br>with the transformed equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                tools_25.LinearMapTool = LinearMapTool;
                LinearMapTool["__class"] = "com.vzome.core.tools.LinearMapTool";
                LinearMapTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_26) {
                class ProjectionTool extends com.vzome.core.tools.TransformationTool {
                    constructor(id, tools) {
                        super(id, tools);
                        this.setInputBehaviors(false, true);
                    }
                    /**
                     *
                     */
                    perform() {
                        let plane = null;
                        let line = null;
                        let point = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    if (plane == null) {
                                        const panel = man;
                                        const polygon = panel.toConstruction();
                                        plane = new com.vzome.core.construction.PlaneExtensionOfPolygon(polygon);
                                    }
                                    else {
                                        throw new com.vzome.core.commands.Command.Failure("Projection tool allows only a single selected panel");
                                    }
                                }
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (line == null) {
                                        const strut = man;
                                        const segment = strut.toConstruction();
                                        line = new com.vzome.core.construction.LineExtensionOfSegment(segment);
                                    }
                                    else {
                                        throw new com.vzome.core.commands.Command.Failure("Projection tool allows only a single selected strut");
                                    }
                                }
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (point == null) {
                                        point = man.getLocation();
                                        continue;
                                    }
                                    else {
                                        throw new com.vzome.core.commands.Command.Failure("Projection tool allows only a single selected ball");
                                    }
                                }
                            }
                        }
                        if (point != null && line != null) {
                            plane = new com.vzome.core.construction.PlaneFromPointAndNormal(point, line.getDirection());
                        }
                        if (plane == null) {
                            throw new com.vzome.core.commands.Command.Failure("Projection tool requires a selected panel or else a selected ball and strut.");
                        }
                        this.transforms = [null];
                        this.transforms[0] = new com.vzome.core.construction.PlaneProjection(plane, line);
                        if (line != null) {
                            const test = this.transforms[0].transform$com_vzome_core_algebra_AlgebraicVector(line.getDirection());
                            if (test == null)
                                throw new com.vzome.core.commands.Command.Failure("Selected strut and plane must not be parallel");
                        }
                        super.perform();
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ProjectionTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return ProjectionTool.ID;
                    }
                }
                ProjectionTool.ID = "projection";
                ProjectionTool.LABEL = "Create a plane projection tool";
                ProjectionTool.TOOLTIP = "<p>Created tools project selected objects to a 2D plane.<br><br>To create a tool, define the projection plane<br> by selecting either a single panel<br> or strut that is normal to the projection plane<br> and a ball on the plane.<br>When the projection plane is defined by selecting a panel,<br>  an optional strut may be selected to define the line of projection.<br>The default line of projection is orthogonal to the projection plane.<br></p>";
                tools_26.ProjectionTool = ProjectionTool;
                ProjectionTool["__class"] = "com.vzome.core.tools.ProjectionTool";
                ProjectionTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_27) {
                class LineReflectionTool extends com.vzome.core.tools.TransformationTool {
                    constructor(id, tools) {
                        super(id, tools);
                        this.setCopyColors(false);
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let axis = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (prepareTool) {
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                }
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (axis != null) {
                                        if (prepareTool) {
                                            break;
                                        }
                                        else {
                                            return "Only one mirror axis strut may be selected";
                                        }
                                    }
                                    axis = man.getFirstConstruction();
                                }
                            }
                        }
                        if (axis == null) {
                            return "line reflection tool requires a single strut";
                        }
                        if (prepareTool) {
                            this.transforms = [null];
                            this.transforms[0] = new com.vzome.core.construction.LineReflection(axis);
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "LineReflectionTool";
                    }
                }
                tools_27.LineReflectionTool = LineReflectionTool;
                LineReflectionTool["__class"] = "com.vzome.core.tools.LineReflectionTool";
                LineReflectionTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_28) {
                class MirrorTool extends com.vzome.core.tools.TransformationTool {
                    constructor(id, tools) {
                        super(id, tools);
                        if (this.symmSys === undefined) {
                            this.symmSys = null;
                        }
                        this.symmSys = tools.getEditorModel()['getSymmetrySystem$']();
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let center = null;
                        let axis = null;
                        let mirrorPanel = null;
                        if (this.getId() === ("mirror.builtin/reflection through XY plane")) {
                            center = this.originPoint;
                            this.addParameter(center);
                            const field = this.originPoint.getField();
                            const zAxis = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).scale(field['createPower$int'](com.vzome.core.math.symmetry.Direction.USER_SCALE));
                            const p2 = new com.vzome.core.construction.FreePoint(zAxis);
                            axis = new com.vzome.core.construction.SegmentJoiningPoints(center, p2);
                            this.addParameter(axis);
                        }
                        else if (this.getId() === ("mirror.builtin/reflection through X=Y green plane")) {
                            center = this.originPoint;
                            this.addParameter(center);
                            const field = this.originPoint.getField();
                            const greenAxis = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X).plus(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y)).scale(field['createPower$int'](com.vzome.core.math.symmetry.Direction.USER_SCALE));
                            const p2 = new com.vzome.core.construction.FreePoint(greenAxis);
                            axis = new com.vzome.core.construction.SegmentJoiningPoints(center, p2);
                            this.addParameter(axis);
                        }
                        else if (this.getId() === ("mirror.builtin/reflection through red plane")) {
                            center = this.originPoint;
                            this.addParameter(center);
                            const redAxis = this.symmSys.getSymmetry().getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.RED).getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0).normal();
                            const p2 = new com.vzome.core.construction.FreePoint(redAxis);
                            axis = new com.vzome.core.construction.SegmentJoiningPoints(center, p2);
                            this.addParameter(axis);
                        }
                        else if (this.isAutomatic()) {
                            center = this.originPoint;
                            const field = this.originPoint.getField();
                            const xAxis = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                            const p2 = new com.vzome.core.construction.FreePoint(xAxis);
                            axis = new com.vzome.core.construction.SegmentJoiningPoints(center, p2);
                        }
                        else
                            for (let index = this.mSelection.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    if (prepareTool)
                                        this.unselect$com_vzome_core_model_Manifestation(man);
                                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        if (center != null) {
                                            if (prepareTool)
                                                break;
                                            else
                                                return "Only one center ball may be selected";
                                        }
                                        center = man.getFirstConstruction();
                                    }
                                    else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                        if (axis != null) {
                                            if (prepareTool)
                                                break;
                                            else
                                                return "Only one mirror axis strut may be selected";
                                        }
                                        axis = man.getFirstConstruction();
                                    }
                                    else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                        if (mirrorPanel != null) {
                                            if (prepareTool)
                                                break;
                                            else
                                                return "Only one mirror panel may be selected";
                                        }
                                        mirrorPanel = man.getFirstConstruction();
                                    }
                                }
                            }
                        if (center == null) {
                            if (prepareTool)
                                center = this.originPoint;
                            else if (mirrorPanel == null)
                                return "No symmetry center selected";
                        }
                        let mirrorPlane = null;
                        if (axis != null && center != null && mirrorPanel == null) {
                            if (prepareTool)
                                mirrorPlane = new com.vzome.core.construction.PlaneFromNormalSegment(center, axis);
                        }
                        else if (axis == null && mirrorPanel != null) {
                            if (prepareTool)
                                mirrorPlane = new com.vzome.core.construction.PlaneExtensionOfPolygon(mirrorPanel);
                            else if (center != null)
                                return "mirror tool requires a single panel,\nor a single strut and a single center ball";
                        }
                        else {
                            const msg = "mirror tool requires a single panel,\nor a single strut and a single center ball";
                            if (prepareTool) {
                                throw new java.lang.IllegalStateException("Failed to prepare tool: " + msg);
                            }
                            else {
                                return msg;
                            }
                        }
                        if (prepareTool) {
                            this.transforms = [null];
                            this.transforms[0] = new com.vzome.core.construction.PlaneReflection(mirrorPlane);
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "MirrorTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return MirrorTool.ID;
                    }
                }
                MirrorTool.ID = "mirror";
                MirrorTool.LABEL = "Create a mirror reflection tool";
                MirrorTool.TOOLTIP = "<p>Each tool duplicates the selection by reflecting<br>each object in a mirror plane.  To create a<br>tool, define the mirror plane by selecting a single<br>panel, or by selecting a strut orthogonal to the<br>plane and a ball lying in the plane.<br></p>";
                tools_28.MirrorTool = MirrorTool;
                MirrorTool["__class"] = "com.vzome.core.tools.MirrorTool";
                MirrorTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_29) {
                class TranslationTool extends com.vzome.core.tools.TransformationTool {
                    constructor(id, tools) {
                        super(id, tools);
                        this.setInputBehaviors(false, true);
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let p1 = null;
                        let p2 = null;
                        let correct = true;
                        if (!this.isAutomatic())
                            for (let index = this.mSelection.iterator(); index.hasNext();) {
                                let man = index.next();
                                {
                                    if (prepareTool)
                                        this.unselect$com_vzome_core_model_Manifestation(man);
                                    if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        if (p2 != null) {
                                            correct = false;
                                            break;
                                        }
                                        if (p1 == null)
                                            p1 = man.getFirstConstruction();
                                        else
                                            p2 = man.getFirstConstruction();
                                    }
                                    else if (!prepareTool) {
                                        return "Only balls can be selected for this tool.";
                                    }
                                }
                            }
                        if (p1 == null) {
                            if (this.isAutomatic() || this.isPredefined()) {
                                p1 = this.originPoint;
                                this.addParameter(p1);
                                const field = this.originPoint.getField();
                                let xAxis = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                                let scale = field['createPower$int'](3);
                                scale = scale['times$com_vzome_core_algebra_AlgebraicNumber'](field['createRational$long'](2));
                                xAxis = xAxis.scale(scale);
                                p2 = new com.vzome.core.construction.FreePoint(xAxis);
                                this.addParameter(p2);
                            }
                            else {
                                correct = false;
                            }
                        }
                        else if (p2 == null)
                            if (prepareTool) {
                                p2 = p1;
                                p1 = this.originPoint;
                            }
                            else
                                correct = false;
                        if (!correct)
                            return "translation tool requires start and end points, or just an end point";
                        if (prepareTool) {
                            this.transforms = [null];
                            this.transforms[0] = new com.vzome.core.construction.PointToPointTranslation(p1, p2);
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "TranslationTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return TranslationTool.ID;
                    }
                }
                TranslationTool.ID = "translation";
                TranslationTool.LABEL = "Create a translation tool";
                TranslationTool.TOOLTIP = "<p>Each tool moves the selected objects to a new location.<br>To create a tool, select two balls that are separated by<br>your desired translation offset.  Order of selection<br>matters: the first ball selected is the \"from\" location,<br>and the second is the \"to\" location.<br><br>By default, the input selection will be moved to the new<br>location.  If you want to copy rather than move, you can<br>right-click after creating the tool, to configure it.<br></p>";
                tools_29.TranslationTool = TranslationTool;
                TranslationTool["__class"] = "com.vzome.core.tools.TranslationTool";
                TranslationTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_30) {
                class PerspectiveProjectionTool extends com.vzome.core.tools.TransformationTool {
                    constructor(id, tools) {
                        super(id, tools);
                        this.setInputBehaviors(false, true);
                    }
                    /**
                     *
                     */
                    perform() {
                        let plane = null;
                        let point = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    if (plane == null) {
                                        const panel = man;
                                        const polygon = panel.toConstruction();
                                        plane = new com.vzome.core.construction.PlaneExtensionOfPolygon(polygon);
                                    }
                                    else {
                                        throw new com.vzome.core.commands.Command.Failure("Projection tool allows only a single selected panel");
                                    }
                                }
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (point == null) {
                                        const ball = man;
                                        point = ball.toConstruction();
                                        continue;
                                    }
                                    else {
                                        throw new com.vzome.core.commands.Command.Failure("Projection tool allows only a single selected ball");
                                    }
                                }
                            }
                        }
                        if (plane == null || point == null) {
                            throw new com.vzome.core.commands.Command.Failure("Projection tool requires a selected panel and a selected ball.");
                        }
                        this.transforms = [null];
                        this.transforms[0] = new com.vzome.core.construction.PerspectiveProjection(plane, point);
                        super.perform();
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "PerspectiveProjectionTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return PerspectiveProjectionTool.ID;
                    }
                }
                PerspectiveProjectionTool.ID = "perspective";
                PerspectiveProjectionTool.LABEL = "Create a perspective projection tool";
                PerspectiveProjectionTool.TOOLTIP = "<p>Created tools project selected objects to a 2D plane.<br><br>To create a tool, define the projection<br> by selecting a single panel<br> and a ball not in the plane of the panel.</p>";
                tools_30.PerspectiveProjectionTool = PerspectiveProjectionTool;
                PerspectiveProjectionTool["__class"] = "com.vzome.core.tools.PerspectiveProjectionTool";
                PerspectiveProjectionTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_31) {
                class RotationTool extends com.vzome.core.tools.SymmetryTool {
                    constructor(id, symmetry, tools, full) {
                        if (((typeof id === 'string') || id === null) && ((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null) && ((tools != null && tools instanceof com.vzome.core.editor.ToolsModel) || tools === null) && ((typeof full === 'boolean') || full === null)) {
                            let __args = arguments;
                            super(id, symmetry, tools);
                            if (this.fullRotation === undefined) {
                                this.fullRotation = false;
                            }
                            if (this.corrected === undefined) {
                                this.corrected = false;
                            }
                            this.fullRotation = full;
                            this.corrected = true;
                            if (full)
                                this.setInputBehaviors(true, false);
                            else
                                this.setInputBehaviors(false, true);
                        }
                        else if (((typeof id === 'string') || id === null) && ((symmetry != null && (symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null) && ((tools != null && tools instanceof com.vzome.core.editor.ToolsModel) || tools === null) && full === undefined) {
                            let __args = arguments;
                            let editor = __args[2];
                            {
                                let __args = arguments;
                                let tools = editor;
                                let full = false;
                                super(id, symmetry, tools);
                                if (this.fullRotation === undefined) {
                                    this.fullRotation = false;
                                }
                                if (this.corrected === undefined) {
                                    this.corrected = false;
                                }
                                this.fullRotation = full;
                                this.corrected = true;
                                if (full)
                                    this.setInputBehaviors(true, false);
                                else
                                    this.setInputBehaviors(false, true);
                            }
                            (() => {
                                this.corrected = false;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        if (this.fullRotation)
                            return "axial symmetry";
                        else
                            return com.vzome.core.tools.RotationToolFactory.ID;
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let center = null;
                        let axisStrut = null;
                        let correct = true;
                        let rotationZone = null;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (prepareTool)
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (center != null) {
                                        correct = false;
                                        break;
                                    }
                                    center = man.getFirstConstruction();
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (axisStrut != null) {
                                        correct = false;
                                        break;
                                    }
                                    axisStrut = man.getFirstConstruction();
                                    let vector = axisStrut.getOffset();
                                    vector = axisStrut.getField().projectTo3d(vector, true);
                                    rotationZone = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
                                }
                            }
                        }
                        if (axisStrut == null) {
                            rotationZone = this.symmetry.getPreferredAxis();
                            if (rotationZone != null) {
                                const field = this.symmetry.getField();
                                center = this.originPoint;
                                this.addParameter(center);
                                axisStrut = new com.vzome.core.construction.AnchoredSegment(rotationZone, field.one(), center);
                                this.addParameter(axisStrut);
                            }
                            else if (this.isPredefined()) {
                                center = this.originPoint;
                                this.addParameter(center);
                                const redOrbit = this.symmetry.getSpecialOrbit(com.vzome.core.math.symmetry.SpecialOrbit.RED);
                                rotationZone = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1);
                                const field = this.symmetry.getField();
                                const redScale = redOrbit.getUnitLength()['times$com_vzome_core_algebra_AlgebraicNumber'](field['createPower$int'](com.vzome.core.math.symmetry.Direction.USER_SCALE));
                                axisStrut = new com.vzome.core.construction.AnchoredSegment(rotationZone, redScale, center);
                                this.addParameter(axisStrut);
                            }
                            else if (this.isAutomatic()) {
                                center = this.originPoint;
                                this.addParameter(center);
                                const field = this.symmetry.getField();
                                const zAxis = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                                const len = field['createPower$int'](2);
                                rotationZone = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](zAxis);
                                axisStrut = new com.vzome.core.construction.AnchoredSegment(rotationZone, len, center);
                                this.addParameter(axisStrut);
                            }
                            else
                                correct = false;
                        }
                        else if (center == null)
                            center = new com.vzome.core.construction.SegmentEndPoint(axisStrut);
                        if (!correct)
                            return "rotation tool requires a single axis strut,\nand optionally a separate center point";
                        if (rotationZone == null)
                            return "selected strut is not an axis of rotation";
                        const perm = rotationZone.getRotationPermutation();
                        if (perm == null)
                            return "selected strut is not an axis of rotation";
                        let rotation = this.corrected ? perm.mapIndex(0) : rotationZone.getRotation();
                        if (prepareTool) {
                            if (this.fullRotation) {
                                const order = perm.getOrder();
                                this.transforms = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(order - 1);
                                for (let i = 0; i < this.transforms.length; i++) {
                                    {
                                        this.transforms[i] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, rotation, center);
                                        rotation = perm.mapIndex(rotation);
                                    }
                                    ;
                                }
                            }
                            else {
                                this.transforms = [null];
                                this.transforms[0] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, rotation, center);
                            }
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "RotationTool";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.fullRotation)
                            element.setAttribute("full", "true");
                        if (this.corrected)
                            element.setAttribute("corrected", "true");
                        super.getXmlAttributes(element);
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        let value = element.getAttribute("full");
                        this.fullRotation = (value != null) && ("true" === value);
                        value = element.getAttribute("corrected");
                        this.corrected = (value != null) && ("true" === value);
                        super.setXmlAttributes(element, format);
                    }
                }
                tools_31.RotationTool = RotationTool;
                RotationTool["__class"] = "com.vzome.core.tools.RotationTool";
                RotationTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_32) {
                class ScalingTool extends com.vzome.core.tools.SymmetryTool {
                    constructor(id, symmetry, tools) {
                        super(id, symmetry, tools);
                        if (this.scaleFactor === undefined) {
                            this.scaleFactor = null;
                        }
                        this.scaleFactor = null;
                        this.setInputBehaviors(false, true);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return ScalingTool.ID;
                    }
                    setScaleFactor(scaleFactor) {
                        this.scaleFactor = scaleFactor;
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        if (this.scaleFactor != null) {
                            const field = this.scaleFactor.getField();
                            this.transforms = [null];
                            const column1 = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X).scale(this.scaleFactor);
                            const column2 = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y).scale(this.scaleFactor);
                            const column3 = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).scale(this.scaleFactor);
                            const p1 = new com.vzome.core.construction.FreePoint(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X).scale(field['createPower$int'](4)));
                            const p2 = new com.vzome.core.construction.FreePoint(column2.scale(field['createPower$int'](4)));
                            this.addParameter(this.originPoint);
                            this.addParameter(new com.vzome.core.construction.SegmentJoiningPoints(this.originPoint, p1));
                            this.addParameter(new com.vzome.core.construction.SegmentJoiningPoints(this.originPoint, p2));
                            const transform = new com.vzome.core.algebra.AlgebraicMatrix(column1, column2, column3);
                            this.transforms[0] = new com.vzome.core.construction.MatrixTransformation(transform, this.originPoint.getLocation());
                            return null;
                        }
                        let s1 = null;
                        let s2 = null;
                        let center = null;
                        let correct = true;
                        let hasPanels = false;
                        for (let index = this.mSelection.iterator(); index.hasNext();) {
                            let man = index.next();
                            {
                                if (prepareTool)
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (center != null) {
                                        correct = false;
                                        break;
                                    }
                                    center = man.getFirstConstruction();
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (s2 != null) {
                                        correct = false;
                                        break;
                                    }
                                    if (s1 == null)
                                        s1 = man.getFirstConstruction();
                                    else
                                        s2 = man.getFirstConstruction();
                                }
                                else if (man != null && (man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))
                                    hasPanels = true;
                            }
                        }
                        if (center == null) {
                            if (prepareTool)
                                center = this.originPoint;
                            else
                                return "No symmetry center selected";
                        }
                        correct = correct && s2 != null;
                        if (!prepareTool && hasPanels)
                            correct = false;
                        if (!correct)
                            return "scaling tool requires before and after struts, and a single center";
                        const zone1 = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](s1.getOffset());
                        const zone2 = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](s2.getOffset());
                        if (zone1 == null || zone2 == null)
                            return "struts cannot be automatic";
                        const orbit = zone1.getDirection();
                        if (orbit !== zone2.getDirection())
                            return "before and after struts must be from the same orbit";
                        if (prepareTool) {
                            this.transforms = [null];
                            this.transforms[0] = new com.vzome.core.construction.Scaling(s1, s2, center, this.symmetry);
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ScalingTool";
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        const symmName = element.getAttribute("symmetry");
                        if (symmName == null || /* isEmpty */ (symmName.length === 0)) {
                            element.setAttribute("symmetry", "icosahedral");
                            com.vzome.core.editor.api.SideEffects.logBugAccommodation("scaling tool serialized with no symmetry; assuming icosahedral");
                        }
                        super.setXmlAttributes(element, format);
                    }
                }
                ScalingTool.ID = "scaling";
                ScalingTool.LABEL = "Create a scaling tool";
                ScalingTool.TOOLTIP = "<p>Each tool enlarges or shrinks the selected objects,<br>relative to a central point.  To create a tool,<br>select a ball representing the central point, and<br>two struts from the same orbit (color) with different<br>sizes.<br><br>The selection order matters.  First select a strut<br>that you want to enlarge or shrink, then select a<br>strut that has the desired target size.<br></p>";
                tools_32.ScalingTool = ScalingTool;
                ScalingTool["__class"] = "com.vzome.core.tools.ScalingTool";
                ScalingTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
com.vzome.core.editor.ApplyTool.logger_$LI$();
com.vzome.core.editor.CommandEdit.loadAndPerformLgger_$LI$();
com.vzome.core.editor.CommandEdit.logger_$LI$();
com.vzome.core.commands.CommandTetrahedralSymmetry.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$();
com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$();
com.vzome.fields.sqrtphi.SqrtPhiField.SQRT_PHI_VALUE_$LI$();
com.vzome.fields.sqrtphi.SqrtPhiField.PHI_VALUE_$LI$();
com.vzome.core.editor.api.ChangeSelection.logger_$LI$();
com.vzome.core.commands.CommandCentroid.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandCentroid.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandPolygon.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandPolygon.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandTauDivision.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandTauDivision.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandExecuteZomicScript.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandExecuteZomicScript.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandBuildAnchoredSegment.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandTransform.GROUP_ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandTransform.AXIS_ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandTransform.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandTransform.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandJoinPoints.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandJoinPoints.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandMidpoint.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandMidpoint.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandObliquePentagon.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandObliquePentagon.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandLinePlaneIntersect.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandLinePlaneIntersect.PARAM_SIGNATURE_$LI$();
com.vzome.core.construction.SegmentRotated4D.logger_$LI$();
com.vzome.core.commands.CommandImportVEFData.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandImportVEFData.PARAM_SIGNATURE_$LI$();
com.vzome.core.exporters.POVRayExporter.FORMAT_$LI$();
com.vzome.core.exporters.PlyExporter.FORMAT_$LI$();
com.vzome.core.exporters.PlyExporter.__static_initialize();
com.vzome.desktop.controller.PreviewStrut.logger_$LI$();
com.vzome.desktop.controller.LengthController.SCALE_OFFSET_$LI$();
com.vzome.desktop.controller.NumberController.MATH_OPS_$LI$();
com.vzome.desktop.controller.NumberController.OPTIONAL_NAMED_VALUES_$LI$();
com.vzome.core.algebra.SnubDodecField.IRRATIONAL_LABELS_$LI$();
com.vzome.core.algebra.SnubDodecField.PHI_VALUE_$LI$();
com.vzome.core.exporters.MathTableExporter.OPTIONAL_NAMED_VALUES_$LI$();
com.vzome.core.exporters.MathTableExporter.Y_$LI$();
com.vzome.core.exporters.MathTableExporter.X_$LI$();
com.vzome.core.editor.api.SideEffects.BUG_ACCOMMODATION_LOGGER_$LI$();
com.vzome.core.editor.EditHistory.breakpointLogger_$LI$();
com.vzome.core.editor.EditHistory.logger_$LI$();
com.vzome.core.commands.CommandLoad.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandLoad.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandSetColor.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandHide.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandHide.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandFreePoint.PARAMS_$LI$();
com.vzome.core.commands.XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger_$LI$();
com.vzome.core.commands.XmlSymmetryFormat.__static_initialize();
com.vzome.core.construction.VefToModel.logger_$LI$();
com.vzome.core.viewing.ExportedVEFShapes.LOGGER_$LI$();
com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry.PRINCIPAL_REFLECTION_$LI$();
com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry.TWOFOLD_ROTATION_$LI$();
com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry.FIVEFOLD_ROTATION_$LI$();
com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry.NEXT_TWOFOLD_AXIS_$LI$();
com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry.TWOFOLD_AXIS_$LI$();
com.vzome.fields.sqrtphi.PentagonalAntiprismSymmetry.FIVEFOLD_AXIS_$LI$();
com.vzome.core.exporters.StlExporter.FORMAT_$LI$();
com.vzome.core.exporters.PythonBuild123dExporter.FORMAT_$LI$();
com.vzome.core.exporters.PythonBuild123dExporter.__static_initialize();
com.vzome.core.exporters.OpenScadMeshExporter.FORMAT_$LI$();
com.vzome.core.exporters.OpenScadMeshExporter.__static_initialize();
com.vzome.core.exporters.OffExporter.FORMAT_$LI$();
com.vzome.core.exporters.OffExporter.__static_initialize();
com.vzome.core.math.RealVector.DIRECTION_0_$LI$();
com.vzome.core.math.RealVector.FORMAT_$LI$();
com.vzome.core.math.RealVector.ORIGIN_$LI$();
com.vzome.core.math.RealVector.__static_initialize();
java.beans.PropertyChangeSupport.PropertyChangeListenerMap.EMPTY_$LI$();
com.vzome.desktop.controller.ZoneVectorBall.logger_$LI$();
com.vzome.desktop.controller.DefaultController.logger_$LI$();
com.vzome.xml.ResourceLoader.logger_$LI$();
com.vzome.xml.ResourceLoader.RESOURCE_LOADER_$LI$();
com.vzome.core.editor.SymmetrySystem.logger_$LI$();
com.vzome.core.editor.SelectionSummary.LOGGER_$LI$();
com.vzome.core.editor.SelectionImpl.logger_$LI$();
com.vzome.core.edits.ManifestationColorMappers.colorMappers_$LI$();
com.vzome.core.edits.ManifestationColorMappers.__static_initialize();
com.vzome.core.commands.Command.Failure.logger_$LI$();
com.vzome.core.commands.XmlSaveFormat.NOT_AN_ATTRIBUTE_$LI$();
com.vzome.core.commands.XmlSaveFormat.logger_$LI$();
com.vzome.core.commands.XmlSaveFormat.FORMATS_$LI$();
com.vzome.core.construction.Color.GREY_TRANSPARENT_$LI$();
com.vzome.core.construction.Color.WHITE_$LI$();
com.vzome.core.construction.Color.BLACK_$LI$();
com.vzome.core.model.RealizedModelImpl.logger_$LI$();
com.vzome.core.math.symmetry.B4Group.B4_PERMS_$LI$();
com.vzome.core.math.symmetry.Direction.logger_$LI$();
com.vzome.core.math.symmetry.DirectionNaming.SIGN_$LI$();
com.vzome.core.math.symmetry.D4Group.D4_PERMS_$LI$();
com.vzome.core.math.symmetry.A4Group.S5_PERMS_$LI$();
com.vzome.core.math.Polyhedron.logger_$LI$();
com.vzome.core.viewing.ExportedVEFStrutGeometry.LOGGER_$LI$();
com.vzome.core.render.RenderedManifestation.logger_$LI$();
com.vzome.core.render.Colors.NO_VECTOR_$LI$();
com.vzome.core.render.Colors.PLANE_$LI$();
com.vzome.core.render.Colors.DIRECTION_$LI$();
com.vzome.core.render.Colors.CONNECTOR_$LI$();
com.vzome.core.render.Colors.HIGHLIGHT_MAC_$LI$();
com.vzome.core.render.Colors.HIGHLIGHT_$LI$();
com.vzome.core.render.Colors.PANEL_$LI$();
com.vzome.core.render.Colors.BACKGROUND_$LI$();
java.awt.Color.BLACK_$LI$();
java.awt.Color.WHITE_$LI$();
