/* Generated from Java with JSweet 2.3.7 - http://www.jsweet.org */
var com;
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                class AbstractSymmetryPerspective {
                    constructor(symmetry) {
                        if (this.symmetry === undefined)
                            this.symmetry = null;
                        this.geometries = (new java.util.ArrayList());
                        this.defaultShapes = null;
                        this.symmetry = symmetry;
                        this.symmetry.computeOrbitDots();
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetry() {
                        return this.symmetry;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return this.getSymmetry().getName();
                    }
                    addShapes(shapes) {
                        let old = this.getGeometry(shapes.getName());
                        if (old != null) {
                            this.geometries.remove(old);
                        }
                        this.geometries.add(shapes);
                    }
                    clearShapes() {
                        this.geometries.clear();
                        this.defaultShapes = null;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getGeometries() {
                        return this.geometries;
                    }
                    /*private*/ getGeometry(name) {
                        for (let index121 = this.geometries.iterator(); index121.hasNext();) {
                            let shapes = index121.next();
                            {
                                if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(shapes.getName(), name)) {
                                    return shapes;
                                }
                            }
                        }
                        return null;
                    }
                    setDefaultGeometry(shapes) {
                        this.defaultShapes = shapes;
                        this.addShapes(shapes);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getDefaultGeometry() {
                        return this.defaultShapes;
                    }
                    /**
                     *
                     * @param {string} action
                     * @return {*}
                     */
                    getLegacyCommand(action) {
                        switch ((action)) {
                            case "octasymm":
                                {
                                    let octaSymm = this.getSymmetry();
                                    if (!(octaSymm != null && octaSymm instanceof com.vzome.core.math.symmetry.OctahedralSymmetry)) {
                                        octaSymm = new com.vzome.core.math.symmetry.OctahedralSymmetry(octaSymm.getField());
                                    }
                                    return new com.vzome.core.commands.CommandSymmetry(octaSymm);
                                }
                                ;
                            default:
                                return null;
                        }
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} orbit
                     * @return {boolean}
                     */
                    orbitIsStandard(orbit) {
                        return orbit.isStandard();
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} orbit
                     * @return {boolean}
                     */
                    orbitIsBuildDefault(orbit) {
                        let zone0 = orbit.getAxis$int$int(0, 0);
                        return zone0.getRotationPermutation() != null;
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} orbit
                     * @return {*}
                     */
                    getOrbitUnitLength(orbit) {
                        return orbit.getUnitLength();
                    }
                }
                kinds.AbstractSymmetryPerspective = AbstractSymmetryPerspective;
                AbstractSymmetryPerspective["__class"] = "com.vzome.core.kinds.AbstractSymmetryPerspective";
                AbstractSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.FieldApplication.SymmetryPerspective"];
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                class DefaultFieldApplication {
                    constructor(field) {
                        if (this.field === undefined)
                            this.field = null;
                        if (this.octahedralPerspective === undefined)
                            this.octahedralPerspective = null;
                        this.groups4d = (new java.util.HashMap());
                        this.pointsymm = new com.vzome.core.commands.CommandCentralSymmetry();
                        this.mirrorsymm = new com.vzome.core.commands.CommandMirrorSymmetry();
                        this.translate = new com.vzome.core.commands.CommandTranslate();
                        this.centroid = new com.vzome.core.commands.CommandCentroid();
                        this.hideball = new com.vzome.core.commands.CommandHide();
                        this.hide = new com.vzome.core.commands.CommandHide();
                        this.panel = new com.vzome.core.commands.CommandPolygon();
                        this.midpoint = new com.vzome.core.commands.CommandMidpoint();
                        this.field = field;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return this.field.getName();
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getField() {
                        return this.field;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getDefaultSymmetryPerspective() {
                        return this.getSymmetryPerspective("octahedral");
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetryPerspectives() {
                        return java.util.Arrays.asList(this.getDefaultSymmetryPerspective());
                    }
                    /**
                     *
                     * @param {string} symmName
                     * @return {*}
                     */
                    getSymmetryPerspective(symmName) {
                        switch ((symmName)) {
                            case "octahedral":
                                if (this.octahedralPerspective == null) {
                                    this.octahedralPerspective = new com.vzome.core.kinds.OctahedralSymmetryPerspective(this.field);
                                }
                                return this.octahedralPerspective;
                            default:
                                return null;
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {com.vzome.core.math.symmetry.QuaternionicSymmetry}
                     */
                    getQuaternionSymmetry(name) {
                        return null;
                    }
                    /**
                     *
                     * @param {*} toolFactories
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     */
                    registerToolFactories(toolFactories, tools) {
                        toolFactories.put("SymmetryTool", new com.vzome.core.tools.OctahedralToolFactory(tools, null));
                        toolFactories.put("RotationTool", new com.vzome.core.tools.RotationTool.__com_vzome_core_tools_RotationTool_Factory(tools, null));
                        toolFactories.put("ScalingTool", new com.vzome.core.tools.ScalingTool.__com_vzome_core_tools_ScalingTool_Factory(tools, null));
                        toolFactories.put("InversionTool", new com.vzome.core.tools.InversionTool.Factory(tools));
                        toolFactories.put("MirrorTool", new com.vzome.core.tools.MirrorTool.Factory(tools));
                        toolFactories.put("TranslationTool", new com.vzome.core.tools.TranslationTool.Factory(tools));
                        toolFactories.put("ProjectionTool", new com.vzome.core.tools.ProjectionTool.Factory(tools));
                        toolFactories.put("BookmarkTool", new com.vzome.core.tools.BookmarkTool.Factory(tools));
                        toolFactories.put("LinearTransformTool", new com.vzome.core.tools.LinearMapTool.Factory(tools, null, false));
                        toolFactories.put("LinearMapTool", new com.vzome.core.tools.LinearMapTool.Factory(tools, null, true));
                        toolFactories.put("ModuleTool", new com.vzome.core.tools.ModuleTool.Factory(tools));
                        toolFactories.put("PlaneSelectionTool", new com.vzome.core.tools.PlaneSelectionTool.Factory(tools));
                    }
                    /**
                     *
                     * @param {string} groupName
                     * @param {number} index
                     * @param {number} edgesToRender
                     * @param {Array} edgeScales
                     * @param {*} listener
                     */
                    constructPolytope(groupName, index, edgesToRender, edgeScales, listener) {
                        let group = this.groups4d.get(groupName);
                        if (group == null) {
                            switch ((groupName)) {
                                case "A4":
                                    group = new com.vzome.core.math.symmetry.A4Group(this.field);
                                    break;
                                case "D4":
                                    group = new com.vzome.core.math.symmetry.D4Group(this.field);
                                    break;
                                case "F4":
                                    group = new com.vzome.core.math.symmetry.F4Group(this.field);
                                    break;
                                default:
                                    group = new com.vzome.core.math.symmetry.B4Group(this.field);
                                    break;
                            }
                            this.groups4d.put(groupName, group);
                        }
                        com.vzome.core.math.symmetry.WythoffConstruction.constructPolytope(group, index, edgesToRender, edgeScales, group, listener);
                    }
                    /**
                     *
                     * @param {string} action
                     * @return {*}
                     */
                    getLegacyCommand(action) {
                        switch ((action)) {
                            case "pointsymm":
                                return this.pointsymm;
                            case "mirrorsymm":
                                return this.mirrorsymm;
                            case "translate":
                                return this.translate;
                            case "centroid":
                                return this.centroid;
                            case "hideball":
                                return this.hideball;
                            case "hide":
                                return this.hide;
                            case "panel":
                                return this.panel;
                            case "midpoint":
                                return this.midpoint;
                            case "octasymm":
                                return this.getDefaultSymmetryPerspective().getLegacyCommand(action);
                            default:
                                return null;
                        }
                    }
                }
                kinds.DefaultFieldApplication = DefaultFieldApplication;
                DefaultFieldApplication["__class"] = "com.vzome.core.kinds.DefaultFieldApplication";
                DefaultFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D", "com.vzome.core.editor.FieldApplication"];
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var render;
            (function (render) {
                class Colors {
                    constructor(props) {
                        this.mColors = (new java.util.TreeMap());
                        this.mListeners = (new java.util.ArrayList());
                        if (this.properties === undefined)
                            this.properties = null;
                        this.mNextNewColor = 3221;
                        this.STEP = 73;
                        this.properties = props;
                    }
                    static BACKGROUND_$LI$() { if (Colors.BACKGROUND == null)
                        Colors.BACKGROUND = Colors.PREFIX + "background"; return Colors.BACKGROUND; }
                    ;
                    static PANEL_$LI$() { if (Colors.PANEL == null)
                        Colors.PANEL = Colors.PREFIX + "panel"; return Colors.PANEL; }
                    ;
                    static HIGHLIGHT_$LI$() { if (Colors.HIGHLIGHT == null)
                        Colors.HIGHLIGHT = Colors.PREFIX + "highlight"; return Colors.HIGHLIGHT; }
                    ;
                    static HIGHLIGHT_MAC_$LI$() { if (Colors.HIGHLIGHT_MAC == null)
                        Colors.HIGHLIGHT_MAC = Colors.HIGHLIGHT_$LI$() + ".mac"; return Colors.HIGHLIGHT_MAC; }
                    ;
                    static CONNECTOR_$LI$() { if (Colors.CONNECTOR == null)
                        Colors.CONNECTOR = Colors.PREFIX + "connector"; return Colors.CONNECTOR; }
                    ;
                    static DIRECTION_$LI$() { if (Colors.DIRECTION == null)
                        Colors.DIRECTION = Colors.PREFIX + "direction."; return Colors.DIRECTION; }
                    ;
                    static PLANE_$LI$() { if (Colors.PLANE == null)
                        Colors.PLANE = Colors.DIRECTION_$LI$() + "plane."; return Colors.PLANE; }
                    ;
                    addColor(name, color) {
                        this.mColors.put(name, color);
                        for (let index122 = this.mListeners.iterator(); index122.hasNext();) {
                            let next = index122.next();
                            {
                                next.colorAdded(name, color);
                            }
                        }
                    }
                    setColor(name, color) {
                        this.mColors.put(name, color);
                        for (let index123 = this.mListeners.iterator(); index123.hasNext();) {
                            let next = index123.next();
                            {
                                next.colorChanged(name, color);
                            }
                        }
                    }
                    addListener(changes) {
                        this.mListeners.add(changes);
                    }
                    removeListener(changes) {
                        this.mListeners.remove(changes);
                    }
                    static NO_VECTOR_$LI$() { if (Colors.NO_VECTOR == null)
                        Colors.NO_VECTOR = [0.0, 0.0, 0.0]; return Colors.NO_VECTOR; }
                    ;
                    getVectorPref(name) {
                        let result = Colors.NO_VECTOR_$LI$();
                        let pref = this.properties.getProperty(name);
                        if (pref == null || /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(pref, ""))
                            return result;
                        result = /* clone */ ((o) => { if (o.clone != undefined) {
                            return o.clone();
                        }
                        else {
                            let clone = Object.create(o);
                            for (let p in o) {
                                if (o.hasOwnProperty(p))
                                    clone[p] = o[p];
                            }
                            return clone;
                        } })(result);
                        let tokens = new java.util.StringTokenizer(pref, ", ");
                        let i = 0;
                        while ((tokens.hasMoreTokens())) {
                            result[i++] = javaemul.internal.FloatHelper.parseFloat(tokens.nextToken());
                        }
                        ;
                        return result;
                    }
                    getColorPref(name) {
                        let percents = this.getVectorPref("color.percent." + name);
                        if (percents !== Colors.NO_VECTOR_$LI$()) {
                            return new com.vzome.core.construction.Color(Math.round(Math.fround(Math.fround(percents[0] * 255) / 100)), Math.round(Math.fround(Math.fround(percents[1] * 255) / 100)), Math.round(Math.fround(Math.fround(percents[2] * 255) / 100)));
                        }
                        let pref = this.properties.getProperty("color." + name);
                        return Colors.parseColor(pref);
                    }
                    static parseColor(colorString) {
                        if (colorString == null || /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(colorString, ""))
                            return com.vzome.core.construction.Color.WHITE_$LI$();
                        let tokens = new java.util.StringTokenizer(colorString, ", ");
                        let rgb = [0, 0, 0];
                        let i = 0;
                        while ((tokens.hasMoreTokens())) {
                            rgb[i++] = javaemul.internal.IntegerHelper.parseInt(tokens.nextToken());
                        }
                        ;
                        return new com.vzome.core.construction.Color(rgb[0], rgb[1], rgb[2]);
                    }
                    static getColorName(color) {
                        return Colors.RGB_ORBIT + " " + color.getRed() + " " + color.getGreen() + " " + color.getBlue();
                    }
                    getColor(name) {
                        let color = this.mColors.get(name);
                        if (color == null) {
                            if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, Colors.DIRECTION_$LI$())) {
                                let prefName = name.substring(Colors.DIRECTION_$LI$().length);
                                color = this.getColorPref(prefName);
                            }
                            else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, Colors.PLANE_$LI$())) {
                                let prefName = name.substring(Colors.PLANE_$LI$().length);
                                color = this.getColorPref(prefName);
                                color = color.getPastel();
                            }
                            else if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, Colors.RGB_ORBIT) || /* startsWith */ ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(name, Colors.RGB_CUSTOM)) {
                                let tokens = new java.util.StringTokenizer(name);
                                tokens.nextToken();
                                let r = javaemul.internal.IntegerHelper.parseInt(tokens.nextToken());
                                let g = javaemul.internal.IntegerHelper.parseInt(tokens.nextToken());
                                let b = javaemul.internal.IntegerHelper.parseInt(tokens.nextToken());
                                color = new com.vzome.core.construction.Color(r, g, b);
                            }
                            else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(name, Colors.CONNECTOR_$LI$()))
                                color = this.getColorPref("white");
                            else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(name, Colors.HIGHLIGHT_$LI$()))
                                color = this.getColorPref("highlight");
                            else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(name, Colors.HIGHLIGHT_MAC_$LI$()))
                                color = this.getColorPref("highlight.mac");
                            else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(name, Colors.PANEL_$LI$()))
                                color = this.getColorPref("panels");
                            else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(name, Colors.BACKGROUND_$LI$()))
                                color = this.getColorPref("background");
                            if (color == null) {
                                this.mNextNewColor = (this.mNextNewColor + this.STEP) % 4096;
                                let i = this.mNextNewColor;
                                let r = 135 + ((i % 16) << 3);
                                i = i >> 4;
                                let g = 135 + ((i % 16) << 3);
                                i = i >> 4;
                                let b = 135 + ((i % 16) << 3);
                                i = i >> 4;
                                color = new com.vzome.core.construction.Color(r, g, b);
                            }
                            this.addColor(name, color);
                        }
                        return color;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    iterator() {
                        return this.mColors.keySet().iterator();
                    }
                    /**
                     * @deprecated Consider using a JDK-5 for-loop if possible. Otherwise use {@link #iterator()} instead.
                     * @return {*}
                     */
                    getColorNames() {
                        return this.iterator();
                    }
                    reset() {
                    }
                }
                Colors.RGB_CUSTOM = "rgb.custom";
                Colors.RGB_ORBIT = "rgb.orbit";
                Colors.PREFIX = "";
                render.Colors = Colors;
                Colors["__class"] = "com.vzome.core.render.Colors";
                Colors["__interfaces"] = ["java.lang.Iterable"];
            })(render = core.render || (core.render = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var render;
            (function (render) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} m
                 * @param {*} orbitSource
                 * @class
                 */
                class RenderedManifestation {
                    constructor(m, orbitSource) {
                        if (this.mManifestation === undefined)
                            this.mManifestation = null;
                        if (this.mShape === undefined)
                            this.mShape = null;
                        this.color = null;
                        if (this.mOrientation === undefined)
                            this.mOrientation = null;
                        this.mGlow = 0.0;
                        this.mTransparency = 0.0;
                        if (this.mGraphicsObject === undefined)
                            this.mGraphicsObject = null;
                        this.mPickable = true;
                        this.isOffset = false;
                        if (this.location === undefined)
                            this.location = null;
                        if (this.fixedLocation === undefined)
                            this.fixedLocation = null;
                        this.strutZone = -1;
                        this.strutLength = null;
                        this.strutOrbit = null;
                        if (this.strutSense === undefined)
                            this.strutSense = 0;
                        this.guid = java.util.UUID.randomUUID();
                        if (this.orbitSource === undefined)
                            this.orbitSource = null;
                        this.mManifestation = m;
                        this.orbitSource = orbitSource;
                        if (m != null)
                            this.location = m.getLocation();
                        this.fixedLocation = this.location;
                        this.mOrientation = null;
                    }
                    static logger_$LI$() { if (RenderedManifestation.logger == null)
                        RenderedManifestation.logger = java.util.logging.Logger.getLogger("com.vzome.core.render.RenderedManifestation"); return RenderedManifestation.logger; }
                    ;
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return this.mManifestation.toString();
                    }
                    getGuid() {
                        return this.guid;
                    }
                    setGraphicsObject(go) {
                        this.mGraphicsObject = go;
                    }
                    getGraphicsObject() {
                        return this.mGraphicsObject;
                    }
                    setGlow(glow) {
                        this.mGlow = glow;
                    }
                    getGlow() {
                        return this.mGlow;
                    }
                    setTransparency(trans) {
                        this.mTransparency = trans;
                    }
                    getTransparency() {
                        return this.mTransparency;
                    }
                    getShapeId() {
                        return this.mShape.getGuid();
                    }
                    getShape() {
                        return this.mShape;
                    }
                    setPickable(value) {
                        this.mPickable = value;
                    }
                    isPickable() {
                        return this.mPickable;
                    }
                    getManifestation() {
                        return this.mManifestation;
                    }
                    getColor() {
                        return this.color;
                    }
                    getColorWeb() {
                        return this.color.toWebString();
                    }
                    setColor(color) {
                        this.color = color;
                    }
                    setOrientation(m) {
                        this.mOrientation = m;
                    }
                    getOrientation() {
                        return this.mOrientation;
                    }
                    getLocation() {
                        return this.getEmbedding().embedInR3(this.location);
                    }
                    getLocationAV() {
                        return this.location;
                    }
                    getEmbedding() {
                        return this.orbitSource.getSymmetry();
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        return /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.guid);
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj) {
                            return true;
                        }
                        if (obj == null) {
                            return false;
                        }
                        if (this.constructor !== obj.constructor) {
                            return false;
                        }
                        let other = obj;
                        if (this.fixedLocation == null) {
                            if (other.fixedLocation != null) {
                                return false;
                            }
                        }
                        else if (!this.fixedLocation.equals(other.fixedLocation)) {
                            return false;
                        }
                        if (this.isOffset !== other.isOffset) {
                            return false;
                        }
                        if (this.mOrientation == null) {
                            if (other.mOrientation != null) {
                                return false;
                            }
                        }
                        else if (!this.mOrientation.equals(other.mOrientation)) {
                            return false;
                        }
                        if (this.mShape == null) {
                            if (other.mShape != null) {
                                return false;
                            }
                        }
                        else if (!this.mShape.equals(other.mShape)) {
                            return false;
                        }
                        if (this.strutSense !== other.strutSense) {
                            return false;
                        }
                        return true;
                    }
                    copy() {
                        let copy = new RenderedManifestation(null, this.orbitSource);
                        copy.location = this.location;
                        copy.fixedLocation = this.fixedLocation;
                        copy.color = this.color;
                        copy.mGlow = this.mGlow;
                        copy.mOrientation = this.mOrientation;
                        copy.mShape = this.mShape;
                        copy.mTransparency = this.mTransparency;
                        copy.strutLength = this.strutLength;
                        copy.strutZone = this.strutZone;
                        return copy;
                    }
                    setStrut(orbit, zone, sense, length) {
                        this.strutOrbit = orbit;
                        this.strutZone = zone;
                        this.strutSense = sense;
                        this.strutLength = length;
                    }
                    getStrutZone() {
                        return this.strutZone;
                    }
                    getStrutSense() {
                        return this.strutSense;
                    }
                    getStrutLength() {
                        return this.strutLength;
                    }
                    getStrutOrbit() {
                        return this.strutOrbit;
                    }
                    offsetLocation() {
                        if (this.mManifestation != null) {
                            let strut = this.mManifestation;
                            this.location = strut.getEnd();
                            this.isOffset = true;
                        }
                    }
                    resetLocation() {
                        if (this.mManifestation != null) {
                            this.location = this.mManifestation.getLocation();
                            this.isOffset = false;
                        }
                    }
                    getSymmetryShapes() {
                        return this.orbitSource.getName() + ":" + this.orbitSource.getShapes().getName();
                    }
                    resetAttributes(oneSidedPanels, colorPanels) {
                        if (this.mManifestation != null && (this.mManifestation["__interfaces"] != null && this.mManifestation["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || this.mManifestation.constructor != null && this.mManifestation.constructor["__interfaces"] != null && this.mManifestation.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                            this.resetPanelAttributes(oneSidedPanels, colorPanels);
                        }
                        else if (this.orbitSource.getShapes() == null) {
                            return;
                        }
                        else if (this.mManifestation != null && (this.mManifestation["__interfaces"] != null && this.mManifestation["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || this.mManifestation.constructor != null && this.mManifestation.constructor["__interfaces"] != null && this.mManifestation.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                            this.resetConnectorAttributes(this.mManifestation);
                        }
                        else if (this.mManifestation != null && (this.mManifestation["__interfaces"] != null && this.mManifestation["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || this.mManifestation.constructor != null && this.mManifestation.constructor["__interfaces"] != null && this.mManifestation.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                            let strut = this.mManifestation;
                            this.resetStrutAttributes(strut);
                        }
                        else
                            throw new java.lang.UnsupportedOperationException("only strut, ball, and panel shapes currently supported");
                    }
                    /*private*/ resetPanelAttributes(oneSidedPanels, colorPanels) {
                        let panel = this.mManifestation;
                        let shape = RenderedManifestation.makePanelPolyhedron(panel, oneSidedPanels);
                        if (shape == null)
                            return;
                        let normal = panel['getNormal$']();
                        if (normal.isOrigin())
                            return;
                        this.mShape = shape;
                        if (!colorPanels)
                            return;
                        this.setOrientation(this.orbitSource.getSymmetry().getField().identityMatrix(3));
                        try {
                            let axis = this.orbitSource.getAxis(normal);
                            if (axis == null) {
                                this.setColor(com.vzome.core.construction.Color.WHITE_$LI$());
                                return;
                            }
                            panel.setZoneVector(axis.normal());
                            let orbit = axis.getDirection();
                            let color = this.mManifestation.getColor();
                            if (color == null) {
                                color = this.orbitSource.getColor(orbit);
                                if (color != null)
                                    color = color.getPastel();
                            }
                            this.setColor(color);
                        }
                        catch (e) {
                            if (RenderedManifestation.logger_$LI$().isLoggable(java.util.logging.Level.WARNING))
                                RenderedManifestation.logger_$LI$().warning("Unable to set color for panel, normal = " + normal.toString());
                        }
                        ;
                    }
                    resetStrutAttributes(strut) {
                        let shapes = this.orbitSource.getShapes();
                        let offset = strut.getOffset();
                        if (offset.isOrigin())
                            return;
                        let axis = this.orbitSource.getAxis(offset);
                        if (axis == null)
                            return;
                        strut.setZoneVector(axis.normal());
                        let orbit = axis.getDirection();
                        let len = axis.getLength(offset);
                        let prototypeLengthShape = shapes.getStrutShape(orbit, len);
                        this.mShape = prototypeLengthShape;
                        let orn = axis.getOrientation();
                        let orientation = shapes.getSymmetry().getMatrix(orn);
                        let reflection = this.orbitSource.getSymmetry().getPrincipalReflection();
                        if (reflection != null) {
                            if (RenderedManifestation.logger_$LI$().isLoggable(java.util.logging.Level.FINE)) {
                                RenderedManifestation.logger_$LI$().fine("rendering " + offset + " as " + axis);
                            }
                            if (axis.getSense() === com.vzome.core.math.symmetry.Axis.MINUS) {
                                if (RenderedManifestation.logger_$LI$().isLoggable(java.util.logging.Level.FINER)) {
                                    RenderedManifestation.logger_$LI$().finer("mirroring orientation " + orn);
                                }
                                this.mShape = prototypeLengthShape.getEvilTwin(reflection);
                            }
                            if (!axis.isOutbound()) {
                                this.offsetLocation();
                            }
                            else
                                this.resetLocation();
                        }
                        else {
                            if (axis.getSense() === com.vzome.core.math.symmetry.Axis.MINUS) {
                                this.offsetLocation();
                            }
                            else
                                this.resetLocation();
                        }
                        this.setStrut(orbit, orn, axis.getSense(), len);
                        this.setOrientation(orientation);
                        let color = this.getManifestation().getColor();
                        if (color == null)
                            color = shapes.getColor(orbit);
                        if (color == null)
                            color = this.orbitSource.getColor(orbit);
                        this.setColor(color);
                    }
                    resetConnectorAttributes(m) {
                        let shapes = this.orbitSource.getShapes();
                        this.mShape = shapes.getConnectorShape();
                        let color = this.getManifestation().getColor();
                        if (color == null)
                            color = shapes.getColor(null);
                        if (color == null)
                            color = this.orbitSource.getColor(null);
                        this.setColor(color);
                        this.setOrientation(this.orbitSource.getSymmetry().getField().identityMatrix(3));
                    }
                    /*private*/ static makePanelPolyhedron(panel, oneSided) {
                        let poly = new com.vzome.core.math.Polyhedron(panel.getZoneVector().getField());
                        poly.setPanel(true);
                        let arity = 0;
                        for (let index124 = panel.iterator(); index124.hasNext();) {
                            let gv = index124.next();
                            {
                                arity++;
                                poly.addVertex(gv);
                            }
                        }
                        if (poly.getVertexList().size() < arity)
                            return null;
                        let front = poly.newFace();
                        let back = poly.newFace();
                        for (let i = 0; i < arity; i++) {
                            {
                                let j = i;
                                front.add(j);
                                back.add(0, j);
                            }
                            ;
                        }
                        poly.addFace(front);
                        if (!oneSided)
                            poly.addFace(back);
                        return poly;
                    }
                    setOrbitSource(orbitSource) {
                        this.orbitSource = orbitSource;
                    }
                    getOrbitSource() {
                        return this.orbitSource;
                    }
                }
                render.RenderedManifestation = RenderedManifestation;
                RenderedManifestation["__class"] = "com.vzome.core.render.RenderedManifestation";
                RenderedManifestation["__interfaces"] = ["com.vzome.core.model.RenderedObject"];
            })(render = core.render || (core.render = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var viewing;
            (function (viewing) {
                class AbstractShapes {
                    constructor(pkgName, name, alias, symm) {
                        this.strutShapesByLengthAndOrbit = (new java.util.HashMap());
                        this.strutGeometriesByOrbit = (new java.util.HashMap());
                        if (this.mPkgName === undefined)
                            this.mPkgName = null;
                        if (this.mName === undefined)
                            this.mName = null;
                        if (this.alias === undefined)
                            this.alias = null;
                        if (this.mSymmetry === undefined)
                            this.mSymmetry = null;
                        if (this.mConnectorGeometry === undefined)
                            this.mConnectorGeometry = null;
                        this.mPkgName = pkgName;
                        this.mName = name;
                        this.alias = alias;
                        this.mConnectorGeometry = null;
                        this.mSymmetry = symm;
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} dir
                     * @return {com.vzome.core.construction.Color}
                     */
                    getColor(dir) {
                        return null;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasColors() {
                        return false;
                    }
                    createStrutGeometry(dir) {
                        return new com.vzome.core.parts.FastDefaultStrutGeometry(dir);
                    }
                    /*private*/ getStrutGeometry(orbit) {
                        let orbitStrutGeometry = this.strutGeometriesByOrbit.get(orbit);
                        if (orbitStrutGeometry == null) {
                            orbitStrutGeometry = this.createStrutGeometry(orbit);
                            this.strutGeometriesByOrbit.put(orbit, orbitStrutGeometry);
                        }
                        return orbitStrutGeometry;
                    }
                    getStrutGeometries() {
                        return (java.util.Arrays.stream(this.mSymmetry.getDirectionNames()).collect(java.util.stream.Collectors.toMap(((x => x)), (name) => this.getStrutGeometry(this.mSymmetry.getDirection(name)))));
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return this.mName;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getAlias() {
                        return this.alias;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getPackage() {
                        return this.mPkgName;
                    }
                    /**
                     *
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    getConnectorShape() {
                        if (this.mConnectorGeometry == null) {
                            this.mConnectorGeometry = this.buildConnectorShape(this.mPkgName);
                            this.mConnectorGeometry.setName("ball");
                        }
                        return this.mConnectorGeometry;
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} orbit
                     * @param {*} length
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    getStrutShape(orbit, length) {
                        let strutShapesByLength = this.strutShapesByLengthAndOrbit.get(orbit);
                        if (strutShapesByLength == null) {
                            strutShapesByLength = (new java.util.HashMap());
                            this.strutShapesByLengthAndOrbit.put(orbit, strutShapesByLength);
                        }
                        let lengthShape = strutShapesByLength.get(length);
                        if (lengthShape == null) {
                            let orbitStrutGeometry = this.getStrutGeometry(orbit);
                            lengthShape = orbitStrutGeometry.getStrutPolyhedron(length);
                            strutShapesByLength.put(length, lengthShape);
                            if (lengthShape != null) {
                                lengthShape.setName(orbit.getName() + strutShapesByLength.size());
                                lengthShape.setOrbit(orbit);
                                lengthShape.setLength(orbit.getLengthInUnits(length));
                            }
                        }
                        return lengthShape;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetry() {
                        return this.mSymmetry;
                    }
                }
                viewing.AbstractShapes = AbstractShapes;
                AbstractShapes["__class"] = "com.vzome.core.viewing.AbstractShapes";
                AbstractShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];
            })(viewing = core.viewing || (core.viewing = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var viewing;
            (function (viewing) {
                class ExportedVEFStrutGeometry {
                    constructor(vertices, faces, prototype, fullScaleVertices, halfScaleVertices, field) {
                        if (((vertices != null && (vertices["__interfaces"] != null && vertices["__interfaces"].indexOf("java.util.List") >= 0 || vertices.constructor != null && vertices.constructor["__interfaces"] != null && vertices.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || vertices === null) && ((faces != null && (faces["__interfaces"] != null && faces["__interfaces"].indexOf("java.util.List") >= 0 || faces.constructor != null && faces.constructor["__interfaces"] != null && faces.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || faces === null) && ((prototype != null && prototype instanceof com.vzome.core.algebra.AlgebraicVector) || prototype === null) && ((fullScaleVertices != null && (fullScaleVertices["__interfaces"] != null && fullScaleVertices["__interfaces"].indexOf("java.util.Set") >= 0 || fullScaleVertices.constructor != null && fullScaleVertices.constructor["__interfaces"] != null && fullScaleVertices.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || fullScaleVertices === null) && ((halfScaleVertices != null && (halfScaleVertices["__interfaces"] != null && halfScaleVertices["__interfaces"].indexOf("java.util.Set") >= 0 || halfScaleVertices.constructor != null && halfScaleVertices.constructor["__interfaces"] != null && halfScaleVertices.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || halfScaleVertices === null) && ((field != null && (field["__interfaces"] != null && field["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null)) {
                            let __args = arguments;
                            if (this.prototypeVertices === undefined)
                                this.prototypeVertices = null;
                            if (this.prototypeFaces === undefined)
                                this.prototypeFaces = null;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.prototypeVector === undefined)
                                this.prototypeVector = null;
                            if (this.fullScaleVertices === undefined)
                                this.fullScaleVertices = null;
                            if (this.halfScaleVertices === undefined)
                                this.halfScaleVertices = null;
                            if (this.prototypeVertices === undefined)
                                this.prototypeVertices = null;
                            if (this.prototypeFaces === undefined)
                                this.prototypeFaces = null;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.prototypeVector === undefined)
                                this.prototypeVector = null;
                            if (this.fullScaleVertices === undefined)
                                this.fullScaleVertices = null;
                            if (this.halfScaleVertices === undefined)
                                this.halfScaleVertices = null;
                            (() => {
                                this.prototypeVertices = vertices;
                                this.prototypeFaces = faces;
                                this.prototypeVector = prototype;
                                this.fullScaleVertices = fullScaleVertices;
                                this.halfScaleVertices = halfScaleVertices;
                                this.field = field;
                            })();
                        }
                        else if (((vertices != null && (vertices["__interfaces"] != null && vertices["__interfaces"].indexOf("java.util.List") >= 0 || vertices.constructor != null && vertices.constructor["__interfaces"] != null && vertices.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || vertices === null) && ((faces != null && (faces["__interfaces"] != null && faces["__interfaces"].indexOf("java.util.List") >= 0 || faces.constructor != null && faces.constructor["__interfaces"] != null && faces.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || faces === null) && ((prototype != null && prototype instanceof com.vzome.core.algebra.AlgebraicVector) || prototype === null) && ((fullScaleVertices != null && (fullScaleVertices["__interfaces"] != null && fullScaleVertices["__interfaces"].indexOf("java.util.Set") >= 0 || fullScaleVertices.constructor != null && fullScaleVertices.constructor["__interfaces"] != null && fullScaleVertices.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || fullScaleVertices === null) && ((halfScaleVertices != null && (halfScaleVertices["__interfaces"] != null && halfScaleVertices["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || halfScaleVertices.constructor != null && halfScaleVertices.constructor["__interfaces"] != null && halfScaleVertices.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || halfScaleVertices === null) && field === undefined) {
                            let __args = arguments;
                            let field = __args[4];
                            {
                                let __args = arguments;
                                let halfScaleVertices = null;
                                if (this.prototypeVertices === undefined)
                                    this.prototypeVertices = null;
                                if (this.prototypeFaces === undefined)
                                    this.prototypeFaces = null;
                                if (this.field === undefined)
                                    this.field = null;
                                if (this.prototypeVector === undefined)
                                    this.prototypeVector = null;
                                if (this.fullScaleVertices === undefined)
                                    this.fullScaleVertices = null;
                                if (this.halfScaleVertices === undefined)
                                    this.halfScaleVertices = null;
                                if (this.prototypeVertices === undefined)
                                    this.prototypeVertices = null;
                                if (this.prototypeFaces === undefined)
                                    this.prototypeFaces = null;
                                if (this.field === undefined)
                                    this.field = null;
                                if (this.prototypeVector === undefined)
                                    this.prototypeVector = null;
                                if (this.fullScaleVertices === undefined)
                                    this.fullScaleVertices = null;
                                if (this.halfScaleVertices === undefined)
                                    this.halfScaleVertices = null;
                                (() => {
                                    this.prototypeVertices = vertices;
                                    this.prototypeFaces = faces;
                                    this.prototypeVector = prototype;
                                    this.fullScaleVertices = fullScaleVertices;
                                    this.halfScaleVertices = halfScaleVertices;
                                    this.field = field;
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static LOGGER_$LI$() { if (ExportedVEFStrutGeometry.LOGGER == null)
                        ExportedVEFStrutGeometry.LOGGER = java.util.logging.Logger.getLogger(new Error().getStackTrace()[0].getClassName()); return ExportedVEFStrutGeometry.LOGGER; }
                    ;
                    /**
                     *
                     * @param {*} length
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    getStrutPolyhedron(length) {
                        let tipVertex = this.prototypeVector.scale(length);
                        let midpoint = tipVertex.scale(this.field['createRational$long$long'](1, 2));
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.field.getName(), "snubDodec") && ExportedVEFStrutGeometry.LOGGER_$LI$().isLoggable(java.util.logging.Level.FINE)) {
                            ExportedVEFStrutGeometry.LOGGER_$LI$().fine("proto length = " + this.prototypeVector.toRealVector().length());
                            ExportedVEFStrutGeometry.LOGGER_$LI$().fine("strut length = " + length.evaluate());
                            ExportedVEFStrutGeometry.LOGGER_$LI$().fine("tip length = " + tipVertex.toRealVector().length());
                        }
                        let result = new com.vzome.core.math.Polyhedron(this.field);
                        for (let i = 0; i < this.prototypeVertices.size(); i++) {
                            {
                                let vertex = this.prototypeVertices.get(i);
                                if (this.fullScaleVertices.contains(i)) {
                                    vertex = vertex.plus(tipVertex);
                                }
                                else if (this.halfScaleVertices != null && this.halfScaleVertices.contains(i)) {
                                    vertex = vertex.plus(midpoint);
                                }
                                result.addVertex(vertex);
                            }
                            ;
                        }
                        for (let index125 = this.prototypeFaces.iterator(); index125.hasNext();) {
                            let prototypeFace = index125.next();
                            {
                                let face = result.newFace();
                                face.addAll(prototypeFace);
                                result.addFace(face);
                            }
                        }
                        return result;
                    }
                }
                viewing.ExportedVEFStrutGeometry = ExportedVEFStrutGeometry;
                ExportedVEFStrutGeometry["__class"] = "com.vzome.core.viewing.ExportedVEFStrutGeometry";
                ExportedVEFStrutGeometry["__interfaces"] = ["com.vzome.core.parts.StrutGeometry"];
            })(viewing = core.viewing || (core.viewing = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                /**
                 * @author David Hall
                 * @param {*} field
                 * @class
                 */
                class TetrahedralProjection {
                    constructor(field) {
                        if (this.field === undefined)
                            this.field = null;
                        if (this.basis === undefined)
                            this.basis = null;
                        this.field = field;
                        let pos = field.one();
                        let neg = pos.negate();
                        this.basis = [null, null, null, null];
                        this.basis[0] = new com.vzome.core.algebra.AlgebraicVector(pos, pos, pos);
                        this.basis[1] = new com.vzome.core.algebra.AlgebraicVector(pos, neg, neg);
                        this.basis[2] = new com.vzome.core.algebra.AlgebraicVector(neg, pos, neg);
                        this.basis[3] = new com.vzome.core.algebra.AlgebraicVector(neg, neg, pos);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} source
                     * @param {boolean} wFirst
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    projectImage(source, wFirst) {
                        let result = this.field.origin(this.basis[0].dimension());
                        let pos = wFirst ? 0 : this.basis.length - 1;
                        for (let index126 = 0; index126 < this.basis.length; index126++) {
                            let unitVector = this.basis[index126];
                            {
                                let scalar = source.getComponent(pos);
                                result = result.plus(unitVector.scale(scalar));
                                pos = (pos + 1) % this.basis.length;
                            }
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    setXmlAttributes(xml) {
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getProjectionName() {
                        return "Tetrahedral";
                    }
                }
                math.TetrahedralProjection = TetrahedralProjection;
                TetrahedralProjection["__class"] = "com.vzome.core.math.TetrahedralProjection";
                TetrahedralProjection["__interfaces"] = ["com.vzome.core.math.Projection"];
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                class Polyhedron {
                    constructor(field) {
                        this.numVertices = 0;
                        this.m_vertices = (new java.util.HashMap());
                        this.m_vertexList = (new java.util.ArrayList());
                        this.m_faces = (new java.util.HashSet());
                        if (this.field === undefined)
                            this.field = null;
                        if (this.evilTwin === undefined)
                            this.evilTwin = null;
                        this.isEvil = false;
                        this.__isPanel = false;
                        this.guid = java.util.UUID.randomUUID();
                        if (this.name === undefined)
                            this.name = null;
                        if (this.orbit === undefined)
                            this.orbit = null;
                        if (this.length === undefined)
                            this.length = null;
                        this.field = field;
                    }
                    static logger_$LI$() { if (Polyhedron.logger == null)
                        Polyhedron.logger = java.util.logging.Logger.getLogger("com.vzome.core.math.Polyhedron"); return Polyhedron.logger; }
                    ;
                    /**
                     * Get the mirror twin of this Polyhedron.
                     * The vertices are transformed by the given reflection.
                     * The faces are oriented in reverse, so that when oriented with
                     * a mirroring transformation, the face normals will still point
                     * outward.
                     * @return
                     * @param {com.vzome.core.algebra.AlgebraicMatrix} reflection
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    getEvilTwin(reflection) {
                        if (this.evilTwin == null) {
                            try {
                                this.evilTwin = ((o) => { if (o.clone != undefined) {
                                    return o.clone();
                                }
                                else {
                                    let clone = Object.create(o);
                                    for (let p in o) {
                                        if (o.hasOwnProperty(p))
                                            clone[p] = o[p];
                                    }
                                    return clone;
                                } })(this);
                            }
                            catch (e) {
                                console.error(e.message, e);
                            }
                            ;
                            this.evilTwin.isEvil = true;
                            this.evilTwin.m_vertexList = (new java.util.ArrayList());
                            for (let index127 = this.m_vertexList.iterator(); index127.hasNext();) {
                                let vertex = index127.next();
                                {
                                    this.evilTwin.addVertex(reflection.timesColumn(vertex));
                                }
                            }
                            this.evilTwin.m_faces = (new java.util.HashSet());
                            for (let index128 = this.m_faces.iterator(); index128.hasNext();) {
                                let face = index128.next();
                                {
                                    let mirrorFace = ((o) => { if (o.clone != undefined) {
                                        return o.clone();
                                    }
                                    else {
                                        let clone = Object.create(o);
                                        for (let p in o) {
                                            if (o.hasOwnProperty(p))
                                                clone[p] = o[p];
                                        }
                                        return clone;
                                    } })(face);
                                    java.util.Collections.reverse(mirrorFace);
                                    this.evilTwin.addFace(mirrorFace);
                                }
                            }
                        }
                        return this.evilTwin;
                    }
                    getField() {
                        return this.field;
                    }
                    setName(name) {
                        this.name = name;
                    }
                    getName() {
                        return this.name;
                    }
                    addVertex(location) {
                        this.m_vertexList.add(location);
                    }
                    /**
                     * Only used in ZomicPolyhedronModelInterpreter.
                     * This used to be the implementation of addVertex, but all other callers
                     * don't use the return value, and have already assigned their own indices,
                     * so the collisions here are a bad idea.
                     * @param halfLoc
                     * @return
                     * @param {com.vzome.core.algebra.AlgebraicVector} location
                     * @return {number}
                     */
                    addIndexedVertex(location) {
                        let vertexObj = this.m_vertices.get(location);
                        if (vertexObj == null) {
                            this.m_vertexList.add(location);
                            this.m_vertices.put(location, vertexObj = this.numVertices++);
                        }
                        return vertexObj;
                    }
                    addFace(face) {
                        face.canonicallyOrder();
                        if (!this.m_faces.contains(face)) {
                            this.m_faces.add(face);
                        }
                    }
                    newFace() {
                        return new Polyhedron.Face(this);
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let prime = 31;
                        let result = 1;
                        result = prime * result + (this.isEvil ? 1231 : 1237);
                        result = prime * result + ((this.length == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.length));
                        result = prime * result + ((this.m_faces == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.m_faces));
                        result = prime * result + ((this.m_vertexList == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.m_vertexList));
                        result = prime * result + this.numVertices;
                        result = prime * result + ((this.orbit == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.orbit));
                        return result;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj) {
                            return true;
                        }
                        if (obj == null) {
                            return false;
                        }
                        if (this.constructor !== obj.constructor) {
                            return false;
                        }
                        let other = obj;
                        if (this.isEvil !== other.isEvil) {
                            return false;
                        }
                        if (this.length == null) {
                            if (other.length != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.length, other.length)) {
                            return false;
                        }
                        if (this.m_faces == null) {
                            if (other.m_faces != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.m_faces, other.m_faces)) {
                            return false;
                        }
                        if (this.m_vertexList == null) {
                            if (other.m_vertexList != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.m_vertexList, other.m_vertexList)) {
                            return false;
                        }
                        if (this.numVertices !== other.numVertices) {
                            return false;
                        }
                        if (this.orbit == null) {
                            if (other.orbit != null) {
                                return false;
                            }
                        }
                        else if (!this.orbit.equals(other.orbit)) {
                            return false;
                        }
                        return true;
                    }
                    setOrbit(orbit) {
                        this.orbit = orbit;
                    }
                    setLength(length) {
                        this.length = length;
                    }
                    getOrbit() {
                        return this.orbit;
                    }
                    getLength() {
                        return this.length;
                    }
                    isPanel() {
                        return this.__isPanel;
                    }
                    setPanel(isPanel) {
                        this.__isPanel = isPanel;
                    }
                    getVertexList() {
                        return this.m_vertexList;
                    }
                    getFaceSet() {
                        return this.m_faces;
                    }
                    getGuid() {
                        return this.guid;
                    }
                    getTriangleFaces() {
                        let result = (new java.util.ArrayList());
                        for (let index129 = this.m_faces.iterator(); index129.hasNext();) {
                            let face = index129.next();
                            {
                                result.addAll(face.getTriangles());
                            }
                        }
                        return result;
                    }
                    getTriangles() {
                        let index = 0;
                        let result = (new java.util.ArrayList());
                        for (let index130 = this.m_faces.iterator(); index130.hasNext();) {
                            let face = index130.next();
                            {
                                for (let index131 = face.getTriangles().iterator(); index131.hasNext();) {
                                    let triangle = index131.next();
                                    {
                                        result.add(index++);
                                        result.add(index++);
                                        result.add(index++);
                                    }
                                }
                            }
                        }
                        return result;
                    }
                    getTriangleVertices() {
                        let result = (new java.util.ArrayList());
                        for (let index132 = this.m_faces.iterator(); index132.hasNext();) {
                            let face = index132.next();
                            {
                                for (let index133 = face.getTriangles().iterator(); index133.hasNext();) {
                                    let triangle = index133.next();
                                    {
                                        for (let index134 = 0; index134 < triangle.vertices.length; index134++) {
                                            let index = triangle.vertices[index134];
                                            {
                                                let vertex = this.m_vertexList.get(index);
                                                result.add(vertex.toRealVector());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return result;
                    }
                }
                math.Polyhedron = Polyhedron;
                Polyhedron["__class"] = "com.vzome.core.math.Polyhedron";
                Polyhedron["__interfaces"] = ["java.lang.Cloneable"];
                (function (Polyhedron) {
                    class Face extends java.util.ArrayList {
                        constructor(__parent) {
                            super();
                            this.__parent = __parent;
                        }
                        getVertex(index) {
                            if (index >= this.size()) {
                                let msg = "index larger than Face size";
                                com.vzome.core.math.Polyhedron.logger_$LI$().severe(msg);
                                throw new java.lang.IllegalStateException(msg);
                            }
                            return this.get(index);
                        }
                        getTriangles() {
                            let arity = this.size();
                            let result = (new java.util.ArrayList());
                            let v0 = -1;
                            let v1 = -1;
                            for (let j = 0; j < arity; j++) {
                                {
                                    let index = this.get(j);
                                    if (v0 === -1) {
                                        v0 = index;
                                    }
                                    else if (v1 === -1) {
                                        v1 = index;
                                    }
                                    else {
                                        let triangle = new com.vzome.core.math.Polyhedron.Face.Triangle(this, v0, v1, index);
                                        result.add(triangle);
                                        v1 = index;
                                    }
                                }
                                ;
                            }
                            return result;
                        }
                        getNormal(vertices) {
                            return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(vertices.get(this.getVertex(0)), vertices.get(this.getVertex(1)), vertices.get(this.getVertex(2)));
                        }
                        canonicallyOrder() {
                            let minIndex = -1;
                            let minVertex = javaemul.internal.IntegerHelper.MAX_VALUE;
                            let sz = this.size();
                            for (let i = 0; i < sz; i++) {
                                if (this.getVertex(i) <= minVertex) {
                                    minVertex = this.getVertex(i);
                                    minIndex = i;
                                }
                                ;
                            }
                            let temp = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(sz);
                            for (let j = 0; j < sz; j++) {
                                {
                                    temp[j] = this.get((j + minIndex) % sz);
                                }
                                ;
                            }
                            for (let k = 0; k < sz; k++) {
                                this.set(k, temp[k]);
                            }
                        }
                        /**
                         *
                         * @return {number}
                         */
                        hashCode() {
                            let tot = 0;
                            for (let i = 0; i < this.size(); i++) {
                                tot += this.getVertex(i);
                            }
                            return tot;
                        }
                        /**
                         *
                         * @param {*} other
                         * @return {boolean}
                         */
                        equals(other) {
                            if (other == null)
                                return false;
                            if (other === this)
                                return true;
                            if (!(other != null && other instanceof com.vzome.core.math.Polyhedron.Face))
                                return false;
                            let otherFace = other;
                            if (otherFace.size() !== this.size())
                                return false;
                            for (let i = 0; i < this.size(); i++) {
                                if (!((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(this.get(i), otherFace.get(i)))
                                    return false;
                                ;
                            }
                            return true;
                        }
                    }
                    Polyhedron.Face = Face;
                    Face["__class"] = "com.vzome.core.math.Polyhedron.Face";
                    Face["__interfaces"] = ["java.util.RandomAccess", "java.lang.Cloneable", "java.util.List", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
                    (function (Face) {
                        class Triangle {
                            constructor(__parent, v0, v1, v2) {
                                this.__parent = __parent;
                                this.vertices = [0, 0, 0];
                                this.vertices[0] = v0;
                                this.vertices[1] = v1;
                                this.vertices[2] = v2;
                            }
                        }
                        Face.Triangle = Triangle;
                        Triangle["__class"] = "com.vzome.core.math.Polyhedron.Face.Triangle";
                    })(Face = Polyhedron.Face || (Polyhedron.Face = {}));
                    class Views {
                        constructor() {
                        }
                    }
                    Polyhedron.Views = Views;
                    Views["__class"] = "com.vzome.core.math.Polyhedron.Views";
                })(Polyhedron = math.Polyhedron || (math.Polyhedron = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var convexhull;
                (function (convexhull) {
                    /**
                     * Constructs a vertex with the specified coordinates and index.
                     * @param {com.vzome.core.algebra.AlgebraicVector} v
                     * @param {number} idx
                     * @class
                     * @author John E. Lloyd, Fall 2004
                     */
                    class Vertex {
                        constructor(v, idx) {
                            if (this.pnt === undefined)
                                this.pnt = null;
                            if (this.index === undefined)
                                this.index = 0;
                            if (this.prev === undefined)
                                this.prev = null;
                            if (this.next === undefined)
                                this.next = null;
                            if (this.face === undefined)
                                this.face = null;
                            this.pnt = v;
                            this.index = idx;
                        }
                    }
                    convexhull.Vertex = Vertex;
                    Vertex["__class"] = "com.vzome.core.math.convexhull.Vertex";
                })(convexhull = math.convexhull || (math.convexhull = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var convexhull;
                (function (convexhull) {
                    class GrahamScan2D {
                        constructor() {
                        }
                        /**
                         * Constructs the 2d convex hull of a coplanar set of 3d points.
                         *
                         * @param {*} points
                         * a set of 3d input points
                         * @return  {Array} an array of the vertices of the planar convex hull.
                         * The points are ordered so that the normal of the resulting polygon points AWAY from the origin.
                         * The points in the array are unique, so the last point is NOT the same as the first.
                         * This means that polygon edges derived from this array must connect the last to the first.
                         * @throws Failure
                         * if the number of input points is less than three,
                         * or if the points are collinear
                         * or if the points are not coplanar.
                         */
                        static buildHull(points) {
                            if (points.size() < 3) {
                                GrahamScan2D.fail("At least three input points are required for a 2d convex hull.\n\n" + points.size() + " specified.");
                            }
                            let normal = com.vzome.core.algebra.AlgebraicVectors.getNormal$java_util_Collection(points);
                            if (normal.isOrigin()) {
                                GrahamScan2D.fail("Cannot generate a 2d convex hull from collinear points");
                            }
                            if (!com.vzome.core.algebra.AlgebraicVectors.areOrthogonalTo(normal, points)) {
                                GrahamScan2D.fail("Cannot generate a 2d convex hull from non-coplanar points");
                            }
                            let xyTo3dMap = GrahamScan2D.map3dToXY(points, normal);
                            let stack2d = GrahamScan2D.getHull2d(xyTo3dMap.keySet());
                            let vertices3d = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(stack2d.size());
                            let i = 0;
                            for (let index135 = stack2d.iterator(); index135.hasNext();) {
                                let point2d = index135.next();
                                {
                                    let point3d = xyTo3dMap.get(point2d);
                                    vertices3d[i++] = point3d;
                                }
                            }
                            return vertices3d;
                        }
                        /*private*/ static map3dToXY(points3d, normal) {
                            let maxAxis = com.vzome.core.algebra.AlgebraicVectors.getMaxComponentIndex(normal);
                            let mapX = (maxAxis + 1) % 3;
                            let mapY = (maxAxis + 2) % 3;
                            let map = (new java.util.HashMap());
                            for (let index136 = points3d.iterator(); index136.hasNext();) {
                                let point3d = index136.next();
                                {
                                    let point2d = new com.vzome.core.algebra.AlgebraicVector(point3d.getComponent(mapX), point3d.getComponent(mapY));
                                    map.put(point2d, point3d);
                                }
                            }
                            return map;
                        }
                        /*private*/ static getHull2d(points2d) {
                            let sortedPoints2d = GrahamScan2D.getSortedPoints(points2d);
                            let stack2d = (new java.util.ArrayDeque());
                            stack2d.push(sortedPoints2d.get(0));
                            stack2d.push(sortedPoints2d.get(1));
                            for (let i = 2; i < sortedPoints2d.size(); i++) {
                                {
                                    let head = sortedPoints2d.get(i);
                                    let middle = stack2d.pop();
                                    let tail = stack2d.peek();
                                    let turn = GrahamScan2D.getWindingDirection(tail, middle, head);
                                    switch ((turn)) {
                                        case 1:
                                            stack2d.push(middle);
                                            stack2d.push(head);
                                            break;
                                        case -1:
                                            i--;
                                            break;
                                        case 0:
                                            stack2d.push(head);
                                            break;
                                        default:
                                            throw new java.lang.IllegalStateException("Illegal turn: " + turn);
                                    }
                                }
                                ;
                            }
                            return stack2d;
                        }
                        /**
                         * @param {*} points2d set of 2d points to be sorted
                         * @return {*} a list of points sorted:
                         * 1) in increasing order of the angle they and the lowest point make with the x-axis.
                         * 2) by increasing distance from the lowest point.
                         * @private
                         */
                        /*private*/ static getSortedPoints(points2d) {
                            let lowest = GrahamScan2D.getLowest2dPoint(points2d);
                            let list = (new java.util.ArrayList(points2d));
                            list.sort((a, b) => {
                                if (a.equals(b)) {
                                    return 0;
                                }
                                if (a.equals(lowest)) {
                                    return -1;
                                }
                                if (b.equals(lowest)) {
                                    return 1;
                                }
                                let turn = GrahamScan2D.getWindingDirection(lowest, a, b);
                                if (turn !== 0) {
                                    return -turn;
                                }
                                let lengthSqA = com.vzome.core.algebra.AlgebraicVectors.getMagnitudeSquared(a.minus(lowest));
                                let lengthSqB = com.vzome.core.algebra.AlgebraicVectors.getMagnitudeSquared(b.minus(lowest));
                                return lengthSqA.compareTo(lengthSqB);
                            });
                            return list;
                        }
                        /**
                         * @param {*} points2d a collection of 2d points from which to determine the lowest point.
                         * @return  {com.vzome.core.algebra.AlgebraicVector} the point with the lowest y coordinate.
                         * In case more than one point has the same minimum y coordinate,
                         * the one with the lowest x coordinate is returned.
                         */
                        static getLowest2dPoint(points2d) {
                            let lowest = null;
                            for (let index137 = points2d.iterator(); index137.hasNext();) {
                                let point2d = index137.next();
                                {
                                    if (lowest == null) {
                                        lowest = point2d;
                                    }
                                    else {
                                        let signum = point2d.getComponent(com.vzome.core.algebra.AlgebraicVector.Y)['minus$com_vzome_core_algebra_AlgebraicNumber'](lowest.getComponent(com.vzome.core.algebra.AlgebraicVector.Y)).signum();
                                        switch ((signum)) {
                                            case -1:
                                                lowest = point2d;
                                                break;
                                            case 0:
                                                if (point2d.getComponent(com.vzome.core.algebra.AlgebraicVector.X).lessThan(lowest.getComponent(com.vzome.core.algebra.AlgebraicVector.X))) {
                                                    lowest = point2d;
                                                }
                                                break;
                                        }
                                    }
                                }
                            }
                            return lowest;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} a 2d coordinate
                         * @param {com.vzome.core.algebra.AlgebraicVector} b 2d coordinate
                         * @param {com.vzome.core.algebra.AlgebraicVector} c 2d coordinate
                         * @return {number} -1, 0 or 1, depending on the orientation of vector ac with respect to vector ab:
                         * 1: COUNTER_CLOCKWISE
                         * c
                         * /
                         * /
                         * a-----b
                         * -1: CLOCKWISE
                         * b
                         * /
                         * /
                         * a-----c
                         * 0: COLLINEAR
                         * a-----b--c
                         * @private
                         */
                        /*private*/ static getWindingDirection(a, b, c) {
                            let ab = b.minus(a);
                            let ac = c.minus(a);
                            return (new com.vzome.core.algebra.AlgebraicMatrix(ab, ac)).determinant().signum();
                        }
                        /*private*/ static fail(msg) {
                            throw new com.vzome.core.commands.Command.Failure(msg);
                        }
                    }
                    convexhull.GrahamScan2D = GrahamScan2D;
                    GrahamScan2D["__class"] = "com.vzome.core.math.convexhull.GrahamScan2D";
                })(convexhull = math.convexhull || (math.convexhull = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var convexhull;
                (function (convexhull) {
                    /**
                     * Basic triangular face used to form the hull.
                     *
                     * <p>
                     * The information stored for each face consists of a planar normal, a planar
                     * offset, and a doubly-linked list of three <a href=HalfEdge>HalfEdges</a>
                     * which surround the face in a counter-clockwise direction.
                     *
                     * @author John E. Lloyd, Fall 2004
                     * @class
                     */
                    class Face {
                        constructor() {
                            if (this.he0 === undefined)
                                this.he0 = null;
                            if (this.normal === undefined)
                                this.normal = null;
                            if (this.area === undefined)
                                this.area = 0;
                            if (this.centroid === undefined)
                                this.centroid = null;
                            if (this.planeOffset === undefined)
                                this.planeOffset = null;
                            if (this.index === undefined)
                                this.index = 0;
                            if (this.numVerts === undefined)
                                this.numVerts = 0;
                            if (this.next === undefined)
                                this.next = null;
                            this.mark = Face.VISIBLE;
                            if (this.outside === undefined)
                                this.outside = null;
                            this.mark = Face.VISIBLE;
                        }
                        computeCentroid() {
                            let vectors = (new java.util.HashSet());
                            let he = this.he0;
                            do {
                                {
                                    vectors.add(he.head().pnt);
                                    he = he.next;
                                }
                            } while ((he !== this.he0));
                            this.centroid = com.vzome.core.algebra.AlgebraicVectors.calculateCentroid(vectors);
                            return this.centroid;
                        }
                        computeNormal() {
                            let he1 = this.he0.next;
                            let he2 = he1.next;
                            let p0 = this.he0.head().pnt;
                            let p2 = he1.head().pnt;
                            let d2 = p2.minus(p0);
                            this.normal = p0.getField().origin(3);
                            this.numVerts = 2;
                            while ((he2 !== this.he0)) {
                                {
                                    let d1 = d2;
                                    p2 = he2.head().pnt;
                                    d2 = p2.minus(p0);
                                    this.normal = this.normal.plus(d1.cross(d2));
                                    he1 = he2;
                                    he2 = he2.next;
                                    this.numVerts++;
                                }
                            }
                            ;
                            return this.normal;
                        }
                        /*private*/ computeNormalAndCentroid$() {
                            this.normal = this.computeNormal();
                            this.centroid = this.computeCentroid();
                            this.planeOffset = this.normal.dot(this.centroid);
                            let numv = 0;
                            let he = this.he0;
                            do {
                                {
                                    numv++;
                                    he = he.next;
                                }
                            } while ((he !== this.he0));
                            if (numv !== this.numVerts) {
                                this.fail("face " + this.getVertexString() + " numVerts=" + this.numVerts + " should be " + numv);
                            }
                        }
                        computeNormalAndCentroid$double(minArea) {
                            this.normal = this.computeNormal();
                            this.centroid = this.computeCentroid();
                            this.planeOffset = this.normal.dot(this.centroid);
                        }
                        computeNormalAndCentroid(minArea) {
                            if (((typeof minArea === 'number') || minArea === null)) {
                                return this.computeNormalAndCentroid$double(minArea);
                            }
                            else if (minArea === undefined) {
                                return this.computeNormalAndCentroid$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(v0, v1, v2) {
                            return Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$double(v0, v1, v2, 0);
                        }
                        static createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$double(v0, v1, v2, minArea) {
                            let face = new Face();
                            let he0 = new com.vzome.core.math.convexhull.HalfEdge(v0, face);
                            let he1 = new com.vzome.core.math.convexhull.HalfEdge(v1, face);
                            let he2 = new com.vzome.core.math.convexhull.HalfEdge(v2, face);
                            he0.prev = he2;
                            he0.next = he1;
                            he1.prev = he0;
                            he1.next = he2;
                            he2.prev = he1;
                            he2.next = he0;
                            face.he0 = he0;
                            face.computeNormalAndCentroid$double(minArea);
                            return face;
                        }
                        /**
                         * Constructs a triangule Face from vertices v0, v1, and v2.
                         *
                         * @param {com.vzome.core.math.convexhull.Vertex} v0
                         * first vertex
                         * @param {com.vzome.core.math.convexhull.Vertex} v1
                         * second vertex
                         * @param {com.vzome.core.math.convexhull.Vertex} v2
                         * third vertex
                         * @param {number} minArea
                         * @return {com.vzome.core.math.convexhull.Face}
                         */
                        static createTriangle(v0, v1, v2, minArea) {
                            if (((v0 != null && v0 instanceof com.vzome.core.math.convexhull.Vertex) || v0 === null) && ((v1 != null && v1 instanceof com.vzome.core.math.convexhull.Vertex) || v1 === null) && ((v2 != null && v2 instanceof com.vzome.core.math.convexhull.Vertex) || v2 === null) && ((typeof minArea === 'number') || minArea === null)) {
                                return com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$double(v0, v1, v2, minArea);
                            }
                            else if (((v0 != null && v0 instanceof com.vzome.core.math.convexhull.Vertex) || v0 === null) && ((v1 != null && v1 instanceof com.vzome.core.math.convexhull.Vertex) || v1 === null) && ((v2 != null && v2 instanceof com.vzome.core.math.convexhull.Vertex) || v2 === null) && minArea === undefined) {
                                return com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(v0, v1, v2);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static create(vtxArray, indices) {
                            let face = new Face();
                            let hePrev = null;
                            for (let i = 0; i < indices.length; i++) {
                                {
                                    let he = new com.vzome.core.math.convexhull.HalfEdge(vtxArray[indices[i]], face);
                                    if (hePrev != null) {
                                        he.setPrev(hePrev);
                                        hePrev.setNext(he);
                                    }
                                    else {
                                        face.he0 = he;
                                    }
                                    hePrev = he;
                                }
                                ;
                            }
                            face.he0.setPrev(hePrev);
                            hePrev.setNext(face.he0);
                            face.computeNormalAndCentroid$();
                            return face;
                        }
                        /**
                         * Gets the i-th half-edge associated with the face.
                         *
                         * @param {number} i
                         * the half-edge index, in the range 0-2.
                         * @return {com.vzome.core.math.convexhull.HalfEdge} the half-edge
                         */
                        getEdge(i) {
                            let he = this.he0;
                            while ((i > 0)) {
                                {
                                    he = he.next;
                                    i--;
                                }
                            }
                            ;
                            while ((i < 0)) {
                                {
                                    he = he.prev;
                                    i++;
                                }
                            }
                            ;
                            return he;
                        }
                        getFirstEdge() {
                            return this.he0;
                        }
                        /**
                         * Finds the half-edge within this face which has tail <code>vt</code> and head
                         * <code>vh</code>.
                         *
                         * @param {com.vzome.core.math.convexhull.Vertex} vt
                         * tail point
                         * @param {com.vzome.core.math.convexhull.Vertex} vh
                         * head point
                         * @return {com.vzome.core.math.convexhull.HalfEdge} the half-edge, or null if none is found.
                         */
                        findEdge(vt, vh) {
                            let he = this.he0;
                            do {
                                {
                                    if (he.head() === vh && he.tail() === vt) {
                                        return he;
                                    }
                                    he = he.next;
                                }
                            } while ((he !== this.he0));
                            return null;
                        }
                        /**
                         * Computes the distance from a point p to the plane of this face.
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} p
                         * the point
                         * @return {*} distance from the point to the plane
                         */
                        distanceToPlane(p) {
                            return this.normal.dot(p)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.planeOffset);
                        }
                        /**
                         * Returns the normal of the plane associated with this face.
                         *
                         * @return {com.vzome.core.algebra.AlgebraicVector} the planar normal
                         */
                        getNormal() {
                            return this.normal;
                        }
                        getCentroid() {
                            return this.centroid;
                        }
                        numVertices() {
                            return this.numVerts;
                        }
                        getVertexString() {
                            let s = null;
                            let he = this.he0;
                            do {
                                {
                                    if (s == null) {
                                        s = "" + he.head().index;
                                    }
                                    else {
                                        s += " " + he.head().index;
                                    }
                                    he = he.next;
                                }
                            } while ((he !== this.he0));
                            return s;
                        }
                        getVertexIndices(idxs) {
                            let he = this.he0;
                            let i = 0;
                            do {
                                {
                                    idxs[i++] = he.head().index;
                                    he = he.next;
                                }
                            } while ((he !== this.he0));
                        }
                        /*private*/ connectHalfEdges(hedgePrev, hedge) {
                            let discardedFace = null;
                            if (hedgePrev.oppositeFace() === hedge.oppositeFace()) {
                                let oppFace = hedge.oppositeFace();
                                let hedgeOpp;
                                if (hedgePrev === this.he0) {
                                    this.he0 = hedge;
                                }
                                if (oppFace.numVertices() === 3) {
                                    hedgeOpp = hedge.getOpposite().prev.getOpposite();
                                    oppFace.mark = Face.DELETED;
                                    discardedFace = oppFace;
                                }
                                else {
                                    hedgeOpp = hedge.getOpposite().next;
                                    if (oppFace.he0 === hedgeOpp.prev) {
                                        oppFace.he0 = hedgeOpp;
                                    }
                                    hedgeOpp.prev = hedgeOpp.prev.prev;
                                    hedgeOpp.prev.next = hedgeOpp;
                                }
                                hedge.prev = hedgePrev.prev;
                                hedge.prev.next = hedge;
                                hedge.opposite = hedgeOpp;
                                hedgeOpp.opposite = hedge;
                                oppFace.computeNormalAndCentroid$();
                            }
                            else {
                                hedgePrev.next = hedge;
                                hedge.prev = hedgePrev;
                            }
                            return discardedFace;
                        }
                        /*private*/ fail(msg) {
                            throw new com.vzome.core.commands.Command.Failure(msg);
                        }
                        checkConsistency() {
                            let hedge = this.he0;
                            let maxd = 0;
                            let numv = 0;
                            if (this.numVerts < 3) {
                                this.fail("degenerate face: " + this.getVertexString());
                            }
                            do {
                                {
                                    let hedgeOpp = hedge.getOpposite();
                                    if (hedgeOpp == null) {
                                        this.fail("face " + this.getVertexString() + ": unreflected half edge " + hedge.getVertexString());
                                    }
                                    else if (hedgeOpp.getOpposite() !== hedge) {
                                        this.fail("face " + this.getVertexString() + ": opposite half edge " + hedgeOpp.getVertexString() + " has opposite " + hedgeOpp.getOpposite().getVertexString());
                                    }
                                    if (hedgeOpp.head() !== hedge.tail() || hedge.head() !== hedgeOpp.tail()) {
                                        this.fail("face " + this.getVertexString() + ": half edge " + hedge.getVertexString() + " reflected by " + hedgeOpp.getVertexString());
                                    }
                                    let oppFace = hedgeOpp.face;
                                    if (oppFace == null) {
                                        this.fail("face " + this.getVertexString() + ": no face on half edge " + hedgeOpp.getVertexString());
                                    }
                                    else if (oppFace.mark === Face.DELETED) {
                                        this.fail("face " + this.getVertexString() + ": opposite face " + oppFace.getVertexString() + " not on hull");
                                    }
                                    let d = Math.abs(this.distanceToPlane(hedge.head().pnt).evaluate());
                                    if (d > maxd) {
                                        maxd = d;
                                    }
                                    numv++;
                                    hedge = hedge.next;
                                }
                            } while ((hedge !== this.he0));
                            if (numv !== this.numVerts) {
                                this.fail("face " + this.getVertexString() + " numVerts=" + this.numVerts + " should be " + numv);
                            }
                        }
                        mergeAdjacentFace(hedgeAdj, discarded) {
                            let oppFace = hedgeAdj.oppositeFace();
                            let numDiscarded = 0;
                            discarded[numDiscarded++] = oppFace;
                            oppFace.mark = Face.DELETED;
                            let hedgeOpp = hedgeAdj.getOpposite();
                            let hedgeAdjPrev = hedgeAdj.prev;
                            let hedgeAdjNext = hedgeAdj.next;
                            let hedgeOppPrev = hedgeOpp.prev;
                            let hedgeOppNext = hedgeOpp.next;
                            let foo = 0;
                            while ((hedgeAdjPrev.oppositeFace() === oppFace)) {
                                {
                                    hedgeAdjPrev = hedgeAdjPrev.prev;
                                    hedgeOppNext = hedgeOppNext.next;
                                    if (++foo > 1000) {
                                        this.fail("Oops, it\'s hung.");
                                    }
                                }
                            }
                            ;
                            foo = 0;
                            while ((hedgeAdjNext.oppositeFace() === oppFace)) {
                                {
                                    hedgeOppPrev = hedgeOppPrev.prev;
                                    hedgeAdjNext = hedgeAdjNext.next;
                                    if (++foo > 1000) {
                                        this.fail("Oops, it\'s hung.");
                                    }
                                }
                            }
                            ;
                            let hedge;
                            foo = 0;
                            for (hedge = hedgeOppNext; hedge !== hedgeOppPrev.next; hedge = hedge.next) {
                                {
                                    hedge.face = this;
                                    if (++foo > 1000) {
                                        this.fail("Oops, it\'s hung.");
                                    }
                                }
                                ;
                            }
                            if (hedgeAdj === this.he0) {
                                this.he0 = hedgeAdjNext;
                            }
                            let discardedFace;
                            discardedFace = this.connectHalfEdges(hedgeOppPrev, hedgeAdjNext);
                            if (discardedFace != null) {
                                discarded[numDiscarded++] = discardedFace;
                            }
                            discardedFace = this.connectHalfEdges(hedgeAdjPrev, hedgeOppNext);
                            if (discardedFace != null) {
                                discarded[numDiscarded++] = discardedFace;
                            }
                            this.computeNormalAndCentroid$();
                            this.checkConsistency();
                            return numDiscarded;
                        }
                        triangulate(newFaces) {
                            let minArea = 0;
                            let hedge;
                            if (this.numVertices() < 4) {
                                return;
                            }
                            let v0 = this.he0.head();
                            hedge = this.he0.next;
                            let oppPrev = hedge.opposite;
                            let face0 = null;
                            for (hedge = hedge.next; hedge !== this.he0.prev; hedge = hedge.next) {
                                {
                                    let face = Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$double(v0, hedge.prev.head(), hedge.head(), minArea);
                                    face.he0.next.setOpposite(oppPrev);
                                    face.he0.prev.setOpposite(hedge.opposite);
                                    oppPrev = face.he0;
                                    newFaces.add(face);
                                    if (face0 == null) {
                                        face0 = face;
                                    }
                                }
                                ;
                            }
                            hedge = new com.vzome.core.math.convexhull.HalfEdge(this.he0.prev.prev.head(), this);
                            hedge.setOpposite(oppPrev);
                            hedge.prev = this.he0;
                            hedge.prev.next = hedge;
                            hedge.next = this.he0.prev;
                            hedge.next.prev = hedge;
                            this.computeNormalAndCentroid$double(minArea);
                            this.checkConsistency();
                            for (let face = face0; face != null; face = face.next) {
                                {
                                    face.checkConsistency();
                                }
                                ;
                            }
                        }
                    }
                    Face.VISIBLE = 1;
                    Face.NON_CONVEX = 2;
                    Face.DELETED = 3;
                    convexhull.Face = Face;
                    Face["__class"] = "com.vzome.core.math.convexhull.Face";
                })(convexhull = math.convexhull || (math.convexhull = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var convexhull;
                (function (convexhull) {
                    /**
                     * Creates an empty convex hull object.
                     * @class
                     * @author John E. Lloyd, Fall 2004
                     */
                    class QuickHull3D {
                        constructor() {
                            this.findIndex = -1;
                            this.debug = false;
                            this.pointBuffer = [];
                            this.vertexPointIndices = [];
                            this.discardedFaces = [null, null, null];
                            this.maxVtxs = [null, null, null];
                            this.minVtxs = [null, null, null];
                            this.faces = (new java.util.Vector(16));
                            this.newFaces = (new java.util.LinkedList());
                            this.unclaimed = new com.vzome.core.math.convexhull.VertexList();
                            this.claimed = new com.vzome.core.math.convexhull.VertexList();
                            if (this.numVertices === undefined)
                                this.numVertices = 0;
                            if (this.numFaces === undefined)
                                this.numFaces = 0;
                            if (this.numPoints === undefined)
                                this.numPoints = 0;
                        }
                        /**
                         * Returns true if debugging is enabled.
                         *
                         * @return {boolean} true is debugging is enabled
                         * @see QuickHull3D#setDebug
                         */
                        getDebug() {
                            return this.debug;
                        }
                        /**
                         * Enables the printing of debugging diagnostics.
                         *
                         * @param {boolean} enable
                         * if true, enables debugging
                         */
                        setDebug(enable) {
                            this.debug = enable;
                        }
                        /*private*/ addPointToFace(vtx, face) {
                            vtx.face = face;
                            if (face.outside == null) {
                                this.claimed.add(vtx);
                            }
                            else {
                                this.claimed.insertBefore(vtx, face.outside);
                            }
                            face.outside = vtx;
                        }
                        /*private*/ removePointFromFace(vtx, face) {
                            if (vtx === face.outside) {
                                if (vtx.next != null && vtx.next.face === face) {
                                    face.outside = vtx.next;
                                }
                                else {
                                    face.outside = null;
                                }
                            }
                            this.claimed.delete$com_vzome_core_math_convexhull_Vertex(vtx);
                        }
                        /*private*/ removeAllPointsFromFace(face) {
                            if (face.outside != null) {
                                let end = face.outside;
                                while ((end.next != null && end.next.face === face)) {
                                    {
                                        end = end.next;
                                    }
                                }
                                ;
                                this.claimed.delete$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(face.outside, end);
                                end.next = null;
                                return face.outside;
                            }
                            else {
                                return null;
                            }
                        }
                        /*private*/ findHalfEdge(tail, head) {
                            for (let index138 = this.faces.iterator(); index138.hasNext();) {
                                let face = index138.next();
                                {
                                    let he = face.findEdge(tail, head);
                                    if (he != null) {
                                        return he;
                                    }
                                }
                            }
                            return null;
                        }
                        setHull(coords, nump, faceIndices, numf) {
                            this.initBuffers(nump);
                            this.setPoints(coords, nump);
                            this.computeMaxAndMin();
                            for (let i = 0; i < numf; i++) {
                                {
                                    let face = com.vzome.core.math.convexhull.Face.create(this.pointBuffer, faceIndices[i]);
                                    let he = face.he0;
                                    do {
                                        {
                                            let heOpp = this.findHalfEdge(he.head(), he.tail());
                                            if (heOpp != null) {
                                                he.setOpposite(heOpp);
                                            }
                                            he = he.next;
                                        }
                                    } while ((he !== face.he0));
                                    this.faces.add(face);
                                }
                                ;
                            }
                        }
                        build$java_util_Collection(points) {
                            this.build$com_vzome_core_algebra_AlgebraicVector_A(points.toArray((s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(points.size())));
                        }
                        build$com_vzome_core_algebra_AlgebraicVector_A(points) {
                            this.build$com_vzome_core_algebra_AlgebraicVector_A$int(points, points.length);
                        }
                        build$com_vzome_core_algebra_AlgebraicVector_A$int(points, nump) {
                            if (nump < 4) {
                                throw new com.vzome.core.commands.Command.Failure("At least four input points are required for a 3d convex hull.\n\n" + nump + " specified.");
                            }
                            if (points.length < nump) {
                                throw new com.vzome.core.commands.Command.Failure("Point array too small for specified number of points");
                            }
                            this.printPointSet(points, nump);
                            this.initBuffers(nump);
                            this.setPoints(points, nump);
                            this.buildHull();
                        }
                        /**
                         * Constructs the convex hull of an array of points.
                         *
                         * @param {Array} points
                         * input points
                         * @param {number} nump
                         * number of input points
                         * @throws Failure
                         * if the number of input points is less than four or greater than the
                         * length of <code>points</code>, or the points are
                         * coincident, collinear, or coplanar.
                         */
                        build(points, nump) {
                            if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof com.vzome.core.algebra.AlgebraicVector))) || points === null) && ((typeof nump === 'number') || nump === null)) {
                                return this.build$com_vzome_core_algebra_AlgebraicVector_A$int(points, nump);
                            }
                            else if (((points != null && (points["__interfaces"] != null && points["__interfaces"].indexOf("java.util.Collection") >= 0 || points.constructor != null && points.constructor["__interfaces"] != null && points.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || points === null) && nump === undefined) {
                                return this.build$java_util_Collection(points);
                            }
                            else if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof com.vzome.core.algebra.AlgebraicVector))) || points === null) && nump === undefined) {
                                return this.build$com_vzome_core_algebra_AlgebraicVector_A(points);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         * prints the initial set of points.
                         *
                         * @param {Array} points
                         * input points
                         * @param {number} nump
                         * number of input points
                         */
                        printPointSet(points, nump) {
                            if (this.debug) {
                                console.info("initial point set:");
                                for (let i = 0; i < nump; i++) {
                                    {
                                        console.info(i + ": " + points[i]);
                                    }
                                    ;
                                }
                            }
                        }
                        /**
                         * Triangulates any non-triangular hull faces. In some cases, due to precision
                         * issues, the resulting triangles may be very thin or small, and hence appear
                         * to be non-convex (this same limitation is present in <a href=http://www.qhull.org>qhull</a>).
                         * @throws Failure
                         */
                        triangulate() {
                            this.newFaces.clear();
                            for (let index139 = this.faces.iterator(); index139.hasNext();) {
                                let face = index139.next();
                                {
                                    if (face.mark === com.vzome.core.math.convexhull.Face.VISIBLE) {
                                        face.triangulate(this.newFaces);
                                    }
                                }
                            }
                            for (let index140 = this.newFaces.iterator(); index140.hasNext();) {
                                let face = index140.next();
                                {
                                    this.faces.add(face);
                                }
                            }
                        }
                        initBuffers(nump) {
                            if (this.pointBuffer.length < nump) {
                                let newBuffer = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(nump);
                                this.vertexPointIndices = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(nump);
                                for (let i = 0; i < this.pointBuffer.length; i++) {
                                    {
                                        newBuffer[i] = this.pointBuffer[i];
                                    }
                                    ;
                                }
                                for (let i = this.pointBuffer.length; i < nump; i++) {
                                    {
                                        newBuffer[i] = null;
                                    }
                                    ;
                                }
                                this.pointBuffer = newBuffer;
                            }
                            this.faces.clear();
                            this.claimed.clear();
                            this.numFaces = 0;
                            this.numPoints = nump;
                        }
                        setPoints(pnts, nump) {
                            this.pointBuffer = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(nump);
                            for (let i = 0; i < nump; i++) {
                                {
                                    this.pointBuffer[i] = new com.vzome.core.math.convexhull.Vertex(pnts[i], i);
                                }
                                ;
                            }
                        }
                        computeMaxAndMin() {
                            for (let i = 0; i < 3; i++) {
                                {
                                    this.maxVtxs[i] = this.minVtxs[i] = this.pointBuffer[0];
                                }
                                ;
                            }
                            let max = this.pointBuffer[0].pnt;
                            let maxx = max.getComponent(com.vzome.core.algebra.AlgebraicVector.X).evaluate();
                            let maxy = max.getComponent(com.vzome.core.algebra.AlgebraicVector.Y).evaluate();
                            let maxz = max.getComponent(com.vzome.core.algebra.AlgebraicVector.Z).evaluate();
                            let minx = maxx;
                            let miny = maxy;
                            let minz = maxz;
                            for (let i = 1; i < this.numPoints; i++) {
                                {
                                    let pnt = this.pointBuffer[i].pnt;
                                    let pntx = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.X).evaluate();
                                    let pnty = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.Y).evaluate();
                                    let pntz = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.Z).evaluate();
                                    if (pntx > maxx) {
                                        maxx = pntx;
                                        this.maxVtxs[0] = this.pointBuffer[i];
                                    }
                                    else if (pntx < minx) {
                                        minx = pntx;
                                        this.minVtxs[0] = this.pointBuffer[i];
                                    }
                                    if (pnty > maxy) {
                                        maxy = pnty;
                                        this.maxVtxs[1] = this.pointBuffer[i];
                                    }
                                    else if (pnty < miny) {
                                        miny = pnty;
                                        this.minVtxs[1] = this.pointBuffer[i];
                                    }
                                    if (pntz > maxz) {
                                        maxz = pntz;
                                        this.maxVtxs[2] = this.pointBuffer[i];
                                    }
                                    else if (pntz < minz) {
                                        minz = pntz;
                                        this.minVtxs[2] = this.pointBuffer[i];
                                    }
                                }
                                ;
                            }
                        }
                        /**
                         * Creates the initial simplex from which the hull will be built.
                         */
                        createInitialSimplex() {
                            let max = 0;
                            let imax = 0;
                            for (let i = 0; i < 3; i++) {
                                {
                                    let diff = this.maxVtxs[i].pnt.getComponent(i)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.minVtxs[i].pnt.getComponent(i)).evaluate();
                                    if (diff > max) {
                                        max = diff;
                                        imax = i;
                                    }
                                }
                                ;
                            }
                            if (max <= 0) {
                                throw new com.vzome.core.commands.Command.Failure("Input points are coincident");
                            }
                            let vtx = [null, null, null, null];
                            vtx[0] = this.maxVtxs[imax];
                            vtx[1] = this.minVtxs[imax];
                            let diff02;
                            let nrml = null;
                            let maxSqr = 0;
                            let u01 = vtx[1].pnt.minus(vtx[0].pnt);
                            for (let i = 0; i < this.numPoints; i++) {
                                {
                                    diff02 = this.pointBuffer[i].pnt.minus(vtx[0].pnt);
                                    let xprod = u01.cross(diff02);
                                    let lenSqr = xprod.dot(xprod);
                                    if (lenSqr.evaluate() > maxSqr && this.pointBuffer[i] !== vtx[0] && this.pointBuffer[i] !== vtx[1]) {
                                        maxSqr = lenSqr.evaluate();
                                        vtx[2] = this.pointBuffer[i];
                                        nrml = xprod;
                                    }
                                }
                                ;
                            }
                            if (maxSqr === 0) {
                                throw new com.vzome.core.commands.Command.Failure("Input points are collinear");
                            }
                            let res = u01.scale(nrml.dot(u01));
                            nrml = nrml.minus(res);
                            let maxDist = 0.0;
                            let d0 = vtx[2].pnt.dot(nrml);
                            for (let i = 0; i < this.numPoints; i++) {
                                {
                                    let dist = Math.abs(this.pointBuffer[i].pnt.dot(nrml)['minus$com_vzome_core_algebra_AlgebraicNumber'](d0).evaluate());
                                    if (dist > maxDist && this.pointBuffer[i] !== vtx[0] && this.pointBuffer[i] !== vtx[1] && this.pointBuffer[i] !== vtx[2]) {
                                        maxDist = dist;
                                        vtx[3] = this.pointBuffer[i];
                                    }
                                }
                                ;
                            }
                            if (maxDist === 0.0) {
                                throw new com.vzome.core.commands.Command.Failure("Input points are coplanar");
                            }
                            if (this.debug) {
                                console.info("initial vertices:");
                                console.info(vtx[0].index + ": " + vtx[0].pnt);
                                console.info(vtx[1].index + ": " + vtx[1].pnt);
                                console.info(vtx[2].index + ": " + vtx[2].pnt);
                                console.info(vtx[3].index + ": " + vtx[3].pnt);
                            }
                            let tris = [null, null, null, null];
                            if (vtx[3].pnt.dot(nrml)['minus$com_vzome_core_algebra_AlgebraicNumber'](d0).evaluate() < 0) {
                                tris[0] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[0], vtx[1], vtx[2]);
                                tris[1] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[1], vtx[0]);
                                tris[2] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[2], vtx[1]);
                                tris[3] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[0], vtx[2]);
                                for (let i = 0; i < 3; i++) {
                                    {
                                        let k = (i + 1) % 3;
                                        tris[i + 1].getEdge(1).setOpposite(tris[k + 1].getEdge(0));
                                        tris[i + 1].getEdge(2).setOpposite(tris[0].getEdge(k));
                                    }
                                    ;
                                }
                            }
                            else {
                                tris[0] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[0], vtx[2], vtx[1]);
                                tris[1] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[0], vtx[1]);
                                tris[2] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[1], vtx[2]);
                                tris[3] = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx[3], vtx[2], vtx[0]);
                                for (let i = 0; i < 3; i++) {
                                    {
                                        let k = (i + 1) % 3;
                                        tris[i + 1].getEdge(0).setOpposite(tris[k + 1].getEdge(1));
                                        tris[i + 1].getEdge(2).setOpposite(tris[0].getEdge((3 - i) % 3));
                                    }
                                    ;
                                }
                            }
                            for (let i = 0; i < 4; i++) {
                                {
                                    this.faces.add(tris[i]);
                                }
                                ;
                            }
                            for (let i = 0; i < this.numPoints; i++) {
                                {
                                    let v = this.pointBuffer[i];
                                    if (v === vtx[0] || v === vtx[1] || v === vtx[2] || v === vtx[3]) {
                                        continue;
                                    }
                                    maxDist = 0.0;
                                    let maxFace = null;
                                    for (let k = 0; k < 4; k++) {
                                        {
                                            let dist = tris[k].distanceToPlane(v.pnt).evaluate();
                                            if (dist > maxDist) {
                                                maxFace = tris[k];
                                                maxDist = dist;
                                            }
                                        }
                                        ;
                                    }
                                    if (maxFace != null) {
                                        this.addPointToFace(v, maxFace);
                                    }
                                }
                                ;
                            }
                        }
                        /**
                         * Returns the number of vertices in this hull.
                         *
                         * @return {number} number of vertices
                         */
                        getNumVertices() {
                            return this.numVertices;
                        }
                        getVertices$() {
                            let vtxs = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(this.numVertices);
                            for (let i = 0; i < this.numVertices; i++) {
                                {
                                    vtxs[i] = this.pointBuffer[this.vertexPointIndices[i]].pnt;
                                }
                                ;
                            }
                            return vtxs;
                        }
                        getVertices$com_vzome_core_algebra_AlgebraicNumber_A(coords) {
                            for (let i = 0; i < this.numVertices; i++) {
                                {
                                    let pnt = this.pointBuffer[this.vertexPointIndices[i]].pnt;
                                    coords[i * 3 + 0] = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.X);
                                    coords[i * 3 + 1] = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.Y);
                                    coords[i * 3 + 2] = pnt.getComponent(com.vzome.core.algebra.AlgebraicVector.Z);
                                }
                                ;
                            }
                            return this.numVertices;
                        }
                        /**
                         * Returns the coordinates of the vertex points of this hull.
                         *
                         * @param {Array} coords
                         * returns the x, y, z coordinates of each vertex. This length of
                         * this array must be at least three times the number of vertices.
                         * @return {number} the number of vertices
                         * @see QuickHull3D#getVertices()
                         * @see QuickHull3D#getFaces()
                         */
                        getVertices(coords) {
                            if (((coords != null && coords instanceof Array && (coords.length == 0 || coords[0] == null || (coords[0] != null && (coords[0]["__interfaces"] != null && coords[0]["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || coords[0].constructor != null && coords[0].constructor["__interfaces"] != null && coords[0].constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)))) || coords === null)) {
                                return this.getVertices$com_vzome_core_algebra_AlgebraicNumber_A(coords);
                            }
                            else if (coords === undefined) {
                                return this.getVertices$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         * Returns an array specifing the index of each hull vertex with respect to the
                         * original input points.
                         *
                         * @return {Array} vertex indices with respect to the original points
                         */
                        getVertexPointIndices() {
                            let indices = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(this.numVertices);
                            for (let i = 0; i < this.numVertices; i++) {
                                {
                                    indices[i] = this.vertexPointIndices[i];
                                }
                                ;
                            }
                            return indices;
                        }
                        /**
                         * Returns the number of edges in this hull.
                         *
                         * @return {number} number of edges
                         */
                        getNumEdges() {
                            let count = 0;
                            for (let index141 = this.faces.iterator(); index141.hasNext();) {
                                let face = index141.next();
                                {
                                    count += face.numVertices();
                                }
                            }
                            return (count / 2 | 0);
                        }
                        /**
                         * Returns the number of faces in this hull.
                         *
                         * @return {number} number of faces
                         */
                        getNumFaces() {
                            return this.faces.size();
                        }
                        getFaces$() {
                            return this.getFaces$int(0);
                        }
                        getFaces$int(indexFlags) {
                            let allFaces = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(this.faces.size());
                            let k = 0;
                            for (let index142 = this.faces.iterator(); index142.hasNext();) {
                                let face = index142.next();
                                {
                                    allFaces[k] = (s => { let a = []; while (s-- > 0)
                                        a.push(0); return a; })(face.numVertices());
                                    this.getFaceIndices(allFaces[k], face, indexFlags);
                                    k++;
                                }
                            }
                            return allFaces;
                        }
                        /**
                         * Returns the faces associated with this hull.
                         *
                         * <p>
                         * Each face is represented by an integer array which gives the indices of the
                         * vertices. By default, these indices are numbered with respect to the hull
                         * vertices (as opposed to the input points), are zero-based, and are arranged
                         * counter-clockwise. However, this can be changed by setting
                         * {@link #POINT_RELATIVE}, {@link #INDEXED_FROM_ONE}, or {@link #CLOCKWISE} in the indexFlags
                         * parameter.
                         *
                         * @param {number} indexFlags
                         * specifies index characteristics (0 results in the default)
                         * @return {Array} array of integer arrays, giving the vertex indices for each face.
                         * @see QuickHull3D#getVertices()
                         */
                        getFaces(indexFlags) {
                            if (((typeof indexFlags === 'number') || indexFlags === null)) {
                                return this.getFaces$int(indexFlags);
                            }
                            else if (indexFlags === undefined) {
                                return this.getFaces$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        print$java_io_PrintStream(ps) {
                            this.print$java_io_PrintStream$int(ps, 0);
                        }
                        print$java_io_PrintStream$int(ps, indexFlags) {
                            if ((indexFlags & QuickHull3D.INDEXED_FROM_ZERO) === 0) {
                                indexFlags |= QuickHull3D.INDEXED_FROM_ONE;
                            }
                            for (let i = 0; i < this.numVertices; i++) {
                                {
                                    let pnt = this.pointBuffer[this.vertexPointIndices[i]].pnt;
                                    ps.println(pnt);
                                }
                                ;
                            }
                            for (let index143 = this.faces.iterator(); index143.hasNext();) {
                                let face = index143.next();
                                {
                                    let indices = (s => { let a = []; while (s-- > 0)
                                        a.push(0); return a; })(face.numVertices());
                                    this.getFaceIndices(indices, face, indexFlags);
                                    ps.print("f");
                                    for (let k = 0; k < indices.length; k++) {
                                        {
                                            ps.print(" " + indices[k]);
                                        }
                                        ;
                                    }
                                    ps.println("");
                                }
                            }
                        }
                        /**
                         * Prints the vertices and faces of this hull to the stream ps.
                         *
                         * <p>
                         * This is done using the Alias Wavefront .obj file format, with the vertices
                         * printed first (each preceding by the letter <code>v</code>), followed by the
                         * vertex indices for each face (each preceded by the letter <code>f</code>).
                         *
                         * <p>
                         * By default, the face indices are numbered with respect to the hull vertices
                         * (as opposed to the input points), with a lowest index of 1, and are arranged
                         * counter-clockwise. However, this can be changed by setting
                         * {@link #POINT_RELATIVE}, {@link #INDEXED_FROM_ONE}, or {@link #CLOCKWISE} in the indexFlags
                         * parameter.
                         *
                         * @param {java.io.PrintStream} ps
                         * stream used for printing
                         * @param {number} indexFlags
                         * specifies index characteristics (0 results in the default).
                         * @see QuickHull3D#getVertices()
                         * @see QuickHull3D#getFaces()
                         */
                        print(ps, indexFlags) {
                            if (((ps != null && ps instanceof java.io.PrintStream) || ps === null) && ((typeof indexFlags === 'number') || indexFlags === null)) {
                                return this.print$java_io_PrintStream$int(ps, indexFlags);
                            }
                            else if (((ps != null && ps instanceof java.io.PrintStream) || ps === null) && indexFlags === undefined) {
                                return this.print$java_io_PrintStream(ps);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /*private*/ getFaceIndices(indices, face, flags) {
                            let ccw = ((flags & QuickHull3D.CLOCKWISE) === 0);
                            let indexedFromOne = ((flags & QuickHull3D.INDEXED_FROM_ONE) !== 0);
                            let pointRelative = ((flags & QuickHull3D.POINT_RELATIVE) !== 0);
                            let hedge = face.he0;
                            let k = 0;
                            do {
                                {
                                    let idx = hedge.head().index;
                                    if (pointRelative) {
                                        idx = this.vertexPointIndices[idx];
                                    }
                                    if (indexedFromOne) {
                                        idx++;
                                    }
                                    indices[k++] = idx;
                                    hedge = (ccw ? hedge.next : hedge.prev);
                                }
                            } while ((hedge !== face.he0));
                        }
                        resolveUnclaimedPoints(newFaces) {
                            let vtxNext = this.unclaimed.first();
                            for (let vtx = vtxNext; vtx != null; vtx = vtxNext) {
                                {
                                    vtxNext = vtx.next;
                                    let maxDist = 0;
                                    let maxFace = null;
                                    for (let index144 = newFaces.iterator(); index144.hasNext();) {
                                        let newFace = index144.next();
                                        {
                                            if (newFace.mark === com.vzome.core.math.convexhull.Face.VISIBLE) {
                                                let dist = newFace.distanceToPlane(vtx.pnt).evaluate();
                                                if (dist > maxDist) {
                                                    maxDist = dist;
                                                    maxFace = newFace;
                                                }
                                                if (maxDist > 0) {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (maxFace != null) {
                                        this.addPointToFace(vtx, maxFace);
                                        if (this.debug && vtx.index === this.findIndex) {
                                            console.info(this.findIndex + " CLAIMED BY " + maxFace.getVertexString());
                                        }
                                    }
                                    else {
                                        if (this.debug && vtx.index === this.findIndex) {
                                            console.info(this.findIndex + " DISCARDED");
                                        }
                                    }
                                }
                                ;
                            }
                        }
                        deleteFacePoints(face, absorbingFace) {
                            let faceVtxs = this.removeAllPointsFromFace(face);
                            if (faceVtxs != null) {
                                if (absorbingFace == null) {
                                    this.unclaimed.addAll(faceVtxs);
                                }
                                else {
                                    let vtxNext = faceVtxs;
                                    for (let vtx = vtxNext; vtx != null; vtx = vtxNext) {
                                        {
                                            vtxNext = vtx.next;
                                            let dist = absorbingFace.distanceToPlane(vtx.pnt).evaluate();
                                            if (dist > 0) {
                                                this.addPointToFace(vtx, absorbingFace);
                                            }
                                            else {
                                                this.unclaimed.add(vtx);
                                            }
                                        }
                                        ;
                                    }
                                }
                            }
                        }
                        oppFaceDistance(he) {
                            return he.face.distanceToPlane(he.opposite.face.getCentroid());
                        }
                        /*private*/ doAdjacentMerge(face, mergeType) {
                            let hedge = face.he0;
                            let convex = true;
                            do {
                                {
                                    let oppFace = hedge.oppositeFace();
                                    let merge = false;
                                    let tolerance = 0;
                                    if (mergeType === QuickHull3D.NONCONVEX) {
                                        if (this.oppFaceDistance(hedge).evaluate() > -tolerance || this.oppFaceDistance(hedge.opposite).evaluate() > -tolerance) {
                                            merge = true;
                                        }
                                    }
                                    else {
                                        if (face.area > oppFace.area) {
                                            if (this.oppFaceDistance(hedge).evaluate() > -tolerance) {
                                                merge = true;
                                            }
                                            else if (this.oppFaceDistance(hedge.opposite).evaluate() > -tolerance) {
                                                convex = false;
                                            }
                                        }
                                        else {
                                            if (this.oppFaceDistance(hedge.opposite).evaluate() >= -tolerance) {
                                                merge = true;
                                            }
                                            else if (this.oppFaceDistance(hedge).evaluate() >= -tolerance) {
                                                convex = false;
                                            }
                                        }
                                    }
                                    if (merge) {
                                        if (this.debug) {
                                            console.info("  merging " + face.getVertexString() + "  and  " + oppFace.getVertexString());
                                        }
                                        let numd = face.mergeAdjacentFace(hedge, this.discardedFaces);
                                        for (let i = 0; i < numd; i++) {
                                            {
                                                this.deleteFacePoints(this.discardedFaces[i], face);
                                            }
                                            ;
                                        }
                                        if (this.debug) {
                                            console.info("  result: " + face.getVertexString());
                                        }
                                        return true;
                                    }
                                    hedge = hedge.next;
                                }
                            } while ((hedge !== face.he0));
                            if (!convex) {
                                face.mark = com.vzome.core.math.convexhull.Face.NON_CONVEX;
                            }
                            return false;
                        }
                        calculateHorizon(eyePnt, edge0, face, horizon) {
                            this.deleteFacePoints(face, null);
                            face.mark = com.vzome.core.math.convexhull.Face.DELETED;
                            if (this.debug) {
                                console.info("  visiting face " + face.getVertexString());
                            }
                            let edge;
                            if (edge0 == null) {
                                edge0 = face.getEdge(0);
                                edge = edge0;
                            }
                            else {
                                edge = edge0.getNext();
                            }
                            let tolerance = 0;
                            do {
                                {
                                    let oppFace = edge.oppositeFace();
                                    if (oppFace.mark === com.vzome.core.math.convexhull.Face.VISIBLE) {
                                        if (oppFace.distanceToPlane(eyePnt).evaluate() > tolerance) {
                                            this.calculateHorizon(eyePnt, edge.getOpposite(), oppFace, horizon);
                                        }
                                        else {
                                            horizon.add(edge);
                                            if (this.debug) {
                                                console.info("  adding horizon edge " + edge.getVertexString());
                                            }
                                        }
                                    }
                                    edge = edge.getNext();
                                }
                            } while ((edge !== edge0));
                        }
                        /*private*/ addAdjoiningFace(eyeVtx, he) {
                            let face = com.vzome.core.math.convexhull.Face.createTriangle$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(eyeVtx, he.tail(), he.head());
                            this.faces.add(face);
                            face.getEdge(-1).setOpposite(he.getOpposite());
                            return face.getEdge(0);
                        }
                        addNewFaces(newFaces, eyeVtx, horizon) {
                            newFaces.clear();
                            let hedgeSidePrev = null;
                            let hedgeSideBegin = null;
                            for (let index145 = horizon.iterator(); index145.hasNext();) {
                                let horizonHe = index145.next();
                                {
                                    let hedgeSide = this.addAdjoiningFace(eyeVtx, horizonHe);
                                    if (this.debug) {
                                        console.info("new face: " + hedgeSide.face.getVertexString());
                                    }
                                    if (hedgeSidePrev != null) {
                                        hedgeSide.next.setOpposite(hedgeSidePrev);
                                    }
                                    else {
                                        hedgeSideBegin = hedgeSide;
                                    }
                                    newFaces.add(hedgeSide.getFace());
                                    hedgeSidePrev = hedgeSide;
                                }
                            }
                            hedgeSideBegin.next.setOpposite(hedgeSidePrev);
                        }
                        nextPointToAdd() {
                            if (!this.claimed.isEmpty()) {
                                let eyeFace = this.claimed.first().face;
                                let eyeVtx = null;
                                let maxDist = 0;
                                for (let vtx = eyeFace.outside; vtx != null && vtx.face === eyeFace; vtx = vtx.next) {
                                    {
                                        let dist = eyeFace.distanceToPlane(vtx.pnt).evaluate();
                                        if (dist > maxDist) {
                                            maxDist = dist;
                                            eyeVtx = vtx;
                                        }
                                    }
                                    ;
                                }
                                return eyeVtx;
                            }
                            else {
                                return null;
                            }
                        }
                        addPointToHull(eyeVtx) {
                            let horizon = (new java.util.Vector());
                            this.unclaimed.clear();
                            if (this.debug) {
                                console.info("Adding point: " + eyeVtx.index);
                                console.info(" which is " + eyeVtx.face.distanceToPlane(eyeVtx.pnt) + " above face " + eyeVtx.face.getVertexString());
                            }
                            this.removePointFromFace(eyeVtx, eyeVtx.face);
                            this.calculateHorizon(eyeVtx.pnt, null, eyeVtx.face, horizon);
                            this.newFaces.clear();
                            this.addNewFaces(this.newFaces, eyeVtx, horizon);
                            for (let index146 = this.newFaces.iterator(); index146.hasNext();) {
                                let face = index146.next();
                                {
                                    if (face.mark === com.vzome.core.math.convexhull.Face.VISIBLE) {
                                        while ((this.doAdjacentMerge(face, QuickHull3D.NONCONVEX_WRT_LARGER_FACE))) { }
                                        ;
                                    }
                                }
                            }
                            for (let index147 = this.newFaces.iterator(); index147.hasNext();) {
                                let face = index147.next();
                                {
                                    if (face.mark === com.vzome.core.math.convexhull.Face.NON_CONVEX) {
                                        face.mark = com.vzome.core.math.convexhull.Face.VISIBLE;
                                        while ((this.doAdjacentMerge(face, QuickHull3D.NONCONVEX))) { }
                                        ;
                                    }
                                }
                            }
                            this.resolveUnclaimedPoints(this.newFaces);
                        }
                        buildHull() {
                            let cnt = 0;
                            let eyeVtx;
                            this.computeMaxAndMin();
                            this.createInitialSimplex();
                            while (((eyeVtx = this.nextPointToAdd()) != null)) {
                                {
                                    this.addPointToHull(eyeVtx);
                                    cnt++;
                                    if (this.debug) {
                                        console.info("iteration " + cnt + " done");
                                    }
                                }
                            }
                            ;
                            this.reindexFacesAndVertices();
                            if (this.debug) {
                                console.info("hull done");
                            }
                        }
                        /*private*/ markFaceVertices(face, mark) {
                            let he0 = face.getFirstEdge();
                            let he = he0;
                            do {
                                {
                                    he.head().index = mark;
                                    he = he.next;
                                }
                            } while ((he !== he0));
                        }
                        reindexFacesAndVertices() {
                            for (let i = 0; i < this.numPoints; i++) {
                                {
                                    this.pointBuffer[i].index = -1;
                                }
                                ;
                            }
                            this.numFaces = 0;
                            for (let it = this.faces.iterator(); it.hasNext();) {
                                {
                                    let face = it.next();
                                    if (face.mark !== com.vzome.core.math.convexhull.Face.VISIBLE) {
                                        it.remove();
                                    }
                                    else {
                                        this.markFaceVertices(face, 0);
                                        this.numFaces++;
                                    }
                                }
                                ;
                            }
                            this.numVertices = 0;
                            for (let i = 0; i < this.numPoints; i++) {
                                {
                                    let vtx = this.pointBuffer[i];
                                    if (vtx.index === 0) {
                                        this.vertexPointIndices[this.numVertices] = i;
                                        vtx.index = this.numVertices++;
                                    }
                                }
                                ;
                            }
                        }
                        checkFaceConvexity(face, ps) {
                            let he = face.he0;
                            do {
                                {
                                    face.checkConsistency();
                                    let dist = this.oppFaceDistance(he);
                                    if (!dist.isZero()) {
                                        if (ps != null) {
                                            ps.println("Edge " + he.getVertexString() + " non-convex by " + dist);
                                        }
                                        return false;
                                    }
                                    dist = this.oppFaceDistance(he.opposite);
                                    if (!dist.isZero()) {
                                        if (ps != null) {
                                            ps.println("Opposite edge " + he.opposite.getVertexString() + " non-convex by " + dist);
                                        }
                                        return false;
                                    }
                                    if (he.next.oppositeFace() === he.oppositeFace()) {
                                        if (ps != null) {
                                            ps.println("Redundant vertex " + he.head().index + " in face " + face.getVertexString());
                                        }
                                        return false;
                                    }
                                    he = he.next;
                                }
                            } while ((he !== face.he0));
                            return true;
                        }
                        checkFaces(ps) {
                            let convex = true;
                            for (let index148 = this.faces.iterator(); index148.hasNext();) {
                                let face = index148.next();
                                {
                                    if (face.mark === com.vzome.core.math.convexhull.Face.VISIBLE) {
                                        if (!this.checkFaceConvexity(face, ps)) {
                                            convex = false;
                                        }
                                    }
                                }
                            }
                            return convex;
                        }
                        /**
                         * Checks the correctness of the hull. This is done by making sure that no faces
                         * are non-convex and that no points are outside any face. These tests are
                         * performed using the distance tolerance <i>tol</i>. Faces are considered
                         * non-convex if any edge is non-convex, and an edge is non-convex if the
                         * centroid of either adjoining face is more than <i>tol</i> above the plane of
                         * the other face. Similarly, a point is considered outside a face if its
                         * distance to that face's plane is more than 10 times <i>tol</i>.
                         *
                         * <p>
                         * If the hull has been {@link #triangulate}, then this routine may
                         * fail if some of the resulting triangles are very small or thin.
                         *
                         * @param {java.io.PrintStream} ps
                         * print stream for diagnostic messages; may be set to
                         * <code>null</code> if no messages are desired.
                         * @return {boolean} true if the hull is valid
                         * @throws Failure
                         * @see QuickHull3D#check(PrintStream)
                         */
                        check(ps) {
                            if (!this.checkFaces(ps)) {
                                return false;
                            }
                            for (let i = 0; i < this.numPoints; i++) {
                                {
                                    let pnt = this.pointBuffer[i].pnt;
                                    for (let index149 = this.faces.iterator(); index149.hasNext();) {
                                        let face = index149.next();
                                        {
                                            if (face.mark === com.vzome.core.math.convexhull.Face.VISIBLE) {
                                                let dist = face.distanceToPlane(pnt);
                                                if (!dist.isZero()) {
                                                    if (ps != null) {
                                                        ps.println("Point " + i + " " + dist + " above face " + face.getVertexString());
                                                    }
                                                    return false;
                                                }
                                            }
                                        }
                                    }
                                }
                                ;
                            }
                            return true;
                        }
                    }
                    /**
                     * Specifies that (on output) vertex indices for a face should be listed in
                     * clockwise order.
                     */
                    QuickHull3D.CLOCKWISE = 1;
                    /**
                     * Specifies that (on output) the vertex indices for a face should be numbered
                     * starting from 1.
                     */
                    QuickHull3D.INDEXED_FROM_ONE = 2;
                    /**
                     * Specifies that (on output) the vertex indices for a face should be numbered
                     * starting from 0.
                     */
                    QuickHull3D.INDEXED_FROM_ZERO = 4;
                    /**
                     * Specifies that (on output) the vertex indices for a face should be numbered
                     * with respect to the original input points.
                     */
                    QuickHull3D.POINT_RELATIVE = 8;
                    QuickHull3D.NONCONVEX_WRT_LARGER_FACE = 1;
                    QuickHull3D.NONCONVEX = 2;
                    convexhull.QuickHull3D = QuickHull3D;
                    QuickHull3D["__class"] = "com.vzome.core.math.convexhull.QuickHull3D";
                })(convexhull = math.convexhull || (math.convexhull = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var convexhull;
                (function (convexhull) {
                    /**
                     * Maintains a double-linked list of vertices for use by QuickHull3D
                     * @class
                     */
                    class VertexList {
                        constructor() {
                            if (this.head === undefined)
                                this.head = null;
                            if (this.tail === undefined)
                                this.tail = null;
                        }
                        /**
                         * Clears this list.
                         */
                        clear() {
                            this.head = this.tail = null;
                        }
                        /**
                         * Adds a vertex to the end of this list.
                         * @param {com.vzome.core.math.convexhull.Vertex} vtx
                         */
                        add(vtx) {
                            if (this.head == null) {
                                this.head = vtx;
                            }
                            else {
                                this.tail.next = vtx;
                            }
                            vtx.prev = this.tail;
                            vtx.next = null;
                            this.tail = vtx;
                        }
                        /**
                         * Adds a chain of vertices to the end of this list.
                         * @param {com.vzome.core.math.convexhull.Vertex} vtx
                         */
                        addAll(vtx) {
                            if (this.head == null) {
                                this.head = vtx;
                            }
                            else {
                                this.tail.next = vtx;
                            }
                            vtx.prev = this.tail;
                            while ((vtx.next != null)) {
                                {
                                    vtx = vtx.next;
                                }
                            }
                            ;
                            this.tail = vtx;
                        }
                        delete$com_vzome_core_math_convexhull_Vertex(vtx) {
                            if (vtx.prev == null) {
                                this.head = vtx.next;
                            }
                            else {
                                vtx.prev.next = vtx.next;
                            }
                            if (vtx.next == null) {
                                this.tail = vtx.prev;
                            }
                            else {
                                vtx.next.prev = vtx.prev;
                            }
                        }
                        delete$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx1, vtx2) {
                            if (vtx1.prev == null) {
                                this.head = vtx2.next;
                            }
                            else {
                                vtx1.prev.next = vtx2.next;
                            }
                            if (vtx2.next == null) {
                                this.tail = vtx1.prev;
                            }
                            else {
                                vtx2.next.prev = vtx1.prev;
                            }
                        }
                        /**
                         * Deletes a chain of vertices from this list.
                         * @param {com.vzome.core.math.convexhull.Vertex} vtx1
                         * @param {com.vzome.core.math.convexhull.Vertex} vtx2
                         */
                        delete(vtx1, vtx2) {
                            if (((vtx1 != null && vtx1 instanceof com.vzome.core.math.convexhull.Vertex) || vtx1 === null) && ((vtx2 != null && vtx2 instanceof com.vzome.core.math.convexhull.Vertex) || vtx2 === null)) {
                                return this.delete$com_vzome_core_math_convexhull_Vertex$com_vzome_core_math_convexhull_Vertex(vtx1, vtx2);
                            }
                            else if (((vtx1 != null && vtx1 instanceof com.vzome.core.math.convexhull.Vertex) || vtx1 === null) && vtx2 === undefined) {
                                return this.delete$com_vzome_core_math_convexhull_Vertex(vtx1);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         * Inserts a vertex into this list before another specificed vertex.
                         * @param {com.vzome.core.math.convexhull.Vertex} vtx
                         * @param {com.vzome.core.math.convexhull.Vertex} next
                         */
                        insertBefore(vtx, next) {
                            vtx.prev = next.prev;
                            if (next.prev == null) {
                                this.head = vtx;
                            }
                            else {
                                next.prev.next = vtx;
                            }
                            vtx.next = next;
                            next.prev = vtx;
                        }
                        /**
                         * Returns the first element in this list.
                         * @return {com.vzome.core.math.convexhull.Vertex}
                         */
                        first() {
                            return this.head;
                        }
                        /**
                         * Returns true if this list is empty.
                         * @return {boolean}
                         */
                        isEmpty() {
                            return this.head == null;
                        }
                    }
                    convexhull.VertexList = VertexList;
                    VertexList["__class"] = "com.vzome.core.math.convexhull.VertexList";
                })(convexhull = math.convexhull || (math.convexhull = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var convexhull;
                (function (convexhull) {
                    /**
                     * Constructs a HalfEdge with head vertex <code>v</code> and left-hand
                     * triangular face <code>f</code>.
                     *
                     * @param {com.vzome.core.math.convexhull.Vertex} v
                     * head vertex
                     * @param {com.vzome.core.math.convexhull.Face} f
                     * left-hand triangular face
                     * @class
                     * @author John E. Lloyd, Fall 2004
                     */
                    class HalfEdge {
                        constructor(v, f) {
                            if (((v != null && v instanceof com.vzome.core.math.convexhull.Vertex) || v === null) && ((f != null && f instanceof com.vzome.core.math.convexhull.Face) || f === null)) {
                                let __args = arguments;
                                if (this.vertex === undefined)
                                    this.vertex = null;
                                if (this.face === undefined)
                                    this.face = null;
                                if (this.next === undefined)
                                    this.next = null;
                                if (this.prev === undefined)
                                    this.prev = null;
                                if (this.opposite === undefined)
                                    this.opposite = null;
                                if (this.vertex === undefined)
                                    this.vertex = null;
                                if (this.face === undefined)
                                    this.face = null;
                                if (this.next === undefined)
                                    this.next = null;
                                if (this.prev === undefined)
                                    this.prev = null;
                                if (this.opposite === undefined)
                                    this.opposite = null;
                                (() => {
                                    this.vertex = v;
                                    this.face = f;
                                })();
                            }
                            else if (v === undefined && f === undefined) {
                                let __args = arguments;
                                if (this.vertex === undefined)
                                    this.vertex = null;
                                if (this.face === undefined)
                                    this.face = null;
                                if (this.next === undefined)
                                    this.next = null;
                                if (this.prev === undefined)
                                    this.prev = null;
                                if (this.opposite === undefined)
                                    this.opposite = null;
                                if (this.vertex === undefined)
                                    this.vertex = null;
                                if (this.face === undefined)
                                    this.face = null;
                                if (this.next === undefined)
                                    this.next = null;
                                if (this.prev === undefined)
                                    this.prev = null;
                                if (this.opposite === undefined)
                                    this.opposite = null;
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         * Sets the value of the next edge adjacent (counter-clockwise) to this one
                         * within the triangle.
                         *
                         * @param {com.vzome.core.math.convexhull.HalfEdge} edge
                         * next adjacent edge
                         */
                        setNext(edge) {
                            this.next = edge;
                        }
                        /**
                         * Gets the value of the next edge adjacent (counter-clockwise) to this one
                         * within the triangle.
                         *
                         * @return {com.vzome.core.math.convexhull.HalfEdge} next adjacent edge
                         */
                        getNext() {
                            return this.next;
                        }
                        /**
                         * Sets the value of the previous edge adjacent (clockwise) to this one within
                         * the triangle.
                         *
                         * @param {com.vzome.core.math.convexhull.HalfEdge} edge
                         * previous adjacent edge
                         */
                        setPrev(edge) {
                            this.prev = edge;
                        }
                        /**
                         * Gets the value of the previous edge adjacent (clockwise) to this one within
                         * the triangle.
                         *
                         * @return {com.vzome.core.math.convexhull.HalfEdge} previous adjacent edge
                         */
                        getPrev() {
                            return this.prev;
                        }
                        /**
                         * Returns the triangular face located to the left of this half-edge.
                         *
                         * @return {com.vzome.core.math.convexhull.Face} left-hand triangular face
                         */
                        getFace() {
                            return this.face;
                        }
                        /**
                         * Returns the half-edge opposite to this half-edge.
                         *
                         * @return {com.vzome.core.math.convexhull.HalfEdge} opposite half-edge
                         */
                        getOpposite() {
                            return this.opposite;
                        }
                        /**
                         * Sets the half-edge opposite to this half-edge.
                         *
                         * @param {com.vzome.core.math.convexhull.HalfEdge} edge
                         * opposite half-edge
                         */
                        setOpposite(edge) {
                            this.opposite = edge;
                            edge.opposite = this;
                        }
                        /**
                         * Returns the head vertex associated with this half-edge.
                         *
                         * @return {com.vzome.core.math.convexhull.Vertex} head vertex
                         */
                        head() {
                            return this.vertex;
                        }
                        /**
                         * Returns the tail vertex associated with this half-edge.
                         *
                         * @return {com.vzome.core.math.convexhull.Vertex} tail vertex
                         */
                        tail() {
                            return this.prev != null ? this.prev.vertex : null;
                        }
                        /**
                         * Returns the opposite triangular face associated with this half-edge.
                         *
                         * @return {com.vzome.core.math.convexhull.Face} opposite triangular face
                         */
                        oppositeFace() {
                            return this.opposite == null ? null : this.opposite.face;
                        }
                        /**
                         * Produces a string identifying this half-edge by the point index values of its
                         * tail and head vertices.
                         *
                         * @return {string} identifying string
                         */
                        getVertexString() {
                            if (this.tail() != null) {
                                return "" + this.tail().index + "-" + this.head().index;
                            }
                            else {
                                return "?-" + this.head().index;
                            }
                        }
                        /**
                         * Returns the length squared of this half-edge.
                         *
                         * @return {*} half-edge length squared
                         */
                        lengthSquared() {
                            if (this.tail() == null) {
                                return this.head().pnt.getField()['createRational$long'](-1);
                            }
                            let offset = this.head().pnt.minus(this.tail().pnt);
                            return offset.dot(offset);
                        }
                    }
                    convexhull.HalfEdge = HalfEdge;
                    HalfEdge["__class"] = "com.vzome.core.math.convexhull.HalfEdge";
                })(convexhull = math.convexhull || (math.convexhull = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} field
                 * @class
                 */
                class SixCubeProjection {
                    constructor(field) {
                        if (this.field === undefined)
                            this.field = null;
                        if (this.basis === undefined)
                            this.basis = null;
                        this.field = field;
                        let zero = field.zero();
                        let one = field.one();
                        let nOne = one.negate();
                        let phi = field['createPower$int'](1);
                        this.basis = [null, null, null, null, null, null];
                        this.basis[0] = new com.vzome.core.algebra.AlgebraicVector(phi, one, zero);
                        this.basis[1] = new com.vzome.core.algebra.AlgebraicVector(phi, nOne, zero);
                        this.basis[2] = new com.vzome.core.algebra.AlgebraicVector(zero, phi, one);
                        this.basis[3] = new com.vzome.core.algebra.AlgebraicVector(zero, phi, nOne);
                        this.basis[4] = new com.vzome.core.algebra.AlgebraicVector(one, zero, phi);
                        this.basis[5] = new com.vzome.core.algebra.AlgebraicVector(nOne, zero, phi);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} source
                     * @param {boolean} wFirst
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    projectImage(source, wFirst) {
                        let result = this.field.origin(this.basis[0].dimension());
                        let pos = wFirst ? 0 : this.basis.length - 1;
                        for (let index150 = 0; index150 < this.basis.length; index150++) {
                            let unitVector = this.basis[index150];
                            {
                                let scalar = source.getComponent(pos);
                                result = result.plus(unitVector.scale(scalar));
                                pos = (pos + 1) % this.basis.length;
                            }
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    setXmlAttributes(xml) {
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getProjectionName() {
                        return "SixCube";
                    }
                }
                math.SixCubeProjection = SixCubeProjection;
                SixCubeProjection["__class"] = "com.vzome.core.math.SixCubeProjection";
                SixCubeProjection["__interfaces"] = ["com.vzome.core.math.Projection"];
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class A4Group {
                        constructor(field) {
                            if (this.field === undefined)
                                this.field = null;
                            this.ROOTS = [null, null, null, null];
                            this.WEIGHTS = [null, null, null, null];
                            this.ROOTS_R4 = [null, null, null, null];
                            if (this.ONE_FIFTH === undefined)
                                this.ONE_FIFTH = null;
                            if (this.TWO_FIFTHS === undefined)
                                this.TWO_FIFTHS = null;
                            if (this.THREE_FIFTHS === undefined)
                                this.THREE_FIFTHS = null;
                            if (this.FOUR_FIFTHS === undefined)
                                this.FOUR_FIFTHS = null;
                            this.field = field;
                            this.ONE_FIFTH = field['createRational$long$long'](1, 5);
                            this.TWO_FIFTHS = field['createRational$long$long'](2, 5);
                            this.THREE_FIFTHS = field['createRational$long$long'](3, 5);
                            this.FOUR_FIFTHS = field['createRational$long$long'](4, 5);
                            let neg_one = field['createRational$long'](-1);
                            this.ROOTS[0] = field.basisVector(5, 0);
                            this.ROOTS[0].setComponent(1, neg_one);
                            this.ROOTS[1] = field.basisVector(5, 1);
                            this.ROOTS[1].setComponent(2, neg_one);
                            this.ROOTS[2] = field.basisVector(5, 2);
                            this.ROOTS[2].setComponent(3, neg_one);
                            this.ROOTS[3] = field.basisVector(5, 3);
                            this.ROOTS[3].setComponent(4, neg_one);
                            this.WEIGHTS[0] = field.basisVector(5, 0);
                            this.WEIGHTS[0].setComponent(0, this.FOUR_FIFTHS);
                            this.WEIGHTS[0].setComponent(1, this.ONE_FIFTH.negate());
                            this.WEIGHTS[0].setComponent(2, this.ONE_FIFTH.negate());
                            this.WEIGHTS[0].setComponent(3, this.ONE_FIFTH.negate());
                            this.WEIGHTS[0].setComponent(4, this.ONE_FIFTH.negate());
                            this.WEIGHTS[1] = field.basisVector(5, 0);
                            this.WEIGHTS[1].setComponent(0, this.THREE_FIFTHS);
                            this.WEIGHTS[1].setComponent(1, this.THREE_FIFTHS);
                            this.WEIGHTS[1].setComponent(2, this.TWO_FIFTHS.negate());
                            this.WEIGHTS[1].setComponent(3, this.TWO_FIFTHS.negate());
                            this.WEIGHTS[1].setComponent(4, this.TWO_FIFTHS.negate());
                            this.WEIGHTS[2] = field.basisVector(5, 0);
                            this.WEIGHTS[2].setComponent(0, this.TWO_FIFTHS);
                            this.WEIGHTS[2].setComponent(1, this.TWO_FIFTHS);
                            this.WEIGHTS[2].setComponent(2, this.TWO_FIFTHS);
                            this.WEIGHTS[2].setComponent(3, this.THREE_FIFTHS.negate());
                            this.WEIGHTS[2].setComponent(4, this.THREE_FIFTHS.negate());
                            this.WEIGHTS[3] = field.basisVector(5, 0);
                            this.WEIGHTS[3].setComponent(0, this.ONE_FIFTH);
                            this.WEIGHTS[3].setComponent(1, this.ONE_FIFTH);
                            this.WEIGHTS[3].setComponent(2, this.ONE_FIFTH);
                            this.WEIGHTS[3].setComponent(3, this.ONE_FIFTH);
                            this.WEIGHTS[3].setComponent(4, this.FOUR_FIFTHS.negate());
                            let two = field['createRational$long'](2);
                            let two_neg = field['createRational$long'](-2);
                            this.ROOTS_R4[0] = field.basisVector(4, 1);
                            this.ROOTS_R4[0].setComponent(1, two);
                            this.ROOTS_R4[0].setComponent(2, two_neg);
                            this.ROOTS_R4[1] = field.basisVector(4, 1);
                            this.ROOTS_R4[1].setComponent(3, two_neg);
                            this.ROOTS_R4[1].setComponent(1, two_neg);
                            this.ROOTS_R4[2] = field.basisVector(4, 1);
                            this.ROOTS_R4[2].setComponent(1, two);
                            this.ROOTS_R4[2].setComponent(2, two);
                            this.ROOTS_R4[3] = field.basisVector(4, 3);
                            let root5 = field['createAlgebraicNumber$int$int$int$int'](-1, 2, 1, 0);
                            this.ROOTS_R4[3].setComponent(1, neg_one);
                            this.ROOTS_R4[3].setComponent(2, neg_one);
                            this.ROOTS_R4[3].setComponent(0, root5);
                        }
                        static S5_PERMS_$LI$() { if (A4Group.S5_PERMS == null)
                            A4Group.S5_PERMS = [[0, 1, 2, 3, 4], [1, 2, 3, 4, 0], [2, 3, 4, 0, 1], [3, 4, 0, 1, 2], [4, 0, 1, 2, 3], [1, 2, 0, 3, 4], [2, 0, 3, 4, 1], [0, 3, 4, 1, 2], [3, 4, 1, 2, 0], [4, 1, 2, 0, 3], [0, 2, 3, 1, 4], [2, 3, 1, 4, 0], [3, 1, 4, 0, 2], [1, 4, 0, 2, 3], [4, 0, 2, 3, 1], [0, 1, 3, 4, 2], [1, 3, 4, 2, 0], [3, 4, 2, 0, 1], [4, 2, 0, 1, 3], [2, 0, 1, 3, 4], [3, 1, 2, 4, 0], [1, 2, 4, 0, 3], [2, 4, 0, 3, 1], [4, 0, 3, 1, 2], [0, 3, 1, 2, 4], [1, 4, 2, 3, 0], [4, 2, 3, 0, 1], [2, 3, 0, 1, 4], [3, 0, 1, 4, 2], [0, 1, 4, 2, 3], [1, 3, 2, 0, 4], [3, 2, 0, 4, 1], [2, 0, 4, 1, 3], [0, 4, 1, 3, 2], [4, 1, 3, 2, 0], [0, 2, 4, 3, 1], [2, 4, 3, 1, 0], [4, 3, 1, 0, 2], [3, 1, 0, 2, 4], [1, 0, 2, 4, 3], [2, 1, 3, 0, 4], [1, 3, 0, 4, 2], [3, 0, 4, 2, 1], [0, 4, 2, 1, 3], [4, 2, 1, 3, 0], [0, 3, 2, 4, 1], [3, 2, 4, 1, 0], [2, 4, 1, 0, 3], [4, 1, 0, 3, 2], [1, 0, 3, 2, 4], [2, 1, 4, 3, 0], [1, 4, 3, 0, 2], [4, 3, 0, 2, 1], [3, 0, 2, 1, 4], [0, 2, 1, 4, 3], [4, 3, 2, 1, 0], [3, 2, 1, 0, 4], [2, 1, 0, 4, 3], [1, 0, 4, 3, 2], [0, 4, 3, 2, 1], [0, 1, 3, 2, 4], [0, 2, 1, 3, 4], [0, 3, 2, 1, 4], [1, 0, 2, 3, 4], [1, 2, 3, 0, 4], [1, 3, 0, 2, 4], [2, 1, 0, 3, 4], [2, 0, 3, 1, 4], [2, 3, 1, 0, 4], [3, 1, 2, 0, 4], [3, 2, 0, 1, 4], [3, 0, 1, 2, 4], [0, 1, 2, 4, 3], [0, 2, 3, 4, 1], [0, 3, 1, 4, 2], [1, 0, 3, 4, 2], [1, 2, 0, 4, 3], [1, 3, 2, 4, 0], [2, 1, 3, 4, 0], [2, 0, 1, 4, 3], [2, 3, 0, 4, 1], [3, 1, 0, 4, 2], [3, 2, 1, 4, 0], [3, 0, 2, 4, 1], [0, 2, 4, 1, 3], [0, 3, 4, 2, 1], [1, 0, 4, 2, 3], [1, 2, 4, 3, 0], [1, 3, 4, 0, 2], [2, 1, 4, 0, 3], [2, 0, 4, 3, 1], [2, 3, 4, 1, 0], [3, 1, 4, 2, 0], [3, 2, 4, 0, 1], [3, 0, 4, 1, 2], [0, 4, 1, 2, 3], [0, 4, 2, 3, 1], [0, 4, 3, 1, 2], [1, 4, 0, 3, 2], [1, 4, 2, 0, 3], [1, 4, 3, 2, 0], [2, 4, 1, 3, 0], [2, 4, 0, 1, 3], [2, 4, 3, 0, 1], [3, 4, 1, 0, 2], [3, 4, 2, 1, 0], [3, 4, 0, 2, 1], [4, 0, 1, 3, 2], [4, 0, 2, 1, 3], [4, 0, 3, 2, 1], [4, 1, 0, 2, 3], [4, 1, 2, 3, 0], [4, 1, 3, 0, 2], [4, 2, 1, 0, 3], [4, 2, 0, 3, 1], [4, 2, 3, 1, 0], [4, 3, 1, 2, 0], [4, 3, 2, 0, 1], [0, 1, 4, 3, 2], [4, 3, 0, 1, 2]]; return A4Group.S5_PERMS; }
                        ;
                        /**
                         *
                         * @return {number}
                         */
                        getOrder() {
                            return A4Group.S5_PERMS_$LI$().length;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        groupAction(model, element) {
                            let result = this.field.origin(4);
                            let sum = this.field['createRational$long'](0);
                            for (let c = 0; c < 4; c++) {
                                {
                                    let source = model.getComponent(A4Group.S5_PERMS_$LI$()[element][c]);
                                    sum = sum['plus$com_vzome_core_algebra_AlgebraicNumber'](source);
                                    let scaled = this.ROOTS_R4[c].scale(sum);
                                    result = result.plus(scaled);
                                }
                                ;
                            }
                            return result.scale(this.field['createPower$int'](-1));
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getOrigin() {
                            return this.field.origin(5);
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getWeight(i) {
                            return this.WEIGHTS[i];
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getSimpleRoot(i) {
                            return this.ROOTS[i];
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getField() {
                            return this.field;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        chiralSubgroupAction(model, element) {
                            if (element >= 60)
                                return null;
                            let result = this.field.origin(4);
                            let sum = this.field['createRational$long'](0);
                            for (let c = 0; c < 4; c++) {
                                {
                                    let source = model.getComponent(A4Group.S5_PERMS_$LI$()[element][c]);
                                    sum = sum['plus$com_vzome_core_algebra_AlgebraicNumber'](source);
                                    let scaled = this.ROOTS_R4[c].scale(sum);
                                    result = result.plus(scaled);
                                }
                                ;
                            }
                            return result.scale(this.field['createPower$int'](-1));
                        }
                    }
                    symmetry.A4Group = A4Group;
                    A4Group["__class"] = "com.vzome.core.math.symmetry.A4Group";
                    A4Group["__interfaces"] = ["com.vzome.core.math.symmetry.CoxeterGroup"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class WythoffConstruction {
                        static constructPolytope(group, index, edgesToRender, edgeScales, renderingGroup, listener) {
                            let neighbors = [null, null, null, null];
                            let chiral = false;
                            if (chiral) {
                                index = edgesToRender = 15;
                            }
                            let origin = group.getOrigin();
                            let model = origin;
                            let bits = index;
                            for (let i = 0; i < 4; i++) {
                                {
                                    if (bits % 2 === 1)
                                        model = model.plus(group.getWeight(i).scale(edgeScales[i]));
                                    bits >>= 1;
                                }
                                ;
                            }
                            bits = index;
                            for (let i = 0; i < 4; i++) {
                                {
                                    if ((bits % 2 === 1) && (edgesToRender % 2 === 1))
                                        neighbors[i] = model.minus(group.getSimpleRoot(i).scale(edgeScales[i]));
                                    else
                                        neighbors[i] = origin;
                                    bits >>= 1;
                                    edgesToRender >>= 1;
                                }
                                ;
                            }
                            let order = renderingGroup.getOrder();
                            if (chiral) {
                                for (let i = 0; i < order; i++) {
                                    {
                                        let vector = renderingGroup.chiralSubgroupAction(model, i);
                                        if (vector == null)
                                            continue;
                                        for (let e = 0; e < 4; e++) {
                                            for (let f = e + 1; f < 4; f++) {
                                                {
                                                    let v1 = renderingGroup.chiralSubgroupAction(neighbors[e], i);
                                                    let p1 = listener.addVertex(v1);
                                                    let v2 = renderingGroup.chiralSubgroupAction(neighbors[f], i);
                                                    let p2 = listener.addVertex(v2);
                                                    listener.addEdge(p1, p2);
                                                }
                                                ;
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            }
                            else
                                for (let i = 0; i < order; i++) {
                                    {
                                        let vector = renderingGroup.groupAction(model, i);
                                        let p = listener.addVertex(vector);
                                        for (let e = 0; e < 4; e++) {
                                            {
                                                if (neighbors[e].equals(origin))
                                                    continue;
                                                let other = renderingGroup.groupAction(neighbors[e], i);
                                                if (!other.equals(vector)) {
                                                    let p2 = listener.addVertex(other);
                                                    listener.addEdge(p, p2);
                                                }
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                        }
                    }
                    symmetry.WythoffConstruction = WythoffConstruction;
                    WythoffConstruction["__class"] = "com.vzome.core.math.symmetry.WythoffConstruction";
                    (function (WythoffConstruction) {
                        class VefPrinter {
                            constructor(field2) {
                                this.vefVertices = new java.lang.StringBuffer();
                                this.vefEdges = new java.lang.StringBuffer();
                                this.numEdges = 0;
                                this.numVertices = 0;
                                if (this.field === undefined)
                                    this.field = null;
                                this.field = field2;
                            }
                            /**
                             *
                             * @param {*} p1
                             * @param {*} p2
                             * @return {*}
                             */
                            addEdge(p1, p2) {
                                this.vefEdges.append(p1 + "\t" + p2 + "\n");
                                ++this.numEdges;
                                return null;
                            }
                            /**
                             *
                             * @param {Array} vertices
                             * @return {*}
                             */
                            addFace(vertices) {
                                return null;
                            }
                            /**
                             *
                             * @param {com.vzome.core.algebra.AlgebraicVector} gv
                             * @return {*}
                             */
                            addVertex(gv) {
                                gv.getVectorExpression$java_lang_StringBuffer$int(this.vefVertices, com.vzome.core.algebra.AlgebraicField.VEF_FORMAT);
                                this.vefVertices.append("\n");
                                return this.numVertices++;
                            }
                            print(out) {
                                out.println$java_lang_Object("vZome VEF 5");
                                out.println$java_lang_Object(this.numVertices);
                                out.println$java_lang_Object(this.vefVertices.toString());
                                out.println$java_lang_Object(this.numEdges);
                                out.println$java_lang_Object(this.vefEdges.toString());
                                out.close();
                            }
                        }
                        WythoffConstruction.VefPrinter = VefPrinter;
                        VefPrinter["__class"] = "com.vzome.core.math.symmetry.WythoffConstruction.VefPrinter";
                        VefPrinter["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];
                    })(WythoffConstruction = symmetry.WythoffConstruction || (symmetry.WythoffConstruction = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class D4Group {
                        constructor(field) {
                            if (this.field === undefined)
                                this.field = null;
                            this.ROOTS = [null, null, null, null];
                            this.WEIGHTS = [null, null, null, null];
                            this.field = field;
                            let neg_one = field['createRational$long'](-1);
                            this.ROOTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.ROOTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_one);
                            this.ROOTS[1] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
                            this.ROOTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_one);
                            this.ROOTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
                            this.ROOTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_one);
                            this.ROOTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
                            this.ROOTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, field['createPower$int'](0));
                            let y = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
                            let half = field['createRational$long$long'](1, 2);
                            let neg_half = field['createRational$long$long'](-1, 2);
                            this.WEIGHTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.WEIGHTS[1] = this.WEIGHTS[0].plus(y);
                            this.WEIGHTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_half);
                            this.WEIGHTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, half);
                        }
                        static D4_PERMS_$LI$() { if (D4Group.D4_PERMS == null)
                            D4Group.D4_PERMS = [[0, 1, 2, 3], [2, 3, 0, 1], [1, 0, 3, 2], [3, 2, 1, 0], [2, 1, 3, 0], [3, 0, 2, 1], [1, 2, 0, 3], [0, 3, 1, 2], [0, 2, 3, 1], [3, 1, 0, 2], [2, 0, 1, 3], [1, 3, 2, 0], [1, 0, 2, 3], [2, 3, 1, 0], [0, 1, 3, 2], [3, 2, 0, 1], [0, 2, 1, 3], [1, 3, 0, 2], [2, 0, 3, 1], [3, 1, 2, 0], [2, 1, 0, 3], [0, 3, 2, 1], [1, 2, 3, 0], [3, 0, 1, 2]]; return D4Group.D4_PERMS; }
                        ;
                        /**
                         *
                         * @return {number}
                         */
                        getOrder() {
                            return 24 * 8;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        groupAction(model, element) {
                            let result = this.field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            let perm = (element / 8 | 0);
                            let signs = element % 8;
                            let even = true;
                            for (let c = 0; c < 4; c++) {
                                {
                                    let source = model.getComponent((D4Group.D4_PERMS_$LI$()[perm][c] + 1) % 4);
                                    if (c === 3 && !even) {
                                        source = source.negate();
                                    }
                                    else if (signs % 2 !== 0) {
                                        even = !even;
                                        source = source.negate();
                                    }
                                    result.setComponent((c + 1) % 4, source);
                                    signs = signs >> 1;
                                }
                                ;
                            }
                            return result;
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getOrigin() {
                            return this.field.origin(4);
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getWeight(i) {
                            return this.WEIGHTS[i];
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getSimpleRoot(i) {
                            return this.ROOTS[i];
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getField() {
                            return this.field;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        chiralSubgroupAction(model, element) {
                            let result = this.field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            let perm = (element / 8 | 0);
                            if (perm >= 12)
                                return null;
                            let signs = element % 8;
                            let even = true;
                            for (let c = 0; c < 4; c++) {
                                {
                                    let source = model.getComponent((D4Group.D4_PERMS_$LI$()[perm][c] + 1) % 4);
                                    if (c === 3 && !even) {
                                        source = source.negate();
                                    }
                                    else if (signs % 2 !== 0) {
                                        even = !even;
                                        source = source.negate();
                                    }
                                    result.setComponent((c + 1) % 4, source);
                                    signs = signs >> 1;
                                }
                                ;
                            }
                            return result;
                        }
                    }
                    symmetry.D4Group = D4Group;
                    D4Group["__class"] = "com.vzome.core.math.symmetry.D4Group";
                    D4Group["__interfaces"] = ["com.vzome.core.math.symmetry.CoxeterGroup"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class Permutation {
                        constructor(group, map) {
                            if (this.m_map === undefined)
                                this.m_map = null;
                            this.m_order = 1;
                            if (this.mSymmetryGroup === undefined)
                                this.mSymmetryGroup = null;
                            this.mSymmetryGroup = group;
                            if (map == null) {
                                let numUnits = group.getChiralOrder();
                                map = (s => { let a = []; while (s-- > 0)
                                    a.push(0); return a; })(numUnits);
                                for (let unit = 0; unit < numUnits; unit++) {
                                    map[unit] = unit;
                                }
                            }
                            this.m_map = map;
                            let unit = 0;
                            for (let i = 0; i < 20; i++) {
                                {
                                    unit = this.m_map[unit];
                                    if (unit === 0) {
                                        this.m_order = i + 1;
                                        break;
                                    }
                                }
                                ;
                            }
                        }
                        getJsonValue() {
                            return this.m_map;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        toString() {
                            return "permutation #" + this.mapIndex(0);
                        }
                        getOrder() {
                            return this.m_order;
                        }
                        /**
                         * Composition, where p1.compose( p2 ) .permute(axis)  == p1.permute( p2.permute( axis ) )
                         * @param {com.vzome.core.math.symmetry.Permutation} other
                         * @return {com.vzome.core.math.symmetry.Permutation}
                         */
                        compose(other) {
                            return this.mSymmetryGroup.getPermutation(this.m_map[other.m_map[0]]);
                        }
                        inverse() {
                            for (let i = 0; i < this.m_map.length; i++) {
                                if (this.mapIndex(i) === 0)
                                    return this.mSymmetryGroup.getPermutation(i);
                                ;
                            }
                            return null;
                        }
                        power(power) {
                            if (power === 0)
                                return this.mSymmetryGroup.getPermutation(0);
                            let base = this;
                            if (power < 0) {
                                base = this.inverse();
                                power *= -1;
                            }
                            if (power === 1)
                                return base;
                            return base.compose(base.power(power - 1));
                        }
                        mapIndex(i) {
                            if ((i < 0) || (i >= this.m_map.length))
                                return com.vzome.core.math.symmetry.Symmetry.NO_ROTATION;
                            return this.m_map[i];
                        }
                        permute(axis, sense) {
                            let orn = axis.getOrientation();
                            orn = this.mapIndex(orn);
                            return axis.getDirection().getAxis$int$int((sense + axis.getSense()) % 2, orn);
                        }
                    }
                    symmetry.Permutation = Permutation;
                    Permutation["__class"] = "com.vzome.core.math.symmetry.Permutation";
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry_1) {
                    class OrbitDotLocator {
                        constructor(symmetry, worldTriangle) {
                            if (this.worldTrianglePoint === undefined)
                                this.worldTrianglePoint = null;
                            if (this.worldTriangleNormal === undefined)
                                this.worldTriangleNormal = null;
                            if (this.dotTransform === undefined)
                                this.dotTransform = null;
                            if (this.orbitProbe === undefined)
                                this.orbitProbe = null;
                            if (this.symmetry === undefined)
                                this.symmetry = null;
                            if (this.debugger === undefined)
                                this.debugger = null;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.vefDebugOutput === undefined)
                                this.vefDebugOutput = null;
                            this.symmetry = symmetry;
                            this.field = symmetry.getField();
                            let oldMatrix = new com.vzome.core.algebra.AlgebraicMatrix(worldTriangle);
                            let X = this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                            let Y = this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
                            let Z = this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                            let viewTriangle = [Z, X.plus(Z), Y.plus(Z)];
                            let newMatrix = new com.vzome.core.algebra.AlgebraicMatrix(viewTriangle);
                            this.dotTransform = newMatrix.times(oldMatrix.inverse());
                            let blueVertex = worldTriangle[0];
                            let redVertex = worldTriangle[1];
                            let yellowVertex = worldTriangle[2];
                            this.orbitProbe = redVertex.plus(yellowVertex.plus(blueVertex)).toRealVector();
                            this.worldTrianglePoint = blueVertex;
                            this.worldTriangleNormal = com.vzome.core.algebra.AlgebraicVectors.getNormal$java_util_Collection(java.util.Arrays.asList(worldTriangle));
                            if (this.debugger != null) {
                                this.debugger.exportSegment(this.field.origin(3), redVertex);
                                this.debugger.exportPoint(redVertex);
                                this.debugger.exportSegment(this.field.origin(3), yellowVertex);
                                this.debugger.exportPoint(yellowVertex);
                                this.debugger.exportSegment(this.field.origin(3), blueVertex);
                                this.debugger.exportPoint(blueVertex);
                                this.debugger.exportPolygon(java.util.Arrays.asList(worldTriangle));
                                this.debugger.exportPolygon(java.util.Arrays.asList(viewTriangle));
                                this.debugger.exportSegment(blueVertex, this.worldTriangleNormal);
                            }
                        }
                        enableDebugger() {
                            this.vefDebugOutput = new java.io.StringWriter();
                            this.debugger = new com.vzome.core.algebra.VefVectorExporter(this.vefDebugOutput, this.field);
                        }
                        locateOrbitDot(orbit) {
                            let dotZone = this.symmetry['getAxis$com_vzome_core_math_RealVector$java_util_Set'](this.orbitProbe, java.util.Collections.singleton(orbit)).normal();
                            let lineStart = this.field.origin(3);
                            let worldDot = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(lineStart, dotZone, this.worldTrianglePoint, this.worldTriangleNormal);
                            let viewDot = this.dotTransform.timesColumn(worldDot);
                            let dotX = viewDot.getComponent(com.vzome.core.algebra.AlgebraicVector.X).evaluate();
                            let dotY = viewDot.getComponent(com.vzome.core.algebra.AlgebraicVector.Y).evaluate();
                            orbit.setDotLocation(dotX, dotY);
                            if (this.debugger != null) {
                                this.debugger.exportSegment(this.field.origin(3), dotZone);
                                this.debugger.exportPoint(worldDot);
                                this.debugger.exportPoint(viewDot);
                            }
                        }
                        getDebuggerOutput() {
                            this.debugger.finishExport();
                            this.debugger = null;
                            return this.vefDebugOutput.toString();
                        }
                    }
                    symmetry_1.OrbitDotLocator = OrbitDotLocator;
                    OrbitDotLocator["__class"] = "com.vzome.core.math.symmetry.OrbitDotLocator";
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * Should be called Zone, an infinite family of parallel lines, one member of an orbit (Direction)
                     * of a Symmetry group.
                     * @class
                     */
                    class Axis {
                        constructor(dir, index, sense, rotation, rotPerm, normal, outbound) {
                            if (((dir != null && dir instanceof com.vzome.core.math.symmetry.Direction) || dir === null) && ((typeof index === 'number') || index === null) && ((typeof sense === 'number') || sense === null) && ((typeof rotation === 'number') || rotation === null) && ((rotPerm != null && rotPerm instanceof com.vzome.core.math.symmetry.Permutation) || rotPerm === null) && ((normal != null && normal instanceof com.vzome.core.algebra.AlgebraicVector) || normal === null) && ((typeof outbound === 'boolean') || outbound === null)) {
                                let __args = arguments;
                                if (this.mDirection === undefined)
                                    this.mDirection = null;
                                if (this.orientation === undefined)
                                    this.orientation = 0;
                                if (this.mSense === undefined)
                                    this.mSense = 0;
                                if (this.mRotationPerm === undefined)
                                    this.mRotationPerm = null;
                                if (this.mRotation === undefined)
                                    this.mRotation = 0;
                                if (this.__normal === undefined)
                                    this.__normal = null;
                                this.outbound = true;
                                if (this.mDirection === undefined)
                                    this.mDirection = null;
                                if (this.orientation === undefined)
                                    this.orientation = 0;
                                if (this.mSense === undefined)
                                    this.mSense = 0;
                                this.outbound = true;
                                if (this.mRotationPerm === undefined)
                                    this.mRotationPerm = null;
                                if (this.mRotation === undefined)
                                    this.mRotation = 0;
                                if (this.__normal === undefined)
                                    this.__normal = null;
                                (() => {
                                    this.mDirection = dir;
                                    this.mRotation = rotation;
                                    this.mRotationPerm = rotPerm;
                                    this.orientation = index;
                                    this.__normal = normal;
                                    this.mSense = sense;
                                    this.outbound = outbound;
                                })();
                            }
                            else if (((dir != null && dir instanceof com.vzome.core.math.symmetry.Direction) || dir === null) && ((typeof index === 'number') || index === null) && ((typeof sense === 'number') || sense === null) && ((typeof rotation === 'number') || rotation === null) && ((rotPerm != null && rotPerm instanceof com.vzome.core.math.symmetry.Permutation) || rotPerm === null) && ((normal != null && normal instanceof com.vzome.core.algebra.AlgebraicVector) || normal === null) && outbound === undefined) {
                                let __args = arguments;
                                {
                                    let __args = arguments;
                                    let outbound = true;
                                    if (this.mDirection === undefined)
                                        this.mDirection = null;
                                    if (this.orientation === undefined)
                                        this.orientation = 0;
                                    if (this.mSense === undefined)
                                        this.mSense = 0;
                                    if (this.mRotationPerm === undefined)
                                        this.mRotationPerm = null;
                                    if (this.mRotation === undefined)
                                        this.mRotation = 0;
                                    if (this.__normal === undefined)
                                        this.__normal = null;
                                    this.outbound = true;
                                    if (this.mDirection === undefined)
                                        this.mDirection = null;
                                    if (this.orientation === undefined)
                                        this.orientation = 0;
                                    if (this.mSense === undefined)
                                        this.mSense = 0;
                                    this.outbound = true;
                                    if (this.mRotationPerm === undefined)
                                        this.mRotationPerm = null;
                                    if (this.mRotation === undefined)
                                        this.mRotation = 0;
                                    if (this.__normal === undefined)
                                        this.__normal = null;
                                    (() => {
                                        this.mDirection = dir;
                                        this.mRotation = rotation;
                                        this.mRotationPerm = rotPerm;
                                        this.orientation = index;
                                        this.__normal = normal;
                                        this.mSense = sense;
                                        this.outbound = outbound;
                                    })();
                                }
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         * Return the normal vector for this axis.
                         * Note that this vector may not have length=1.0, but it will have length
                         * equal to one "unit" for this axis.
                         * @return {com.vzome.core.algebra.AlgebraicVector} AlgebraicVector
                         */
                        normal() {
                            return this.__normal;
                        }
                        isOutbound() {
                            return this.outbound;
                        }
                        getLength(vector) {
                            return vector.getLength(this.__normal);
                        }
                        /**
                         *
                         * @return {number}
                         */
                        hashCode() {
                            let prime = 31;
                            let result = 1;
                            result = prime * result + ((this.mDirection == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                                return o.hashCode();
                            }
                            else {
                                return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                            } })(this.mDirection));
                            result = prime * result + this.mSense;
                            result = prime * result + ((this.__normal == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                                return o.hashCode();
                            }
                            else {
                                return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                            } })(this.__normal));
                            return result;
                        }
                        /**
                         *
                         * @param {*} obj
                         * @return {boolean}
                         */
                        equals(obj) {
                            if (this === obj)
                                return true;
                            if (obj == null)
                                return false;
                            if (this.constructor !== obj.constructor)
                                return false;
                            let other = obj;
                            if (this.mDirection == null) {
                                if (other.mDirection != null)
                                    return false;
                            }
                            else if (!this.mDirection.equals(other.mDirection))
                                return false;
                            if (this.mSense !== other.mSense)
                                return false;
                            if (this.__normal == null) {
                                if (other.__normal != null)
                                    return false;
                            }
                            else if (!this.__normal.equals(other.__normal))
                                return false;
                            return true;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        toString() {
                            return this.mDirection.toString() + " " + ((this.mSense === com.vzome.core.math.symmetry.Symmetry.PLUS) ? "+" : "-") + this.orientation + (this.outbound ? "" : "i");
                        }
                        getOrbit() {
                            return this.mDirection;
                        }
                        getDirection() {
                            return this.mDirection;
                        }
                        getOrientation() {
                            return this.orientation;
                        }
                        getRotation() {
                            return this.mRotation;
                        }
                        getCorrectRotation() {
                            return (this.mRotationPerm == null) ? com.vzome.core.math.symmetry.Symmetry.NO_ROTATION : this.mRotationPerm.mapIndex(0);
                        }
                        getRotationPermutation() {
                            return this.mRotationPerm;
                        }
                        getSense() {
                            return this.mSense;
                        }
                        /**
                         * @param plus
                         * @param {number} orientation2
                         * @param {boolean} outbound
                         * @param {number} sense
                         */
                        rename(sense, orientation2, outbound) {
                            this.mSense = sense;
                            this.orientation = orientation2;
                            this.outbound = outbound;
                        }
                        getXML(elem) {
                            com.vzome.xml.DomUtils.addAttribute(elem, "symm", this.mDirection.getSymmetry().getName());
                            com.vzome.xml.DomUtils.addAttribute(elem, "dir", this.mDirection.getName());
                            com.vzome.xml.DomUtils.addAttribute(elem, "index", /* toString */ ('' + (this.orientation)));
                            if (this.mSense !== com.vzome.core.math.symmetry.Symmetry.PLUS)
                                com.vzome.xml.DomUtils.addAttribute(elem, "sense", "minus");
                        }
                    }
                    Axis.PLUS = 0;
                    Axis.MINUS = 1;
                    symmetry.Axis = Axis;
                    Axis["__class"] = "com.vzome.core.math.symmetry.Axis";
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     * @param {com.vzome.core.math.symmetry.Direction} dir
                     * @param {string} name
                     * @class
                     */
                    class DirectionNaming {
                        constructor(dir, name) {
                            if (this.mName === undefined)
                                this.mName = null;
                            if (this.mDirection === undefined)
                                this.mDirection = null;
                            this.mName = name;
                            this.mDirection = dir;
                        }
                        static SIGN_$LI$() { if (DirectionNaming.SIGN == null)
                            DirectionNaming.SIGN = ["+", "-"]; return DirectionNaming.SIGN; }
                        ;
                        getName$() {
                            return this.mName;
                        }
                        /**
                         * Default behavior.
                         * @param {string} axisName
                         * @return
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getAxis(axisName) {
                            return this.mDirection.getAxis$int$int(this.getSign(axisName), this.getInteger(axisName));
                        }
                        getSign(axisName) {
                            if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "-"))
                                return com.vzome.core.math.symmetry.Symmetry.MINUS;
                            return com.vzome.core.math.symmetry.Symmetry.PLUS;
                        }
                        getInteger(axisName) {
                            if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "-") || /* startsWith */ ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(axisName, "+"))
                                return javaemul.internal.IntegerHelper.parseInt(axisName.substring(1));
                            return javaemul.internal.IntegerHelper.parseInt(axisName);
                        }
                        getName$com_vzome_core_math_symmetry_Axis(axis) {
                            let sign = DirectionNaming.SIGN_$LI$()[axis.getSense()];
                            return sign + axis.getOrientation();
                        }
                        getName(axis) {
                            if (((axis != null && axis instanceof com.vzome.core.math.symmetry.Axis) || axis === null)) {
                                return this.getName$com_vzome_core_math_symmetry_Axis(axis);
                            }
                            else if (axis === undefined) {
                                return this.getName$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        getFullName(axis) {
                            return this.mName + " " + this.getName$com_vzome_core_math_symmetry_Axis(axis);
                        }
                        getDirection() {
                            return this.mDirection;
                        }
                    }
                    symmetry.DirectionNaming = DirectionNaming;
                    DirectionNaming["__class"] = "com.vzome.core.math.symmetry.DirectionNaming";
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     * @class
                     */
                    class AbstractSymmetry {
                        constructor(order, field, frameColor, principalReflection) {
                            if (((typeof order === 'number') || order === null) && ((field != null && (field["__interfaces"] != null && field["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((typeof frameColor === 'string') || frameColor === null) && ((principalReflection != null && principalReflection instanceof com.vzome.core.algebra.AlgebraicMatrix) || principalReflection === null)) {
                                let __args = arguments;
                                if (this.mOrientations === undefined)
                                    this.mOrientations = null;
                                if (this.mMatrices === undefined)
                                    this.mMatrices = null;
                                if (this.mField === undefined)
                                    this.mField = null;
                                if (this.dotLocator === undefined)
                                    this.dotLocator = null;
                                this.mDirectionMap = (new java.util.HashMap());
                                this.mDirectionList = (new java.util.ArrayList());
                                this.orbitSet = new com.vzome.core.math.symmetry.OrbitSet(this);
                                this.principalReflection = null;
                                this.mDirectionMap = (new java.util.HashMap());
                                this.mDirectionList = (new java.util.ArrayList());
                                this.orbitSet = new com.vzome.core.math.symmetry.OrbitSet(this);
                                if (this.mOrientations === undefined)
                                    this.mOrientations = null;
                                if (this.mMatrices === undefined)
                                    this.mMatrices = null;
                                if (this.mField === undefined)
                                    this.mField = null;
                                this.principalReflection = null;
                                if (this.dotLocator === undefined)
                                    this.dotLocator = null;
                                (() => {
                                    this.mField = field;
                                    this.principalReflection = principalReflection;
                                    this.mOrientations = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(order);
                                    this.mMatrices = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(order);
                                    this.createInitialPermutations();
                                    let done = false;
                                    while ((!done)) {
                                        {
                                            done = true;
                                            for (let i = 1; i < order; i++) {
                                                {
                                                    let p1 = this.mOrientations[i];
                                                    if (p1 == null) {
                                                        done = false;
                                                        continue;
                                                    }
                                                    done = true;
                                                    for (let j = 1; j < order; j++) {
                                                        {
                                                            let p2 = this.mOrientations[j];
                                                            if (p2 == null) {
                                                                done = false;
                                                                continue;
                                                            }
                                                            let result = p1.mapIndex(p2.mapIndex(0));
                                                            if (this.mOrientations[result] != null)
                                                                continue;
                                                            let map = (s => { let a = []; while (s-- > 0)
                                                                a.push(0); return a; })(order);
                                                            for (let k = 0; k < order; k++) {
                                                                map[k] = p1.mapIndex(p2.mapIndex(k));
                                                            }
                                                            this.mOrientations[result] = new com.vzome.core.math.symmetry.Permutation(this, map);
                                                        }
                                                        ;
                                                    }
                                                    if (done)
                                                        break;
                                                }
                                                ;
                                            }
                                        }
                                    }
                                    ;
                                    this.createFrameOrbit(frameColor);
                                    this.createOtherOrbits();
                                })();
                            }
                            else if (((typeof order === 'number') || order === null) && ((field != null && (field["__interfaces"] != null && field["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((typeof frameColor === 'string') || frameColor === null) && principalReflection === undefined) {
                                let __args = arguments;
                                {
                                    let __args = arguments;
                                    let principalReflection = null;
                                    if (this.mOrientations === undefined)
                                        this.mOrientations = null;
                                    if (this.mMatrices === undefined)
                                        this.mMatrices = null;
                                    if (this.mField === undefined)
                                        this.mField = null;
                                    if (this.dotLocator === undefined)
                                        this.dotLocator = null;
                                    this.mDirectionMap = (new java.util.HashMap());
                                    this.mDirectionList = (new java.util.ArrayList());
                                    this.orbitSet = new com.vzome.core.math.symmetry.OrbitSet(this);
                                    this.principalReflection = null;
                                    this.mDirectionMap = (new java.util.HashMap());
                                    this.mDirectionList = (new java.util.ArrayList());
                                    this.orbitSet = new com.vzome.core.math.symmetry.OrbitSet(this);
                                    if (this.mOrientations === undefined)
                                        this.mOrientations = null;
                                    if (this.mMatrices === undefined)
                                        this.mMatrices = null;
                                    if (this.mField === undefined)
                                        this.mField = null;
                                    this.principalReflection = null;
                                    if (this.dotLocator === undefined)
                                        this.dotLocator = null;
                                    (() => {
                                        this.mField = field;
                                        this.principalReflection = principalReflection;
                                        this.mOrientations = (s => { let a = []; while (s-- > 0)
                                            a.push(null); return a; })(order);
                                        this.mMatrices = (s => { let a = []; while (s-- > 0)
                                            a.push(null); return a; })(order);
                                        this.createInitialPermutations();
                                        let done = false;
                                        while ((!done)) {
                                            {
                                                done = true;
                                                for (let i = 1; i < order; i++) {
                                                    {
                                                        let p1 = this.mOrientations[i];
                                                        if (p1 == null) {
                                                            done = false;
                                                            continue;
                                                        }
                                                        done = true;
                                                        for (let j = 1; j < order; j++) {
                                                            {
                                                                let p2 = this.mOrientations[j];
                                                                if (p2 == null) {
                                                                    done = false;
                                                                    continue;
                                                                }
                                                                let result = p1.mapIndex(p2.mapIndex(0));
                                                                if (this.mOrientations[result] != null)
                                                                    continue;
                                                                let map = (s => { let a = []; while (s-- > 0)
                                                                    a.push(0); return a; })(order);
                                                                for (let k = 0; k < order; k++) {
                                                                    map[k] = p1.mapIndex(p2.mapIndex(k));
                                                                }
                                                                this.mOrientations[result] = new com.vzome.core.math.symmetry.Permutation(this, map);
                                                            }
                                                            ;
                                                        }
                                                        if (done)
                                                            break;
                                                    }
                                                    ;
                                                }
                                            }
                                        }
                                        ;
                                        this.createFrameOrbit(frameColor);
                                        this.createOtherOrbits();
                                    })();
                                }
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getField() {
                            return this.mField;
                        }
                        /**
                         *
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getPreferredAxis() {
                            return null;
                        }
                        createZoneOrbit$java_lang_String$int$int$int_A_A(name, prototype, rotatedPrototype, norm) {
                            let aNorm = this.mField.createVector(norm);
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(name, prototype, rotatedPrototype, aNorm, false);
                        }
                        createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector(name, prototype, rotatedPrototype, norm) {
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(name, prototype, rotatedPrototype, norm, false);
                        }
                        createZoneOrbit$java_lang_String$int$int$int_A_A$boolean(name, prototype, rotatedPrototype, norm, standard) {
                            let aNorm = this.mField.createVector(norm);
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean(name, prototype, rotatedPrototype, aNorm, standard, false);
                        }
                        createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(name, prototype, rotatedPrototype, norm, standard) {
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, false);
                        }
                        createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, halfSizes) {
                            let aNorm = this.mField.createVector(norm);
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, aNorm, standard, false, null);
                        }
                        createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, halfSizes) {
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, false, this.mField.one());
                        }
                        createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, halfSizes, unitLength) {
                            let aNorm = this.mField.createVector(norm);
                            return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, aNorm, standard, halfSizes, unitLength);
                        }
                        createZoneOrbit(name, prototype, rotatedPrototype, norm, standard, halfSizes, unitLength) {
                            if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof Array && (norm.length == 0 || norm[0] == null || norm[0] instanceof Array)) || norm === null) && ((typeof standard === 'boolean') || standard === null) && ((typeof halfSizes === 'boolean') || halfSizes === null) && ((unitLength != null && (unitLength["__interfaces"] != null && unitLength["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || unitLength.constructor != null && unitLength.constructor["__interfaces"] != null && unitLength.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || unitLength === null)) {
                                return this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, halfSizes, unitLength);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof com.vzome.core.algebra.AlgebraicVector) || norm === null) && ((typeof standard === 'boolean') || standard === null) && ((typeof halfSizes === 'boolean') || halfSizes === null) && ((unitLength != null && (unitLength["__interfaces"] != null && unitLength["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || unitLength.constructor != null && unitLength.constructor["__interfaces"] != null && unitLength.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || unitLength === null)) {
                                return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, halfSizes, unitLength);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof Array && (norm.length == 0 || norm[0] == null || norm[0] instanceof Array)) || norm === null) && ((typeof standard === 'boolean') || standard === null) && ((typeof halfSizes === 'boolean') || halfSizes === null) && unitLength === undefined) {
                                return this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, halfSizes);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof com.vzome.core.algebra.AlgebraicVector) || norm === null) && ((typeof standard === 'boolean') || standard === null) && ((typeof halfSizes === 'boolean') || halfSizes === null) && unitLength === undefined) {
                                return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean(name, prototype, rotatedPrototype, norm, standard, halfSizes);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof Array && (norm.length == 0 || norm[0] == null || norm[0] instanceof Array)) || norm === null) && ((typeof standard === 'boolean') || standard === null) && halfSizes === undefined && unitLength === undefined) {
                                return this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean(name, prototype, rotatedPrototype, norm, standard);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof com.vzome.core.algebra.AlgebraicVector) || norm === null) && ((typeof standard === 'boolean') || standard === null) && halfSizes === undefined && unitLength === undefined) {
                                return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(name, prototype, rotatedPrototype, norm, standard);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof Array && (norm.length == 0 || norm[0] == null || norm[0] instanceof Array)) || norm === null) && standard === undefined && halfSizes === undefined && unitLength === undefined) {
                                return this.createZoneOrbit$java_lang_String$int$int$int_A_A(name, prototype, rotatedPrototype, norm);
                            }
                            else if (((typeof name === 'string') || name === null) && ((typeof prototype === 'number') || prototype === null) && ((typeof rotatedPrototype === 'number') || rotatedPrototype === null) && ((norm != null && norm instanceof com.vzome.core.algebra.AlgebraicVector) || norm === null) && standard === undefined && halfSizes === undefined && unitLength === undefined) {
                                return this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector(name, prototype, rotatedPrototype, norm);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(name, prototype, rotatedPrototype, norm, standard, halfSizes, unitLength) {
                            let existingDir = this.mDirectionMap.get(name);
                            if (existingDir != null) {
                                this.mDirectionMap.remove(name);
                                this.orbitSet.remove(existingDir);
                                this.mDirectionList.remove(existingDir);
                            }
                            let orbit = new com.vzome.core.math.symmetry.Direction(name, this, prototype, rotatedPrototype, norm, standard);
                            if (halfSizes)
                                orbit.setHalfSizes(true);
                            orbit.setUnitLength(unitLength);
                            this.mDirectionMap.put(orbit.getName(), orbit);
                            this.mDirectionList.add(orbit);
                            this.orbitSet.add(orbit);
                            if (this.dotLocator != null)
                                this.dotLocator.locateOrbitDot(orbit);
                            return orbit;
                        }
                        /**
                         *
                         * @param {string} name
                         * @param {number} prototype
                         * @param {number} rotatedPrototype
                         * @param {com.vzome.core.algebra.AlgebraicVector} norm
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        createNewZoneOrbit(name, prototype, rotatedPrototype, norm) {
                            let orbit = new com.vzome.core.math.symmetry.Direction(name, this, prototype, rotatedPrototype, norm, false).withCorrection();
                            if (this.dotLocator != null)
                                this.dotLocator.locateOrbitDot(orbit);
                            return orbit;
                        }
                        /**
                         *
                         * @return {com.vzome.core.math.symmetry.OrbitSet}
                         */
                        getOrbitSet() {
                            return this.orbitSet;
                        }
                        /**
                         * @param unit
                         * @param rot
                         * @return
                         * @param {number} from
                         * @param {number} to
                         * @return {number}
                         */
                        getMapping(from, to) {
                            if (to === com.vzome.core.math.symmetry.Symmetry.NO_ROTATION)
                                return com.vzome.core.math.symmetry.Symmetry.NO_ROTATION;
                            for (let p = 0; p < this.mOrientations.length; p++) {
                                if (this.mOrientations[p].mapIndex(from) === to)
                                    return p;
                                ;
                            }
                            return com.vzome.core.math.symmetry.Symmetry.NO_ROTATION;
                        }
                        mapAxis(from, to) {
                            return this.mapAxes([from], [to]);
                        }
                        mapAxes(from, to) {
                            if (from.length !== to.length)
                                throw new AbstractSymmetry.MismatchedAxes("must map to equal number of axes");
                            if (from.length > 3)
                                throw new AbstractSymmetry.MismatchedAxes("must map three or fewer axes");
                            for (let i = 0; i < from.length; i++) {
                                if (from[i].getDirection().equals(to[i].getDirection()))
                                    throw new AbstractSymmetry.MismatchedAxes("must map between same color axes");
                                ;
                            }
                            let result = [null];
                            return result[0];
                        }
                        /**
                         *
                         * @return {*}
                         */
                        iterator() {
                            return this.mDirectionList.iterator();
                        }
                        /**
                         * @deprecated Consider using a JDK-5 for-loop if possible. Otherwise use {@link #iterator()} instead.
                         * @return {*}
                         */
                        getDirections() {
                            return this.iterator();
                        }
                        getAxis$com_vzome_core_algebra_AlgebraicVector(vector) {
                            return this.getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet(vector, this.orbitSet);
                        }
                        getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet(vector, orbits) {
                            if (vector.isOrigin()) {
                                return null;
                            }
                            let canonicalOrbit = this.getSpecialOrbit(symmetry.Symmetry.SpecialOrbit.BLACK);
                            if (canonicalOrbit == null)
                                for (let index151 = orbits.iterator(); index151.hasNext();) {
                                    let dir = index151.next();
                                    {
                                        let candidate = dir.getAxis$com_vzome_core_algebra_AlgebraicVector(vector);
                                        if (candidate != null) {
                                            return candidate;
                                        }
                                    }
                                }
                            else {
                                let zone = canonicalOrbit.getAxis$com_vzome_core_math_RealVector(vector.toRealVector());
                                let orientation = zone.getOrientation();
                                let sense = zone.getSense();
                                for (let index152 = orbits.iterator(); index152.hasNext();) {
                                    let orbit = index152.next();
                                    {
                                        let candidate = orbit.getCanonicalAxis(sense, orientation);
                                        if (com.vzome.core.algebra.AlgebraicVectors.areParallel(candidate.normal(), vector)) {
                                            return candidate;
                                        }
                                    }
                                }
                            }
                            return null;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @param {com.vzome.core.math.symmetry.OrbitSet} orbits
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getAxis(vector, orbits) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((orbits != null && orbits instanceof com.vzome.core.math.symmetry.OrbitSet) || orbits === null)) {
                                return this.getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet(vector, orbits);
                            }
                            else if (((vector != null && vector instanceof com.vzome.core.math.RealVector) || vector === null) && ((orbits != null && (orbits["__interfaces"] != null && orbits["__interfaces"].indexOf("java.util.Set") >= 0 || orbits.constructor != null && orbits.constructor["__interfaces"] != null && orbits.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || orbits === null)) {
                                return this.getAxis$com_vzome_core_math_RealVector$java_util_Set(vector, orbits);
                            }
                            else if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && orbits === undefined) {
                                return this.getAxis$com_vzome_core_algebra_AlgebraicVector(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        getAxis$com_vzome_core_math_RealVector$java_util_Set(vector, dirMask) {
                            if (com.vzome.core.math.RealVector.ORIGIN_$LI$().equals(vector)) {
                                return null;
                            }
                            let maxCosine = -1.0;
                            let closest = null;
                            let orientation = -1;
                            let sense = -1;
                            let chiralOrbit = this.getSpecialOrbit(symmetry.Symmetry.SpecialOrbit.BLACK);
                            if (chiralOrbit != null) {
                                let closestChiralAxis = chiralOrbit.getChiralAxis(vector);
                                orientation = closestChiralAxis.getOrientation();
                                sense = closestChiralAxis.getSense();
                            }
                            let dirs = dirMask == null ? this.orbitSet.iterator() : dirMask.iterator();
                            while ((dirs.hasNext())) {
                                {
                                    let dir = dirs.next();
                                    let axis = (orientation >= 0) ? dir.getCanonicalAxis(sense, orientation) : dir.getAxisBruteForce(vector);
                                    let axisV = axis.normal().toRealVector();
                                    let cosine = vector.dot(axisV) / (vector.length() * axisV.length());
                                    if (cosine > maxCosine) {
                                        maxCosine = cosine;
                                        closest = axis;
                                    }
                                }
                            }
                            ;
                            return closest;
                        }
                        /**
                         *
                         * @return {number}
                         */
                        getChiralOrder() {
                            return this.mOrientations.length;
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.math.symmetry.Permutation}
                         */
                        getPermutation(i) {
                            if ((i < 0) || (i > this.mOrientations.length))
                                return null;
                            return this.mOrientations[i];
                        }
                        getPermutations() {
                            return this.mOrientations;
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicMatrix}
                         */
                        getMatrix(i) {
                            return this.mMatrices[i];
                        }
                        getMatrices() {
                            return this.mMatrices;
                        }
                        /**
                         *
                         * @param {number} orientation
                         * @return {number}
                         */
                        inverse(orientation) {
                            if ((orientation < 0) || (orientation > this.mOrientations.length))
                                return com.vzome.core.math.symmetry.Symmetry.NO_ROTATION;
                            return this.mOrientations[orientation].inverse().mapIndex(0);
                        }
                        /**
                         *
                         * @param {string} color
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getDirection(color) {
                            return this.mDirectionMap.get(color);
                        }
                        /**
                         *
                         * @return {Array}
                         */
                        getDirectionNames() {
                            let list = (new java.util.ArrayList());
                            for (let index153 = this.mDirectionList.iterator(); index153.hasNext();) {
                                let dir = index153.next();
                                {
                                    if (!dir.isAutomatic())
                                        list.add(dir.getName());
                                }
                            }
                            return list.toArray([]);
                        }
                        /**
                         *
                         * @param {Array} perms
                         * @return {Array}
                         */
                        closure(perms) {
                            let newPerms = (new java.util.ArrayList());
                            let knownPerms = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(this.mOrientations.length);
                            let closureSize = 0;
                            for (let i = 0; i < perms.length; i++) {
                                {
                                    let perm = this.mOrientations[perms[i]];
                                    knownPerms[perms[i]] = perm;
                                    newPerms.add(perm);
                                    ++closureSize;
                                }
                                ;
                            }
                            while ((!newPerms.isEmpty())) {
                                {
                                    let perm = newPerms.remove(0);
                                    for (let index154 = 0; index154 < knownPerms.length; index154++) {
                                        let knownPerm = knownPerms[index154];
                                        {
                                            if (knownPerm != null) {
                                                let composition = perm.compose(knownPerm);
                                                let j = composition.mapIndex(0);
                                                if (knownPerms[j] == null) {
                                                    newPerms.add(composition);
                                                    knownPerms[j] = composition;
                                                    ++closureSize;
                                                }
                                                composition = knownPerm.compose(perm);
                                                j = composition.mapIndex(0);
                                                if (knownPerms[j] == null) {
                                                    newPerms.add(composition);
                                                    knownPerms[j] = composition;
                                                    ++closureSize;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            ;
                            let result = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(closureSize);
                            let j = 0;
                            for (let i = 0; i < knownPerms.length; i++) {
                                {
                                    if (knownPerms[i] != null) {
                                        result[j++] = i;
                                    }
                                }
                                ;
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {number} orientation
                         * @return {Array}
                         */
                        getIncidentOrientations(orientation) {
                            return null;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} v
                         * @return {com.vzome.core.math.RealVector}
                         */
                        embedInR3(v) {
                            return v.toRealVector();
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isTrivial() {
                            return true;
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.AlgebraicMatrix}
                         */
                        getPrincipalReflection() {
                            return this.principalReflection;
                        }
                        getOrbitTriangle() {
                            let blueVertex = this.getSpecialOrbit(symmetry.Symmetry.SpecialOrbit.BLUE).getPrototype();
                            let redVertex = this.getSpecialOrbit(symmetry.Symmetry.SpecialOrbit.RED).getPrototype();
                            let yellowVertex = this.getSpecialOrbit(symmetry.Symmetry.SpecialOrbit.YELLOW).getPrototype();
                            return [blueVertex, redVertex, yellowVertex];
                        }
                        /**
                         *
                         * @return {string}
                         */
                        computeOrbitDots() {
                            this.dotLocator = new com.vzome.core.math.symmetry.OrbitDotLocator(this, this.getOrbitTriangle());
                            for (let index155 = this.mDirectionList.iterator(); index155.hasNext();) {
                                let orbit = index155.next();
                                {
                                    this.dotLocator.locateOrbitDot(orbit);
                                }
                            }
                            return null;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        reverseOrbitTriangle() {
                            return false;
                        }
                    }
                    symmetry.AbstractSymmetry = AbstractSymmetry;
                    AbstractSymmetry["__class"] = "com.vzome.core.math.symmetry.AbstractSymmetry";
                    AbstractSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "java.lang.Iterable", "com.vzome.core.math.symmetry.Embedding"];
                    (function (AbstractSymmetry) {
                        class MismatchedAxes extends java.lang.RuntimeException {
                            constructor(message) {
                                super(message);
                                Object.setPrototypeOf(this, MismatchedAxes.prototype);
                            }
                        }
                        MismatchedAxes.serialVersionUID = 2610579323321804987;
                        AbstractSymmetry.MismatchedAxes = MismatchedAxes;
                        MismatchedAxes["__class"] = "com.vzome.core.math.symmetry.AbstractSymmetry.MismatchedAxes";
                        MismatchedAxes["__interfaces"] = ["java.io.Serializable"];
                    })(AbstractSymmetry = symmetry.AbstractSymmetry || (symmetry.AbstractSymmetry = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    let Embedding;
                    (function (Embedding) {
                        class Trivial {
                            /**
                             *
                             * @param {com.vzome.core.algebra.AlgebraicVector} v
                             * @return {com.vzome.core.math.RealVector}
                             */
                            embedInR3(v) {
                                return v.toRealVector();
                            }
                            /**
                             *
                             * @return {boolean}
                             */
                            isTrivial() {
                                return true;
                            }
                            constructor() {
                            }
                        }
                        Embedding.Trivial = Trivial;
                        Trivial["__class"] = "com.vzome.core.math.symmetry.Embedding.Trivial";
                        Trivial["__interfaces"] = ["com.vzome.core.math.symmetry.Embedding"];
                    })(Embedding = symmetry.Embedding || (symmetry.Embedding = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry_2) {
                    class OrbitSet extends java.util.TreeSet {
                        constructor(symmetry) {
                            super();
                            if (this.symmetry === undefined)
                                this.symmetry = null;
                            this.symmetry = symmetry;
                        }
                        getSymmetry() {
                            return this.symmetry;
                        }
                        getAxis(vector) {
                            return this.symmetry['getAxis$com_vzome_core_math_RealVector$java_util_Set'](vector, this);
                        }
                        getDirection(name) {
                            for (let index156 = this.iterator(); index156.hasNext();) {
                                let dir = index156.next();
                                {
                                    if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                        return o1.equals(o2);
                                    }
                                    else {
                                        return o1 === o2;
                                    } })(dir.getName(), name))
                                        return dir;
                                }
                            }
                            return null;
                        }
                    }
                    symmetry_2.OrbitSet = OrbitSet;
                    OrbitSet["__class"] = "com.vzome.core.math.symmetry.OrbitSet";
                    OrbitSet["__interfaces"] = ["java.lang.Cloneable", "java.util.SortedSet", "java.util.Collection", "java.util.Set", "java.util.NavigableSet", "java.lang.Iterable", "java.io.Serializable"];
                    (function (OrbitSet) {
                        class OrbitComparator {
                            constructor(__parent) {
                                this.__parent = __parent;
                                this.names = this.__parent.getSymmetry().getDirectionNames();
                            }
                            /**
                             *
                             * @param {com.vzome.core.math.symmetry.Direction} dir1
                             * @param {com.vzome.core.math.symmetry.Direction} dir2
                             * @return {number}
                             */
                            compare(dir1, dir2) {
                                let name1 = dir1.getName();
                                let name2 = dir2.getName();
                                let i1 = -1;
                                let i2 = -1;
                                for (let i = 0; i < this.names.length; i++) {
                                    {
                                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                            return o1.equals(o2);
                                        }
                                        else {
                                            return o1 === o2;
                                        } })(name1, this.names[i]))
                                            i1 = i;
                                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                            return o1.equals(o2);
                                        }
                                        else {
                                            return o1 === o2;
                                        } })(name2, this.names[i]))
                                            i2 = i;
                                    }
                                    ;
                                }
                                return i2 - i1;
                            }
                        }
                        OrbitSet.OrbitComparator = OrbitComparator;
                        OrbitComparator["__class"] = "com.vzome.core.math.symmetry.OrbitSet.OrbitComparator";
                        OrbitComparator["__interfaces"] = ["java.util.Comparator"];
                    })(OrbitSet = symmetry_2.OrbitSet || (symmetry_2.OrbitSet = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     * @class
                     */
                    class NamingConvention {
                        constructor() {
                            this.mNamings = (new java.util.HashMap());
                        }
                        addDirectionNaming(naming) {
                            this.mNamings.put(naming.getName$(), naming);
                        }
                        getAxis(color, name) {
                            let naming = this.mNamings.get(color);
                            if (naming == null)
                                return null;
                            return naming.getAxis(name);
                        }
                        getName(axis) {
                            for (let index157 = this.mNamings.values().iterator(); index157.hasNext();) {
                                let naming = index157.next();
                                {
                                    if (naming.getDirection().equals(axis.getDirection()))
                                        return naming.getName$com_vzome_core_math_symmetry_Axis(axis);
                                }
                            }
                            return NamingConvention.UNKNOWN_AXIS;
                        }
                    }
                    NamingConvention.UNKNOWN_AXIS = "UNKNOWN AXIS";
                    symmetry.NamingConvention = NamingConvention;
                    NamingConvention["__class"] = "com.vzome.core.math.symmetry.NamingConvention";
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    let Symmetry;
                    (function (Symmetry) {
                        Symmetry.PLUS = com.vzome.core.math.symmetry.Axis.PLUS;
                        Symmetry.MINUS = com.vzome.core.math.symmetry.Axis.MINUS;
                        Symmetry.NO_ROTATION = -1;
                        Symmetry.TETRAHEDRAL = "tetrahedral";
                        Symmetry.PYRITOHEDRAL = "pyritohedral";
                    })(Symmetry = symmetry.Symmetry || (symmetry.Symmetry = {}));
                    (function (Symmetry) {
                        let SpecialOrbit;
                        (function (SpecialOrbit) {
                            SpecialOrbit[SpecialOrbit["BLUE"] = 0] = "BLUE";
                            SpecialOrbit[SpecialOrbit["RED"] = 1] = "RED";
                            SpecialOrbit[SpecialOrbit["YELLOW"] = 2] = "YELLOW";
                            SpecialOrbit[SpecialOrbit["BLACK"] = 3] = "BLACK";
                        })(SpecialOrbit = Symmetry.SpecialOrbit || (Symmetry.SpecialOrbit = {}));
                    })(Symmetry = symmetry.Symmetry || (symmetry.Symmetry = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * A single orbit in a Symmetry group.
                     * Consists of a collection of zones (Axis), each of which is an infinite family of parallel lines.
                     * There is a prototype zone (Axis) which has index==0; ideally, that zone should
                     * have normal vector =~ (1,e,e), for 0 < e << 1, but this is not true, historically.
                     *
                     * The orbit is represented by a single "dot" on the fundamental region triangle, and typically
                     * struts in the orbit are rendered with a shape and color unique from all other orbits.
                     *
                     * @author Scott Vorthmann
                     * @param {string} name
                     * @param {*} group
                     * @param {number} prototype
                     * @param {number} rotatedPrototype
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector
                     * @param {boolean} isStd
                     * @class
                     */
                    class Direction {
                        constructor(name, group, prototype, rotatedPrototype, vector, isStd) {
                            if (this.mName === undefined)
                                this.mName = null;
                            if (this.zoneNames === undefined)
                                this.zoneNames = null;
                            this.zoneVectors = (new java.util.HashMap());
                            if (this.mSymmetryGroup === undefined)
                                this.mSymmetryGroup = null;
                            if (this.mPrototype === undefined)
                                this.mPrototype = null;
                            if (this.mStandard === undefined)
                                this.mStandard = false;
                            if (this.mAutomatic === undefined)
                                this.mAutomatic = false;
                            if (this.__hasHalfSizes === undefined)
                                this.__hasHalfSizes = false;
                            this.scaleNames = ["shorter", "short", "medium", "long"];
                            this.scales = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(this.scaleNames.length);
                            if (this.unitLength === undefined)
                                this.unitLength = null;
                            if (this.unitLengthReciprocal === undefined)
                                this.unitLengthReciprocal = null;
                            this.dotX = -999.0;
                            this.dotY = -999.0;
                            if (this.index === undefined)
                                this.index = 0;
                            this.canonicalize = 0;
                            this.index = Direction.globalIndex++;
                            this.mStandard = isStd;
                            this.mName = name;
                            this.mSymmetryGroup = group;
                            for (let i = 0; i < this.scales.length; i++) {
                                {
                                    this.scales[i] = this.mSymmetryGroup.getField()['createPower$int'](i - 1);
                                }
                                ;
                            }
                            this.mPrototype = vector;
                            let order = group.getChiralOrder();
                            this.zoneNames = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                                return null;
                            }
                            else {
                                let array = [];
                                for (let i = 0; i < dims[0]; i++) {
                                    array.push(allocate(dims.slice(1)));
                                }
                                return array;
                            } }; return allocate(dims); })([2, 2, order]);
                            for (let i = 0; i < order; i++) {
                                {
                                    let transform = group.getMatrix(i);
                                    if (transform == null)
                                        return;
                                    let perm = group.getPermutation(i);
                                    let j = perm.mapIndex(prototype);
                                    let rotated = perm.mapIndex(rotatedPrototype);
                                    let normal = transform.timesColumn(vector);
                                    let rot = group.getMapping(j, rotated);
                                    this.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(j, rot, normal);
                                }
                                ;
                            }
                        }
                        /**
                         *
                         * @return {number}
                         */
                        hashCode() {
                            let prime = 31;
                            let result = 1;
                            result = prime * result + this.index;
                            result = prime * result + ((this.mPrototype == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                                return o.hashCode();
                            }
                            else {
                                return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                            } })(this.mPrototype));
                            result = prime * result + ((this.mSymmetryGroup == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                                return o.hashCode();
                            }
                            else {
                                return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                            } })(this.mSymmetryGroup));
                            return result;
                        }
                        /**
                         *
                         * @param {*} obj
                         * @return {boolean}
                         */
                        equals(obj) {
                            if (this === obj) {
                                return true;
                            }
                            if (obj == null) {
                                return false;
                            }
                            if (this.constructor !== obj.constructor) {
                                return false;
                            }
                            let other = obj;
                            if (this.index !== other.index) {
                                return false;
                            }
                            if (this.mPrototype == null) {
                                if (other.mPrototype != null) {
                                    return false;
                                }
                            }
                            else if (!this.mPrototype.equals(other.mPrototype)) {
                                return false;
                            }
                            if (this.mSymmetryGroup == null) {
                                if (other.mSymmetryGroup != null) {
                                    return false;
                                }
                            }
                            else if (!((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(this.mSymmetryGroup, other.mSymmetryGroup)) {
                                return false;
                            }
                            return true;
                        }
                        static logger_$LI$() { if (Direction.logger == null)
                            Direction.logger = java.util.logging.Logger.getLogger("com.vzome.core.math.symmetry.Orbit"); return Direction.logger; }
                        ;
                        setAutomatic(auto) {
                            this.mAutomatic = auto;
                        }
                        isAutomatic() {
                            return this.mAutomatic;
                        }
                        isStandard() {
                            return this.mStandard;
                        }
                        /**
                         *
                         * @return {string}
                         */
                        toString() {
                            return this.mSymmetryGroup.getName() + " " + this.mName;
                        }
                        getPrototype() {
                            return this.mPrototype;
                        }
                        /**
                         *
                         * @return {*}
                         */
                        iterator() {
                            return this.zoneVectors.values().iterator();
                        }
                        /**
                         * @deprecated Consider using a JDK-5 for-loop if possible. Otherwise use {@link #iterator()} instead.
                         * @return {*}
                         */
                        getAxes() {
                            return this.iterator();
                        }
                        getSymmetry() {
                            return this.mSymmetryGroup;
                        }
                        getName() {
                            return this.mName;
                        }
                        getAxis$com_vzome_core_algebra_AlgebraicVector(vector) {
                            for (let index158 = this.zoneVectors.values().iterator(); index158.hasNext();) {
                                let axis = index158.next();
                                {
                                    let normal = axis.normal();
                                    if (com.vzome.core.algebra.AlgebraicVectors.areParallel(normal, vector)) {
                                        let dotProd = normal.dot(vector);
                                        if (dotProd.evaluate() > 0) {
                                            return axis;
                                        }
                                        else {
                                            let principalReflection = this.mSymmetryGroup.getPrincipalReflection();
                                            if (principalReflection == null) {
                                                let opp = (axis.getSense() + 1) % 2;
                                                return this.getAxis$int$int(opp, axis.getOrientation());
                                            }
                                            else {
                                                return this.getAxis$int$int$boolean(axis.getSense(), axis.getOrientation(), !axis.isOutbound());
                                            }
                                        }
                                    }
                                }
                            }
                            return null;
                        }
                        getAxis$com_vzome_core_math_RealVector(vector) {
                            return this.getSymmetry()['getAxis$com_vzome_core_math_RealVector$java_util_Set'](vector, java.util.Collections.singleton(this));
                        }
                        getChiralAxis(vector) {
                            if (com.vzome.core.math.RealVector.ORIGIN_$LI$().equals(vector)) {
                                return null;
                            }
                            let vectorLength = vector.length();
                            let checked = (new java.util.HashSet());
                            let closestOrientation = 0;
                            let closestSense = com.vzome.core.math.symmetry.Symmetry.PLUS;
                            let closestAxis = this.getCanonicalAxis(com.vzome.core.math.symmetry.Symmetry.PLUS, 0);
                            checked.add(closestAxis);
                            let axisV = closestAxis.normal().toRealVector();
                            let maxCosine = vector.dot(axisV) / (vectorLength * axisV.length());
                            if (maxCosine < 0) {
                                closestAxis = this.getCanonicalAxis(com.vzome.core.math.symmetry.Symmetry.MINUS, 0);
                                closestSense = com.vzome.core.math.symmetry.Symmetry.MINUS;
                                checked.add(closestAxis);
                                axisV = closestAxis.normal().toRealVector();
                                maxCosine = vector.dot(axisV) / (vectorLength * axisV.length());
                            }
                            let finished = false;
                            while ((!finished)) {
                                {
                                    let incidentOrientations = this.getSymmetry().getIncidentOrientations(closestOrientation);
                                    if (incidentOrientations == null) {
                                        break;
                                    }
                                    let reverseSense = (closestSense + 1) % 2;
                                    for (let index159 = 0; index159 < incidentOrientations.length; index159++) {
                                        let i = incidentOrientations[index159];
                                        {
                                            let neighbor = this.getCanonicalAxis(reverseSense, i);
                                            if (checked.contains(neighbor))
                                                continue;
                                            checked.add(neighbor);
                                            axisV = neighbor.normal().toRealVector();
                                            let cosine = vector.dot(axisV) / (vectorLength * axisV.length());
                                            if (cosine > maxCosine) {
                                                maxCosine = cosine;
                                                closestAxis = neighbor;
                                                closestOrientation = i;
                                                closestSense = reverseSense;
                                            }
                                        }
                                    }
                                    if (reverseSense !== closestSense) {
                                        return closestAxis;
                                    }
                                }
                            }
                            ;
                            return this.getAxisBruteForce(vector);
                        }
                        getAxisBruteForce(vector) {
                            let closestAxis = null;
                            let maxCosine = -1.0;
                            for (let index160 = this.iterator(); index160.hasNext();) {
                                let axis = index160.next();
                                {
                                    let axisV = axis.normal().toRealVector();
                                    let cosine = vector.dot(axisV) / (vector.length() * axisV.length());
                                    if (cosine > maxCosine) {
                                        maxCosine = cosine;
                                        closestAxis = axis;
                                    }
                                }
                            }
                            return closestAxis;
                        }
                        getAxis$int$int(sense, index) {
                            return this.getAxis$int$int$boolean(sense, index, true);
                        }
                        getAxis$int$int$boolean(sense, index, outbound) {
                            return this.zoneNames[outbound ? 1 : 0][sense][index];
                        }
                        getAxis(sense, index, outbound) {
                            if (((typeof sense === 'number') || sense === null) && ((typeof index === 'number') || index === null) && ((typeof outbound === 'boolean') || outbound === null)) {
                                return this.getAxis$int$int$boolean(sense, index, outbound);
                            }
                            else if (((typeof sense === 'number') || sense === null) && ((typeof index === 'number') || index === null) && outbound === undefined) {
                                return this.getAxis$int$int(sense, index);
                            }
                            else if (((sense != null && sense instanceof com.vzome.core.algebra.AlgebraicVector) || sense === null) && index === undefined && outbound === undefined) {
                                return this.getAxis$com_vzome_core_algebra_AlgebraicVector(sense);
                            }
                            else if (((sense != null && sense instanceof com.vzome.core.math.RealVector) || sense === null) && index === undefined && outbound === undefined) {
                                return this.getAxis$com_vzome_core_math_RealVector(sense);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        withCorrection() {
                            let treatedAs0 = this.getAxisBruteForce(com.vzome.core.math.RealVector.DIRECTION_0_$LI$());
                            this.canonicalize = treatedAs0.getOrientation();
                            if (treatedAs0.getSense() === com.vzome.core.math.symmetry.Symmetry.MINUS)
                                this.canonicalize *= -1;
                            return this;
                        }
                        /**
                         * Get the axis that protrudes from the canonical direction on the zome ball.
                         * Many Directions (orbits) are created without regard to whether "axis 0" actually sticks out
                         * of the ball in the fundamental domain with index 0.
                         * @param {number} sense
                         * @param {number} index
                         * @return
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getCanonicalAxis(sense, index) {
                            if (this.canonicalize !== 0) {
                                if (this.canonicalize < 0)
                                    sense = (sense + 1) % 2;
                                let target = this.mSymmetryGroup.getPermutation(index);
                                index = target.mapIndex(Math.abs(this.canonicalize));
                            }
                            return this.getAxis$int$int(sense, index);
                        }
                        createAxis$int$int$int_A_A(orientation, rotation, norm) {
                            let aNorm = this.mSymmetryGroup.getField().createVector(norm);
                            this.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(orientation, rotation, aNorm);
                        }
                        createAxis(orientation, rotation, norm) {
                            if (((typeof orientation === 'number') || orientation === null) && ((typeof rotation === 'number') || rotation === null) && ((norm != null && norm instanceof Array && (norm.length == 0 || norm[0] == null || norm[0] instanceof Array)) || norm === null)) {
                                return this.createAxis$int$int$int_A_A(orientation, rotation, norm);
                            }
                            else if (((typeof orientation === 'number') || orientation === null) && ((typeof rotation === 'number') || rotation === null) && ((norm != null && norm instanceof com.vzome.core.algebra.AlgebraicVector) || norm === null)) {
                                return this.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(orientation, rotation, norm);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(orientation, rotation, norm) {
                            let perm = this.mSymmetryGroup.getPermutation(rotation);
                            this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.PLUS, rotation, perm, norm, true);
                            let inversion = this.mSymmetryGroup.getPrincipalReflection();
                            if (inversion == null) {
                                if (perm != null)
                                    perm = perm.inverse();
                                this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.MINUS, rotation, perm, norm.negate(), true);
                            }
                            else {
                                let reverseRotation = rotation;
                                let reversePerm = perm;
                                if (perm != null) {
                                    reversePerm = perm.inverse();
                                    reverseRotation = perm.mapIndex(0);
                                }
                                this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.PLUS, reverseRotation, reversePerm, norm.negate(), false);
                                let reflectedNorm = inversion.timesColumn(norm);
                                this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.MINUS, reverseRotation, reversePerm, reflectedNorm, true);
                                reflectedNorm = reflectedNorm.negate();
                                this.recordZone(this, orientation, com.vzome.core.math.symmetry.Symmetry.MINUS, rotation, perm, reflectedNorm, false);
                            }
                        }
                        /*private*/ recordZone(dir, orientation, sense, rotation, rotPerm, normal, outbound) {
                            let zone = this.zoneVectors.get(normal.toString());
                            if (zone == null) {
                                zone = new com.vzome.core.math.symmetry.Axis(this, orientation, sense, rotation, rotPerm, normal, outbound);
                                this.zoneVectors.put(normal.toString(), zone);
                                if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                                    Direction.logger_$LI$().finer("creating zone " + zone.toString() + " " + normal.toString());
                            }
                            else {
                                if (outbound && !zone.isOutbound()) {
                                    let oldName = zone.toString();
                                    zone.rename(sense, orientation, true);
                                    if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                                        Direction.logger_$LI$().finer("zone " + oldName + " upgraded to " + zone.toString());
                                }
                                else if (zone.isOutbound() && !outbound) {
                                    if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))
                                        Direction.logger_$LI$().finest("zone " + zone.toString() + " aliased as " + ((sense === com.vzome.core.math.symmetry.Axis.MINUS) ? "-" : "") + orientation + (outbound ? "" : "i"));
                                }
                                else if (sense === com.vzome.core.math.symmetry.Axis.PLUS && (zone.getSense() === com.vzome.core.math.symmetry.Axis.MINUS)) {
                                    let oldName = zone.toString();
                                    zone.rename(sense, orientation, outbound);
                                    if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINER))
                                        Direction.logger_$LI$().finer("zone " + oldName + " upgraded to " + zone.toString());
                                }
                                else {
                                    if (Direction.logger_$LI$().isLoggable(java.util.logging.Level.FINEST))
                                        Direction.logger_$LI$().finest("zone " + zone.toString() + " aliased as " + ((sense === com.vzome.core.math.symmetry.Axis.MINUS) ? "-" : "") + orientation + (outbound ? "" : "i"));
                                }
                            }
                            this.zoneNames[outbound ? 1 : 0][sense][orientation] = zone;
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.Direction} other
                         * @return {number}
                         */
                        compareTo(other) {
                            return this.index - other.index;
                        }
                        setHalfSizes(value) {
                            this.__hasHalfSizes = value;
                        }
                        hasHalfSizes() {
                            return this.__hasHalfSizes;
                        }
                        setScaleNames(names) {
                            for (let i = 0; i < names.length; i++) {
                                {
                                    this.scaleNames[i] = names[i];
                                }
                                ;
                            }
                        }
                        getScaleName(scale) {
                            if (scale < this.scaleNames.length && scale >= 0)
                                return this.scaleNames[scale];
                            else
                                return "scale " + (scale - 1);
                        }
                        setUnitLength(unitLength) {
                            this.unitLength = unitLength;
                            this.unitLengthReciprocal = unitLength.reciprocal();
                        }
                        getUnitLength() {
                            if (this.unitLength == null)
                                return this.mSymmetryGroup.getField()['createPower$int'](0);
                            else
                                return this.unitLength;
                        }
                        getLengthInUnits(rawLength) {
                            let field = this.mSymmetryGroup.getField();
                            let scaledLength = rawLength['times$com_vzome_core_algebra_AlgebraicNumber'](field['createPower$int'](-Direction.USER_SCALE));
                            if (this.unitLength == null)
                                return scaledLength;
                            else
                                return scaledLength['times$com_vzome_core_algebra_AlgebraicNumber'](this.unitLengthReciprocal);
                        }
                        getLengthName(length) {
                            for (let i = 0; i < this.scales.length; i++) {
                                {
                                    if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                        return o1.equals(o2);
                                    }
                                    else {
                                        return o1 === o2;
                                    } })(this.scales[i], length)) {
                                        return this.scaleNames[i];
                                    }
                                }
                                ;
                            }
                            return "";
                        }
                        getLengthExpression(buf, length) {
                            let bufLen = buf.length();
                            buf.append(this.getLengthName(length));
                            if (buf.length() === bufLen) {
                                buf.append(" ");
                            }
                            buf.append(":");
                            length.getNumberExpression(buf, com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT);
                        }
                        getDotX() {
                            return this.dotX;
                        }
                        getDotY() {
                            return this.dotY;
                        }
                        setDotLocation(x, y) {
                            this.dotX = x;
                            this.dotY = y;
                        }
                    }
                    Direction.globalIndex = 0;
                    Direction.USER_SCALE = 3;
                    symmetry.Direction = Direction;
                    Direction["__class"] = "com.vzome.core.math.symmetry.Direction";
                    Direction["__interfaces"] = ["java.lang.Comparable", "java.lang.Iterable"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class B4Group {
                        constructor(field) {
                            if (this.field === undefined)
                                this.field = null;
                            this.ROOTS = [null, null, null, null];
                            this.WEIGHTS = [null, null, null, null];
                            this.field = field;
                            let neg_one = field['createRational$long'](-1);
                            this.ROOTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.ROOTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_one);
                            this.ROOTS[1] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
                            this.ROOTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_one);
                            this.ROOTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
                            this.ROOTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_one);
                            this.ROOTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.W4);
                            let y = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
                            let z = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
                            this.WEIGHTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.WEIGHTS[1] = this.WEIGHTS[0].plus(y);
                            this.WEIGHTS[2] = this.WEIGHTS[1].plus(z);
                            this.WEIGHTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            let half = field['createRational$long$long'](1, 2);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, half);
                            if (field.scale4dRoots()) {
                                let scale = field['createPower$int'](1);
                                this.ROOTS[3] = this.ROOTS[3].scale(scale);
                                this.WEIGHTS[3] = this.WEIGHTS[3].scale(scale);
                            }
                        }
                        static B4_PERMS_$LI$() { if (B4Group.B4_PERMS == null)
                            B4Group.B4_PERMS = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 2, 3, 1], [0, 3, 2, 1], [0, 3, 1, 2], [1, 0, 2, 3], [1, 0, 3, 2], [1, 2, 0, 3], [1, 2, 3, 0], [1, 3, 2, 0], [1, 3, 0, 2], [2, 1, 0, 3], [2, 1, 3, 0], [2, 0, 1, 3], [2, 0, 3, 1], [2, 3, 0, 1], [2, 3, 1, 0], [3, 1, 2, 0], [3, 1, 0, 2], [3, 2, 1, 0], [3, 2, 0, 1], [3, 0, 2, 1], [3, 0, 1, 2]]; return B4Group.B4_PERMS; }
                        ;
                        /**
                         *
                         * @return {number}
                         */
                        getOrder() {
                            return 24 * 16;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        groupAction(model, element) {
                            let result = this.field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            let perm = (element / 16 | 0);
                            let signs = element % 16;
                            for (let c = 0; c < 4; c++) {
                                {
                                    let source = model.getComponent((B4Group.B4_PERMS_$LI$()[perm][c] + 1) % 4);
                                    if (signs % 2 !== 0)
                                        source = source.negate();
                                    result.setComponent((c + 1) % 4, source);
                                    signs = signs >> 1;
                                }
                                ;
                            }
                            return result;
                        }
                        /**
                         *
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getOrigin() {
                            return this.field.origin(4);
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getWeight(i) {
                            return this.WEIGHTS[i];
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getSimpleRoot(i) {
                            return this.ROOTS[i];
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getField() {
                            return this.field;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        chiralSubgroupAction(model, element) {
                            let result = this.field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            let perm = (element / 16 | 0);
                            let signs = element % 16;
                            let even = true;
                            for (let c = 0; c < 4; c++) {
                                {
                                    let source = model.getComponent((B4Group.B4_PERMS_$LI$()[perm][c] + 1) % 4);
                                    if (signs % 2 !== 0) {
                                        even = !even;
                                        source = source.negate();
                                    }
                                    result.setComponent((c + 1) % 4, source);
                                    signs = signs >> 1;
                                }
                                ;
                            }
                            return even ? result : null;
                        }
                    }
                    symmetry.B4Group = B4Group;
                    B4Group["__class"] = "com.vzome.core.math.symmetry.B4Group";
                    B4Group["__interfaces"] = ["com.vzome.core.math.symmetry.CoxeterGroup"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    let Constants;
                    (function (Constants) {
                        Constants.RED = 0;
                        Constants.YELLOW = 1;
                        Constants.BLUE = 2;
                        Constants.GREEN = 3;
                        Constants.ORANGE = 4;
                        Constants.PURPLE = 5;
                        Constants.BLACK = 6;
                        Constants.NO_AXIS = 7;
                        /**
                         * Blue axes of basis.
                         */
                        Constants.X = 2;
                        /**
                         * Blue axes of basis.
                         */
                        Constants.Y = 5;
                        /**
                         * Blue axes of basis.
                         */
                        Constants.Z = 13;
                        Constants.SHORT = 3;
                        Constants.MEDIUM = 4;
                        Constants.LONG = 5;
                        Constants.JUST_RED = 1 << Constants.RED;
                        Constants.JUST_YELLOW = 1 << Constants.YELLOW;
                        Constants.JUST_BLUE = 1 << Constants.BLUE;
                        Constants.JUST_GREEN = 1 << Constants.GREEN;
                        Constants.JUST_ORANGE = 1 << Constants.ORANGE;
                        Constants.JUST_PURPLE = 1 << Constants.PURPLE;
                        Constants.JUST_BLACK = 1 << Constants.BLACK;
                        Constants.ORIGINAL_STRUTS = Constants.JUST_RED | Constants.JUST_YELLOW | Constants.JUST_BLUE;
                        Constants.ALL_STRUTS = Constants.ORIGINAL_STRUTS | Constants.JUST_GREEN | Constants.JUST_ORANGE | Constants.JUST_PURPLE | Constants.JUST_BLACK;
                        Constants.RED_AXIS_YELLOW_NEIGHBORS = [[0, 1, 2, 3, 4], [1, 0, 5, -8, 6], [2, 1, 6, -9, 7], [3, 2, 7, -5, 8], [4, 3, 8, -6, 9], [0, 4, 9, -7, 5]];
                        Constants.AXIS_SYMMETRY = [5, 3, 2, 1, 1, 1, 1];
                    })(Constants = symmetry.Constants || (symmetry.Constants = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                class VefParser {
                    constructor() {
                        this.mVersion = 0;
                        this.dimension = 4;
                        this.__isRational = false;
                        if (this.field === undefined)
                            this.field = null;
                        if (this.parsedOffset === undefined)
                            this.parsedOffset = null;
                    }
                    endVertices() {
                    }
                    endEdges() {
                    }
                    endFaces() {
                    }
                    endBalls() {
                    }
                    getVersion() {
                        return this.mVersion;
                    }
                    getField() {
                        return this.field;
                    }
                    isRational() {
                        return this.__isRational;
                    }
                    wFirst() {
                        return this.mVersion >= VefParser.VERSION_W_FIRST;
                    }
                    static fieldsAreCompatible(field, fieldName) {
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(fieldName, field.getName()))
                            return true;
                        return /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(fieldName, "golden") && field.getGoldenRatio() != null;
                    }
                    parseVEF(vefData, field) {
                        this.field = field;
                        let tokens = new java.util.StringTokenizer(vefData);
                        let token = null;
                        try {
                            token = tokens.nextToken();
                        }
                        catch (e1) {
                            throw new java.lang.IllegalStateException("VEF format error: no tokens in file data: \"" + vefData + "\"");
                        }
                        ;
                        this.mVersion = 0;
                        this.__isRational = false;
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(token, "vZome")) {
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e1) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"vZome\"");
                            }
                            ;
                            if (!((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })("VEF", token))
                                throw new java.lang.IllegalStateException("VEF format error: token after \"vZome\" (\"" + token + "\" should be \"VEF\"");
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e1) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"VEF\"");
                            }
                            ;
                            try {
                                this.mVersion = javaemul.internal.IntegerHelper.parseInt(token);
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException("VEF format error: VEF version number (\"" + token + "\") must be an integer", e);
                            }
                            ;
                            token = tokens.nextToken();
                        }
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(token, "field")) {
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e1) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"field\"");
                            }
                            ;
                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(token, "rational")) {
                                this.__isRational = true;
                                token = field.getName();
                            }
                            if (!VefParser.fieldsAreCompatible(field, token)) {
                                throw new java.lang.IllegalStateException("VEF field mismatch error: VEF field name (\"" + token + "\") does not match current model field name (\"" + field.getName() + "\").");
                            }
                            token = tokens.nextToken();
                        }
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(token, "actual")) {
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e1) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"actual\"");
                            }
                            ;
                        }
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(token, "dimension")) {
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e1) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"dimension\"");
                            }
                            ;
                            try {
                                this.dimension = javaemul.internal.IntegerHelper.parseInt(token);
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException("VEF format error: dimension number (\"" + token + "\") must be an integer", e);
                            }
                            ;
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"dimension\"");
                            }
                            ;
                        }
                        let scaleVector = new com.vzome.core.algebra.AlgebraicVector(field, this.dimension);
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(token, "scale")) {
                            try {
                                token = tokens.nextToken();
                                if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(token, "vector")) {
                                    try {
                                        for (let tokNum = 0; tokNum < this.dimension; tokNum++) {
                                            {
                                                token = tokens.nextToken();
                                                let coord = this.field.parseVefNumber(token, this.__isRational);
                                                scaleVector.setComponent(tokNum, coord);
                                            }
                                            ;
                                        }
                                    }
                                    catch (e) {
                                        throw new java.lang.IllegalStateException("VEF format error: scale vector requires " + this.dimension + " coordinates");
                                    }
                                    ;
                                }
                                else {
                                    let scale = this.field.parseVefNumber(token, this.__isRational);
                                    for (let i = 0; i < this.dimension; i++) {
                                        {
                                            scaleVector.setComponent(i, scale);
                                        }
                                        ;
                                    }
                                }
                                token = tokens.nextToken();
                            }
                            catch (e) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"scale\"");
                            }
                            ;
                        }
                        else {
                            for (let i = 0; i < this.dimension; i++) {
                                {
                                    scaleVector.setComponent(i, field.one());
                                }
                                ;
                            }
                        }
                        this.parsedOffset = new com.vzome.core.algebra.AlgebraicVector(field, this.dimension);
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(token, "offset")) {
                            try {
                                for (let tokNum = 0; tokNum < this.dimension; tokNum++) {
                                    {
                                        token = tokens.nextToken();
                                        let coord = this.field.parseVefNumber(token, this.__isRational);
                                        this.parsedOffset.setComponent(tokNum, coord);
                                    }
                                    ;
                                }
                            }
                            catch (e) {
                                throw new java.lang.IllegalStateException("VEF format error: offset vector requires " + this.dimension + " coordinates");
                            }
                            ;
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"offset\"");
                            }
                            ;
                        }
                        let numVertices;
                        try {
                            numVertices = javaemul.internal.IntegerHelper.parseInt(token);
                        }
                        catch (e) {
                            throw new java.lang.RuntimeException("VEF format error: number of vertices (\"" + token + "\") must be an integer", e);
                        }
                        ;
                        this.startVertices(numVertices);
                        let hasOffset = !this.parsedOffset.isOrigin();
                        for (let i = 0; i < numVertices; i++) {
                            {
                                let v = field.origin(this.dimension);
                                for (let tokNum = 0; tokNum < this.dimension; tokNum++) {
                                    {
                                        try {
                                            token = tokens.nextToken();
                                        }
                                        catch (e1) {
                                            throw new java.lang.IllegalStateException("VEF format error: not enough vertices in list");
                                        }
                                        ;
                                        let coord = this.field.parseVefNumber(token, this.__isRational)['times$com_vzome_core_algebra_AlgebraicNumber'](scaleVector.getComponent(tokNum));
                                        v.setComponent(tokNum, coord);
                                    }
                                    ;
                                }
                                if (hasOffset) {
                                    v = v.plus(this.parsedOffset);
                                }
                                this.addVertex(i, v);
                            }
                            ;
                        }
                        this.endVertices();
                        if (tokens.hasMoreTokens()) {
                            token = tokens.nextToken();
                            let numEdges;
                            try {
                                numEdges = javaemul.internal.IntegerHelper.parseInt(token);
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException("VEF format error: number of edges (\"" + token + "\") must be an integer", e);
                            }
                            ;
                            this.startEdges(numEdges);
                            for (let i = 0; i < numEdges; i++) {
                                {
                                    try {
                                        token = tokens.nextToken();
                                    }
                                    catch (e1) {
                                        throw new java.lang.IllegalStateException("VEF format error: not enough edges in list");
                                    }
                                    ;
                                    let v1 = javaemul.internal.IntegerHelper.parseInt(token);
                                    try {
                                        token = tokens.nextToken();
                                    }
                                    catch (e1) {
                                        throw new java.lang.IllegalStateException("VEF format error: 2nd vertex index of last edge is missing");
                                    }
                                    ;
                                    let v2 = javaemul.internal.IntegerHelper.parseInt(token);
                                    this.addEdge(i, v1, v2);
                                }
                                ;
                            }
                            this.endEdges();
                        }
                        if (tokens.hasMoreTokens()) {
                            token = tokens.nextToken();
                            let numFaces;
                            try {
                                numFaces = javaemul.internal.IntegerHelper.parseInt(token);
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException("VEF format error: number of faces (\"" + token + "\") must be an integer", e);
                            }
                            ;
                            this.startFaces(numFaces);
                            for (let i = 0; i < numFaces; i++) {
                                {
                                    try {
                                        token = tokens.nextToken();
                                    }
                                    catch (e1) {
                                        throw new java.lang.IllegalStateException("VEF format error: not enough faces in list");
                                    }
                                    ;
                                    let order = javaemul.internal.IntegerHelper.parseInt(token);
                                    let verts = (s => { let a = []; while (s-- > 0)
                                        a.push(0); return a; })(order);
                                    for (let j = 0; j < order; j++) {
                                        {
                                            try {
                                                token = tokens.nextToken();
                                            }
                                            catch (e1) {
                                                throw new java.lang.IllegalStateException("VEF format error: not enough vertices in last face");
                                            }
                                            ;
                                            verts[j] = javaemul.internal.IntegerHelper.parseInt(token);
                                        }
                                        ;
                                    }
                                    this.addFace(i, verts);
                                }
                                ;
                            }
                            this.endFaces();
                        }
                        if (tokens.hasMoreTokens()) {
                            token = tokens.nextToken();
                            let numBalls;
                            try {
                                numBalls = javaemul.internal.IntegerHelper.parseInt(token);
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException("VEF format error: number of balls (\"" + token + "\") must be an integer", e);
                            }
                            ;
                            this.startBalls(numBalls);
                            for (let i = 0; i < numBalls; i++) {
                                {
                                    try {
                                        token = tokens.nextToken();
                                    }
                                    catch (e1) {
                                        throw new java.lang.IllegalStateException("VEF format error: not enough balls in list");
                                    }
                                    ;
                                    let v1 = javaemul.internal.IntegerHelper.parseInt(token);
                                    this.addBall(i, v1);
                                }
                                ;
                            }
                            this.endBalls();
                        }
                        this.endFile(tokens);
                    }
                    endFile(tokens) {
                    }
                }
                VefParser.VERSION_EXPLICIT_OFFSET = 10;
                VefParser.VERSION_EXPLICIT_DIMENSION = 9;
                VefParser.VERSION_SCALE_VECTOR = 8;
                VefParser.VERSION_RATIONAL_ACTUAL_SCALE = 7;
                VefParser.VERSION_EXPLICIT_BALLS = 6;
                VefParser.VERSION_ANY_FIELD = 5;
                VefParser.VERSION_W_FIRST = 4;
                math.VefParser = VefParser;
                VefParser["__class"] = "com.vzome.core.math.VefParser";
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                /**
                 * @param {*} field
                 * @param {com.vzome.core.algebra.AlgebraicVector} leftQuat
                 * @param {com.vzome.core.algebra.AlgebraicVector} rightQuat
                 * @class
                 */
                class QuaternionProjection {
                    constructor(field, leftQuat, rightQuat) {
                        this.quaternions = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                            return null;
                        }
                        else {
                            let array = [];
                            for (let i = 0; i < dims[0]; i++) {
                                array.push(allocate(dims.slice(1)));
                            }
                            return array;
                        } }; return allocate(dims); })([2, 2]);
                        if (this.field === undefined)
                            this.field = null;
                        this.field = field;
                        this.setQuaternion(leftQuat, QuaternionProjection.LEFT);
                        this.setQuaternion(rightQuat, QuaternionProjection.RIGHT);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} source
                     * @param {boolean} wFirst
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    projectImage(source, wFirst) {
                        let result = source;
                        let leftQuat = this.getQuaternion(QuaternionProjection.LEFT, wFirst);
                        let rightQuat = this.getQuaternion(QuaternionProjection.RIGHT, wFirst);
                        if (rightQuat != null) {
                            if (leftQuat != null) {
                                result = leftQuat.rightMultiply(result);
                                console.info("left mult: " + result.toString());
                            }
                            result = rightQuat.leftMultiply(result);
                        }
                        else {
                            result = leftQuat.rightMultiply(result);
                        }
                        return this.field.projectTo3d(result, wFirst);
                    }
                    /*private*/ setQuaternion(quatVector, hand) {
                        this.quaternions[hand][QuaternionProjection.WFIRST] = quatVector == null ? null : new com.vzome.core.algebra.Quaternion(this.field, quatVector.inflateTo4d$boolean(true));
                        this.quaternions[hand][QuaternionProjection.WLAST] = quatVector == null ? null : new com.vzome.core.algebra.Quaternion(this.field, quatVector.inflateTo4d$boolean(false));
                    }
                    /*private*/ getQuaternion(hand, wFirst) {
                        return this.quaternions[hand][wFirst ? QuaternionProjection.WFIRST : QuaternionProjection.WLAST];
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        let leftQuat = this.getQuaternion(QuaternionProjection.LEFT, true);
                        let rightQuat = this.getQuaternion(QuaternionProjection.RIGHT, true);
                        if (leftQuat != null) {
                            com.vzome.xml.DomUtils.addAttribute(element, QuaternionProjection.LEFT_QUATERNION_ATTRIBUTENAME, leftQuat.getVector().toParsableString());
                        }
                        if (rightQuat != null) {
                            com.vzome.xml.DomUtils.addAttribute(element, QuaternionProjection.RIGHT_QUATERNION_ATTRIBUTENAME, rightQuat.getVector().toParsableString());
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    setXmlAttributes(xml) {
                        this.setQuaternion(this.parseRationalVector(xml, QuaternionProjection.LEFT_QUATERNION_ATTRIBUTENAME), QuaternionProjection.LEFT);
                        this.setQuaternion(this.parseRationalVector(xml, QuaternionProjection.RIGHT_QUATERNION_ATTRIBUTENAME), QuaternionProjection.RIGHT);
                    }
                    /*private*/ parseRationalVector(xml, attrName) {
                        let nums = xml.getAttribute(attrName);
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return null;
                        let loc = this.field.parseVector(nums);
                        return loc;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getProjectionName() {
                        return "Quaternion";
                    }
                }
                QuaternionProjection.LEFT = 0;
                QuaternionProjection.RIGHT = 1;
                QuaternionProjection.WFIRST = 0;
                QuaternionProjection.WLAST = 1;
                QuaternionProjection.RIGHT_QUATERNION_ATTRIBUTENAME = "quaternion";
                QuaternionProjection.LEFT_QUATERNION_ATTRIBUTENAME = "leftQuaternion";
                math.QuaternionProjection = QuaternionProjection;
                QuaternionProjection["__class"] = "com.vzome.core.math.QuaternionProjection";
                QuaternionProjection["__interfaces"] = ["com.vzome.core.math.Projection"];
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                let Projection;
                (function (Projection) {
                    class Default {
                        constructor(field) {
                            if (this.field === undefined)
                                this.field = null;
                            this.field = field;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} source
                         * @param {boolean} wFirst
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        projectImage(source, wFirst) {
                            return this.field.projectTo3d(source, wFirst);
                        }
                        /**
                         *
                         * @param {*} element
                         */
                        getXmlAttributes(element) {
                        }
                        /**
                         *
                         * @param {*} xml
                         */
                        setXmlAttributes(xml) {
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getProjectionName() {
                            return "";
                        }
                    }
                    Projection.Default = Default;
                    Default["__class"] = "com.vzome.core.math.Projection.Default";
                    Default["__interfaces"] = ["com.vzome.core.math.Projection"];
                })(Projection = math.Projection || (math.Projection = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                class PerspectiveProjection {
                    constructor(field, cameraDist) {
                        if (this.field === undefined)
                            this.field = null;
                        if (this.cameraDist === undefined)
                            this.cameraDist = null;
                        if (this.minDenom === undefined)
                            this.minDenom = null;
                        if (this.minDenomValue === undefined)
                            this.minDenomValue = 0;
                        this.field = field;
                        this.cameraDist = cameraDist;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} source
                     * @param {boolean} wFirst
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    projectImage(source, wFirst) {
                        let result = this.field.origin(4);
                        let w = source.getComponent(0);
                        let denom = this.cameraDist['minus$com_vzome_core_algebra_AlgebraicNumber'](w);
                        if (this.minDenom == null) {
                            this.minDenom = this.field['createPower$int'](-5);
                            this.minDenomValue = this.minDenom.evaluate();
                        }
                        let denomValue = denom.evaluate();
                        if (denomValue < this.minDenomValue) {
                            denom = this.minDenom;
                        }
                        let numerator = denom.reciprocal();
                        result.setComponent(0, this.field['createPower$int'](0));
                        result.setComponent(1, source.getComponent(1)['times$com_vzome_core_algebra_AlgebraicNumber'](numerator));
                        result.setComponent(2, source.getComponent(2)['times$com_vzome_core_algebra_AlgebraicNumber'](numerator));
                        result.setComponent(3, source.getComponent(3)['times$com_vzome_core_algebra_AlgebraicNumber'](numerator));
                        return result;
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.cameraDist != null) {
                            com.vzome.xml.DomUtils.addAttribute(element, "cameraDist", this.cameraDist.toString(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    setXmlAttributes(xml) {
                        let nums = xml.getAttribute("cameraDist");
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return;
                        this.cameraDist = this.field.parseNumber(nums);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getProjectionName() {
                        return "Perspective";
                    }
                }
                math.PerspectiveProjection = PerspectiveProjection;
                PerspectiveProjection["__class"] = "com.vzome.core.math.PerspectiveProjection";
                PerspectiveProjection["__interfaces"] = ["com.vzome.core.math.Projection"];
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                class Line {
                    constructor(origin, direction) {
                        if (this.origin === undefined)
                            this.origin = null;
                        if (this.direction === undefined)
                            this.direction = null;
                        this.direction = direction;
                        this.origin = origin;
                    }
                    getOrigin() {
                        return this.origin;
                    }
                    getDirection() {
                        return this.direction;
                    }
                }
                math.Line = Line;
                Line["__class"] = "com.vzome.core.math.Line";
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var model;
            (function (model_1) {
                class ColoredMeshJson {
                    static generate(model, field, writer) {
                        let vertices = (new java.util.TreeSet());
                        let balls = (new java.util.ArrayList());
                        let struts = (new java.util.ArrayList());
                        let panels = (new java.util.ArrayList());
                        let lastBall = null;
                        let lastVertex = null;
                        for (let index161 = model.iterator(); index161.hasNext();) {
                            let man = index161.next();
                            {
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    lastBall = man.getLocation();
                                    vertices.add(lastBall);
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    lastVertex = man.getLocation();
                                    vertices.add(lastVertex);
                                    vertices.add(man.getEnd());
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    for (let index162 = man.iterator(); index162.hasNext();) {
                                        let vertex = index162.next();
                                        {
                                            lastVertex = vertex;
                                            vertices.add(vertex);
                                        }
                                    }
                                }
                            }
                        }
                        let origin = (lastBall != null) ? lastBall : lastVertex;
                        let sortedVertexList = (new java.util.ArrayList(vertices));
                        vertices = null;
                        let mapper = new com.fasterxml.jackson.databind.ObjectMapper();
                        for (let index163 = model.iterator(); index163.hasNext();) {
                            let man = index163.next();
                            {
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    let ballJson = mapper.createObjectNode();
                                    ballJson.set("vertex", (mapper.valueToTree(sortedVertexList.indexOf(man.getLocation()))));
                                    ballJson.set("color", (mapper.valueToTree(man.getColor().toWebString())));
                                    balls.add(ballJson);
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    let strutJson = mapper.createObjectNode();
                                    let start = sortedVertexList.indexOf(man.getLocation());
                                    let end = sortedVertexList.indexOf(man.getEnd());
                                    let ends = (mapper.valueToTree([start, end]));
                                    strutJson.set("vertices", ends);
                                    strutJson.set("color", (mapper.valueToTree(man.getColor().toWebString())));
                                    struts.add(strutJson);
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    let panelJson = mapper.createObjectNode();
                                    let vertexStream = java.util.stream.StreamSupport.stream(man.spliterator(), false);
                                    let node = (mapper.valueToTree((vertexStream.map(((sortedVertexList) => {
                                        return (v) => sortedVertexList.indexOf(v);
                                    })(sortedVertexList)).collect(java.util.stream.Collectors.toList()))));
                                    panelJson.set("vertices", node);
                                    panelJson.set("color", (mapper.valueToTree(man.getColor().toWebString())));
                                    panels.add(panelJson);
                                }
                            }
                        }
                        let factory = new com.fasterxml.jackson.core.JsonFactory().disable(com.fasterxml.jackson.core.JsonGenerator.Feature.AUTO_CLOSE_TARGET);
                        let generator = factory.createGenerator(writer);
                        generator.useDefaultPrettyPrinter();
                        generator.setCodec(mapper);
                        generator.writeStartObject();
                        generator.writeStringField("field", field.getName());
                        generator.writeFieldName("vertices");
                        generator.writeStartArray();
                        let objectWriter = mapper.writerWithView("com.vzome.core.algebra.AlgebraicNumber.Views.TrailingDivisor");
                        for (let index164 = sortedVertexList.iterator(); index164.hasNext();) {
                            let algebraicVector = index164.next();
                            {
                                algebraicVector = algebraicVector.minus(origin);
                                generator.writeObject(mapper.readTree(objectWriter.writeValueAsString(algebraicVector)));
                            }
                        }
                        generator.writeEndArray();
                        generator.writeObjectField("balls", balls);
                        generator.writeObjectField("struts", struts);
                        generator.writeObjectField("panels", panels);
                        generator.writeEndObject();
                        generator.close();
                    }
                    static parse(json, offset, projection, events, registry) {
                        let mapper = new com.fasterxml.jackson.databind.ObjectMapper();
                        let node = mapper.readTree(json);
                        let fieldName = (node.has("field")) ? node.get("field").asText() : "golden";
                        let field = registry.getField(fieldName);
                        if (!node.has("vertices")) {
                            throw new java.io.IOException("There is no \'vertices\' list in the JSON");
                        }
                        if (!node.has("balls") && !node.has("struts") && !node.has("panels")) {
                            throw new java.io.IOException("There are no balls, struts, or panels in the JSON");
                        }
                        let vertices = (new java.util.ArrayList());
                        {
                            let verticesNode = node.get("vertices");
                            for (let index165 = verticesNode.iterator(); index165.hasNext();) {
                                let vectorNode = index165.next();
                                {
                                    let dimension = vectorNode.size();
                                    let nums = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(dimension);
                                    let i = 0;
                                    for (let index166 = vectorNode.iterator(); index166.hasNext();) {
                                        let numberNode = index166.next();
                                        {
                                            nums[i++] = (mapper.treeToValue(numberNode, [].constructor));
                                        }
                                    }
                                    let vertex = field.createIntegerVectorFromTDs(nums);
                                    if (vertex.dimension() > 3)
                                        vertex = projection.projectImage(vertex, false);
                                    if (offset != null)
                                        vertex = offset.plus(vertex);
                                    vertices.add(vertex);
                                }
                            }
                        }
                        ;
                        let collection = node.get("balls");
                        if (collection != null) {
                            try {
                                let indices = (mapper.treeToValue(collection, [].constructor));
                                java.util.Arrays.stream(indices).forEach(((vertices) => {
                                    return (i) => events.constructionAdded(new com.vzome.core.construction.FreePoint(vertices.get(i)), null);
                                })(vertices));
                            }
                            catch (e) {
                                for (let index167 = collection.iterator(); index167.hasNext();) {
                                    let ballNode = index167.next();
                                    {
                                        let vertexNode = ballNode.get("vertex");
                                        let i = vertexNode.asInt();
                                        let colorNode = ballNode.get("color");
                                        let color = (colorNode == null) ? null : com.vzome.core.construction.Color.parseWebColor(colorNode.asText());
                                        events.constructionAdded(new com.vzome.core.construction.FreePoint(vertices.get(i)), color);
                                    }
                                }
                            }
                            ;
                        }
                        collection = node.get("struts");
                        if (collection != null) {
                            for (let index168 = collection.iterator(); index168.hasNext();) {
                                let strutNode = index168.next();
                                {
                                    if (strutNode.has("start")) {
                                        let start = (mapper.treeToValue(strutNode.get("start"), Number));
                                        let end = (mapper.treeToValue(strutNode.get("end"), Number));
                                        let p1 = new com.vzome.core.construction.FreePoint(vertices.get(start));
                                        let p2 = new com.vzome.core.construction.FreePoint(vertices.get(end));
                                        events.constructionAdded(new com.vzome.core.construction.SegmentJoiningPoints(p1, p2), null);
                                    }
                                    else {
                                        let verticesNode = strutNode.get("vertices");
                                        let ends = (mapper.treeToValue(verticesNode, [].constructor));
                                        let p1 = new com.vzome.core.construction.FreePoint(vertices.get(ends[0]));
                                        let p2 = new com.vzome.core.construction.FreePoint(vertices.get(ends[1]));
                                        let colorNode = strutNode.get("color");
                                        let color = (colorNode == null) ? null : com.vzome.core.construction.Color.parseWebColor(colorNode.asText());
                                        events.constructionAdded(new com.vzome.core.construction.SegmentJoiningPoints(p1, p2), color);
                                    }
                                }
                            }
                        }
                        collection = node.get("panels");
                        if (collection != null) {
                            for (let index169 = collection.iterator(); index169.hasNext();) {
                                let panelNode = index169.next();
                                {
                                    let verticesNode = panelNode.get("vertices");
                                    let indices = (mapper.treeToValue(verticesNode, [].constructor));
                                    let points = (java.util.Arrays.stream(indices).mapToObj(((vertices) => {
                                        return (i) => new com.vzome.core.construction.FreePoint(vertices.get(i));
                                    })(vertices)).collect(java.util.stream.Collectors.toList()));
                                    let panel = new com.vzome.core.construction.PolygonFromVertices(points);
                                    let colorNode = panelNode.get("color");
                                    let color = (colorNode == null) ? null : com.vzome.core.construction.Color.parseWebColor(colorNode.asText());
                                    events.constructionAdded(panel, color);
                                }
                            }
                        }
                    }
                }
                model_1.ColoredMeshJson = ColoredMeshJson;
                ColoredMeshJson["__class"] = "com.vzome.core.model.ColoredMeshJson";
            })(model = core.model || (core.model = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var model;
            (function (model) {
                class Group extends java.util.ArrayList {
                    constructor() {
                        super();
                        if (this.mContainer === undefined)
                            this.mContainer = null;
                    }
                    getContainer() {
                        return this.mContainer;
                    }
                    /**
                     *
                     * @param {com.vzome.core.model.Group} container
                     */
                    setContainer(container) {
                        this.mContainer = container;
                    }
                }
                model.Group = Group;
                Group["__class"] = "com.vzome.core.model.Group";
                Group["__interfaces"] = ["java.util.RandomAccess", "com.vzome.core.model.GroupElement", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
            })(model = core.model || (core.model = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var model;
            (function (model_2) {
                class SimpleMeshJson {
                    static generate(model, field, writer) {
                        let vertices = (new java.util.TreeSet());
                        let vertexIndices = (new java.util.ArrayList());
                        let edgeNodes = (new java.util.ArrayList());
                        let faceNodes = (new java.util.ArrayList());
                        let lastBall = null;
                        let lastVertex = null;
                        for (let index170 = model.iterator(); index170.hasNext();) {
                            let man = index170.next();
                            {
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    lastBall = man.getLocation();
                                    vertices.add(lastBall);
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    lastVertex = man.getLocation();
                                    vertices.add(lastVertex);
                                    vertices.add(man.getEnd());
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    for (let index171 = man.iterator(); index171.hasNext();) {
                                        let vertex = index171.next();
                                        {
                                            lastVertex = vertex;
                                            vertices.add(vertex);
                                        }
                                    }
                                }
                            }
                        }
                        let origin = (lastBall != null) ? lastBall : lastVertex;
                        let sortedVertexList = (new java.util.ArrayList(vertices));
                        vertices = null;
                        let mapper = new com.fasterxml.jackson.databind.ObjectMapper();
                        for (let index172 = model.iterator(); index172.hasNext();) {
                            let man = index172.next();
                            {
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    vertexIndices.add(sortedVertexList.indexOf(man.getLocation()));
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    let start = sortedVertexList.indexOf(man.getLocation());
                                    let end = sortedVertexList.indexOf(man.getEnd());
                                    let ends = (mapper.valueToTree([start, end]));
                                    edgeNodes.add(ends);
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    let vertexStream = java.util.stream.StreamSupport.stream(man.spliterator(), false);
                                    let node = (mapper.valueToTree((vertexStream.map(((sortedVertexList) => {
                                        return (v) => sortedVertexList.indexOf(v);
                                    })(sortedVertexList)).collect(java.util.stream.Collectors.toList()))));
                                    faceNodes.add(node);
                                }
                            }
                        }
                        let factory = new com.fasterxml.jackson.core.JsonFactory().disable(com.fasterxml.jackson.core.JsonGenerator.Feature.AUTO_CLOSE_TARGET);
                        let generator = factory.createGenerator(writer);
                        generator.useDefaultPrettyPrinter();
                        generator.setCodec(mapper);
                        generator.writeStartObject();
                        generator.writeStringField("field", field.getName());
                        generator.writeFieldName("vertices");
                        generator.writeStartArray();
                        let objectWriter = mapper.writerWithView("com.vzome.core.algebra.AlgebraicNumber.Views.TrailingDivisor");
                        for (let index173 = sortedVertexList.iterator(); index173.hasNext();) {
                            let algebraicVector = index173.next();
                            {
                                algebraicVector = algebraicVector.minus(origin);
                                generator.writeObject(mapper.readTree(objectWriter.writeValueAsString(algebraicVector)));
                            }
                        }
                        generator.writeEndArray();
                        generator.writeObjectField("edges", edgeNodes);
                        generator.writeObjectField("faces", faceNodes);
                        generator.writeEndObject();
                        generator.close();
                    }
                    static parse(json, offset, projection, events, registry) {
                        let mapper = new com.fasterxml.jackson.databind.ObjectMapper();
                        let node = mapper.readTree(json);
                        let fieldName = (node.has("field")) ? node.get("field").asText() : "golden";
                        let field = registry.getField(fieldName);
                        if (!node.has("vertices")) {
                            throw new java.io.IOException("There is no \'vertices\' list in the JSON");
                        }
                        if (!node.has("edges")) {
                            throw new java.io.IOException("There is no \'edges\' list in the JSON");
                        }
                        if (!node.has("faces")) {
                            throw new java.io.IOException("There is no \'faces\' list in the JSON");
                        }
                        let vertices = (new java.util.ArrayList());
                        {
                            let verticesNode = node.get("vertices");
                            for (let index174 = verticesNode.iterator(); index174.hasNext();) {
                                let vectorNode = index174.next();
                                {
                                    let dimension = vectorNode.size();
                                    let nums = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(dimension);
                                    let i = 0;
                                    for (let index175 = vectorNode.iterator(); index175.hasNext();) {
                                        let numberNode = index175.next();
                                        {
                                            nums[i++] = (mapper.treeToValue(numberNode, [].constructor));
                                        }
                                    }
                                    let vertex = field.createIntegerVectorFromTDs(nums);
                                    if (vertex.dimension() > 3)
                                        vertex = projection.projectImage(vertex, false);
                                    if (offset != null)
                                        vertex = offset.plus(vertex);
                                    vertices.add(vertex);
                                }
                            }
                        }
                        ;
                        let collection = node.get("edges");
                        for (let index176 = collection.iterator(); index176.hasNext();) {
                            let strutNode = index176.next();
                            {
                                let ends = (mapper.treeToValue(strutNode, [].constructor));
                                let p1 = new com.vzome.core.construction.FreePoint(vertices.get(ends[0]));
                                let p2 = new com.vzome.core.construction.FreePoint(vertices.get(ends[1]));
                                events.constructionAdded(p1);
                                events.constructionAdded(p2);
                                events.constructionAdded(new com.vzome.core.construction.SegmentJoiningPoints(p1, p2));
                            }
                        }
                        collection = node.get("faces");
                        for (let index177 = collection.iterator(); index177.hasNext();) {
                            let panelNode = index177.next();
                            {
                                let indices = (mapper.treeToValue(panelNode, [].constructor));
                                let points = (java.util.Arrays.stream(indices).mapToObj(((vertices) => {
                                    return (i) => new com.vzome.core.construction.FreePoint(vertices.get(i));
                                })(vertices)).collect(java.util.stream.Collectors.toList()));
                                let panel = new com.vzome.core.construction.PolygonFromVertices(points);
                                events.constructionAdded(panel);
                            }
                        }
                    }
                }
                model_2.SimpleMeshJson = SimpleMeshJson;
                SimpleMeshJson["__class"] = "com.vzome.core.model.SimpleMeshJson";
            })(model = core.model || (core.model = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var parts;
            (function (parts) {
                /**
                 * @author Scott Vorthmann
                 *
                 * Since every field allows octahedral symmetry, we want the richest triangular
                 * tiling of that symmetry, which means we want the fundamental triangles of
                 * the reflection group, by definition.  Rather than rely on any symmetry orbits,
                 * we can simply hard-code the vertices of a disdyakis dodecahedron, all
                 * reflections and permutations of (8,0,0), (4,4,4), and (5,5,0).
                 * (This is a simple approximation with integers.)
                 * These vertices correspond to blue-like, yellow-like, and green-like axes,
                 * in the usual Zome coloring.
                 * @param {com.vzome.core.math.symmetry.Direction} dir
                 * @class
                 */
                class FastDefaultStrutGeometry {
                    constructor(dir) {
                        if (this.g2_vector === undefined)
                            this.g2_vector = null;
                        if (this.b2_vector === undefined)
                            this.b2_vector = null;
                        if (this.y2_vector === undefined)
                            this.y2_vector = null;
                        if (this.g2n_vector === undefined)
                            this.g2n_vector = null;
                        if (this.y2n_vector === undefined)
                            this.y2n_vector = null;
                        if (this.mAxis === undefined)
                            this.mAxis = null;
                        this.mAxis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0);
                        let v = this.mAxis.normal();
                        let x = v.getComponent(com.vzome.core.algebra.AlgebraicVector.X).evaluate();
                        let y = v.getComponent(com.vzome.core.algebra.AlgebraicVector.Y).evaluate();
                        let z = v.getComponent(com.vzome.core.algebra.AlgebraicVector.Z).evaluate();
                        let evenParity = true;
                        let xNeg = x < 0.0;
                        if (xNeg) {
                            x = -x;
                            evenParity = !evenParity;
                        }
                        let yNeg = y < 0.0;
                        if (yNeg) {
                            y = -y;
                            evenParity = !evenParity;
                        }
                        let zNeg = z < 0.0;
                        if (zNeg) {
                            z = -z;
                            evenParity = !evenParity;
                        }
                        let first;
                        let second;
                        let third;
                        let firstNeg;
                        let secondNeg;
                        let thirdNeg;
                        if (x >= y) {
                            if (y >= z) {
                                first = com.vzome.core.algebra.AlgebraicVector.X;
                                firstNeg = xNeg;
                                second = com.vzome.core.algebra.AlgebraicVector.Y;
                                secondNeg = yNeg;
                                third = com.vzome.core.algebra.AlgebraicVector.Z;
                                thirdNeg = zNeg;
                            }
                            else if (x >= z) {
                                first = com.vzome.core.algebra.AlgebraicVector.X;
                                firstNeg = xNeg;
                                second = com.vzome.core.algebra.AlgebraicVector.Z;
                                secondNeg = zNeg;
                                third = com.vzome.core.algebra.AlgebraicVector.Y;
                                thirdNeg = yNeg;
                                evenParity = !evenParity;
                            }
                            else {
                                first = com.vzome.core.algebra.AlgebraicVector.Z;
                                firstNeg = zNeg;
                                second = com.vzome.core.algebra.AlgebraicVector.X;
                                secondNeg = xNeg;
                                third = com.vzome.core.algebra.AlgebraicVector.Y;
                                thirdNeg = yNeg;
                            }
                        }
                        else {
                            if (x >= z) {
                                first = com.vzome.core.algebra.AlgebraicVector.Y;
                                firstNeg = yNeg;
                                second = com.vzome.core.algebra.AlgebraicVector.X;
                                secondNeg = xNeg;
                                third = com.vzome.core.algebra.AlgebraicVector.Z;
                                thirdNeg = zNeg;
                                evenParity = !evenParity;
                            }
                            else if (y >= z) {
                                first = com.vzome.core.algebra.AlgebraicVector.Y;
                                firstNeg = yNeg;
                                second = com.vzome.core.algebra.AlgebraicVector.Z;
                                secondNeg = zNeg;
                                third = com.vzome.core.algebra.AlgebraicVector.X;
                                thirdNeg = xNeg;
                            }
                            else {
                                first = com.vzome.core.algebra.AlgebraicVector.Z;
                                firstNeg = zNeg;
                                second = com.vzome.core.algebra.AlgebraicVector.Y;
                                secondNeg = yNeg;
                                third = com.vzome.core.algebra.AlgebraicVector.X;
                                thirdNeg = xNeg;
                                evenParity = !evenParity;
                            }
                        }
                        let field = v.getField();
                        let eight = field['createRational$long$long'](8, 10);
                        this.b2_vector = field.origin(3);
                        this.b2_vector.setComponent(first, firstNeg ? eight.negate() : eight);
                        let five = field['createRational$long$long'](5, 10);
                        this.g2_vector = field.origin(3);
                        this.g2_vector.setComponent(first, firstNeg ? five.negate() : five);
                        this.g2_vector.setComponent(second, secondNeg ? five.negate() : five);
                        let four = field['createRational$long$long'](4, 10);
                        this.y2_vector = field.origin(3);
                        this.y2_vector.setComponent(first, firstNeg ? four.negate() : four);
                        this.y2_vector.setComponent(second, secondNeg ? four.negate() : four);
                        this.y2_vector.setComponent(third, thirdNeg ? four.negate() : four);
                        if (!evenParity) {
                            let swap = this.y2_vector;
                            this.y2_vector = this.g2_vector;
                            this.g2_vector = swap;
                        }
                        let centroid = com.vzome.core.algebra.AlgebraicVectors.getCentroid([this.b2_vector, this.g2_vector, this.y2_vector]);
                        let b2g2 = this.g2_vector.minus(this.b2_vector);
                        let y2g2 = this.g2_vector.minus(this.y2_vector);
                        let normal = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(b2g2, y2g2);
                        let intersection = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(field.origin(3), v, this.g2_vector, normal);
                        let g2_offset = this.g2_vector.minus(centroid);
                        let y2_offset = this.y2_vector.minus(centroid);
                        this.g2_vector = intersection.plus(g2_offset);
                        this.y2_vector = intersection.plus(y2_offset);
                        this.g2n_vector = intersection.minus(g2_offset);
                        this.y2n_vector = intersection.minus(y2_offset);
                    }
                    /**
                     *
                     * @param {*} length
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    getStrutPolyhedron(length) {
                        let field = this.mAxis.getDirection().getSymmetry().getField();
                        let poly = new com.vzome.core.math.Polyhedron(field);
                        let strutVector = this.mAxis.normal().scale(length);
                        let g1_vector = this.g2_vector.negate().plus(strutVector);
                        let y1_vector = this.y2_vector.negate().plus(strutVector);
                        let g1n_vector = this.g2n_vector.negate().plus(strutVector);
                        let y1n_vector = this.y2n_vector.negate().plus(strutVector);
                        poly.addVertex(y1_vector);
                        let y1 = 0;
                        poly.addVertex(g1_vector);
                        let g1 = 1;
                        poly.addVertex(this.y2_vector);
                        let y2 = 2;
                        poly.addVertex(this.g2_vector);
                        let g2 = 3;
                        poly.addVertex(y1n_vector);
                        let y1n = 4;
                        poly.addVertex(g1n_vector);
                        let g1n = 5;
                        poly.addVertex(this.y2n_vector);
                        let y2n = 6;
                        poly.addVertex(this.g2n_vector);
                        let g2n = 7;
                        let face = poly.newFace();
                        face.add(g2);
                        face.add(y2);
                        face.add(y1n);
                        face.add(g1n);
                        poly.addFace(face);
                        face = poly.newFace();
                        face.add(g2);
                        face.add(g1n);
                        face.add(y1);
                        face.add(y2n);
                        poly.addFace(face);
                        face = poly.newFace();
                        face.add(g2n);
                        face.add(y2n);
                        face.add(y1);
                        face.add(g1);
                        poly.addFace(face);
                        face = poly.newFace();
                        face.add(g2n);
                        face.add(g1);
                        face.add(y1n);
                        face.add(y2);
                        poly.addFace(face);
                        face = poly.newFace();
                        face.add(y2);
                        face.add(g2);
                        face.add(y2n);
                        face.add(g2n);
                        poly.addFace(face);
                        face = poly.newFace();
                        face.add(g1);
                        face.add(y1);
                        face.add(g1n);
                        face.add(y1n);
                        poly.addFace(face);
                        return poly;
                    }
                }
                parts.FastDefaultStrutGeometry = FastDefaultStrutGeometry;
                FastDefaultStrutGeometry["__class"] = "com.vzome.core.parts.FastDefaultStrutGeometry";
                FastDefaultStrutGeometry["__interfaces"] = ["com.vzome.core.parts.StrutGeometry"];
            })(parts = core.parts || (core.parts = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 */
                class Construction {
                    constructor(field) {
                        if (this.field === undefined)
                            this.field = null;
                        this.mImpossible = false;
                        this.mIndex = -1;
                        this.__failed = false;
                        if (this.color === undefined)
                            this.color = null;
                        this.field = field;
                    }
                    getField() {
                        return this.field;
                    }
                    setIndex(index) {
                        this.mIndex = index;
                    }
                    getIndex() {
                        return this.mIndex;
                    }
                    isImpossible() {
                        return this.mImpossible;
                    }
                    setImpossible(value) {
                        this.mImpossible = value;
                    }
                    setFailed() {
                        this.__failed = true;
                    }
                    failed() {
                        return this.__failed;
                    }
                    setColor(color) {
                        this.color = color;
                    }
                    getColor() {
                        return this.color;
                    }
                }
                construction.Construction = Construction;
                Construction["__class"] = "com.vzome.core.construction.Construction";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * A selection in the model.
                 * @class
                 * @extends java.util.ArrayList
                 */
                class ConstructionList extends java.util.ArrayList {
                    addConstruction(ball) {
                        this.add(ball);
                        return this;
                    }
                    removeConstruction(ball) {
                        this.remove(ball);
                        return this;
                    }
                    getConstructions() {
                        return this.toArray((s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.size()));
                    }
                    constructor() {
                        super();
                    }
                }
                construction.ConstructionList = ConstructionList;
                ConstructionList["__class"] = "com.vzome.core.construction.ConstructionList";
                ConstructionList["__interfaces"] = ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {number} r
                 * @param {number} g
                 * @param {number} b
                 * @param {number} a
                 * @class
                 */
                class Color {
                    constructor(r, g, b, a) {
                        if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && ((typeof a === 'number') || a === null)) {
                            let __args = arguments;
                            if (this.red === undefined)
                                this.red = 0;
                            if (this.green === undefined)
                                this.green = 0;
                            if (this.blue === undefined)
                                this.blue = 0;
                            if (this.alpha === undefined)
                                this.alpha = 0;
                            if (this.red === undefined)
                                this.red = 0;
                            if (this.green === undefined)
                                this.green = 0;
                            if (this.blue === undefined)
                                this.blue = 0;
                            if (this.alpha === undefined)
                                this.alpha = 0;
                            (() => {
                                this.red = r > 255 ? 255 : (r < 0 ? 0 : r);
                                this.green = g > 255 ? 255 : (g < 0 ? 0 : g);
                                this.blue = b > 255 ? 255 : (b < 0 ? 0 : b);
                                this.alpha = a > 255 ? 255 : (a < 0 ? 0 : a);
                            })();
                        }
                        else if (((typeof r === 'number') || r === null) && ((typeof g === 'number') || g === null) && ((typeof b === 'number') || b === null) && a === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let a = 255;
                                if (this.red === undefined)
                                    this.red = 0;
                                if (this.green === undefined)
                                    this.green = 0;
                                if (this.blue === undefined)
                                    this.blue = 0;
                                if (this.alpha === undefined)
                                    this.alpha = 0;
                                if (this.red === undefined)
                                    this.red = 0;
                                if (this.green === undefined)
                                    this.green = 0;
                                if (this.blue === undefined)
                                    this.blue = 0;
                                if (this.alpha === undefined)
                                    this.alpha = 0;
                                (() => {
                                    this.red = r > 255 ? 255 : (r < 0 ? 0 : r);
                                    this.green = g > 255 ? 255 : (g < 0 ? 0 : g);
                                    this.blue = b > 255 ? 255 : (b < 0 ? 0 : b);
                                    this.alpha = a > 255 ? 255 : (a < 0 ? 0 : a);
                                })();
                            }
                        }
                        else if (((typeof r === 'string') || r === null) && g === undefined && b === undefined && a === undefined) {
                            let __args = arguments;
                            let rgbaHex = __args[0];
                            if (this.red === undefined)
                                this.red = 0;
                            if (this.green === undefined)
                                this.green = 0;
                            if (this.blue === undefined)
                                this.blue = 0;
                            if (this.alpha === undefined)
                                this.alpha = 0;
                            if (this.red === undefined)
                                this.red = 0;
                            if (this.green === undefined)
                                this.green = 0;
                            if (this.blue === undefined)
                                this.blue = 0;
                            if (this.alpha === undefined)
                                this.alpha = 0;
                            (() => {
                                let rgba = javaemul.internal.IntegerHelper.parseUnsignedInt(rgbaHex, 16);
                                let r = (rgba >> 24) & 255;
                                let g = (rgba >> 16) & 255;
                                let b = (rgba >> 8) & 255;
                                let a = (rgba >> 0) & 255;
                                this.red = r > 255 ? 255 : (r < 0 ? 0 : r);
                                this.green = g > 255 ? 255 : (g < 0 ? 0 : g);
                                this.blue = b > 255 ? 255 : (b < 0 ? 0 : b);
                                this.alpha = a > 255 ? 255 : (a < 0 ? 0 : a);
                            })();
                        }
                        else if (((typeof r === 'number') || r === null) && g === undefined && b === undefined && a === undefined) {
                            let __args = arguments;
                            let rgb = __args[0];
                            {
                                let __args = arguments;
                                let r = (rgb >> 16) & 255;
                                let g = (rgb >> 8) & 255;
                                let b = rgb & 255;
                                {
                                    let __args = arguments;
                                    let a = 255;
                                    if (this.red === undefined)
                                        this.red = 0;
                                    if (this.green === undefined)
                                        this.green = 0;
                                    if (this.blue === undefined)
                                        this.blue = 0;
                                    if (this.alpha === undefined)
                                        this.alpha = 0;
                                    if (this.red === undefined)
                                        this.red = 0;
                                    if (this.green === undefined)
                                        this.green = 0;
                                    if (this.blue === undefined)
                                        this.blue = 0;
                                    if (this.alpha === undefined)
                                        this.alpha = 0;
                                    (() => {
                                        this.red = r > 255 ? 255 : (r < 0 ? 0 : r);
                                        this.green = g > 255 ? 255 : (g < 0 ? 0 : g);
                                        this.blue = b > 255 ? 255 : (b < 0 ? 0 : b);
                                        this.alpha = a > 255 ? 255 : (a < 0 ? 0 : a);
                                    })();
                                }
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static BLACK_$LI$() { if (Color.BLACK == null)
                        Color.BLACK = new Color(0, 0, 0); return Color.BLACK; }
                    ;
                    static WHITE_$LI$() { if (Color.WHITE == null)
                        Color.WHITE = new Color(255, 255, 255); return Color.WHITE; }
                    ;
                    static GREY_TRANSPARENT_$LI$() { if (Color.GREY_TRANSPARENT == null)
                        Color.GREY_TRANSPARENT = new Color(25, 25, 25, 50); return Color.GREY_TRANSPARENT; }
                    ;
                    getRGBColorComponents(rgb) {
                        let len = rgb.length;
                        if (len < 3 || len > 4) {
                            throw new java.lang.IllegalArgumentException("Expected rgb.length to be 3 or 4. Found " + len + ".");
                        }
                        rgb[0] = Math.fround(this.red / 255.0);
                        rgb[1] = Math.fround(this.green / 255.0);
                        rgb[2] = Math.fround(this.blue / 255.0);
                        if (len === 4) {
                            rgb[3] = Math.fround(this.alpha / 255.0);
                        }
                        return rgb;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        return this.getRGBA();
                    }
                    /**
                     *
                     * @param {*} other
                     * @return {boolean}
                     */
                    equals(other) {
                        if (this === other)
                            return true;
                        if (other == null)
                            return true;
                        if (!(other != null && other instanceof com.vzome.core.construction.Color))
                            return false;
                        let c = other;
                        return this.red === c.red && this.green === c.green && this.blue === c.blue && this.alpha === c.alpha;
                    }
                    getPastel() {
                        let r = this.red + ((255 - this.red) / 2 | 0);
                        let g = this.green + ((255 - this.green) / 2 | 0);
                        let b = this.blue + ((255 - this.blue) / 2 | 0);
                        return new Color(r, g, b, this.alpha);
                    }
                    /**
                     * @return
                     * @return {number}
                     */
                    getRGBA() {
                        return this.red * 16777216 + this.green * 65536 + this.blue * 256 + this.alpha;
                    }
                    getRGB() {
                        return this.red * 65536 + this.green * 256 + this.blue;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return this.red + "," + this.green + "," + this.blue + ((this.alpha < 255) ? "," + this.alpha : "");
                    }
                    toWebString() {
                        return javaemul.internal.StringHelper.format("#%02X%02X%02X", this.red, this.green, this.blue);
                    }
                    static parseColor(str) {
                        let toks = new java.util.StringTokenizer(str, ",");
                        let red = toks.nextToken();
                        let green = toks.nextToken();
                        let blue = toks.nextToken();
                        return new Color(javaemul.internal.IntegerHelper.parseInt(red), javaemul.internal.IntegerHelper.parseInt(green), javaemul.internal.IntegerHelper.parseInt(blue));
                    }
                    static parseWebColor(colorStr) {
                        return new Color(/* intValue */ (javaemul.internal.IntegerHelper.valueOf(colorStr.substring(1, 3), 16) | 0), /* intValue */ (javaemul.internal.IntegerHelper.valueOf(colorStr.substring(3, 5), 16) | 0), /* intValue */ (javaemul.internal.IntegerHelper.valueOf(colorStr.substring(5, 7), 16) | 0));
                    }
                    getRed() {
                        return this.red;
                    }
                    getGreen() {
                        return this.green;
                    }
                    getBlue() {
                        return this.blue;
                    }
                    getAlpha() {
                        return this.alpha;
                    }
                    static getComplement(color) {
                        return (color == null) ? null : new Color((128 + color.red) % 256, (128 + color.green) % 256, (128 + color.blue) % 256, color.alpha);
                    }
                    static getInverted(color) {
                        return (color == null) ? null : new Color(255 - color.red, 255 - color.green, 255 - color.blue, color.alpha);
                    }
                    /**
                     * @param {com.vzome.core.construction.Color} color color to be modified.
                     * @param {number} scale0to1 is adjusted internally to be between 0 and 1.
                     * @return {com.vzome.core.construction.Color} The original color maximized then having each component
                     * multiplied by the specified scale (between 0 and 1).
                     * Multiplying by 0 returns BLACK.
                     * Multiplying by 1 returns the maximized color.
                     */
                    static getScaledTo(color, scale0to1) {
                        if (color == null) {
                            return null;
                        }
                        let maxColor = Color.getMaximum(color);
                        let scale = Math.min(Math.max(0.0, scale0to1), 1.0);
                        if (scale === 0.0)
                            return Color.BLACK_$LI$();
                        if (scale === 1.0)
                            return maxColor;
                        let red = maxColor.getRed() * scale;
                        let green = maxColor.getGreen() * scale;
                        let blue = maxColor.getBlue() * scale;
                        return new Color(/* intValue */ (red | 0), /* intValue */ (green | 0), /* intValue */ (blue | 0), color.getAlpha());
                    }
                    /**
                     * @param {com.vzome.core.construction.Color} color
                     * @return {com.vzome.core.construction.Color} A new color where each of the RGB components are proportional to the parameter
                     * but scaled so that the component with the highest value becomes 0xFF.
                     * Other components are scaled proportionally. The alpha component is unchanged.
                     * If the color is null or BLACK (0,0,0) or if one or more elements are already at 0xFF
                     * then the original value is returned unchanged.
                     */
                    static getMaximum(color) {
                        if (color == null) {
                            return null;
                        }
                        let most = Math.max(Math.max(color.red, color.green), color.blue);
                        return (most === 0 || most === 255) ? color : new Color((255 * color.red / most | 0), (255 * color.green / most | 0), (255 * color.blue / most | 0), color.alpha);
                    }
                    static getPastel(color) {
                        return (color == null) ? null : color.getPastel();
                    }
                }
                construction.Color = Color;
                Color["__class"] = "com.vzome.core.construction.Color";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var generic;
            (function (generic) {
                /**
                 * @author David Hall
                 * @class
                 */
                class ArrayComparator {
                    getContentFirstArrayComparator() {
                        return (new ArrayComparator.ContentFirstArrayComparator());
                    }
                    getLengthFirstArrayComparator() {
                        return (new ArrayComparator.LengthFirstArrayComparator());
                    }
                }
                generic.ArrayComparator = ArrayComparator;
                ArrayComparator["__class"] = "com.vzome.core.generic.ArrayComparator";
                (function (ArrayComparator) {
                    class ContentFirstArrayComparator {
                        /**
                         *
                         * @param {Array} array1
                         * @param {Array} array2
                         * @return {number}
                         */
                        compare(array1, array2) {
                            let len1 = array1.length;
                            let len2 = array2.length;
                            let smaller = len1 < len2 ? len1 : len2;
                            for (let i = 0; i < smaller; i++) {
                                {
                                    let element1 = array1[i];
                                    let element2 = array2[i];
                                    let comparison = element1.compareTo(element2);
                                    if (comparison !== 0) {
                                        return comparison;
                                    }
                                }
                                ;
                            }
                            return /* compareTo */ ((o1, o2) => { if (o1 && o1.compareTo) {
                                return o1.compareTo(o2);
                            }
                            else {
                                return o1 < o2 ? -1 : o2 < o1 ? 1 : 0;
                            } })(len1, len2);
                        }
                        constructor() {
                        }
                    }
                    ArrayComparator.ContentFirstArrayComparator = ContentFirstArrayComparator;
                    ContentFirstArrayComparator["__class"] = "com.vzome.core.generic.ArrayComparator.ContentFirstArrayComparator";
                    ContentFirstArrayComparator["__interfaces"] = ["java.util.Comparator"];
                    class LengthFirstArrayComparator {
                        /**
                         *
                         * @param {Array} array1
                         * @param {Array} array2
                         * @return {number}
                         */
                        compare(array1, array2) {
                            let len1 = array1.length;
                            let len2 = array2.length;
                            let comparison = ((o1, o2) => { if (o1 && o1.compareTo) {
                                return o1.compareTo(o2);
                            }
                            else {
                                return o1 < o2 ? -1 : o2 < o1 ? 1 : 0;
                            } })(len1, len2);
                            if (comparison !== 0) {
                                return comparison;
                            }
                            for (let i = 0; i < len1; i++) {
                                {
                                    let element1 = array1[i];
                                    let element2 = array2[i];
                                    comparison = element1.compareTo(element2);
                                    if (comparison !== 0) {
                                        return comparison;
                                    }
                                }
                                ;
                            }
                            return comparison;
                        }
                        constructor() {
                        }
                    }
                    ArrayComparator.LengthFirstArrayComparator = LengthFirstArrayComparator;
                    LengthFirstArrayComparator["__class"] = "com.vzome.core.generic.ArrayComparator.LengthFirstArrayComparator";
                    LengthFirstArrayComparator["__interfaces"] = ["java.util.Comparator"];
                })(ArrayComparator = generic.ArrayComparator || (generic.ArrayComparator = {}));
            })(generic = core.generic || (core.generic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var generic;
            (function (generic) {
                /**
                 * @author David Hall
                 * Based on http://stackoverflow.com/questions/5474893/how-to-implement-this-filteringiterator
                 * @class
                 */
                class FilteredIterator {
                    constructor(preTest, iterable, postTest) {
                        if (this.wrappedIterator === undefined)
                            this.wrappedIterator = null;
                        if (this.__preFilter === undefined)
                            this.__preFilter = null;
                        if (this.__postFilter === undefined)
                            this.__postFilter = null;
                        this.nextElement = null;
                        this.__hasNext = null;
                        this.wrappedIterator = iterable.iterator();
                        this.__preFilter = (preTest);
                        this.__postFilter = (postTest);
                    }
                    /**
                     * Elements must match this filter before conversion
                     * @param {*} element
                     * @return {boolean}
                     */
                    preFilter(element) {
                        return this.__preFilter == null ? true : (target => (typeof target === 'function') ? target(element) : target.test(element))(this.__preFilter);
                    }
                    /**
                     * Elements must match this filter after conversion
                     * @param {*} element
                     * @return {boolean}
                     */
                    postFilter(element) {
                        return this.__postFilter == null ? true : (target => (typeof target === 'function') ? target(element) : target.test(element))(this.__postFilter);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    iterator() {
                        return this;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        if (this.__hasNext == null) {
                            this.nextMatch();
                        }
                        return this.__hasNext;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    next() {
                        if (this.__hasNext == null) {
                            this.nextMatch();
                        }
                        if (!this.__hasNext) {
                            throw new java.util.NoSuchElementException();
                        }
                        return this.nextMatch();
                    }
                    nextMatch() {
                        let lastMatch = this.nextElement;
                        while ((this.wrappedIterator.hasNext())) {
                            {
                                let next = this.wrappedIterator.next();
                                if (this.preFilter(next)) {
                                    let converted = this.apply(next);
                                    if (this.postFilter(converted)) {
                                        this.nextElement = converted;
                                        this.__hasNext = true;
                                        return lastMatch;
                                    }
                                }
                            }
                        }
                        ;
                        this.__hasNext = false;
                        return lastMatch;
                    }
                    /**
                     *
                     */
                    remove() {
                        this.wrappedIterator.remove();
                    }
                }
                generic.FilteredIterator = FilteredIterator;
                FilteredIterator["__class"] = "com.vzome.core.generic.FilteredIterator";
                FilteredIterator["__interfaces"] = ["java.util.Iterator", "java.lang.Iterable"];
                (function (FilteredIterator) {
                    class Filters {
                        constructor() {
                        }
                        /**
                         * A static convenience function that may be passed as a preFilter parameter
                         * @param <T>
                         * @param {*} element
                         * @return {boolean} {@code true} if element is not null
                         */
                        static elementNotNull(element) {
                            return element != null;
                        }
                        /**
                         * A static convenience function that may be passed as a postFilter parameter
                         * @param <R>
                         * @param {*} result
                         * @return {boolean} {@code true} if result is not null
                         */
                        static resultNotNull(result) {
                            return result != null;
                        }
                        /**
                         * A static convenience function that may be used with another predicate
                         * to be passed as a preFilter or postFilter parameter
                         * @param <B>
                         * @param {*} predicate The predicate to be negated.
                         * @param {*} arg The parameter to be passed to the predicate.
                         * @return {boolean} The opposite of what the predicate returns.
                         */
                        static not(predicate, arg) {
                            return (target => (typeof target === 'function') ? target(arg) : target.test(arg))((target => (typeof target === 'function') ? target() : target.negate())(predicate));
                        }
                        /**
                         * A static convenience function that may be used to combine two other predicates
                         * to be passed as a preFilter or postFilter parameter
                         * @param <B>
                         * @param {*} check1 The 1st predicate to be evaluated.
                         * @param {*} check2 The 2nd predicate to be evaluated.
                         * @param {*} arg The parameter to be passed to the predicates.
                         * @return {boolean} {@code true} only if both predicates are true.
                         */
                        static and(check1, check2, arg) {
                            return (target => (typeof target === 'function') ? target(arg) : target.test(arg))((target => (typeof target === 'function') ? target(check2) : target.and(check2))(check1));
                        }
                        /**
                         * A static convenience function that may be used to combine two other predicates
                         * to be passed as a preFilter or postFilter parameter
                         * @param <B>
                         * @param {*} check1 The 1st predicate to be evaluated.
                         * @param {*} check2 The 2nd predicate to be evaluated.
                         * @param {*} arg The parameter to be passed to the predicates.
                         * @return {boolean} {@code true} if either predicate is true.
                         */
                        static or(check1, check2, arg) {
                            return (target => (typeof target === 'function') ? target(arg) : target.test(arg))((target => (typeof target === 'function') ? target(check2) : target.or(check2))(check1));
                        }
                    }
                    FilteredIterator.Filters = Filters;
                    Filters["__class"] = "com.vzome.core.generic.FilteredIterator.Filters";
                })(FilteredIterator = generic.FilteredIterator || (generic.FilteredIterator = {}));
            })(generic = core.generic || (core.generic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class XmlSaveFormat {
                    constructor(version, capabilities) {
                        if (this.mProject4d === undefined)
                            this.mProject4d = false;
                        if (this.mSelectionNotSaved === undefined)
                            this.mSelectionNotSaved = false;
                        if (this.mRationalVectors === undefined)
                            this.mRationalVectors = false;
                        if (this.mGroupingInSelection === undefined)
                            this.mGroupingInSelection = false;
                        if (this.mField === undefined)
                            this.mField = null;
                        if (this.mScale === undefined)
                            this.mScale = 0;
                        if (this.mMultiplier === undefined)
                            this.mMultiplier = null;
                        if (this.writerVersion === undefined)
                            this.writerVersion = null;
                        if (this.version === undefined)
                            this.version = null;
                        this.capabilities = (new java.util.HashSet());
                        if (this.properties === undefined)
                            this.properties = null;
                        this.version = version;
                        this.capabilities.addAll(java.util.Arrays.asList(capabilities));
                        this.mProject4d = this.capabilities.contains(XmlSaveFormat.PROJECT_4D);
                        this.mSelectionNotSaved = this.capabilities.contains(XmlSaveFormat.SELECTION_NOT_SAVED);
                        this.mRationalVectors = this.capabilities.contains(XmlSaveFormat.RATIONAL_VECTORS);
                        this.mGroupingInSelection = this.capabilities.contains(XmlSaveFormat.GROUPING_IN_SELECTION);
                        XmlSaveFormat.FORMATS_$LI$().put(version, this);
                    }
                    static FORMATS_$LI$() { if (XmlSaveFormat.FORMATS == null)
                        XmlSaveFormat.FORMATS = (new java.util.HashMap()); return XmlSaveFormat.FORMATS; }
                    ;
                    static logger_$LI$() { if (XmlSaveFormat.logger == null)
                        XmlSaveFormat.logger = java.util.logging.Logger.getLogger("com.vzome.core.commands.XmlSaveFormat"); return XmlSaveFormat.logger; }
                    ;
                    /**
                     * Initialize.
                     *
                     * If you're tempted to add another parameter, see if you can make it a property instead.
                     *
                     * Shouldn't we just replace all the parameters with one Controller object?
                     *
                     * @param root
                     * @param {*} field
                     * @param symms
                     * @param {number} scale
                     * @param {string} writerVersion
                     * @param {java.util.Properties} props
                     */
                    initialize(field, scale, writerVersion, props) {
                        this.properties = props;
                        this.writerVersion = writerVersion;
                        if ((writerVersion == null) || /* isEmpty */ (writerVersion.length === 0))
                            this.writerVersion = "before 2.1 Beta 7";
                        this.mField = field;
                        this.mScale = scale;
                        if (scale === 0)
                            this.mMultiplier = null;
                        else
                            this.mMultiplier = field['createPower$int'](scale);
                    }
                    getVersion() {
                        return this.version;
                    }
                    isMigration() {
                        return !this.multipleDesigns();
                    }
                    selectionsNotSaved() {
                        return this.mSelectionNotSaved;
                    }
                    rationalVectors() {
                        return this.mRationalVectors;
                    }
                    actionHistory() {
                        return false;
                    }
                    commandEditsCompacted() {
                        return this.capabilities.contains(XmlSaveFormat.COMPACTED_COMMAND_EDITS);
                    }
                    multipleDesigns() {
                        return this.capabilities.contains(XmlSaveFormat.MULTIPLE_DESIGNS);
                    }
                    groupingDoneInSelection() {
                        return this.mGroupingInSelection && !((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("2.1.3", this.writerVersion);
                    }
                    groupingRecursive() {
                        return !this.groupingDoneInSelection() || /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("2.1.2", this.writerVersion);
                    }
                    interim210format() {
                        return this.capabilities.contains(XmlSaveFormat.FORMAT_2_1_0);
                    }
                    parseAlgebraicVector(elem) {
                        let val = elem.getAttribute("x");
                        let x = (val == null || /* isEmpty */ (val.length === 0)) ? this.mField.zero() : this.mField.parseLegacyNumber(val);
                        val = elem.getAttribute("y");
                        let y = (val == null || /* isEmpty */ (val.length === 0)) ? this.mField.zero() : this.mField.parseLegacyNumber(val);
                        val = elem.getAttribute("z");
                        let z = (val == null || /* isEmpty */ (val.length === 0)) ? this.mField.zero() : this.mField.parseLegacyNumber(val);
                        val = elem.getAttribute("w");
                        let threeD = val == null || /* isEmpty */ (val.length === 0);
                        let w = null;
                        if (!threeD)
                            w = this.mField.parseLegacyNumber(val);
                        let value = threeD ? new com.vzome.core.algebra.AlgebraicVector(x, y, z) : new com.vzome.core.algebra.AlgebraicVector(w, x, y, z);
                        if (this.mProject4d && !threeD) {
                            if (!w.isZero() && XmlSaveFormat.logger_$LI$().isLoggable(java.util.logging.Level.WARNING))
                                XmlSaveFormat.logger_$LI$().warning("stripping non-zero W component from " + value.toString());
                            value = this.mField.projectTo3d(value, true);
                        }
                        if (this.mMultiplier != null)
                            value = value.scale(this.mMultiplier);
                        return value;
                    }
                    static NOT_AN_ATTRIBUTE_$LI$() { if (XmlSaveFormat.NOT_AN_ATTRIBUTE == null)
                        XmlSaveFormat.NOT_AN_ATTRIBUTE = new Object(); return XmlSaveFormat.NOT_AN_ATTRIBUTE; }
                    ;
                    parseAlgebraicObject(valName, val) {
                        let value = XmlSaveFormat.NOT_AN_ATTRIBUTE_$LI$();
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(valName, "Null"))
                            value = null;
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(valName, "RationalVector")) {
                            let nums = val.getAttribute("nums");
                            if (nums == null || /* isEmpty */ (nums.length === 0))
                                return this.mField.origin(3);
                            let denoms = val.getAttribute("denoms");
                            let tokens = new java.util.StringTokenizer(nums);
                            let result = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1];
                            for (let i = 0; i < this.mField.getOrder(); i++) {
                                {
                                    let token = tokens.nextToken();
                                    if (token == null)
                                        throw new java.lang.IllegalStateException("RationalVector nums too short for field " + this.mField.getName());
                                    result[i * 2] = javaemul.internal.IntegerHelper.parseInt(token);
                                }
                                ;
                            }
                            if (denoms != null && !(denoms.length === 0)) {
                                tokens = new java.util.StringTokenizer(denoms);
                                for (let i = 0; i < this.mField.getOrder(); i++) {
                                    {
                                        let token = tokens.nextToken();
                                        if (token == null)
                                            throw new java.lang.IllegalStateException("RationalVector denoms too short for field " + this.mField.getName());
                                        result[i * 2 + 1] = javaemul.internal.IntegerHelper.parseInt(token);
                                    }
                                    ;
                                }
                            }
                            let oneThirdLen = (result.length / 3 | 0);
                            let twoThirdLen = oneThirdLen * 2;
                            let result3d = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                                return 0;
                            }
                            else {
                                let array = [];
                                for (let i = 0; i < dims[0]; i++) {
                                    array.push(allocate(dims.slice(1)));
                                }
                                return array;
                            } }; return allocate(dims); })([3, oneThirdLen]);
                            for (let i = 0; i < oneThirdLen; i++) {
                                {
                                    result3d[0][i] = result[i];
                                    result3d[1][i] = result[i + oneThirdLen];
                                    result3d[2][i] = result[i + twoThirdLen];
                                }
                                ;
                            }
                            value = this.mField.createVector(result3d);
                        }
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(valName, "GoldenVector"))
                            value = this.parseAlgebraicVector(val);
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(valName, "Boolean")) {
                            let gnum = val.getAttribute("value");
                            value = javaemul.internal.BooleanHelper.parseBoolean(gnum);
                        }
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(valName, "Integer")) {
                            let gnum = val.getAttribute("value");
                            value = javaemul.internal.IntegerHelper.parseInt(gnum);
                        }
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(valName, "GoldenNumber") || /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(valName, "IntegralNumber")) {
                            let gnum = val.getAttribute("value");
                            value = this.mField.parseLegacyNumber(gnum);
                            if (this.mMultiplier != null)
                                value = value['times$com_vzome_core_algebra_AlgebraicNumber'](this.mMultiplier);
                        }
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(valName, "String"))
                            value = val.getTextContent();
                        return value;
                    }
                    parseConstruction$java_lang_String$org_w3c_dom_Element(apName, attrOrParam) {
                        return this.parseConstruction$java_lang_String$org_w3c_dom_Element$boolean(apName, attrOrParam, false);
                    }
                    parseConstruction$java_lang_String$org_w3c_dom_Element$boolean(apName, attrOrParam, projectTo3d) {
                        let c = null;
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(apName, "point")) {
                            let loc = this.parseAlgebraicVector(attrOrParam);
                            if (projectTo3d)
                                loc = loc.projectTo3d(true);
                            c = new com.vzome.core.construction.FreePoint(loc);
                        }
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(apName, "segment")) {
                            let start = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element$java_lang_String(attrOrParam, "start");
                            let end = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element$java_lang_String(attrOrParam, "end");
                            let sloc = this.parseAlgebraicVector(start);
                            let eloc = this.parseAlgebraicVector(end);
                            if (projectTo3d) {
                                sloc = sloc.projectTo3d(true);
                                eloc = eloc.projectTo3d(true);
                            }
                            c = new com.vzome.core.construction.SegmentJoiningPoints(new com.vzome.core.construction.FreePoint(sloc), new com.vzome.core.construction.FreePoint(eloc));
                        }
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(apName, "polygon")) {
                            let kids = attrOrParam.getElementsByTagName("vertex");
                            let pts = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(kids.getLength());
                            for (let k = 0; k < kids.getLength(); k++) {
                                {
                                    let loc = this.parseAlgebraicVector(kids.item(k));
                                    if (projectTo3d)
                                        loc = loc.projectTo3d(true);
                                    pts[k] = new com.vzome.core.construction.FreePoint(loc);
                                }
                                ;
                            }
                            c = new com.vzome.core.construction.PolygonFromVertices(pts);
                        }
                        return c;
                    }
                    /**
                     * this is for the old format (before rationalVectors)
                     * @param {string} apName
                     * @param {*} attrOrParam
                     * @param {boolean} projectTo3d
                     * @return {com.vzome.core.construction.Construction}
                     */
                    parseConstruction(apName, attrOrParam, projectTo3d) {
                        if (((typeof apName === 'string') || apName === null) && ((attrOrParam != null && (attrOrParam["__interfaces"] != null && attrOrParam["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || attrOrParam.constructor != null && attrOrParam.constructor["__interfaces"] != null && attrOrParam.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || attrOrParam === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                            return this.parseConstruction$java_lang_String$org_w3c_dom_Element$boolean(apName, attrOrParam, projectTo3d);
                        }
                        else if (((typeof apName === 'string') || apName === null) && ((attrOrParam != null && (attrOrParam["__interfaces"] != null && attrOrParam["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || attrOrParam.constructor != null && attrOrParam.constructor["__interfaces"] != null && attrOrParam.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || attrOrParam === null) && projectTo3d === undefined) {
                            return this.parseConstruction$java_lang_String$org_w3c_dom_Element(apName, attrOrParam);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    loadCommandAttributes$org_w3c_dom_Element(editElem) {
                        return this.loadCommandAttributes$org_w3c_dom_Element$boolean(editElem, false);
                    }
                    loadCommandAttributes$org_w3c_dom_Element$boolean(editElem, projectTo3d) {
                        let attrs = new com.vzome.core.commands.AttributeMap();
                        let kids = editElem.getChildNodes();
                        for (let j = 0; j < kids.getLength(); j++) {
                            {
                                let node = kids.item(j);
                                if (!(node != null && (node["__interfaces"] != null && node["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)))
                                    continue;
                                let attrElem = node;
                                let elemName = attrElem.getLocalName();
                                let attrName = attrElem.getAttribute("attrName");
                                if (this.interim210format()) {
                                    attrName = attrElem.getAttribute("name");
                                    let elemKid = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element(attrElem);
                                    if (elemKid != null) {
                                        attrElem = elemKid;
                                        elemName = attrElem.getLocalName();
                                    }
                                }
                                let value = this.parseAlgebraicObject(elemName, attrElem);
                                if (value === XmlSaveFormat.NOT_AN_ATTRIBUTE_$LI$())
                                    if (this.rationalVectors()) {
                                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                            return o1.equals(o2);
                                        }
                                        else {
                                            return o1 === o2;
                                        } })(elemName, "point"))
                                            value = this.parsePoint$org_w3c_dom_Element$java_lang_String$boolean(attrElem, "at", projectTo3d);
                                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                            return o1.equals(o2);
                                        }
                                        else {
                                            return o1 === o2;
                                        } })(elemName, "segment"))
                                            value = this.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String$boolean(attrElem, "start", "end", projectTo3d);
                                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                            return o1.equals(o2);
                                        }
                                        else {
                                            return o1 === o2;
                                        } })(elemName, "polygon"))
                                            value = this.parsePolygon$org_w3c_dom_Element$java_lang_String$boolean(attrElem, "vertex", projectTo3d);
                                        else
                                            throw new java.lang.IllegalStateException("unknown parameter construction: " + elemName);
                                    }
                                    else
                                        value = this.parseConstruction$java_lang_String$org_w3c_dom_Element$boolean(elemName, attrElem, projectTo3d);
                                attrs.put(attrName, value);
                            }
                            ;
                        }
                        return attrs;
                    }
                    loadCommandAttributes(editElem, projectTo3d) {
                        if (((editElem != null && (editElem["__interfaces"] != null && editElem["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || editElem.constructor != null && editElem.constructor["__interfaces"] != null && editElem.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || editElem === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                            return this.loadCommandAttributes$org_w3c_dom_Element$boolean(editElem, projectTo3d);
                        }
                        else if (((editElem != null && (editElem["__interfaces"] != null && editElem["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || editElem.constructor != null && editElem.constructor["__interfaces"] != null && editElem.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || editElem === null) && projectTo3d === undefined) {
                            return this.loadCommandAttributes$org_w3c_dom_Element(editElem);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getField() {
                        return this.mField;
                    }
                    getScale() {
                        return this.mScale;
                    }
                    static serializeNumber(xml, attrName, number) {
                        com.vzome.xml.DomUtils.addAttribute(xml, attrName, number.toString(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                    }
                    static serializePoint(xml, attrName, point) {
                        com.vzome.xml.DomUtils.addAttribute(xml, attrName, point.getLocation().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                    }
                    static serializeSegment(xml, startAttrName, endAttrName, segment) {
                        com.vzome.xml.DomUtils.addAttribute(xml, startAttrName, segment.getStart().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                        com.vzome.xml.DomUtils.addAttribute(xml, endAttrName, segment.getEnd().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                    }
                    static serializePolygon(xml, vertexChildName, polygon) {
                        polygon.getXml$org_w3c_dom_Element$java_lang_String(xml, vertexChildName);
                    }
                    parseRationalVector(xml, attrName) {
                        let nums = xml.getAttribute(attrName);
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return null;
                        let loc = this.mField.parseVector(nums);
                        return loc;
                    }
                    parseRationalNumber(xml, attrName) {
                        let nums = xml.getAttribute(attrName);
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return null;
                        let loc = this.mField.parseNumber(nums);
                        return loc;
                    }
                    parsePoint$org_w3c_dom_Element$java_lang_String(xml, attrName) {
                        return this.parsePoint$org_w3c_dom_Element$java_lang_String$boolean(xml, attrName, false);
                    }
                    parsePoint$org_w3c_dom_Element$java_lang_String$boolean(xml, attrName, projectTo3d) {
                        let nums = xml.getAttribute(attrName);
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return null;
                        let loc = this.mField.parseVector(nums);
                        if (projectTo3d)
                            loc = loc.projectTo3d(true);
                        return new com.vzome.core.construction.FreePoint(loc);
                    }
                    parsePoint(xml, attrName, projectTo3d) {
                        if (((xml != null && (xml["__interfaces"] != null && xml["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof attrName === 'string') || attrName === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                            return this.parsePoint$org_w3c_dom_Element$java_lang_String$boolean(xml, attrName, projectTo3d);
                        }
                        else if (((xml != null && (xml["__interfaces"] != null && xml["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof attrName === 'string') || attrName === null) && projectTo3d === undefined) {
                            return this.parsePoint$org_w3c_dom_Element$java_lang_String(xml, attrName);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, startAttrName, endAttrName) {
                        return this.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String$boolean(xml, startAttrName, endAttrName, false);
                    }
                    parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String$boolean(xml, startAttrName, endAttrName, projectTo3d) {
                        let nums = xml.getAttribute(endAttrName);
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return null;
                        let eloc = this.mField.parseVector(nums);
                        nums = xml.getAttribute(startAttrName);
                        let sloc = (nums == null || /* isEmpty */ (nums.length === 0)) ? this.mField.origin(eloc.dimension()) : this.mField.parseVector(nums);
                        if (projectTo3d) {
                            sloc = sloc.projectTo3d(true);
                            eloc = eloc.projectTo3d(true);
                        }
                        return new com.vzome.core.construction.SegmentJoiningPoints(new com.vzome.core.construction.FreePoint(sloc), new com.vzome.core.construction.FreePoint(eloc));
                    }
                    parseSegment(xml, startAttrName, endAttrName, projectTo3d) {
                        if (((xml != null && (xml["__interfaces"] != null && xml["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof startAttrName === 'string') || startAttrName === null) && ((typeof endAttrName === 'string') || endAttrName === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                            return this.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String$boolean(xml, startAttrName, endAttrName, projectTo3d);
                        }
                        else if (((xml != null && (xml["__interfaces"] != null && xml["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof startAttrName === 'string') || startAttrName === null) && ((typeof endAttrName === 'string') || endAttrName === null) && projectTo3d === undefined) {
                            return this.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, startAttrName, endAttrName);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    parsePolygon$org_w3c_dom_Element$java_lang_String(xml, vertexChildName) {
                        return this.parsePolygon$org_w3c_dom_Element$java_lang_String$boolean(xml, vertexChildName, false);
                    }
                    parsePolygon$org_w3c_dom_Element$java_lang_String$boolean(xml, vertexChildName, projectTo3d) {
                        let kids = xml.getElementsByTagName(vertexChildName);
                        let pts = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(kids.getLength());
                        for (let k = 0; k < kids.getLength(); k++) {
                            {
                                let nums = kids.item(k).getAttribute("at");
                                let loc = this.mField.parseVector(nums);
                                if (projectTo3d)
                                    loc = loc.projectTo3d(true);
                                pts[k] = new com.vzome.core.construction.FreePoint(loc);
                            }
                            ;
                        }
                        return new com.vzome.core.construction.PolygonFromVertices(pts);
                    }
                    parsePolygon(xml, vertexChildName, projectTo3d) {
                        if (((xml != null && (xml["__interfaces"] != null && xml["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof vertexChildName === 'string') || vertexChildName === null) && ((typeof projectTo3d === 'boolean') || projectTo3d === null)) {
                            return this.parsePolygon$org_w3c_dom_Element$java_lang_String$boolean(xml, vertexChildName, projectTo3d);
                        }
                        else if (((xml != null && (xml["__interfaces"] != null && xml["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || xml.constructor != null && xml.constructor["__interfaces"] != null && xml.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || xml === null) && ((typeof vertexChildName === 'string') || vertexChildName === null) && projectTo3d === undefined) {
                            return this.parsePolygon$org_w3c_dom_Element$java_lang_String(xml, vertexChildName);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    parsePolygonReversed(xml, vertexChildName) {
                        let kids = xml.getElementsByTagName(vertexChildName);
                        let pts = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(kids.getLength());
                        let kmax = kids.getLength() - 1;
                        for (let k = 0; k < kids.getLength(); k++) {
                            {
                                let nums = kids.item(k).getAttribute("at");
                                let loc = this.mField.parseVector(nums);
                                pts[kmax - k] = new com.vzome.core.construction.FreePoint(loc);
                            }
                            ;
                        }
                        return new com.vzome.core.construction.PolygonFromVertices(pts);
                    }
                    parseNumber(xml, attrName) {
                        let nums = xml.getAttribute(attrName);
                        if (nums == null || /* isEmpty */ (nums.length === 0))
                            return null;
                        return this.mField.parseNumber(nums);
                    }
                    static escapeNewlines(input) {
                        let buf = new java.lang.StringBuffer();
                        let br = new java.io.BufferedReader(new java.io.StringReader(input));
                        let line = null;
                        try {
                            while (((line = br.readLine()) != null)) {
                                {
                                    let comment = line.indexOf("//");
                                    if (comment >= 0) {
                                        line = line.substring(0, comment);
                                    }
                                    buf.append(line + "\n");
                                }
                            }
                            ;
                        }
                        catch (e) {
                        }
                        ;
                        return buf.toString();
                    }
                    loadToRender() {
                        return !((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("true", this.properties.getProperty("no.rendering"));
                    }
                    getToolVersion(element) {
                        let fileEdition = element.getAttribute("edition");
                        if (fileEdition == null || /* isEmpty */ (fileEdition.length === 0))
                            fileEdition = "vZome";
                        return fileEdition + " " + this.writerVersion;
                    }
                }
                XmlSaveFormat.CURRENT_FORMAT = "http://xml.vzome.com/vZome/4.0.0/";
                XmlSaveFormat.PROJECT_4D = "project-4D-to-3D";
                XmlSaveFormat.SELECTION_NOT_SAVED = "selection-not-saved";
                XmlSaveFormat.FORMAT_2_1_0 = "interim-210-format";
                XmlSaveFormat.GROUPING_IN_SELECTION = "grouping-in-selection";
                XmlSaveFormat.RATIONAL_VECTORS = "rational-vectors";
                XmlSaveFormat.COMPACTED_COMMAND_EDITS = "compacted-command-edits";
                XmlSaveFormat.MULTIPLE_DESIGNS = "multiple-designs";
                XmlSaveFormat.UNKNOWN_COMMAND = "unknown.command";
                commands.XmlSaveFormat = XmlSaveFormat;
                XmlSaveFormat["__class"] = "com.vzome.core.commands.XmlSaveFormat";
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author David Hall
                 * This class doesn't add anything to the TreeMap,
                 * but there were so many places that were using Map<String, Object>,
                 * that I decided to use this class to clarify which ones were using it
                 * for managing attributes. It also avoids cluttering the code
                 * with Map<String, Object> which is just needed for type safety,
                 * but which does nothing for describing the intended use of the variables.
                 *
                 * Note that in XmlSaveFormat, AttributeMap replaces TreeMap<>,
                 * but in other places (such as CommandEdit), it replaces HashMap<>.
                 * XmlSaveFormat requires the Map<> to be ordered, but I assume
                 * that other places can safely use any implementation of Map<>.
                 * Therefore, I have used TreeMap<> rather than HashMap<> as the basis
                 * for AttributeMap across the board.
                 * @class
                 * @extends java.util.TreeMap
                 */
                class AttributeMap extends java.util.TreeMap {
                    constructor() {
                        super();
                    }
                }
                AttributeMap.__com_vzome_core_commands_AttributeMap_serialVersionUID = 1;
                commands.AttributeMap = AttributeMap;
                AttributeMap["__class"] = "com.vzome.core.commands.AttributeMap";
                AttributeMap["__interfaces"] = ["java.lang.Cloneable", "java.util.Map", "java.util.NavigableMap", "java.util.SortedMap", "java.io.Serializable"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class AbstractCommand {
                    /**
                     * This default behavior deserializes in the old way, before XmlSaveFormat .COMPACTED_COMMAND_EDITS
                     * @param attributes
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @return
                     * @return {com.vzome.core.commands.AttributeMap}
                     */
                    setXml(xml, format) {
                        let attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                        this.setFixedAttributes(attrs, format);
                        return attrs;
                    }
                    setFixedAttributes(attributes, format) {
                        attributes.put(com.vzome.core.commands.Command.FIELD_ATTR_NAME, format.getField());
                    }
                    /**
                     * This default behavior serializes in the old way, before XmlSaveFormat .COMPACTED_COMMAND_EDITS
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @return
                     * @param {*} result
                     */
                    getXml(result, attributes) {
                        if (attributes == null)
                            return;
                        for (let index178 = attributes.keySet().iterator(); index178.hasNext();) {
                            let key = index178.next();
                            {
                                if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(key, com.vzome.core.commands.Command.FIELD_ATTR_NAME))
                                    continue;
                                if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(key, com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME))
                                    continue;
                                if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(key, com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME))
                                    continue;
                                if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(key, com.vzome.core.commands.CommandImportVEFData.FIELD_ATTR_NAME))
                                    continue;
                                let value = attributes.get(key);
                                if (value != null && value instanceof com.vzome.core.math.symmetry.IcosahedralSymmetry)
                                    continue;
                                AbstractCommand.saveCommandAttribute(result, key, value);
                            }
                        }
                    }
                    static saveCommandAttribute(command, attrName, value) {
                        let doc = command.getOwnerDocument();
                        let valElem = null;
                        if (value != null && value instanceof Array && (value.length == 0 || value[0] == null || typeof value[0] === 'number')) {
                            let v = value;
                            valElem = command.getOwnerDocument().createElement("RationalVector");
                            let allOnes = true;
                            let allZeros = true;
                            for (let i = 0; i < (v.length / 2 | 0); i++) {
                                {
                                    allZeros = allZeros && (v[2 * i] === 0);
                                    allOnes = allOnes && (v[2 * i + 1] === 1);
                                }
                                ;
                            }
                            if (!allZeros) {
                                let numerators = new java.lang.StringBuffer();
                                for (let i = 0; i < (v.length / 2 | 0); i++) {
                                    {
                                        if (i > 0)
                                            numerators.append(" ");
                                        numerators.append(v[2 * i]);
                                    }
                                    ;
                                }
                                com.vzome.xml.DomUtils.addAttribute(valElem, "nums", numerators.toString());
                                if (!allOnes) {
                                    let denominators = new java.lang.StringBuffer();
                                    for (let i = 0; i < (v.length / 2 | 0); i++) {
                                        {
                                            if (i > 0)
                                                denominators.append(" ");
                                            denominators.append(v[2 * i + 1]);
                                        }
                                        ;
                                    }
                                    com.vzome.xml.DomUtils.addAttribute(valElem, "denoms", denominators.toString());
                                }
                            }
                        }
                        else if (value != null && value instanceof com.vzome.core.math.symmetry.Axis) {
                            valElem = doc.createElement("Axis");
                            value.getXML(valElem);
                        }
                        else if (typeof value === 'boolean') {
                            valElem = doc.createElement("Boolean");
                            com.vzome.xml.DomUtils.addAttribute(valElem, "value", value.toString());
                        }
                        else if (typeof value === 'number') {
                            valElem = doc.createElement("Integer");
                            com.vzome.xml.DomUtils.addAttribute(valElem, "value", value.toString());
                        }
                        else if (value != null && value instanceof com.vzome.core.construction.Construction) {
                            valElem = value.getXml(command.getOwnerDocument());
                        }
                        else if (typeof value === 'string') {
                            valElem = doc.createElement("String");
                            let str = com.vzome.core.commands.XmlSaveFormat.escapeNewlines(value);
                            valElem.appendChild(doc.createTextNode(str));
                        }
                        else if (value != null && value instanceof com.vzome.core.math.symmetry.QuaternionicSymmetry) {
                            valElem = doc.createElement("QuaternionicSymmetry");
                            com.vzome.xml.DomUtils.addAttribute(valElem, "name", value.getName());
                        }
                        else if (value != null && (value["__interfaces"] != null && value["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0 || value.constructor != null && value.constructor["__interfaces"] != null && value.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) {
                            valElem = doc.createElement("Symmetry");
                            com.vzome.xml.DomUtils.addAttribute(valElem, "name", value.getName());
                        }
                        else if (value == null) {
                            valElem = doc.createElement("Null");
                        }
                        else {
                            throw new java.lang.IllegalStateException("unable to save " + /* getName */ (c => c["__class"] ? c["__class"] : c["name"])(value.constructor));
                        }
                        com.vzome.xml.DomUtils.addAttribute(valElem, "attrName", attrName);
                        command.appendChild(valElem);
                    }
                    attributeIs3D(attrName) {
                        return true;
                    }
                    setQuaternion(offset) {
                    }
                    ordersSelection() {
                        return false;
                    }
                    constructor() {
                    }
                }
                commands.AbstractCommand = AbstractCommand;
                AbstractCommand["__class"] = "com.vzome.core.commands.AbstractCommand";
                AbstractCommand["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                let Command;
                (function (Command) {
                    Command.LOADING_FROM_FILE = "org.vorthmann.zome.editor.Command.LOADING_FROM_FILE";
                    Command.FIELD_ATTR_NAME = "org.vorthmann.zome.commands.Command.ALGEBRAIC_FIELD";
                    Command.GENERIC_PARAM_NAME = "org.vorthmann.zome.editor.Command.GENERIC_PARAM";
                })(Command = commands.Command || (commands.Command = {}));
                (function (Command) {
                    /**
                     * @param {string} message
                     * @param {java.lang.Throwable} cause
                     * @class
                     * @extends java.lang.Exception
                     */
                    class Failure extends Error {
                        constructor(message, cause) {
                            if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                                let __args = arguments;
                                super(message);
                                this.message = message;
                                Object.setPrototypeOf(this, Failure.prototype);
                                (() => {
                                    Failure.logger_$LI$().log(java.util.logging.Level.INFO, "command failure: " + message, cause);
                                })();
                            }
                            else if (((typeof message === 'string') || message === null) && cause === undefined) {
                                let __args = arguments;
                                super(message);
                                this.message = message;
                                Object.setPrototypeOf(this, Failure.prototype);
                                (() => {
                                    if (Failure.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                        Failure.logger_$LI$().log(java.util.logging.Level.FINE, "command failure: " + message);
                                })();
                            }
                            else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                                let __args = arguments;
                                let cause = __args[0];
                                super(cause);
                                this.message = cause;
                                Object.setPrototypeOf(this, Failure.prototype);
                                (() => {
                                    Failure.logger_$LI$().log(java.util.logging.Level.INFO, "command failure", cause);
                                })();
                            }
                            else if (message === undefined && cause === undefined) {
                                let __args = arguments;
                                super();
                                Object.setPrototypeOf(this, Failure.prototype);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static logger_$LI$() { if (Failure.logger == null)
                            Failure.logger = java.util.logging.Logger.getLogger("org.vorthmann.zome.commands"); return Failure.logger; }
                        ;
                    }
                    Command.Failure = Failure;
                    Failure["__class"] = "com.vzome.core.commands.Command.Failure";
                    Failure["__interfaces"] = ["java.io.Serializable"];
                })(Command = commands.Command || (commands.Command = {}));
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * @class
                 */
                class ManifestationColorMappers {
                    static __static_initialize() { if (!ManifestationColorMappers.__static_initialized) {
                        ManifestationColorMappers.__static_initialized = true;
                        ManifestationColorMappers.__static_initializer_0();
                    } }
                    static colorMappers_$LI$() { ManifestationColorMappers.__static_initialize(); if (ManifestationColorMappers.colorMappers == null)
                        ManifestationColorMappers.colorMappers = (new java.util.HashMap()); return ManifestationColorMappers.colorMappers; }
                    ;
                    static __static_initializer_0() {
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.RadialCentroidColorMap());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.RadialStandardBasisColorMap());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.CanonicalOrientationColorMap());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.NormalPolarityColorMap());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.CentroidByOctantAndDirectionColorMap());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.CoordinatePlaneColorMap());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.Identity());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.ColorComplementor());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.ColorInverter());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.ColorMaximizer());
                        ManifestationColorMappers.RegisterMapper(new ManifestationColorMappers.ColorSoftener());
                    }
                    static RegisterMapper(mapper) {
                        if (mapper != null) {
                            ManifestationColorMappers.colorMappers_$LI$().put(mapper.getName(), mapper);
                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(mapper.getName(), "ColorComplementor"))
                                ManifestationColorMappers.colorMappers_$LI$().put("ColorComplimentor", mapper);
                        }
                    }
                    static getColorMapper$java_lang_String(mapperName) {
                        let strTransparency = "TransparencyMapper@";
                        if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(mapperName, strTransparency)) {
                            let strAlpha = mapperName.substring(strTransparency.length);
                            let alpha = javaemul.internal.IntegerHelper.parseInt(strAlpha);
                            return new ManifestationColorMappers.TransparencyMapper(alpha);
                        }
                        switch ((mapperName)) {
                            case "TransparencyMapper":
                                return new ManifestationColorMappers.TransparencyMapper(255);
                            case "DarkenWithDistance":
                                return new ManifestationColorMappers.DarkenWithDistance();
                            case "DarkenNearOrigin":
                                return new ManifestationColorMappers.DarkenNearOrigin();
                            case "CopyLastSelectedColor":
                                return new ManifestationColorMappers.CopyLastSelectedColor();
                        }
                        return ManifestationColorMappers.colorMappers_$LI$().get(mapperName);
                    }
                    static getColorMapper$java_lang_String$com_vzome_core_editor_api_OrbitSource(mapperName, symmetry) {
                        let colorMapper = ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(mapperName, "SystemColorMap") ? new ManifestationColorMappers.SystemColorMap(symmetry) : /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(mapperName, "SystemCentroidColorMap") ? new ManifestationColorMappers.SystemCentroidColorMap(symmetry) : /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(mapperName, "NearestSpecialOrbitColorMap") ? new ManifestationColorMappers.NearestSpecialOrbitColorMap(symmetry) : /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(mapperName, "CentroidNearestSpecialOrbitColorMap") ? new ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap(symmetry) : /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(mapperName, "NearestPredefinedOrbitColorMap") ? new ManifestationColorMappers.NearestPredefinedOrbitColorMap(symmetry) : /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(mapperName, "CentroidNearestPredefinedOrbitColorMap") ? new ManifestationColorMappers.CentroidNearestPredefinedOrbitColorMap(symmetry) : ManifestationColorMappers.getColorMapper$java_lang_String(mapperName);
                        if (colorMapper == null) {
                            colorMapper = new ManifestationColorMappers.Identity();
                        }
                        return colorMapper;
                    }
                    static getColorMapper(mapperName, symmetry) {
                        if (((typeof mapperName === 'string') || mapperName === null) && ((symmetry != null && (symmetry["__interfaces"] != null && symmetry["__interfaces"].indexOf("com.vzome.core.editor.api.OrbitSource") >= 0 || symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.OrbitSource") >= 0)) || symmetry === null)) {
                            return com.vzome.core.edits.ManifestationColorMappers.getColorMapper$java_lang_String$com_vzome_core_editor_api_OrbitSource(mapperName, symmetry);
                        }
                        else if (((typeof mapperName === 'string') || mapperName === null) && symmetry === undefined) {
                            return com.vzome.core.edits.ManifestationColorMappers.getColorMapper$java_lang_String(mapperName);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static mapPolarity(vector, alpha) {
                        let polarity = vector.compareTo(vector.negate());
                        let mid = 128;
                        let diff = 64;
                        let shade = polarity < 0 ? mid - diff : polarity > 0 ? mid + diff : mid;
                        return new com.vzome.core.construction.Color(shade, shade, shade, alpha);
                    }
                    /**
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector could be midpoint, start, end, normal, or any basis for mapping to a color
                     * @param {number} alpha the transparency component of the resulting color.
                     * @return
                     * @return {com.vzome.core.construction.Color}
                     */
                    static mapRadially(vector, alpha) {
                        let midPoint = 127;
                        let rgb = [midPoint, midPoint, midPoint];
                        let parts = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(rgb.length);
                        let dimensions = Math.min(rgb.length, vector.dimension());
                        let whole = 0.0;
                        for (let i = 0; i < dimensions; i++) {
                            {
                                let component = vector.getComponent(i);
                                parts[i] = component.evaluate();
                                whole += Math.abs(parts[i]);
                            }
                            ;
                        }
                        if (whole !== 0.0) {
                            for (let i = 0; i < parts.length; i++) {
                                {
                                    let part = (parts[i] / whole);
                                    let contribution = part * midPoint;
                                    rgb[i] = /* intValue */ (contribution | 0) + midPoint;
                                    rgb[i] = Math.min(255, rgb[i]);
                                    rgb[i] = Math.max(0, rgb[i]);
                                }
                                ;
                            }
                        }
                        return new com.vzome.core.construction.Color(rgb[0], rgb[1], rgb[2], alpha);
                    }
                    /**
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector could be midpoint, start, end, normal, or any basis for mapping to a color
                     * @param {number} alpha the transparency component of the resulting color.
                     * @param {number} neg the R, G or B level of vectors with a negative value in the corresponding X, Y, or Z dimension.
                     * @param {number} zero the R, G or B level of vectors with a zero value in the corresponding X, Y, or Z dimension.
                     * @param {number} pos the R, G or B level of vectors with a positive value in the corresponding X, Y, or Z dimension.
                     * @return
                     * @return {com.vzome.core.construction.Color}
                     */
                    static mapToOctant(vector, alpha, neg, zero, pos) {
                        let src = [neg, zero, pos];
                        let rgb = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(src.length);
                        let dimensions = Math.min(rgb.length, vector.dimension());
                        for (let i = 0; i < dimensions; i++) {
                            {
                                let component = vector.getComponent(i);
                                let dir = (f => { if (f > 0) {
                                    return 1;
                                }
                                else if (f < 0) {
                                    return -1;
                                }
                                else {
                                    return 0;
                                } })(component.evaluate());
                                let index = (dir | 0) + 1;
                                rgb[i] = src[index];
                            }
                            ;
                        }
                        return new com.vzome.core.construction.Color(rgb[0], rgb[1], rgb[2], alpha);
                    }
                    static mapToMagnitude(vector, offset, fullScaleSquared, initialColor) {
                        if (vector == null || initialColor == null) {
                            return initialColor;
                        }
                        let magnitudeSquared = com.vzome.core.algebra.AlgebraicVectors.getMagnitudeSquared(vector).evaluate();
                        let denominator = (fullScaleSquared === 0.0) ? 1.0E-4 : fullScaleSquared;
                        let scale = Math.abs(offset - magnitudeSquared) / denominator;
                        return com.vzome.core.construction.Color.getScaledTo(initialColor, scale);
                    }
                }
                ManifestationColorMappers.__static_initialized = false;
                edits.ManifestationColorMappers = ManifestationColorMappers;
                ManifestationColorMappers["__class"] = "com.vzome.core.edits.ManifestationColorMappers";
                (function (ManifestationColorMappers) {
                    /**
                     * Common abstract base class adds xml persistence
                     * and late loading of criteria based on selection and/or model
                     * @class
                     */
                    class ManifestationColorMapper {
                        /* Default method injected from com.vzome.core.edits.ColorMappers.ColorMapper */
                        getName() {
                            let cls = this.constructor;
                            if (cls.isAnonymousClass()) {
                                throw new java.lang.IllegalStateException("Anonymous implementations must override " + /* getSimpleName */ (c => c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))("com.vzome.core.edits.ColorMappers.ColorMapper") + ".getName() so that the result is not derived from the class name.");
                            }
                            return /* getSimpleName */ (c => c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))(cls);
                        }
                        /* Default method injected from com.vzome.core.edits.ColorMappers.ColorMapper */
                        requiresOrderedSelection() {
                            return false;
                        }
                        constructor() {
                        }
                        /**
                         * Optional opportunity to initialize parameters that were not available at time of the constructor
                         * but are determined based on the selection or model iterator
                         * just before apply is called on each individual manifestation.
                         * @param selection
                         * @param model
                         * @param {com.vzome.core.editor.api.Manifestations.ManifestationIterator} manifestations
                         */
                        initialize(manifestations) {
                        }
                        apply$com_vzome_core_model_Manifestation(man) {
                            return (man == null || !man.isRendered()) ? null : this.applyTo(man);
                        }
                        /**
                         *
                         * @param {*} man
                         * @return {com.vzome.core.construction.Color}
                         */
                        apply(man) {
                            if (((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null)) {
                                return this.apply$com_vzome_core_model_Manifestation(man);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        applyTo(manifestation) {
                            let color = manifestation.getColor();
                            if (color == null && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })("com.vzome.core.model.Connector", manifestation.constructor)) {
                                color = com.vzome.core.construction.Color.WHITE_$LI$();
                            }
                            return color;
                        }
                        /**
                         * subclasses should call {@code result.setAttribute()} if they have any parameters to persist
                         * @param {*} result
                         */
                        getXmlAttributes(result) {
                        }
                        /**
                         * subclasses should call {@code xml.getAttribute()} to retrieve any persisted parameters
                         * @param {*} xml
                         */
                        setXmlAttributes(xml) {
                        }
                    }
                    ManifestationColorMappers.ManifestationColorMapper = ManifestationColorMapper;
                    ManifestationColorMapper["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper";
                    ManifestationColorMapper["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * returns current color
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class Identity extends ManifestationColorMappers.ManifestationColorMapper {
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            return rendered.getColor();
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.Identity = Identity;
                    Identity["__class"] = "com.vzome.core.edits.ManifestationColorMappers.Identity";
                    Identity["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * returns complementary color
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class ColorComplementor extends ManifestationColorMappers.ManifestationColorMapper {
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            return com.vzome.core.construction.Color.getComplement(super.applyTo(rendered));
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.ColorComplementor = ColorComplementor;
                    ColorComplementor["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ColorComplementor";
                    ColorComplementor["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * returns inverted color
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class ColorInverter extends ManifestationColorMappers.ManifestationColorMapper {
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            return com.vzome.core.construction.Color.getInverted(super.applyTo(rendered));
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.ColorInverter = ColorInverter;
                    ColorInverter["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ColorInverter";
                    ColorInverter["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * returns maximized color
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class ColorMaximizer extends ManifestationColorMappers.ManifestationColorMapper {
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            return com.vzome.core.construction.Color.getMaximum(super.applyTo(rendered));
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.ColorMaximizer = ColorMaximizer;
                    ColorMaximizer["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ColorMaximizer";
                    ColorMaximizer["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * returns pastel of current color
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class ColorSoftener extends ManifestationColorMappers.ManifestationColorMapper {
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            return com.vzome.core.construction.Color.getPastel(super.applyTo(rendered));
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.ColorSoftener = ColorSoftener;
                    ColorSoftener["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ColorSoftener";
                    ColorSoftener["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    class TransparencyMapper extends ManifestationColorMappers.ManifestationColorMapper {
                        constructor(alpha) {
                            super();
                            if (this.alpha === undefined)
                                this.alpha = 0;
                            this.setAlpha(alpha);
                        }
                        setAlpha(value) {
                            this.alpha = Math.min(255, Math.max(1, value));
                        }
                        /**
                         *
                         * @param {*} xml
                         */
                        setXmlAttributes(xml) {
                            this.alpha = javaemul.internal.IntegerHelper.parseInt(xml.getAttribute(TransparencyMapper.ALPHA_ATTR_NAME));
                        }
                        /**
                         *
                         * @param {*} result
                         */
                        getXmlAttributes(result) {
                            result.setAttribute(TransparencyMapper.ALPHA_ATTR_NAME, /* toString */ ('' + (this.alpha)));
                        }
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            let color = super.applyTo(rendered);
                            return new com.vzome.core.construction.Color(color.getRed(), color.getGreen(), color.getBlue(), this.alpha);
                        }
                    }
                    TransparencyMapper.ALPHA_ATTR_NAME = "alpha";
                    ManifestationColorMappers.TransparencyMapper = TransparencyMapper;
                    TransparencyMapper["__class"] = "com.vzome.core.edits.ManifestationColorMappers.TransparencyMapper";
                    TransparencyMapper["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    class CopyLastSelectedColor extends ManifestationColorMappers.ManifestationColorMapper {
                        constructor() {
                            super();
                            if (this.color === undefined)
                                this.color = null;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        requiresOrderedSelection() {
                            return true;
                        }
                        /**
                         *
                         * @param {com.vzome.core.editor.api.Manifestations.ManifestationIterator} selection
                         */
                        initialize(selection) {
                            if (this.color == null) {
                                let last = null;
                                for (let index179 = selection.iterator(); index179.hasNext();) {
                                    let man = index179.next();
                                    {
                                        if (man != null && man.isRendered()) {
                                            last = man;
                                        }
                                    }
                                }
                                if (last != null) {
                                    this.color = last.getColor();
                                }
                            }
                            if (this.color == null) {
                                throw new com.vzome.core.commands.Command.Failure("select a ball, strut or panel as the color to be copied.");
                            }
                        }
                        /**
                         *
                         * @param {*} xml
                         */
                        setXmlAttributes(xml) {
                            let red = xml.getAttribute("red");
                            let green = xml.getAttribute("green");
                            let blue = xml.getAttribute("blue");
                            let alphaStr = xml.getAttribute("alpha");
                            let alpha = (alphaStr == null || /* isEmpty */ (alphaStr.length === 0)) ? 255 : javaemul.internal.IntegerHelper.parseInt(alphaStr);
                            this.color = new com.vzome.core.construction.Color(javaemul.internal.IntegerHelper.parseInt(red), javaemul.internal.IntegerHelper.parseInt(green), javaemul.internal.IntegerHelper.parseInt(blue), alpha);
                        }
                        /**
                         *
                         * @param {*} result
                         */
                        getXmlAttributes(result) {
                            result.setAttribute("red", "" + this.color.getRed());
                            result.setAttribute("green", "" + this.color.getGreen());
                            result.setAttribute("blue", "" + this.color.getBlue());
                            let alpha = this.color.getAlpha();
                            if (alpha < 255)
                                result.setAttribute("alpha", "" + alpha);
                        }
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            return this.color;
                        }
                    }
                    ManifestationColorMappers.CopyLastSelectedColor = CopyLastSelectedColor;
                    CopyLastSelectedColor["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CopyLastSelectedColor";
                    CopyLastSelectedColor["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Handles getting the centroid and calling overloaded methods to map the subClass specific AlgebraicVector
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     * @class
                     */
                    class CentroidColorMapper extends ManifestationColorMappers.ManifestationColorMapper {
                        constructor() {
                            super();
                        }
                        applyTo$com_vzome_core_model_Manifestation(rendered) {
                            let color = rendered.getColor();
                            let alpha = color == null ? 255 : color.getAlpha();
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(rendered.getCentroid(), alpha);
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
                        applyTo(centroid, alpha) {
                            if (((centroid != null && centroid instanceof com.vzome.core.algebra.AlgebraicVector) || centroid === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha);
                            }
                            else if (((centroid != null && (centroid["__interfaces"] != null && centroid["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || centroid.constructor != null && centroid.constructor["__interfaces"] != null && centroid.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || centroid === null) && alpha === undefined) {
                                return this.applyTo$com_vzome_core_model_Manifestation(centroid);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                    }
                    ManifestationColorMappers.CentroidColorMapper = CentroidColorMapper;
                    CentroidColorMapper["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper";
                    CentroidColorMapper["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Scales the intensity of the current color of each Manifestation
                     * based on the distance of its centroid from the origin.
                     * A position ranging from the origin to the fullScale vector position
                     * adjusts the intensity of the current color from darkest to lightest.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class DarkenNearOrigin extends ManifestationColorMappers.ManifestationColorMapper {
                        constructor() {
                            super();
                            this.offset = 0;
                            this.fullScaleSquared = 0;
                            this.FULLSCALESQUARED_ATTR_NAME = "fullScaleSquared";
                        }
                        /**
                         *
                         * @param {com.vzome.core.editor.api.Manifestations.ManifestationIterator} manifestations
                         */
                        initialize(manifestations) {
                            if (this.fullScaleSquared === 0) {
                                let fullScale = DarkenNearOrigin.getMostDistantPoint(manifestations);
                                if (fullScale == null) {
                                    throw new com.vzome.core.commands.Command.Failure("unable to determine most distant point");
                                }
                                if (fullScale.isOrigin()) {
                                    throw new com.vzome.core.commands.Command.Failure("select at least one point other than the origin");
                                }
                                this.fullScaleSquared = com.vzome.core.algebra.AlgebraicVectors.getMagnitudeSquared(fullScale).evaluate();
                            }
                        }
                        static getMostDistantPoint(manifestations) {
                            let centroids = (new java.util.ArrayList());
                            for (let index180 = manifestations.iterator(); index180.hasNext();) {
                                let man = index180.next();
                                {
                                    centroids.add(man.getCentroid());
                                }
                            }
                            if (centroids.isEmpty()) {
                                return null;
                            }
                            let mostDistant = com.vzome.core.algebra.AlgebraicVectors.getMostDistantFromOrigin(centroids);
                            return mostDistant.isEmpty() ? null : mostDistant.first();
                        }
                        /**
                         *
                         * @param {*} rendered
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(rendered) {
                            let centroid = rendered.getCentroid();
                            let initialColor = super.applyTo(rendered);
                            return ManifestationColorMappers.mapToMagnitude(centroid, this.offset, this.fullScaleSquared, initialColor);
                        }
                        /**
                         *
                         * @param {*} result
                         */
                        getXmlAttributes(result) {
                            result.setAttribute(this.FULLSCALESQUARED_ATTR_NAME, /* toString */ ('' + (this.fullScaleSquared)));
                        }
                        /**
                         *
                         * @param {*} xml
                         */
                        setXmlAttributes(xml) {
                            let attr = xml.getAttribute(this.FULLSCALESQUARED_ATTR_NAME);
                            this.fullScaleSquared = javaemul.internal.DoubleHelper.parseDouble(attr);
                        }
                    }
                    ManifestationColorMappers.DarkenNearOrigin = DarkenNearOrigin;
                    DarkenNearOrigin["__class"] = "com.vzome.core.edits.ManifestationColorMappers.DarkenNearOrigin";
                    DarkenNearOrigin["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Abstract base class which calls subclass specific abstract overloads for all known subtypes.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationColorMapper
                     */
                    class ManifestationSubclassColorMapper extends ManifestationColorMappers.ManifestationColorMapper {
                        /**
                         *
                         * @param {*} man
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(man) {
                            let color = man.getColor();
                            let alpha = color == null ? 255 : color.getAlpha();
                            if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                return this.applyToBall(man, alpha);
                            }
                            else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                return this.applyToBall(man, alpha);
                            }
                            else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                return this.applyToPanel(man, alpha);
                            }
                            return null;
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.ManifestationSubclassColorMapper = ManifestationSubclassColorMapper;
                    ManifestationSubclassColorMapper["__class"] = "com.vzome.core.edits.ManifestationColorMappers.ManifestationSubclassColorMapper";
                    ManifestationSubclassColorMapper["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Maps vector XYZ components to RGB
                     * such that each RGB component is weighted by the contribution
                     * of the corresponding XYZ component
                     * and offset by half of the color range so that a
                     * + directions map between 0x7F and 0xFF color element
                     * 0 direction maps to a midrange    0x7F color element
                     * - directions map between 0x00 and 0x7F color element
                     *
                     * Polarity info IS retained by this mapping.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper
                     */
                    class RadialCentroidColorMap extends ManifestationColorMappers.CentroidColorMapper {
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha) {
                            return ManifestationColorMappers.mapRadially(centroid, alpha);
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} centroid
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(centroid, alpha) {
                            if (((centroid != null && centroid instanceof com.vzome.core.algebra.AlgebraicVector) || centroid === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha);
                            }
                            else if (((centroid != null && (centroid["__interfaces"] != null && centroid["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || centroid.constructor != null && centroid.constructor["__interfaces"] != null && centroid.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || centroid === null) && alpha === undefined) {
                                return this.applyTo$com_vzome_core_model_Manifestation(centroid);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.RadialCentroidColorMap = RadialCentroidColorMap;
                    RadialCentroidColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.RadialCentroidColorMap";
                    RadialCentroidColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Maps vector XYZ components to RGB by Octant
                     *
                     * Polarity info IS retained by this mapping.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper
                     */
                    class CentroidByOctantAndDirectionColorMap extends ManifestationColorMappers.CentroidColorMapper {
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha) {
                            return com.vzome.core.construction.Color.getMaximum(ManifestationColorMappers.mapToOctant(vector, alpha, 0, 127, 255));
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(vector, alpha) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                            }
                            else if (((vector != null && (vector["__interfaces"] != null && vector["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                                return this.applyTo$com_vzome_core_model_Manifestation(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.CentroidByOctantAndDirectionColorMap = CentroidByOctantAndDirectionColorMap;
                    CentroidByOctantAndDirectionColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CentroidByOctantAndDirectionColorMap";
                    CentroidByOctantAndDirectionColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Maps vector XYZ components to RGB
                     * corresponding to the X, Y or Z coordinate plane.
                     *
                     * Polarity info IS NOT retained by this mapping.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper
                     */
                    class CoordinatePlaneColorMap extends ManifestationColorMappers.CentroidColorMapper {
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha) {
                            return com.vzome.core.construction.Color.getInverted(ManifestationColorMappers.mapToOctant(vector, alpha, 0, 255, 0));
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(vector, alpha) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                            }
                            else if (((vector != null && (vector["__interfaces"] != null && vector["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                                return this.applyTo$com_vzome_core_model_Manifestation(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.CoordinatePlaneColorMap = CoordinatePlaneColorMap;
                    CoordinatePlaneColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CoordinatePlaneColorMap";
                    CoordinatePlaneColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Maps standard SymmetrySystem colors
                     * to the Manifestation's Centroid instead of the normal vector
                     * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidColorMapper
                     * @class
                     */
                    class SystemCentroidColorMap extends ManifestationColorMappers.CentroidColorMapper {
                        constructor(symmetry) {
                            super();
                            if (this.symmetrySystem === undefined)
                                this.symmetrySystem = null;
                            this.symmetrySystem = symmetry;
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha) {
                            return this.symmetrySystem.getVectorColor(centroid);
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} centroid
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(centroid, alpha) {
                            if (((centroid != null && centroid instanceof com.vzome.core.algebra.AlgebraicVector) || centroid === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(centroid, alpha);
                            }
                            else if (((centroid != null && (centroid["__interfaces"] != null && centroid["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || centroid.constructor != null && centroid.constructor["__interfaces"] != null && centroid.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || centroid === null) && alpha === undefined) {
                                return this.applyTo$com_vzome_core_model_Manifestation(centroid);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         *
                         * @param {*} element
                         */
                        getXmlAttributes(element) {
                            if (this.symmetrySystem != null) {
                                com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetrySystem.getName());
                            }
                        }
                    }
                    ManifestationColorMappers.SystemCentroidColorMap = SystemCentroidColorMap;
                    SystemCentroidColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.SystemCentroidColorMap";
                    SystemCentroidColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Same as {@code DarkenNearOrigin} except that
                     * the color mapping is reversed from lightest to darkest
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.DarkenNearOrigin
                     */
                    class DarkenWithDistance extends ManifestationColorMappers.DarkenNearOrigin {
                        /**
                         *
                         * @param {com.vzome.core.editor.api.Manifestations.ManifestationIterator} manifestations
                         */
                        initialize(manifestations) {
                            super.initialize(manifestations);
                            this.offset = this.fullScaleSquared;
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.DarkenWithDistance = DarkenWithDistance;
                    DarkenWithDistance["__class"] = "com.vzome.core.edits.ManifestationColorMappers.DarkenWithDistance";
                    DarkenWithDistance["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Polarity info is retained by this mapping
                     * so that inverted struts and panels will be mapped to inverted colors.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationSubclassColorMapper
                     */
                    class RadialStandardBasisColorMap extends ManifestationColorMappers.ManifestationSubclassColorMapper {
                        /**
                         *
                         * @param {*} ball
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToBall(ball, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(ball.getLocation(), alpha);
                        }
                        /**
                         *
                         * @param {*} strut
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToStrut(strut, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(strut.getOffset(), alpha);
                        }
                        /**
                         *
                         * @param {*} panel
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToPanel(panel, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(panel['getNormal$'](), alpha);
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha) {
                            return ManifestationColorMappers.mapRadially(vector, alpha);
                        }
                        applyTo(vector, alpha) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                            }
                            else if (((vector != null && (vector["__interfaces"] != null && vector["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                                super.applyTo(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.RadialStandardBasisColorMap = RadialStandardBasisColorMap;
                    RadialStandardBasisColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.RadialStandardBasisColorMap";
                    RadialStandardBasisColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Gets standard color mapping from the OrbitSource
                     * @extends com.vzome.core.edits.ManifestationColorMappers.ManifestationSubclassColorMapper
                     * @class
                     */
                    class SystemColorMap extends ManifestationColorMappers.ManifestationSubclassColorMapper {
                        constructor(symmetry) {
                            super();
                            if (this.symmetrySystem === undefined)
                                this.symmetrySystem = null;
                            this.symmetrySystem = symmetry;
                        }
                        /**
                         *
                         * @param {*} ball
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToBall(ball, alpha) {
                            return com.vzome.core.construction.Color.WHITE_$LI$();
                        }
                        /**
                         *
                         * @param {*} strut
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToStrut(strut, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector(strut.getOffset());
                        }
                        /**
                         *
                         * @param {*} panel
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToPanel(panel, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector(panel['getNormal$']()).getPastel();
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector(vector) {
                            return this.symmetrySystem.getVectorColor(vector);
                        }
                        applyTo(vector) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector(vector);
                            }
                            else if (((vector != null && (vector["__interfaces"] != null && vector["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null)) {
                                super.applyTo(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         *
                         * @param {*} element
                         */
                        getXmlAttributes(element) {
                            if (this.symmetrySystem != null) {
                                com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetrySystem.getName());
                            }
                        }
                    }
                    ManifestationColorMappers.SystemColorMap = SystemColorMap;
                    SystemColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.SystemColorMap";
                    SystemColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Polarity info is intentionally removed by this mapping for struts and panels, but not balls
                     * so that parallel struts and the panels normal to them will be the same color.
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.RadialStandardBasisColorMap
                     */
                    class CanonicalOrientationColorMap extends ManifestationColorMappers.RadialStandardBasisColorMap {
                        /**
                         *
                         * @param {*} ball
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToBall(ball, alpha) {
                            return super.applyToBall(ball, alpha);
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha) {
                            return super.applyTo$com_vzome_core_algebra_AlgebraicVector$int(com.vzome.core.algebra.AlgebraicVectors.getCanonicalOrientation(vector), alpha);
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(vector, alpha) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                            }
                            else if (((vector != null && (vector["__interfaces"] != null && vector["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                                super.applyTo(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.CanonicalOrientationColorMap = CanonicalOrientationColorMap;
                    CanonicalOrientationColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CanonicalOrientationColorMap";
                    CanonicalOrientationColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Polarity info is the ONLY basis for this mapping
                     * @class
                     * @extends com.vzome.core.edits.ManifestationColorMappers.RadialStandardBasisColorMap
                     */
                    class NormalPolarityColorMap extends ManifestationColorMappers.RadialStandardBasisColorMap {
                        applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha) {
                            return ManifestationColorMappers.mapPolarity(vector, alpha);
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(vector, alpha) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null) && ((typeof alpha === 'number') || alpha === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector$int(vector, alpha);
                            }
                            else if (((vector != null && (vector["__interfaces"] != null && vector["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null) && alpha === undefined) {
                                super.applyTo(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor() {
                            super();
                        }
                    }
                    ManifestationColorMappers.NormalPolarityColorMap = NormalPolarityColorMap;
                    NormalPolarityColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.NormalPolarityColorMap";
                    NormalPolarityColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Gets standard color of the nearest special orbit using the standard color basis
                     * @extends com.vzome.core.edits.ManifestationColorMappers.SystemColorMap
                     * @class
                     */
                    class NearestSpecialOrbitColorMap extends ManifestationColorMappers.SystemColorMap {
                        constructor(symm) {
                            super(symm);
                            this.specialOrbits = (new java.util.LinkedHashSet());
                            this.specialOrbits.add(symm.getSymmetry().getSpecialOrbit(com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.BLUE));
                            this.specialOrbits.add(symm.getSymmetry().getSpecialOrbit(com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.YELLOW));
                            this.specialOrbits.add(symm.getSymmetry().getSpecialOrbit(com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.RED));
                        }
                        /**
                         *
                         * @param {*} ball
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToBall(ball, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector(ball.getLocation());
                        }
                        /**
                         *
                         * @param {*} strut
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToStrut(strut, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector(strut.getOffset());
                        }
                        /**
                         *
                         * @param {*} panel
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToPanel(panel, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector(panel['getNormal$']()).getPastel();
                        }
                        applyTo$com_vzome_core_algebra_AlgebraicVector(vector) {
                            if (vector.isOrigin()) {
                                return com.vzome.core.construction.Color.WHITE_$LI$();
                            }
                            let nearestSpecialOrbit = this.symmetrySystem.getSymmetry()['getAxis$com_vzome_core_math_RealVector$java_util_Set'](vector.toRealVector(), this.specialOrbits);
                            let normal = nearestSpecialOrbit.normal();
                            return this.symmetrySystem.getVectorColor(normal);
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vector
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyTo(vector) {
                            if (((vector != null && vector instanceof com.vzome.core.algebra.AlgebraicVector) || vector === null)) {
                                return this.applyTo$com_vzome_core_algebra_AlgebraicVector(vector);
                            }
                            else if (((vector != null && (vector["__interfaces"] != null && vector["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || vector.constructor != null && vector.constructor["__interfaces"] != null && vector.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || vector === null)) {
                                super.applyTo(vector);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                    }
                    ManifestationColorMappers.NearestSpecialOrbitColorMap = NearestSpecialOrbitColorMap;
                    NearestSpecialOrbitColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.NearestSpecialOrbitColorMap";
                    NearestSpecialOrbitColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Gets standard color of the nearest special orbit based on the Centroid
                     * @extends com.vzome.core.edits.ManifestationColorMappers.NearestSpecialOrbitColorMap
                     * @class
                     */
                    class CentroidNearestSpecialOrbitColorMap extends ManifestationColorMappers.NearestSpecialOrbitColorMap {
                        constructor(symm) {
                            super(symm);
                        }
                        /**
                         *
                         * @param {*} ball
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToBall(ball, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector(ball.getCentroid());
                        }
                        /**
                         *
                         * @param {*} strut
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToStrut(strut, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector(strut.getCentroid());
                        }
                        /**
                         *
                         * @param {*} panel
                         * @param {number} alpha
                         * @return {com.vzome.core.construction.Color}
                         */
                        applyToPanel(panel, alpha) {
                            return this.applyTo$com_vzome_core_algebra_AlgebraicVector(panel.getCentroid()).getPastel();
                        }
                    }
                    ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap = CentroidNearestSpecialOrbitColorMap;
                    CentroidNearestSpecialOrbitColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap";
                    CentroidNearestSpecialOrbitColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Gets standard color of the nearest predefined orbit using the symmetry's standard color scheme
                     * @extends com.vzome.core.edits.ManifestationColorMappers.NearestSpecialOrbitColorMap
                     * @class
                     */
                    class NearestPredefinedOrbitColorMap extends ManifestationColorMappers.NearestSpecialOrbitColorMap {
                        constructor(symm) {
                            super(symm);
                            this.specialOrbits = null;
                        }
                    }
                    ManifestationColorMappers.NearestPredefinedOrbitColorMap = NearestPredefinedOrbitColorMap;
                    NearestPredefinedOrbitColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.NearestPredefinedOrbitColorMap";
                    NearestPredefinedOrbitColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                    /**
                     * Gets standard color of the nearest predefined orbit based on the centroid of each manifestation
                     * @extends com.vzome.core.edits.ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap
                     * @class
                     */
                    class CentroidNearestPredefinedOrbitColorMap extends ManifestationColorMappers.CentroidNearestSpecialOrbitColorMap {
                        constructor(symm) {
                            super(symm);
                            this.specialOrbits = null;
                        }
                    }
                    ManifestationColorMappers.CentroidNearestPredefinedOrbitColorMap = CentroidNearestPredefinedOrbitColorMap;
                    CentroidNearestPredefinedOrbitColorMap["__class"] = "com.vzome.core.edits.ManifestationColorMappers.CentroidNearestPredefinedOrbitColorMap";
                    CentroidNearestPredefinedOrbitColorMap["__interfaces"] = ["com.vzome.core.edits.ColorMappers.ColorMapper", "java.util.function.Function"];
                })(ManifestationColorMappers = edits.ManifestationColorMappers || (edits.ManifestationColorMappers = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * @class
                 */
                class ColorMappers {
                }
                edits.ColorMappers = ColorMappers;
                ColorMappers["__class"] = "com.vzome.core.edits.ColorMappers";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor_1) {
                class ToolsModel extends java.util.TreeMap {
                    constructor(context, originPoint) {
                        super();
                        if (this.editor === undefined)
                            this.editor = null;
                        this.lastId = 0;
                        this.pcs = new java.beans.PropertyChangeSupport(this);
                        if (this.context === undefined)
                            this.context = null;
                        if (this.originPoint === undefined)
                            this.originPoint = null;
                        this.toolLabels = (new java.util.HashMap());
                        this.toolDeleteInputs = (new java.util.HashMap());
                        this.toolSelectInputs = (new java.util.HashMap());
                        this.hiddenTools = (new java.util.HashSet());
                        this.context = context;
                        this.originPoint = originPoint;
                    }
                    reserveId() {
                        return this.lastId++;
                    }
                    /**
                     * Only called during load of a document, before any new tool creations with reserveId.
                     * @param {number} id
                     */
                    setMaxId(id) {
                        if (id >= this.lastId)
                            this.lastId = id + 1;
                    }
                    /**
                     *
                     * @param {string} key
                     * @param {com.vzome.core.editor.Tool} tool
                     * @return {com.vzome.core.editor.Tool}
                     */
                    put(key, tool) {
                        this.pcs.firePropertyChange("tool.instances", null, tool);
                        return super.put(key, tool);
                    }
                    createEdit(className) {
                        switch ((className)) {
                            case "ToolApplied":
                                return new com.vzome.core.editor.ApplyTool(this, null, false, false, false, false, false);
                            case "ApplyTool":
                                return new com.vzome.core.editor.ApplyTool(this, null, false, false, false, false, true);
                            case "SelectToolParameters":
                                return new com.vzome.core.editor.SelectToolParameters(this, null);
                            default:
                                return null;
                        }
                    }
                    applyTool(tool, selectInputs, deleteInputs, createOutputs, selectOutputs) {
                        let edit = new com.vzome.core.editor.ApplyTool(this, tool, selectInputs, deleteInputs, createOutputs, selectOutputs, true);
                        this.getContext().performAndRecord(edit);
                    }
                    selectToolParameters(tool) {
                        let edit = new com.vzome.core.editor.SelectToolParameters(this, tool);
                        this.getContext().performAndRecord(edit);
                    }
                    addPropertyListener(listener) {
                        this.pcs.addPropertyChangeListener(listener);
                    }
                    removePropertyListener(listener) {
                        this.pcs.removePropertyChangeListener(listener);
                    }
                    setEditorModel(editor) {
                        this.editor = editor;
                    }
                    getEditorModel() {
                        return this.editor;
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    getPredefinedTool(id) {
                        return this.get(id);
                    }
                    getContext() {
                        return this.context;
                    }
                    getOriginPoint() {
                        return this.originPoint;
                    }
                    getXml(doc) {
                        let result = doc.createElement("Tools");
                        for (let index181 = this.values().iterator(); index181.hasNext();) {
                            let tool = index181.next();
                            if (!tool.isPredefined()) {
                                let toolElem = doc.createElement("Tool");
                                com.vzome.xml.DomUtils.addAttribute(toolElem, "id", tool.getId());
                                com.vzome.xml.DomUtils.addAttribute(toolElem, "label", tool.getLabel());
                                if (tool.isHidden())
                                    com.vzome.xml.DomUtils.addAttribute(toolElem, "hidden", "true");
                                if (tool.isSelectInputs())
                                    toolElem.setAttribute("selectInputs", "true");
                                if (tool.isDeleteInputs())
                                    toolElem.setAttribute("deleteInputs", "true");
                                result.appendChild(toolElem);
                            }
                        }
                        return result;
                    }
                    loadFromXml(xml) {
                        let nodes = xml.getChildNodes();
                        for (let i = 0; i < nodes.getLength(); i++) {
                            {
                                let node = nodes.item(i);
                                if (node != null && (node["__interfaces"] != null && node["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) {
                                    let toolElem = node;
                                    let id = toolElem.getAttribute("id");
                                    let label = toolElem.getAttribute("label");
                                    this.toolLabels.put(id, label);
                                    let value = toolElem.getAttribute("selectInputs");
                                    if (value != null && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                        return o1.equals(o2);
                                    }
                                    else {
                                        return o1 === o2;
                                    } })(value, "true"))
                                        this.toolSelectInputs.put(id, javaemul.internal.BooleanHelper.parseBoolean(value));
                                    value = toolElem.getAttribute("deleteInputs");
                                    if (value != null && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                        return o1.equals(o2);
                                    }
                                    else {
                                        return o1 === o2;
                                    } })(value, "true"))
                                        this.toolDeleteInputs.put(id, javaemul.internal.BooleanHelper.parseBoolean(value));
                                    let hiddenStr = toolElem.getAttribute("hidden");
                                    if (hiddenStr != null && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                        return o1.equals(o2);
                                    }
                                    else {
                                        return o1 === o2;
                                    } })(hiddenStr, "true"))
                                        this.hiddenTools.add(id);
                                }
                            }
                            ;
                        }
                    }
                    setConfiguration(tool) {
                        let id = tool.getId();
                        let label = this.toolLabels.get(id);
                        if (label != null)
                            tool.setLabel(label);
                        if (this.toolDeleteInputs.containsKey(id) || this.toolSelectInputs.containsKey(id)) {
                            tool.setInputBehaviors(this.toolSelectInputs.containsKey(id), this.toolDeleteInputs.containsKey(id));
                        }
                        tool.setHidden(this.hiddenTools.contains(id));
                    }
                    hideTool(tool) {
                        this.pcs.firePropertyChange("tool.instances", tool, null);
                    }
                }
                editor_1.ToolsModel = ToolsModel;
                ToolsModel["__class"] = "com.vzome.core.editor.ToolsModel";
                ToolsModel["__interfaces"] = ["java.lang.Cloneable", "com.vzome.api.Tool.Source", "java.util.Map", "java.util.NavigableMap", "java.util.SortedMap", "java.io.Serializable"];
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class Duplicator {
                    constructor(edit, offset) {
                        this.vertexData = (new java.util.HashMap());
                        if (this.edit === undefined)
                            this.edit = null;
                        if (this.offset === undefined)
                            this.offset = null;
                        this.edit = edit;
                        this.offset = offset;
                    }
                    duplicateManifestation(man) {
                        let constr = this.duplicateConstruction(man);
                        this.edit.manifestConstruction(constr);
                    }
                    duplicateConstruction(man) {
                        if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                            let vector = man.getLocation();
                            return this.getVertex(vector);
                        }
                        else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                            let strut = man;
                            let p1 = this.getVertex(strut.getLocation());
                            let p2 = this.getVertex(strut.getEnd());
                            return new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                        }
                        else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                            let vs = (new java.util.ArrayList());
                            for (let index182 = man.iterator(); index182.hasNext();) {
                                let v = index182.next();
                                {
                                    vs.add(this.getVertex(v));
                                }
                            }
                            return new com.vzome.core.construction.PolygonFromVertices(vs.toArray([]));
                        }
                        return null;
                    }
                    getVertex(vertexVector) {
                        let result = this.vertexData.get(vertexVector);
                        if (result == null) {
                            let key = vertexVector;
                            if (this.offset != null)
                                vertexVector = vertexVector.plus(this.offset);
                            result = new com.vzome.core.construction.FreePoint(vertexVector);
                            this.vertexData.put(key, result);
                        }
                        return result;
                    }
                }
                editor.Duplicator = Duplicator;
                Duplicator["__class"] = "com.vzome.core.editor.Duplicator";
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class SelectionSummary {
                    constructor(selection) {
                        this.balls = 0;
                        this.struts = 0;
                        this.panels = 0;
                        this.listeners = (new java.util.ArrayList());
                        if (this.selection === undefined)
                            this.selection = null;
                        this.selection = selection;
                    }
                    notifyListeners() {
                        for (let index183 = this.listeners.iterator(); index183.hasNext();) {
                            let listener = index183.next();
                            {
                                listener.selectionChanged(this.selection.size(), this.balls, this.struts, this.panels);
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    manifestationAdded(m) {
                        if (m != null && (m["__interfaces"] != null && m["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))
                            ++this.balls;
                        else if (m != null && (m["__interfaces"] != null && m["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))
                            ++this.struts;
                        else if (m != null && (m["__interfaces"] != null && m["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))
                            ++this.panels;
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    manifestationRemoved(m) {
                        if (m != null && (m["__interfaces"] != null && m["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))
                            --this.balls;
                        else if (m != null && (m["__interfaces"] != null && m["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))
                            --this.struts;
                        else if (m != null && (m["__interfaces"] != null && m["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))
                            --this.panels;
                    }
                    /**
                     *
                     * @param {*} m
                     * @param {com.vzome.core.construction.Color} color
                     */
                    manifestationColored(m, color) {
                    }
                    addListener(listener) {
                        this.listeners.add(listener);
                    }
                }
                editor.SelectionSummary = SelectionSummary;
                SelectionSummary["__class"] = "com.vzome.core.editor.SelectionSummary";
                SelectionSummary["__interfaces"] = ["com.vzome.core.model.ManifestationChanges"];
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    class UndoableEdit {
                        constructor() {
                            this.__hasBreakpoint = false;
                            this.lineNumber = -1;
                        }
                        hasBreakpoint() {
                            return this.__hasBreakpoint;
                        }
                        setBreakpoint(value) {
                            this.__hasBreakpoint = value;
                        }
                        getLineNumber() {
                            return this.lineNumber;
                        }
                        setLineNumber(lineNumber) {
                            this.lineNumber = lineNumber;
                        }
                    }
                    api.UndoableEdit = UndoableEdit;
                    UndoableEdit["__class"] = "com.vzome.core.editor.api.UndoableEdit";
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    class ManifestConstructions extends java.util.ArrayList {
                        constructor(edit) {
                            super();
                            if (this.edit === undefined)
                                this.edit = null;
                            this.edit = edit;
                        }
                        constructionAdded$com_vzome_core_construction_Construction(c) {
                            this.edit.manifestConstruction(c);
                            this.edit.redo();
                        }
                        constructionAdded$com_vzome_core_construction_Construction$com_vzome_core_construction_Color(c, color) {
                            let manifestation = this.edit.manifestConstruction(c);
                            if (color != null)
                                this.edit.colorManifestation(manifestation, color);
                            this.edit.select$com_vzome_core_model_Manifestation(manifestation);
                            this.edit.redo();
                        }
                        /**
                         *
                         * @param {com.vzome.core.construction.Construction} c
                         * @param {com.vzome.core.construction.Color} color
                         */
                        constructionAdded(c, color) {
                            if (((c != null && c instanceof com.vzome.core.construction.Construction) || c === null) && ((color != null && color instanceof com.vzome.core.construction.Color) || color === null)) {
                                return this.constructionAdded$com_vzome_core_construction_Construction$com_vzome_core_construction_Color(c, color);
                            }
                            else if (((c != null && c instanceof com.vzome.core.construction.Construction) || c === null) && color === undefined) {
                                return this.constructionAdded$com_vzome_core_construction_Construction(c);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                    }
                    api.ManifestConstructions = ManifestConstructions;
                    ManifestConstructions["__class"] = "com.vzome.core.editor.api.ManifestConstructions";
                    ManifestConstructions["__interfaces"] = ["java.util.RandomAccess", "com.vzome.core.model.ColoredMeshJson.Events", "com.vzome.core.model.SimpleMeshJson.Events", "java.util.List", "java.lang.Cloneable", "com.vzome.core.construction.ConstructionChanges", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    let Selection;
                    (function (Selection) {
                        function biggestGroup(m) {
                            let parent = m.getContainer();
                            let group = parent;
                            while ((parent != null)) {
                                {
                                    parent = group.getContainer();
                                    if (parent == null)
                                        break;
                                    group = parent;
                                }
                            }
                            ;
                            return group;
                        }
                        Selection.biggestGroup = biggestGroup;
                    })(Selection = api.Selection || (api.Selection = {}));
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    let ActionEnum;
                    (function (ActionEnum) {
                        ActionEnum[ActionEnum["IGNORE"] = 0] = "IGNORE";
                        ActionEnum[ActionEnum["SELECT"] = 1] = "SELECT";
                        ActionEnum[ActionEnum["DESELECT"] = 2] = "DESELECT";
                    })(ActionEnum = api.ActionEnum || (api.ActionEnum = {}));
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class AbstractToolFactory {
                    constructor(tools, symmetry, id, label, tooltip) {
                        this.enabled = false;
                        if (this.pcs === undefined)
                            this.pcs = null;
                        if (this.tools === undefined)
                            this.tools = null;
                        if (this.label === undefined)
                            this.label = null;
                        if (this.tooltip === undefined)
                            this.tooltip = null;
                        if (this.id === undefined)
                            this.id = null;
                        if (this.symmetry === undefined)
                            this.symmetry = null;
                        this.tools = tools;
                        this.symmetry = symmetry;
                        this.id = id;
                        this.label = label;
                        this.tooltip = tooltip;
                        this.pcs = new java.beans.PropertyChangeSupport(this);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     */
                    selectionChanged(total, balls, struts, panels) {
                        let wasEnabled = this.enabled;
                        if (this.countsAreValid(total, balls, struts, panels))
                            this.enabled = this.bindParameters(this.getSelection());
                        else
                            this.enabled = false;
                        if (wasEnabled !== this.enabled)
                            this.pcs.firePropertyChange("enabled", wasEnabled, this.enabled);
                    }
                    getSymmetry() {
                        return this.symmetry;
                    }
                    getId() {
                        return this.id;
                    }
                    getLabel() {
                        return this.label;
                    }
                    getToolTip() {
                        return this.tooltip;
                    }
                    getToolsModel() {
                        return this.tools;
                    }
                    getEditorModel() {
                        return this.tools.getEditorModel();
                    }
                    getSelection() {
                        return this.getEditorModel().getSelection();
                    }
                    getModel() {
                        return this.getEditorModel().getRealizedModel();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isEnabled() {
                        return this.enabled;
                    }
                    addListener(listener) {
                        this.pcs.addPropertyChangeListener(listener);
                    }
                    /**
                     *
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createTool() {
                        let index = this.tools.reserveId();
                        let tool = this.createToolInternal(AbstractToolFactory.NEW_PREFIX + index);
                        tool.setCategory(this.getId());
                        tool.setLabel(this.getId() + " " + index);
                        if (tool != null && tool instanceof com.vzome.core.editor.api.UndoableEdit)
                            this.tools.getContext().performAndRecord(tool);
                        else
                            this.tools.put(tool.getId(), tool);
                        return tool;
                    }
                    createPredefinedTool(label) {
                        let tool = this.createToolInternal(this.getId() + ".builtin/" + label);
                        tool.setLabel(label);
                        tool.setCategory(this.getId());
                        tool.setPredefined(true);
                        tool.checkSelection(true);
                        this.tools.put(tool.getId(), tool);
                        return tool;
                    }
                    deserializeTool(id) {
                        let tool = this.createToolInternal(id);
                        if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(id, AbstractToolFactory.NEW_PREFIX)) {
                            let num = javaemul.internal.IntegerHelper.parseInt(id.substring(AbstractToolFactory.NEW_PREFIX.length));
                            this.tools.setMaxId(num);
                        }
                        this.tools.setConfiguration(tool);
                        let nextDot = id.indexOf(".");
                        if (nextDot > 0) {
                            tool.setCategory(id.substring(0, nextDot));
                        }
                        else {
                            tool.setCategory(this.getId());
                        }
                        return tool;
                    }
                }
                AbstractToolFactory.NEW_PREFIX = "tool-";
                editor.AbstractToolFactory = AbstractToolFactory;
                AbstractToolFactory["__class"] = "com.vzome.core.editor.AbstractToolFactory";
                AbstractToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor_2) {
                class SymmetrySystem {
                    constructor(symmXml, symmetryPerspective, context, colors, allowNonstandard) {
                        if (this.symmetry === undefined)
                            this.symmetry = null;
                        if (this.orbits === undefined)
                            this.orbits = null;
                        this.orbitColors = (new java.util.HashMap());
                        if (this.shapes === undefined)
                            this.shapes = null;
                        this.vectorToAxis = (new java.util.HashMap());
                        this.noKnownDirections = false;
                        if (this.symmetryPerspective === undefined)
                            this.symmetryPerspective = null;
                        this.toolFactoryLists = (new java.util.HashMap());
                        this.toolLists = (new java.util.HashMap());
                        if (this.context === undefined)
                            this.context = null;
                        if (this.editor === undefined)
                            this.editor = null;
                        this.symmetryPerspective = symmetryPerspective;
                        this.context = context;
                        this.symmetry = symmetryPerspective.getSymmetry();
                        let styleName = symmetryPerspective.getDefaultGeometry().getName();
                        this.orbits = new com.vzome.core.math.symmetry.OrbitSet(this.symmetry);
                        if (symmXml == null) {
                            for (let index184 = this.symmetry.getOrbitSet().iterator(); index184.hasNext();) {
                                let orbit = index184.next();
                                {
                                    if (symmetryPerspective.orbitIsStandard(orbit) || allowNonstandard)
                                        this.orbits.add(orbit);
                                    let color = colors.getColor(com.vzome.core.render.Colors.DIRECTION_$LI$() + orbit.getName());
                                    this.orbitColors.put(orbit.getName(), color);
                                }
                            }
                        }
                        else {
                            styleName = symmXml.getAttribute("renderingStyle");
                            let nodes = symmXml.getChildNodes();
                            for (let i = 0; i < nodes.getLength(); i++) {
                                {
                                    let node = nodes.item(i);
                                    if (node != null && (node["__interfaces"] != null && node["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || node.constructor != null && node.constructor["__interfaces"] != null && node.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) {
                                        let dirElem = node;
                                        let name = dirElem.getAttribute("name");
                                        let orbit = null;
                                        let nums = dirElem.getAttribute("prototype");
                                        if (nums != null && !(nums.length === 0)) {
                                            let prototype = this.symmetry.getField().parseVector(nums);
                                            try {
                                                orbit = this.symmetry.createNewZoneOrbit(name, 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, prototype);
                                            }
                                            catch (e) {
                                                console.error("Integer overflow happened while creating orbit: " + name);
                                                continue;
                                            }
                                            ;
                                            orbit.setAutomatic(true);
                                            try {
                                                let autoNum = javaemul.internal.IntegerHelper.parseInt(name);
                                                if (autoNum >= SymmetrySystem.NEXT_NEW_AXIS)
                                                    SymmetrySystem.NEXT_NEW_AXIS = ++autoNum;
                                                else if (autoNum < SymmetrySystem.NEXT_NEW_AXIS)
                                                    name = "" + SymmetrySystem.NEXT_NEW_AXIS++;
                                            }
                                            catch (e) {
                                                console.error(e.message);
                                            }
                                            ;
                                        }
                                        else {
                                            orbit = this.symmetry.getDirection(name);
                                            if (orbit == null)
                                                continue;
                                        }
                                        this.orbits.add(orbit);
                                        let str = dirElem.getAttribute("color");
                                        if (str != null && !(str.length === 0)) {
                                            let color = com.vzome.core.construction.Color.parseColor(str);
                                            this.orbitColors.put(orbit.getName(), color);
                                        }
                                    }
                                }
                                ;
                            }
                            for (let index185 = this.symmetry.getOrbitSet().iterator(); index185.hasNext();) {
                                let orbit = index185.next();
                                {
                                    if (this.orbits.contains(orbit))
                                        continue;
                                    if (orbit.isStandard() || allowNonstandard)
                                        this.orbits.add(orbit);
                                    let color = colors.getColor(com.vzome.core.render.Colors.DIRECTION_$LI$() + orbit.getName());
                                    this.orbitColors.put(orbit.getName(), color);
                                }
                            }
                        }
                        this.setStyle(styleName);
                    }
                    static logger_$LI$() { if (SymmetrySystem.logger == null)
                        SymmetrySystem.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor"); return SymmetrySystem.logger; }
                    ;
                    setEditorModel(editor) {
                        this.editor = editor;
                    }
                    createToolFactories(tools) {
                        {
                            let array187 = /* Enum.values */ function () { let result = []; for (let val in com.vzome.api.Tool.Kind) {
                                if (!isNaN(val)) {
                                    result.push(parseInt(val, 10));
                                }
                            } return result; }();
                            for (let index186 = 0; index186 < array187.length; index186++) {
                                let kind = array187[index186];
                                {
                                    let list = this.symmetryPerspective.createToolFactories(kind, tools);
                                    this.toolFactoryLists.put(kind, list);
                                    let toolList = this.symmetryPerspective.predefineTools(kind, tools);
                                    this.toolLists.put(kind, toolList);
                                }
                            }
                        }
                    }
                    getName() {
                        return this.symmetry.getName();
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector
                     * @return {com.vzome.core.math.symmetry.Axis}
                     */
                    getAxis(vector) {
                        if (vector.isOrigin()) {
                            return null;
                        }
                        let line = this.vectorToAxis.get(vector.toString());
                        if (line != null)
                            return line;
                        if (!this.noKnownDirections) {
                            line = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet'](vector, this.orbits);
                            if (line != null) {
                                this.vectorToAxis.put(vector.toString(), line);
                                return line;
                            }
                        }
                        let dir = this.createAnonymousOrbit(vector);
                        line = dir.getAxis$com_vzome_core_algebra_AlgebraicVector(vector);
                        this.vectorToAxis.put(vector.toString(), line);
                        return line;
                    }
                    createAnonymousOrbit(vector) {
                        let symm = this.orbits.getSymmetry();
                        let field = symm.getField();
                        let longer = field['createPower$int'](1);
                        let shorter = field['createPower$int'](-1);
                        let rv = vector.toRealVector();
                        let longVector = vector;
                        let shortVector = vector;
                        let longLen = 2.0;
                        let shortLen = 2.0;
                        let len = rv.length();
                        if (len > 2.0) {
                            longLen = len;
                            longVector = vector;
                            while ((longLen > 2.0)) {
                                {
                                    shortVector = longVector.scale(shorter);
                                    shortLen = shortVector.toRealVector().length();
                                    if (shortLen <= 2.0)
                                        break;
                                    longLen = shortLen;
                                    longVector = shortVector;
                                }
                            }
                            ;
                        }
                        else {
                            shortLen = len;
                            shortVector = vector;
                            while ((shortLen <= 2.0)) {
                                {
                                    longVector = shortVector.scale(longer);
                                    longLen = longVector.toRealVector().length();
                                    if (longLen > 2.0)
                                        break;
                                    shortLen = longLen;
                                    shortVector = longVector;
                                }
                            }
                            ;
                        }
                        if ((2.0 / shortLen) > longLen)
                            vector = longVector;
                        else
                            vector = shortVector;
                        let colorName = "" + SymmetrySystem.NEXT_NEW_AXIS++;
                        let orbit = symm.createNewZoneOrbit(colorName, 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, vector);
                        orbit.setAutomatic(true);
                        this.orbits.add(orbit);
                        this.orbitColors.put(orbit.getName(), com.vzome.core.construction.Color.WHITE_$LI$());
                        return orbit;
                    }
                    getVectorColor(vector) {
                        if (vector.isOrigin()) {
                            return com.vzome.core.construction.Color.WHITE_$LI$();
                        }
                        let line = this.vectorToAxis.get(vector.toString());
                        if (line == null) {
                            line = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_math_symmetry_OrbitSet'](vector, this.orbits);
                        }
                        return (line == null) ? com.vzome.core.construction.Color.WHITE_$LI$() : this.getColor(line.getDirection());
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} orbit
                     * @return {com.vzome.core.construction.Color}
                     */
                    getColor(orbit) {
                        if (orbit == null)
                            return com.vzome.core.construction.Color.WHITE_$LI$();
                        let shapeColor = this.shapes.getColor(orbit);
                        if (shapeColor == null)
                            shapeColor = this.orbitColors.get(orbit.getName());
                        if (shapeColor == null)
                            return com.vzome.core.construction.Color.WHITE_$LI$();
                        return shapeColor;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetry() {
                        return this.symmetry;
                    }
                    /**
                     *
                     * @return {com.vzome.core.math.symmetry.OrbitSet}
                     */
                    getOrbits() {
                        return this.orbits;
                    }
                    disableKnownDirection() {
                        this.noKnownDirections = true;
                    }
                    getRenderingStyle() {
                        return this.shapes;
                    }
                    getXml(doc) {
                        let result = doc.createElement("SymmetrySystem");
                        com.vzome.xml.DomUtils.addAttribute(result, "name", this.getSymmetry().getName());
                        com.vzome.xml.DomUtils.addAttribute(result, "renderingStyle", this.shapes.getName());
                        for (let index188 = this.orbits.iterator(); index188.hasNext();) {
                            let dir = index188.next();
                            {
                                let dirElem = doc.createElement("Direction");
                                if (dir.isAutomatic())
                                    com.vzome.xml.DomUtils.addAttribute(dirElem, "prototype", dir.getPrototype().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                                com.vzome.xml.DomUtils.addAttribute(dirElem, "name", dir.getName());
                                {
                                    let color = this.getColor(dir);
                                    if (color != null)
                                        com.vzome.xml.DomUtils.addAttribute(dirElem, "color", color.toString());
                                }
                                ;
                                result.appendChild(dirElem);
                            }
                        }
                        return result;
                    }
                    getStyle$java_lang_String(styleName) {
                        let found = this.symmetryPerspective.getGeometries().stream().filter((e) => /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(styleName, e.getName()) || /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(styleName, e.getAlias()) || /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(styleName, e.getPackage())).findFirst();
                        if (found.isPresent())
                            return found.get();
                        else
                            return null;
                    }
                    getStyle(styleName) {
                        if (((typeof styleName === 'string') || styleName === null)) {
                            return this.getStyle$java_lang_String(styleName);
                        }
                        else if (styleName === undefined) {
                            return this.getStyle$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    setStyle(styleName) {
                        let result = this.getStyle$java_lang_String(styleName);
                        if (result != null)
                            this.shapes = result;
                        else {
                            SymmetrySystem.logger_$LI$().warning("UNKNOWN STYLE NAME: " + styleName);
                            this.shapes = this.symmetryPerspective.getDefaultGeometry();
                        }
                    }
                    getStyleNames() {
                        return this.symmetryPerspective.getGeometries().stream().map((e) => e.getName()).toArray((arg0) => { return new Array(arg0); });
                    }
                    getStyle$() {
                        return this.shapes;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getShapes() {
                        return this.shapes;
                    }
                    getShape$com_vzome_core_algebra_AlgebraicVector(offset) {
                        return this.getShape$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_editor_api_Shapes(offset, this.shapes);
                    }
                    getShape$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_editor_api_Shapes(offset, shapes) {
                        if (offset == null)
                            return shapes.getConnectorShape();
                        else {
                            if (offset.isOrigin())
                                return null;
                            let axis = this.getAxis(offset);
                            if (axis == null)
                                return null;
                            let orbit = axis.getDirection();
                            let len = axis.getLength(offset);
                            return shapes.getStrutShape(orbit, len);
                        }
                    }
                    getShape(offset, shapes) {
                        if (((offset != null && offset instanceof com.vzome.core.algebra.AlgebraicVector) || offset === null) && ((shapes != null && (shapes["__interfaces"] != null && shapes["__interfaces"].indexOf("com.vzome.core.editor.api.Shapes") >= 0 || shapes.constructor != null && shapes.constructor["__interfaces"] != null && shapes.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.Shapes") >= 0)) || shapes === null)) {
                            return this.getShape$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_editor_api_Shapes(offset, shapes);
                        }
                        else if (((offset != null && offset instanceof com.vzome.core.algebra.AlgebraicVector) || offset === null) && shapes === undefined) {
                            return this.getShape$com_vzome_core_algebra_AlgebraicVector(offset);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getToolFactories(kind) {
                        return this.toolFactoryLists.get(kind);
                    }
                    getPredefinedTools(kind) {
                        return this.toolLists.get(kind);
                    }
                    doAction(action) {
                        let command = this.symmetryPerspective.getLegacyCommand(action);
                        if (command != null) {
                            let edit = new com.vzome.core.editor.CommandEdit(command, this.editor);
                            this.context.performAndRecord(edit);
                            return true;
                        }
                        return false;
                    }
                    getModelResourcePath() {
                        return this.symmetryPerspective.getModelResourcePath();
                    }
                    orbitIsStandard(orbit) {
                        return this.symmetryPerspective.orbitIsStandard(orbit);
                    }
                    orbitIsBuildDefault(orbit) {
                        return this.symmetryPerspective.orbitIsBuildDefault(orbit);
                    }
                    getOrbitUnitLength(orbit) {
                        return this.symmetryPerspective.getOrbitUnitLength(orbit);
                    }
                }
                SymmetrySystem.NEXT_NEW_AXIS = 0;
                editor_2.SymmetrySystem = SymmetrySystem;
                SymmetrySystem["__class"] = "com.vzome.core.editor.SymmetrySystem";
                SymmetrySystem["__interfaces"] = ["com.vzome.core.editor.api.OrbitSource"];
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Vector3dHomogeneous {
                    constructor(e1, e2, e3, e0, field) {
                        if (((e1 != null && (e1["__interfaces"] != null && e1["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || e1.constructor != null && e1.constructor["__interfaces"] != null && e1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e1 === null) && ((e2 != null && (e2["__interfaces"] != null && e2["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || e2.constructor != null && e2.constructor["__interfaces"] != null && e2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e2 === null) && ((e3 != null && (e3["__interfaces"] != null && e3["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || e3.constructor != null && e3.constructor["__interfaces"] != null && e3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e3 === null) && ((e0 != null && (e0["__interfaces"] != null && e0["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || e0.constructor != null && e0.constructor["__interfaces"] != null && e0.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e0 === null) && ((field != null && (field["__interfaces"] != null && field["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null)) {
                            let __args = arguments;
                            if (this.e1 === undefined)
                                this.e1 = null;
                            if (this.e2 === undefined)
                                this.e2 = null;
                            if (this.e3 === undefined)
                                this.e3 = null;
                            if (this.e0 === undefined)
                                this.e0 = null;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.e1 === undefined)
                                this.e1 = null;
                            if (this.e2 === undefined)
                                this.e2 = null;
                            if (this.e3 === undefined)
                                this.e3 = null;
                            if (this.e0 === undefined)
                                this.e0 = null;
                            if (this.field === undefined)
                                this.field = null;
                            (() => {
                                this.e1 = e1;
                                this.e2 = e2;
                                this.e3 = e3;
                                this.e0 = e0;
                                this.field = field;
                            })();
                        }
                        else if (((e1 != null && (e1["__interfaces"] != null && e1["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || e1.constructor != null && e1.constructor["__interfaces"] != null && e1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e1 === null) && ((e2 != null && (e2["__interfaces"] != null && e2["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || e2.constructor != null && e2.constructor["__interfaces"] != null && e2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e2 === null) && ((e3 != null && (e3["__interfaces"] != null && e3["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || e3.constructor != null && e3.constructor["__interfaces"] != null && e3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || e3 === null) && ((e0 != null && (e0["__interfaces"] != null && e0["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || e0.constructor != null && e0.constructor["__interfaces"] != null && e0.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || e0 === null) && field === undefined) {
                            let __args = arguments;
                            let field = __args[3];
                            {
                                let __args = arguments;
                                let e2 = __args[0];
                                let e3 = __args[0];
                                let e0 = __args[4]['createPower$int'](0);
                                if (this.e1 === undefined)
                                    this.e1 = null;
                                if (this.e2 === undefined)
                                    this.e2 = null;
                                if (this.e3 === undefined)
                                    this.e3 = null;
                                if (this.e0 === undefined)
                                    this.e0 = null;
                                if (this.field === undefined)
                                    this.field = null;
                                if (this.e1 === undefined)
                                    this.e1 = null;
                                if (this.e2 === undefined)
                                    this.e2 = null;
                                if (this.e3 === undefined)
                                    this.e3 = null;
                                if (this.e0 === undefined)
                                    this.e0 = null;
                                if (this.field === undefined)
                                    this.field = null;
                                (() => {
                                    this.e1 = e1;
                                    this.e2 = e2;
                                    this.e3 = e3;
                                    this.e0 = e0;
                                    this.field = field;
                                })();
                            }
                        }
                        else if (((e1 != null && e1 instanceof com.vzome.core.algebra.AlgebraicVector) || e1 === null) && ((e2 != null && (e2["__interfaces"] != null && e2["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || e2.constructor != null && e2.constructor["__interfaces"] != null && e2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || e2 === null) && e3 === undefined && e0 === undefined && field === undefined) {
                            let __args = arguments;
                            let v = __args[0];
                            let field = __args[1];
                            {
                                let __args = arguments;
                                let e1 = v.getComponent(0);
                                let e2 = v.getComponent(1);
                                let e3 = v.getComponent(2);
                                {
                                    let __args = arguments;
                                    let e2 = __args[0];
                                    let e3 = __args[0];
                                    let e0 = __args[4]['createPower$int'](0);
                                    if (this.e1 === undefined)
                                        this.e1 = null;
                                    if (this.e2 === undefined)
                                        this.e2 = null;
                                    if (this.e3 === undefined)
                                        this.e3 = null;
                                    if (this.e0 === undefined)
                                        this.e0 = null;
                                    if (this.field === undefined)
                                        this.field = null;
                                    if (this.e1 === undefined)
                                        this.e1 = null;
                                    if (this.e2 === undefined)
                                        this.e2 = null;
                                    if (this.e3 === undefined)
                                        this.e3 = null;
                                    if (this.e0 === undefined)
                                        this.e0 = null;
                                    if (this.field === undefined)
                                        this.field = null;
                                    (() => {
                                        this.e1 = e1;
                                        this.e2 = e2;
                                        this.e3 = e3;
                                        this.e0 = e0;
                                        this.field = field;
                                    })();
                                }
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    outer(that) {
                        let e12 = this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1));
                        let e23 = this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2));
                        let e31 = this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3));
                        let e10 = this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1));
                        let e20 = this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2));
                        let e30 = this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3));
                        return new com.vzome.core.algebra.Bivector3dHomogeneous(e12, e23, e31, e10, e20, e30, this.field);
                    }
                    getVector() {
                        return new com.vzome.core.algebra.AlgebraicVector(this.e1['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](this.e0), this.e2['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](this.e0), this.e3['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](this.e0));
                    }
                    dot(v) {
                        let e1 = this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](v.e31)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](v.e12))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](v.e10));
                        let e2 = this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](v.e12)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](v.e23))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](v.e20));
                        let e3 = this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](v.e23)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](v.e31))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e0['times$com_vzome_core_algebra_AlgebraicNumber'](v.e30));
                        let e0 = this.e1['times$com_vzome_core_algebra_AlgebraicNumber'](v.e10)['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e2['times$com_vzome_core_algebra_AlgebraicNumber'](v.e20))['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e3['times$com_vzome_core_algebra_AlgebraicNumber'](v.e30));
                        return new Vector3dHomogeneous(e1, e2, e3, e0, this.field);
                    }
                    exists() {
                        return !this.e0.isZero();
                    }
                }
                algebra.Vector3dHomogeneous = Vector3dHomogeneous;
                Vector3dHomogeneous["__class"] = "com.vzome.core.algebra.Vector3dHomogeneous";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Bivector3dHomogeneous {
                    constructor(e12, e23, e31, e10, e20, e30, field) {
                        if (this.e12 === undefined)
                            this.e12 = null;
                        if (this.e23 === undefined)
                            this.e23 = null;
                        if (this.e31 === undefined)
                            this.e31 = null;
                        if (this.e10 === undefined)
                            this.e10 = null;
                        if (this.e20 === undefined)
                            this.e20 = null;
                        if (this.e30 === undefined)
                            this.e30 = null;
                        if (this.field === undefined)
                            this.field = null;
                        this.e12 = e12;
                        this.e23 = e23;
                        this.e31 = e31;
                        this.e10 = e10;
                        this.e20 = e20;
                        this.e30 = e30;
                        this.field = field;
                    }
                    outer(that) {
                        let e123 = this.e12['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3)['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e23['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1))['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e31['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2));
                        let e310 = this.e10['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3)['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e31['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e30['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1));
                        let e320 = this.e20['times$com_vzome_core_algebra_AlgebraicNumber'](that.e3)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e30['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e23['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0));
                        let e120 = this.e12['times$com_vzome_core_algebra_AlgebraicNumber'](that.e0)['plus$com_vzome_core_algebra_AlgebraicNumber'](this.e20['times$com_vzome_core_algebra_AlgebraicNumber'](that.e1))['minus$com_vzome_core_algebra_AlgebraicNumber'](this.e10['times$com_vzome_core_algebra_AlgebraicNumber'](that.e2));
                        return new com.vzome.core.algebra.Trivector3dHomogeneous(e123, e310, e320, e120, this.field);
                    }
                }
                algebra.Bivector3dHomogeneous = Bivector3dHomogeneous;
                Bivector3dHomogeneous["__class"] = "com.vzome.core.algebra.Bivector3dHomogeneous";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class AlgebraicMatrix {
                    constructor(x, y, z, w) {
                        if (((x != null && x instanceof com.vzome.core.algebra.AlgebraicVector) || x === null) && ((y != null && y instanceof com.vzome.core.algebra.AlgebraicVector) || y === null) && ((z != null && z instanceof com.vzome.core.algebra.AlgebraicVector) || z === null) && ((w != null && w instanceof com.vzome.core.algebra.AlgebraicVector) || w === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let columns = [x, y, z, w];
                                if (this.matrix === undefined)
                                    this.matrix = null;
                                if (this.matrix === undefined)
                                    this.matrix = null;
                                (() => {
                                    let rows = columns[0].dimension();
                                    let cols = columns.length;
                                    this.matrix = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                                        return null;
                                    }
                                    else {
                                        let array = [];
                                        for (let i = 0; i < dims[0]; i++) {
                                            array.push(allocate(dims.slice(1)));
                                        }
                                        return array;
                                    } }; return allocate(dims); })([rows, cols]);
                                    for (let i = 0; i < rows; i++) {
                                        {
                                            for (let j = 0; j < cols; j++) {
                                                {
                                                    this.matrix[i][j] = columns[j].getComponent(i);
                                                }
                                                ;
                                            }
                                        }
                                        ;
                                    }
                                })();
                            }
                        }
                        else if (((x != null && x instanceof com.vzome.core.algebra.AlgebraicVector) || x === null) && ((y != null && y instanceof com.vzome.core.algebra.AlgebraicVector) || y === null) && ((z != null && z instanceof com.vzome.core.algebra.AlgebraicVector) || z === null) && w === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let columns = [x, y, z];
                                if (this.matrix === undefined)
                                    this.matrix = null;
                                if (this.matrix === undefined)
                                    this.matrix = null;
                                (() => {
                                    let rows = columns[0].dimension();
                                    let cols = columns.length;
                                    this.matrix = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                                        return null;
                                    }
                                    else {
                                        let array = [];
                                        for (let i = 0; i < dims[0]; i++) {
                                            array.push(allocate(dims.slice(1)));
                                        }
                                        return array;
                                    } }; return allocate(dims); })([rows, cols]);
                                    for (let i = 0; i < rows; i++) {
                                        {
                                            for (let j = 0; j < cols; j++) {
                                                {
                                                    this.matrix[i][j] = columns[j].getComponent(i);
                                                }
                                                ;
                                            }
                                        }
                                        ;
                                    }
                                })();
                            }
                        }
                        else if (((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null) && w === undefined) {
                            let __args = arguments;
                            let field = __args[0];
                            let rows = __args[1];
                            let cols = __args[2];
                            if (this.matrix === undefined)
                                this.matrix = null;
                            if (this.matrix === undefined)
                                this.matrix = null;
                            (() => {
                                this.matrix = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                                    return null;
                                }
                                else {
                                    let array = [];
                                    for (let i = 0; i < dims[0]; i++) {
                                        array.push(allocate(dims.slice(1)));
                                    }
                                    return array;
                                } }; return allocate(dims); })([rows, cols]);
                                for (let i = 0; i < rows; i++) {
                                    {
                                        for (let j = 0; j < cols; j++) {
                                            {
                                                this.matrix[i][j] = field.zero();
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            })();
                        }
                        else if (((x != null && x instanceof com.vzome.core.algebra.AlgebraicVector) || x === null) && ((y != null && y instanceof com.vzome.core.algebra.AlgebraicVector) || y === null) && z === undefined && w === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let columns = [x, y];
                                if (this.matrix === undefined)
                                    this.matrix = null;
                                if (this.matrix === undefined)
                                    this.matrix = null;
                                (() => {
                                    let rows = columns[0].dimension();
                                    let cols = columns.length;
                                    this.matrix = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                                        return null;
                                    }
                                    else {
                                        let array = [];
                                        for (let i = 0; i < dims[0]; i++) {
                                            array.push(allocate(dims.slice(1)));
                                        }
                                        return array;
                                    } }; return allocate(dims); })([rows, cols]);
                                    for (let i = 0; i < rows; i++) {
                                        {
                                            for (let j = 0; j < cols; j++) {
                                                {
                                                    this.matrix[i][j] = columns[j].getComponent(i);
                                                }
                                                ;
                                            }
                                        }
                                        ;
                                    }
                                })();
                            }
                        }
                        else if (((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || x === null) && ((typeof y === 'number') || y === null) && z === undefined && w === undefined) {
                            let __args = arguments;
                            let field = __args[0];
                            let dim = __args[1];
                            if (this.matrix === undefined)
                                this.matrix = null;
                            if (this.matrix === undefined)
                                this.matrix = null;
                            (() => {
                                this.matrix = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                                    return null;
                                }
                                else {
                                    let array = [];
                                    for (let i = 0; i < dims[0]; i++) {
                                        array.push(allocate(dims.slice(1)));
                                    }
                                    return array;
                                } }; return allocate(dims); })([dim, dim]);
                                for (let i = 0; i < dim; i++) {
                                    {
                                        for (let j = 0; j < dim; j++) {
                                            {
                                                if (i === j)
                                                    this.matrix[i][j] = field.one();
                                                else
                                                    this.matrix[i][j] = field.zero();
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            })();
                        }
                        else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (x[0] != null && x[0] instanceof com.vzome.core.algebra.AlgebraicVector))) || x === null) && y === undefined && z === undefined && w === undefined) {
                            let __args = arguments;
                            let columns = __args[0];
                            if (this.matrix === undefined)
                                this.matrix = null;
                            if (this.matrix === undefined)
                                this.matrix = null;
                            (() => {
                                let rows = columns[0].dimension();
                                let cols = columns.length;
                                this.matrix = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                                    return null;
                                }
                                else {
                                    let array = [];
                                    for (let i = 0; i < dims[0]; i++) {
                                        array.push(allocate(dims.slice(1)));
                                    }
                                    return array;
                                } }; return allocate(dims); })([rows, cols]);
                                for (let i = 0; i < rows; i++) {
                                    {
                                        for (let j = 0; j < cols; j++) {
                                            {
                                                this.matrix[i][j] = columns[j].getComponent(i);
                                            }
                                            ;
                                        }
                                    }
                                    ;
                                }
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let prime = 31;
                        let result = 1;
                        for (let index189 = 0; index189 < this.matrix.length; index189++) {
                            let m = this.matrix[index189];
                            {
                                result = prime * result + java.util.Arrays.hashCode(m);
                            }
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj)
                            return true;
                        if (obj == null)
                            return false;
                        if (this.constructor !== obj.constructor)
                            return false;
                        let other = obj;
                        return java.util.Arrays.deepEquals(this.matrix, other.matrix);
                    }
                    getMatrix() {
                        return this.matrix;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        let buf = new java.lang.StringBuilder();
                        for (let index190 = 0; index190 < this.matrix.length; index190++) {
                            let m = this.matrix[index190];
                            {
                                buf.append(java.util.Arrays.toString(m));
                                buf.append(", ");
                            }
                        }
                        return "[ " + buf.toString() + " ]";
                    }
                    negate() {
                        let field = this.matrix[0][0].getField();
                        let result = new AlgebraicMatrix(field, this.matrix.length);
                        for (let i = 0; i < this.matrix.length; i++) {
                            {
                                for (let j = 0; j < this.matrix[i].length; j++) {
                                    {
                                        result.matrix[i][j] = this.matrix[i][j].negate();
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return result;
                    }
                    inverse() {
                        if (!this.isSquare()) {
                            throw new java.lang.IllegalArgumentException("matrix is not square");
                        }
                        let field = this.matrix[0][0].getField();
                        let result = new AlgebraicMatrix(field, this.matrix.length);
                        let rank = com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(this.matrix, result.matrix);
                        if (rank !== this.matrix.length) {
                            let message = "AlgebraicMatrix inverse expects matrix rank to be " + this.matrix.length + ", but it is " + rank + ".";
                            console.error(message);
                        }
                        return result;
                    }
                    transpose() {
                        let field = this.matrix[0][0].getField();
                        let result = new AlgebraicMatrix(field, this.matrix[0].length, this.matrix.length);
                        for (let i = 0; i < result.matrix.length; i++) {
                            {
                                for (let j = 0; j < this.matrix.length; j++) {
                                    {
                                        result.matrix[i][j] = this.matrix[j][i];
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return result;
                    }
                    times(that) {
                        let field = this.matrix[0][0].getField();
                        let result = new AlgebraicMatrix(field, this.matrix.length, that.matrix[0].length);
                        com.vzome.core.algebra.Fields.matrixMultiplication(this.matrix, that.matrix, result.matrix);
                        return result;
                    }
                    timesRow(rowVector) {
                        let colLength = rowVector.dimension();
                        if (this.matrix.length !== colLength)
                            throw new java.lang.IllegalArgumentException("vector length incorrect for this matrix: " + rowVector);
                        let rowLength = this.matrix[0].length;
                        let resultComponents = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(rowLength);
                        let field = this.matrix[0][0].getField();
                        for (let j = 0; j < rowLength; j++) {
                            {
                                resultComponents[j] = field.zero();
                                for (let i = 0; i < colLength; i++) {
                                    {
                                        let product = rowVector.getComponent(i)['times$com_vzome_core_algebra_AlgebraicNumber'](this.matrix[i][j]);
                                        resultComponents[j] = resultComponents[j]['plus$com_vzome_core_algebra_AlgebraicNumber'](product);
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return new com.vzome.core.algebra.AlgebraicVector(resultComponents);
                    }
                    timesColumn(columnVector) {
                        let rowLength = columnVector.dimension();
                        if (this.matrix[0].length !== rowLength)
                            throw new java.lang.IllegalArgumentException("vector length incorrect for this matrix: " + columnVector);
                        let colLength = this.matrix.length;
                        let resultComponents = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(colLength);
                        let field = this.matrix[0][0].getField();
                        for (let i = 0; i < colLength; i++) {
                            {
                                resultComponents[i] = field.zero();
                                for (let j = 0; j < rowLength; j++) {
                                    {
                                        let product = columnVector.getComponent(j)['times$com_vzome_core_algebra_AlgebraicNumber'](this.matrix[i][j]);
                                        resultComponents[i] = resultComponents[i]['plus$com_vzome_core_algebra_AlgebraicNumber'](product);
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return new com.vzome.core.algebra.AlgebraicVector(resultComponents);
                    }
                    timesScalar(scalar) {
                        let result = new AlgebraicMatrix(scalar.getField(), this.matrix.length);
                        for (let i = 0; i < this.matrix.length; i++) {
                            {
                                for (let j = 0; j < this.matrix[i].length; j++) {
                                    {
                                        result.matrix[i][j] = this.matrix[i][j]['times$com_vzome_core_algebra_AlgebraicNumber'](scalar);
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        return result;
                    }
                    isSquare() {
                        return this.matrix.length === this.matrix[0].length;
                    }
                    trace() {
                        if (!this.isSquare()) {
                            throw new java.lang.IllegalArgumentException("matrix is not square");
                        }
                        let trace = this.matrix[0][0].getField().zero();
                        for (let i = 0; i < this.matrix.length; i++) {
                            {
                                trace = trace['plus$com_vzome_core_algebra_AlgebraicNumber'](this.matrix[i][i]);
                            }
                            ;
                        }
                        return trace;
                    }
                    determinant() {
                        return AlgebraicMatrix.laplaceDeterminant(this.matrix);
                    }
                    static laplaceDeterminant(matrix) {
                        if (matrix.length !== matrix[0].length) {
                            throw new java.lang.IllegalArgumentException("matrix is not square");
                        }
                        let determinant = null;
                        switch ((matrix.length)) {
                            case 3:
                                determinant = (matrix[0][0]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][1])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][2]))['plus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][1]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][2])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][0]))['plus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][2]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][0])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][1]))['minus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][2]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][1])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][0]))['minus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][0]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][2])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][1]))['minus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][1]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][0])['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[2][2]));
                                break;
                            case 2:
                                determinant = (matrix[0][0]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][1]))['minus$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][1]['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[1][0]));
                                break;
                            case 1:
                                determinant = matrix[0][0];
                                break;
                            default:
                                determinant = matrix[0][0].getField().zero();
                                let auxLength = matrix.length - 1;
                                let sign = matrix[0][0].getField().one();
                                for (let i = 0; i < matrix.length; i++) {
                                    {
                                        if (!matrix[0][i].isZero()) {
                                            let aux = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                                                return null;
                                            }
                                            else {
                                                let array = [];
                                                for (let i = 0; i < dims[0]; i++) {
                                                    array.push(allocate(dims.slice(1)));
                                                }
                                                return array;
                                            } }; return allocate(dims); })([auxLength, auxLength]);
                                            let iAux = 0;
                                            let jAux = 0;
                                            for (let row = 1; row < matrix.length; row++) {
                                                {
                                                    for (let col = 0; col < matrix.length; col++) {
                                                        {
                                                            if (col !== i) {
                                                                aux[iAux][jAux] = matrix[row][col];
                                                                jAux++;
                                                            }
                                                        }
                                                        ;
                                                    }
                                                    iAux++;
                                                    jAux = 0;
                                                }
                                                ;
                                            }
                                            determinant = determinant['plus$com_vzome_core_algebra_AlgebraicNumber'](sign['times$com_vzome_core_algebra_AlgebraicNumber'](matrix[0][i])['times$com_vzome_core_algebra_AlgebraicNumber'](AlgebraicMatrix.laplaceDeterminant(aux)));
                                        }
                                        sign = sign.negate();
                                    }
                                    ;
                                }
                        }
                        return determinant;
                    }
                    setElement(i, j, value) {
                        this.matrix[i][j] = value;
                        return this;
                    }
                    getElement(i, j) {
                        return this.matrix[i][j];
                    }
                }
                algebra.AlgebraicMatrix = AlgebraicMatrix;
                AlgebraicMatrix["__class"] = "com.vzome.core.algebra.AlgebraicMatrix";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                /**
                 * A collection of static helper methods for the AlgebraicVector class
                 * @class
                 */
                class AlgebraicVectors {
                    constructor() {
                    }
                    static getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v1, v2) {
                        return v1.cross(v2);
                    }
                    static getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2) {
                        return AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v1.minus(v0), v2.minus(v0));
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v0
                     * @param {com.vzome.core.algebra.AlgebraicVector} v1
                     * @param {com.vzome.core.algebra.AlgebraicVector} v2
                     * @return {com.vzome.core.algebra.AlgebraicVector} normal to vectors v1 and v2,
                     * with both v1 and v2 positioned at v0
                     * using the righthand rule.
                     */
                    static getNormal(v0, v1, v2) {
                        if (((v0 != null && v0 instanceof com.vzome.core.algebra.AlgebraicVector) || v0 === null) && ((v1 != null && v1 instanceof com.vzome.core.algebra.AlgebraicVector) || v1 === null) && ((v2 != null && v2 instanceof com.vzome.core.algebra.AlgebraicVector) || v2 === null)) {
                            return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
                        }
                        else if (((v0 != null && v0 instanceof com.vzome.core.algebra.AlgebraicVector) || v0 === null) && ((v1 != null && v1 instanceof com.vzome.core.algebra.AlgebraicVector) || v1 === null) && v2 === undefined) {
                            return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1);
                        }
                        else if (((v0 != null && (v0["__interfaces"] != null && v0["__interfaces"].indexOf("java.util.Collection") >= 0 || v0.constructor != null && v0.constructor["__interfaces"] != null && v0.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || v0 === null) && v1 === undefined && v2 === undefined) {
                            return com.vzome.core.algebra.AlgebraicVectors.getNormal$java_util_Collection(v0);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v1
                     * @param {com.vzome.core.algebra.AlgebraicVector} v2
                     * @return {boolean} true if vectors v1 and v2 are parallel, otherwise false.
                     * Considered as position vectors, this is the same as testing if they are collinear with the origin.
                     */
                    static areParallel(v1, v2) {
                        return AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v1, v2).isOrigin();
                    }
                    static getNormal$java_util_Collection(vectors) {
                        if (vectors.size() < 3) {
                            throw new java.lang.IllegalArgumentException("Three vertices are required to calculate a normal. Found " + vectors.size());
                        }
                        let v0 = null;
                        let v1 = null;
                        let normal = null;
                        for (let index191 = vectors.iterator(); index191.hasNext();) {
                            let vector = index191.next();
                            {
                                if (v0 == null) {
                                    v0 = vector;
                                }
                                else if (v1 == null) {
                                    if (vector !== v0) {
                                        v1 = vector;
                                    }
                                }
                                else {
                                    normal = AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, vector);
                                    if (!normal.isOrigin()) {
                                        return normal;
                                    }
                                }
                            }
                        }
                        return normal;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector
                     * @return {number} index of the vector component having the greatest absolute value.
                     * If more than one component has the same absolute value,
                     * the greatest index will be returned.
                     */
                    static getMaxComponentIndex(vector) {
                        let maxIndex = 0;
                        let maxSq = vector.getField().zero();
                        for (let i = 0; i < vector.dimension(); i++) {
                            {
                                let n = vector.getComponent(i);
                                let sq = n['times$com_vzome_core_algebra_AlgebraicNumber'](n);
                                if (!sq.lessThan(maxSq)) {
                                    maxIndex = i;
                                    maxSq = sq;
                                }
                            }
                            ;
                        }
                        return maxIndex;
                    }
                    static areCoplanar(vectors) {
                        if (vectors.size() < 4) {
                            return true;
                        }
                        let normal = AlgebraicVectors.getNormal$java_util_Collection(vectors);
                        if (normal.isOrigin() || normal.dimension() < 3) {
                            return true;
                        }
                        return AlgebraicVectors.areOrthogonalTo(normal, vectors);
                    }
                    static areOrthogonalTo(normal, vectors) {
                        if (normal.isOrigin()) {
                            throw new java.lang.IllegalArgumentException("Normal vector cannot be the origin");
                        }
                        let v0 = null;
                        for (let index192 = vectors.iterator(); index192.hasNext();) {
                            let vector = index192.next();
                            {
                                if (v0 == null) {
                                    v0 = vector;
                                }
                                else if (!vector.minus(v0).dot(normal).isZero()) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    static areCollinear$java_util_Collection(vectors) {
                        return (vectors.size() < 3) ? true : AlgebraicVectors.getNormal$java_util_Collection(vectors).isOrigin();
                    }
                    static areCollinear$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2) {
                        return AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2).isOrigin();
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v0
                     * @param {com.vzome.core.algebra.AlgebraicVector} v1
                     * @param {com.vzome.core.algebra.AlgebraicVector} v2
                     * @return {boolean} true if position vectors v0, v1 and v2 are collinear, otherwise false.
                     */
                    static areCollinear(v0, v1, v2) {
                        if (((v0 != null && v0 instanceof com.vzome.core.algebra.AlgebraicVector) || v0 === null) && ((v1 != null && v1 instanceof com.vzome.core.algebra.AlgebraicVector) || v1 === null) && ((v2 != null && v2 instanceof com.vzome.core.algebra.AlgebraicVector) || v2 === null)) {
                            return com.vzome.core.algebra.AlgebraicVectors.areCollinear$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
                        }
                        else if (((v0 != null && (v0["__interfaces"] != null && v0["__interfaces"].indexOf("java.util.Collection") >= 0 || v0.constructor != null && v0.constructor["__interfaces"] != null && v0.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || v0 === null) && v1 === undefined && v2 === undefined) {
                            return com.vzome.core.algebra.AlgebraicVectors.areCollinear$java_util_Collection(v0);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static getLinePlaneIntersection(lineStart, lineDirection, planeCenter, planeNormal) {
                        let denom = planeNormal.dot(lineDirection);
                        if (denom.isZero())
                            return null;
                        let p1p3 = planeCenter.minus(lineStart);
                        let numerator = planeNormal.dot(p1p3);
                        let u = numerator['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](denom);
                        return lineStart.plus(lineDirection.scale(u));
                    }
                    static calculateCentroid(vectors) {
                        return AlgebraicVectors.getCentroid(vectors.toArray((s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(vectors.size())));
                    }
                    static getCentroid(vectors) {
                        let field = vectors[0].getField();
                        let sum = new com.vzome.core.algebra.AlgebraicVector(field, vectors[0].dimension());
                        for (let index193 = 0; index193 < vectors.length; index193++) {
                            let vector = vectors[index193];
                            {
                                sum = sum.plus(vector);
                            }
                        }
                        return sum.scale(field['createRational$long$long'](1, vectors.length));
                    }
                    static getMagnitudeSquared(v) {
                        return v.dot(v);
                    }
                    /**
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector
                     * @return {com.vzome.core.algebra.AlgebraicVector} the greater of {@code vector} and its inverse.
                     * The comparison is based on a canonical (not mathematical) comparison as implemented in {@code AlgebraicVector.compareTo()}.
                     * There is no reasonable mathematical sense of ordering vectors,
                     * but this provides a way to map a vector and its inverse to a common vector for such purposes as sorting and color mapping.
                     */
                    static getCanonicalOrientation(vector) {
                        let negate = vector.negate();
                        return vector.compareTo(negate) > 0 ? vector : negate;
                    }
                    /**
                     * getMostDistantFromOrigin() is is used by a few ColorMapper classes, but I think it can eventually be useful elsewhere as well, for example, a zoom-to-fit command or in deriving a convex hull. I've made it a static method of the AlgebraicVector class to encourage such reuse.
                     *
                     * @param {*} vectors A collection of vectors to be evaluated.
                     * @return {java.util.TreeSet} A canonically sorted subset (maybe all) of the {@code vectors} collection. All of the returned vectors will be the same distance from the origin. That distance will be the maximum distance from the origin of any of the vectors in the original collection. If the original collection contains only the origin then so will the result.
                     */
                    static getMostDistantFromOrigin(vectors) {
                        let mostDistant = (new java.util.TreeSet());
                        let maxDistanceSquared = 0.0;
                        for (let index194 = vectors.iterator(); index194.hasNext();) {
                            let vector = index194.next();
                            {
                                let magnitudeSquared = AlgebraicVectors.getMagnitudeSquared(vector).evaluate();
                                if (magnitudeSquared >= maxDistanceSquared) {
                                    if (magnitudeSquared > maxDistanceSquared) {
                                        mostDistant.clear();
                                    }
                                    maxDistanceSquared = magnitudeSquared;
                                    mostDistant.add(vector);
                                }
                            }
                        }
                        return mostDistant;
                    }
                }
                algebra.AlgebraicVectors = AlgebraicVectors;
                AlgebraicVectors["__class"] = "com.vzome.core.algebra.AlgebraicVectors";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                /**
                 * @author vorth
                 * @param {*} n1
                 * @param {*} n2
                 * @param {*} n3
                 * @param {*} n4
                 * @param {*} n5
                 * @class
                 */
                class AlgebraicVector {
                    constructor(n1, n2, n3, n4, n5) {
                        if (((n1 != null && (n1["__interfaces"] != null && n1["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && ((n2 != null && (n2["__interfaces"] != null && n2["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n2.constructor != null && n2.constructor["__interfaces"] != null && n2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n2 === null) && ((n3 != null && (n3["__interfaces"] != null && n3["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n3.constructor != null && n3.constructor["__interfaces"] != null && n3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n3 === null) && ((n4 != null && (n4["__interfaces"] != null && n4["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n4.constructor != null && n4.constructor["__interfaces"] != null && n4.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n4 === null) && ((n5 != null && (n5["__interfaces"] != null && n5["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n5.constructor != null && n5.constructor["__interfaces"] != null && n5.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n5 === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let field = n1.getField();
                                let dims = 5;
                                if (this.coordinates === undefined)
                                    this.coordinates = null;
                                if (this.field === undefined)
                                    this.field = null;
                                if (this.coordinates === undefined)
                                    this.coordinates = null;
                                if (this.field === undefined)
                                    this.field = null;
                                (() => {
                                    this.coordinates = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(dims);
                                    for (let i = 0; i < dims; i++) {
                                        {
                                            this.coordinates[i] = field.zero();
                                        }
                                        ;
                                    }
                                    this.field = field;
                                })();
                            }
                            (() => {
                                this.coordinates[0] = n1;
                                this.coordinates[1] = n2;
                                this.coordinates[2] = n3;
                                this.coordinates[3] = n4;
                                this.coordinates[4] = n5;
                            })();
                        }
                        else if (((n1 != null && (n1["__interfaces"] != null && n1["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && ((n2 != null && (n2["__interfaces"] != null && n2["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n2.constructor != null && n2.constructor["__interfaces"] != null && n2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n2 === null) && ((n3 != null && (n3["__interfaces"] != null && n3["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n3.constructor != null && n3.constructor["__interfaces"] != null && n3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n3 === null) && ((n4 != null && (n4["__interfaces"] != null && n4["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n4.constructor != null && n4.constructor["__interfaces"] != null && n4.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n4 === null) && n5 === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let field = n1.getField();
                                let dims = 4;
                                if (this.coordinates === undefined)
                                    this.coordinates = null;
                                if (this.field === undefined)
                                    this.field = null;
                                if (this.coordinates === undefined)
                                    this.coordinates = null;
                                if (this.field === undefined)
                                    this.field = null;
                                (() => {
                                    this.coordinates = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(dims);
                                    for (let i = 0; i < dims; i++) {
                                        {
                                            this.coordinates[i] = field.zero();
                                        }
                                        ;
                                    }
                                    this.field = field;
                                })();
                            }
                            (() => {
                                this.coordinates[0] = n1;
                                this.coordinates[1] = n2;
                                this.coordinates[2] = n3;
                                this.coordinates[3] = n4;
                            })();
                        }
                        else if (((n1 != null && (n1["__interfaces"] != null && n1["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && ((n2 != null && (n2["__interfaces"] != null && n2["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n2.constructor != null && n2.constructor["__interfaces"] != null && n2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n2 === null) && ((n3 != null && (n3["__interfaces"] != null && n3["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n3.constructor != null && n3.constructor["__interfaces"] != null && n3.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n3 === null) && n4 === undefined && n5 === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let field = n1.getField();
                                let dims = 3;
                                if (this.coordinates === undefined)
                                    this.coordinates = null;
                                if (this.field === undefined)
                                    this.field = null;
                                if (this.coordinates === undefined)
                                    this.coordinates = null;
                                if (this.field === undefined)
                                    this.field = null;
                                (() => {
                                    this.coordinates = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(dims);
                                    for (let i = 0; i < dims; i++) {
                                        {
                                            this.coordinates[i] = field.zero();
                                        }
                                        ;
                                    }
                                    this.field = field;
                                })();
                            }
                            (() => {
                                this.coordinates[0] = n1;
                                this.coordinates[1] = n2;
                                this.coordinates[2] = n3;
                            })();
                        }
                        else if (((n1 != null && (n1["__interfaces"] != null && n1["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && ((n2 != null && (n2["__interfaces"] != null && n2["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n2.constructor != null && n2.constructor["__interfaces"] != null && n2.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n2 === null) && n3 === undefined && n4 === undefined && n5 === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let field = n1.getField();
                                let dims = 2;
                                if (this.coordinates === undefined)
                                    this.coordinates = null;
                                if (this.field === undefined)
                                    this.field = null;
                                if (this.coordinates === undefined)
                                    this.coordinates = null;
                                if (this.field === undefined)
                                    this.field = null;
                                (() => {
                                    this.coordinates = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(dims);
                                    for (let i = 0; i < dims; i++) {
                                        {
                                            this.coordinates[i] = field.zero();
                                        }
                                        ;
                                    }
                                    this.field = field;
                                })();
                            }
                            (() => {
                                this.coordinates[0] = n1;
                                this.coordinates[1] = n2;
                            })();
                        }
                        else if (((n1 != null && (n1["__interfaces"] != null && n1["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || n1 === null) && ((typeof n2 === 'number') || n2 === null) && n3 === undefined && n4 === undefined && n5 === undefined) {
                            let __args = arguments;
                            let field = __args[0];
                            let dims = __args[1];
                            if (this.coordinates === undefined)
                                this.coordinates = null;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.coordinates === undefined)
                                this.coordinates = null;
                            if (this.field === undefined)
                                this.field = null;
                            (() => {
                                this.coordinates = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(dims);
                                for (let i = 0; i < dims; i++) {
                                    {
                                        this.coordinates[i] = field.zero();
                                    }
                                    ;
                                }
                                this.field = field;
                            })();
                        }
                        else if (((n1 != null && n1 instanceof Array && (n1.length == 0 || n1[0] == null || (n1[0] != null && (n1[0]["__interfaces"] != null && n1[0]["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n1[0].constructor != null && n1[0].constructor["__interfaces"] != null && n1[0].constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)))) || n1 === null) && n2 === undefined && n3 === undefined && n4 === undefined && n5 === undefined) {
                            let __args = arguments;
                            let n = __args[0];
                            if (this.coordinates === undefined)
                                this.coordinates = null;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.coordinates === undefined)
                                this.coordinates = null;
                            if (this.field === undefined)
                                this.field = null;
                            (() => {
                                this.coordinates = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(n.length);
                                java.lang.System.arraycopy(n, 0, this.coordinates, 0, n.length);
                                this.field = n[0].getField();
                            })();
                        }
                        else if (((n1 != null && (n1["__interfaces"] != null && n1["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || n1.constructor != null && n1.constructor["__interfaces"] != null && n1.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || n1 === null) && n2 === undefined && n3 === undefined && n4 === undefined && n5 === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let field = n1.getField();
                                let dims = 1;
                                if (this.coordinates === undefined)
                                    this.coordinates = null;
                                if (this.field === undefined)
                                    this.field = null;
                                if (this.coordinates === undefined)
                                    this.coordinates = null;
                                if (this.field === undefined)
                                    this.field = null;
                                (() => {
                                    this.coordinates = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(dims);
                                    for (let i = 0; i < dims; i++) {
                                        {
                                            this.coordinates[i] = field.zero();
                                        }
                                        ;
                                    }
                                    this.field = field;
                                })();
                            }
                            (() => {
                                this.coordinates[0] = n1;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let prime = 31;
                        let result = 1;
                        result = prime * result + java.util.Arrays.hashCode(this.coordinates);
                        return result;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj)
                            return true;
                        if (obj == null)
                            return false;
                        if (this.constructor !== obj.constructor)
                            return false;
                        let other = obj;
                        if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.field, other.field)) {
                            let reason = "Invalid comparison of " + /* getSimpleName */ (c => c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))(this.constructor) + "swith different fields: " + this.field.getName() + " and " + other.field.getName();
                            throw new java.lang.IllegalStateException(reason);
                        }
                        return java.util.Arrays.equals(this.coordinates, other.coordinates);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} other
                     * @return {number}
                     */
                    compareTo(other) {
                        if (this === other) {
                            return 0;
                        }
                        if (other.equals(this)) {
                            return 0;
                        }
                        let comparison = (this.coordinates.length - other.coordinates.length);
                        if (comparison !== 0) {
                            return comparison;
                        }
                        for (let i = 0; i < this.coordinates.length; i++) {
                            {
                                let n1 = this.coordinates[i];
                                let n2 = other.coordinates[i];
                                comparison = n1.compareTo(n2);
                                if (comparison !== 0) {
                                    return comparison;
                                }
                            }
                            ;
                        }
                        return comparison;
                    }
                    toRealVector() {
                        return new com.vzome.core.math.RealVector(this.coordinates[0].evaluate(), this.coordinates[1].evaluate(), this.coordinates[2].evaluate());
                    }
                    /**
                     * @return {string} A String with no extended characters so it's suitable for writing
                     * to an 8 bit stream such as System.out or an ASCII text log file in Windows.
                     * Contrast this with {@link toString()} which contains extended characters (e.g.  (phi))
                     */
                    toASCIIString() {
                        return this.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT);
                    }
                    /**
                     * @return {string} A String representation that can be persisted to XML and parsed by XmlSaveFormat.parseRationalVector().
                     */
                    toParsableString() {
                        return this.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT);
                    }
                    toString(format = com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT) {
                        return this.getVectorExpression$int(format);
                    }
                    getComponent(i) {
                        return this.coordinates[i];
                    }
                    getComponents() {
                        return this.coordinates;
                    }
                    setComponent(component, coord) {
                        this.coordinates[component] = coord;
                        return this;
                    }
                    negate() {
                        let result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.coordinates.length);
                        for (let i = 0; i < result.length; i++) {
                            {
                                result[i] = this.coordinates[i].negate();
                            }
                            ;
                        }
                        return new AlgebraicVector(result);
                    }
                    scale(scale) {
                        let result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.coordinates.length);
                        for (let i = 0; i < result.length; i++) {
                            {
                                result[i] = this.coordinates[i]['times$com_vzome_core_algebra_AlgebraicNumber'](scale);
                            }
                            ;
                        }
                        return new AlgebraicVector(result);
                    }
                    isOrigin() {
                        for (let index195 = 0; index195 < this.coordinates.length; index195++) {
                            let coordinate = this.coordinates[index195];
                            {
                                if (!coordinate.isZero()) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    plus(that) {
                        let result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.coordinates.length);
                        for (let i = 0; i < result.length; i++) {
                            {
                                result[i] = this.coordinates[i]['plus$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[i]);
                            }
                            ;
                        }
                        return new AlgebraicVector(result);
                    }
                    minus(that) {
                        let result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.coordinates.length);
                        for (let i = 0; i < result.length; i++) {
                            {
                                result[i] = this.coordinates[i]['minus$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[i]);
                            }
                            ;
                        }
                        return new AlgebraicVector(result);
                    }
                    dimension() {
                        return this.coordinates.length;
                    }
                    cross(that) {
                        let result = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.coordinates.length);
                        for (let i = 0; i < result.length; i++) {
                            {
                                let j = (i + 1) % 3;
                                let k = (i + 2) % 3;
                                result[i] = this.coordinates[j]['times$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[k])['minus$com_vzome_core_algebra_AlgebraicNumber'](this.coordinates[k]['times$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[j]));
                            }
                            ;
                        }
                        return new AlgebraicVector(result);
                    }
                    inflateTo4d$() {
                        return this.inflateTo4d$boolean(true);
                    }
                    inflateTo4d$boolean(wFirst) {
                        if (this.coordinates.length === 4) {
                            if (wFirst)
                                return this;
                            else
                                return new AlgebraicVector([this.coordinates[1], this.coordinates[2], this.coordinates[3], this.coordinates[0]]);
                        }
                        if (wFirst)
                            return new AlgebraicVector([this.field.zero(), this.coordinates[0], this.coordinates[1], this.coordinates[2]]);
                        else
                            return new AlgebraicVector([this.coordinates[0], this.coordinates[1], this.coordinates[2], this.field.zero()]);
                    }
                    inflateTo4d(wFirst) {
                        if (((typeof wFirst === 'boolean') || wFirst === null)) {
                            return this.inflateTo4d$boolean(wFirst);
                        }
                        else if (wFirst === undefined) {
                            return this.inflateTo4d$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    projectTo3d(wFirst) {
                        if (this.dimension() === 3)
                            return this;
                        if (wFirst)
                            return new AlgebraicVector([this.coordinates[1], this.coordinates[2], this.coordinates[3]]);
                        else
                            return new AlgebraicVector([this.coordinates[0], this.coordinates[1], this.coordinates[2]]);
                    }
                    getVectorExpression$java_lang_StringBuffer$int(buf, format) {
                        if (format === com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT)
                            buf.append("(");
                        for (let i = 0; i < this.coordinates.length; i++) {
                            {
                                if (i > 0)
                                    if (format === com.vzome.core.algebra.AlgebraicField.VEF_FORMAT || format === com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT)
                                        buf.append(" ");
                                    else
                                        buf.append(", ");
                                this.coordinates[i].getNumberExpression(buf, format);
                            }
                            ;
                        }
                        if (format === com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT)
                            buf.append(")");
                    }
                    /**
                     *
                     * @param {java.lang.StringBuffer} buf a StringBuffer to which the formatted vector will be appended.
                     * @param {number} format may be any of the following:
                     * {@code AlgebraicField.DEFAULT_FORMAT = 0; // 4 + 3}
                     * {@code AlgebraicField.EXPRESSION_FORMAT = 1; // 4 +3*phi}
                     * {@code AlgebraicField.ZOMIC_FORMAT = 2; // 4 3}
                     * {@code AlgebraicField.VEF_FORMAT = 3; // (3,4)}
                     */
                    getVectorExpression(buf, format) {
                        if (((buf != null && buf instanceof java.lang.StringBuffer) || buf === null) && ((typeof format === 'number') || format === null)) {
                            return this.getVectorExpression$java_lang_StringBuffer$int(buf, format);
                        }
                        else if (((typeof buf === 'number') || buf === null) && format === undefined) {
                            return this.getVectorExpression$int(buf);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    getVectorExpression$int(format) {
                        let buf = new java.lang.StringBuffer();
                        this.getVectorExpression$java_lang_StringBuffer$int(buf, format);
                        return buf.toString();
                    }
                    dot(that) {
                        let result = this.field.zero();
                        for (let i = 0; i < that.dimension(); i++) {
                            {
                                result = result['plus$com_vzome_core_algebra_AlgebraicNumber'](this.coordinates[i]['times$com_vzome_core_algebra_AlgebraicNumber'](that.coordinates[i]));
                            }
                            ;
                        }
                        return result;
                    }
                    getLength(unit) {
                        for (let i = 0; i < this.coordinates.length; i++) {
                            {
                                if (this.coordinates[i].isZero())
                                    continue;
                                return this.coordinates[i]['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](unit.coordinates[i]);
                            }
                            ;
                        }
                        throw new java.lang.IllegalStateException("vector is the origin!");
                    }
                    getField() {
                        return this.field;
                    }
                }
                AlgebraicVector.X = 0;
                AlgebraicVector.Y = 1;
                AlgebraicVector.Z = 2;
                AlgebraicVector.W4 = 0;
                AlgebraicVector.X4 = 1;
                AlgebraicVector.Y4 = 2;
                AlgebraicVector.Z4 = 3;
                algebra.AlgebraicVector = AlgebraicVector;
                AlgebraicVector["__class"] = "com.vzome.core.algebra.AlgebraicVector";
                AlgebraicVector["__interfaces"] = ["java.lang.Comparable"];
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class VefVectorExporter {
                    constructor(writer, field, scale, withOffset) {
                        if (((writer != null && writer instanceof java.io.Writer) || writer === null) && ((field != null && (field["__interfaces"] != null && field["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((scale != null && (scale["__interfaces"] != null && scale["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || scale.constructor != null && scale.constructor["__interfaces"] != null && scale.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || scale === null) && ((typeof withOffset === 'boolean') || withOffset === null)) {
                            let __args = arguments;
                            if (this.output === undefined)
                                this.output = null;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.strutEnds === undefined)
                                this.strutEnds = null;
                            if (this.panelVertices === undefined)
                                this.panelVertices = null;
                            if (this.scale === undefined)
                                this.scale = null;
                            if (this.includeOffset === undefined)
                                this.includeOffset = false;
                            this.sortedVertexList = null;
                            this.vertices = (new java.util.TreeSet());
                            this.ballLocations = (new java.util.TreeSet());
                            this.exportedOffset = null;
                            this.strTip = "tip";
                            this.strMiddle = "middle";
                            if (this.output === undefined)
                                this.output = null;
                            if (this.field === undefined)
                                this.field = null;
                            this.sortedVertexList = null;
                            this.vertices = (new java.util.TreeSet());
                            this.ballLocations = (new java.util.TreeSet());
                            if (this.strutEnds === undefined)
                                this.strutEnds = null;
                            if (this.panelVertices === undefined)
                                this.panelVertices = null;
                            if (this.scale === undefined)
                                this.scale = null;
                            if (this.includeOffset === undefined)
                                this.includeOffset = false;
                            this.exportedOffset = null;
                            this.strTip = "tip";
                            this.strMiddle = "middle";
                            (() => {
                                this.includeOffset = withOffset;
                                this.scale = scale;
                                this.output = new java.io.PrintWriter(writer);
                                this.field = field;
                                let arrayComparator = (new com.vzome.core.generic.ArrayComparator());
                                this.strutEnds = (new java.util.TreeSet((arrayComparator.getContentFirstArrayComparator())));
                                this.panelVertices = (new java.util.TreeSet((arrayComparator.getLengthFirstArrayComparator())));
                            })();
                        }
                        else if (((writer != null && writer instanceof java.io.Writer) || writer === null) && ((field != null && (field["__interfaces"] != null && field["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && scale === undefined && withOffset === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let scale = null;
                                let withOffset = false;
                                if (this.output === undefined)
                                    this.output = null;
                                if (this.field === undefined)
                                    this.field = null;
                                if (this.strutEnds === undefined)
                                    this.strutEnds = null;
                                if (this.panelVertices === undefined)
                                    this.panelVertices = null;
                                if (this.scale === undefined)
                                    this.scale = null;
                                if (this.includeOffset === undefined)
                                    this.includeOffset = false;
                                this.sortedVertexList = null;
                                this.vertices = (new java.util.TreeSet());
                                this.ballLocations = (new java.util.TreeSet());
                                this.exportedOffset = null;
                                this.strTip = "tip";
                                this.strMiddle = "middle";
                                if (this.output === undefined)
                                    this.output = null;
                                if (this.field === undefined)
                                    this.field = null;
                                this.sortedVertexList = null;
                                this.vertices = (new java.util.TreeSet());
                                this.ballLocations = (new java.util.TreeSet());
                                if (this.strutEnds === undefined)
                                    this.strutEnds = null;
                                if (this.panelVertices === undefined)
                                    this.panelVertices = null;
                                if (this.scale === undefined)
                                    this.scale = null;
                                if (this.includeOffset === undefined)
                                    this.includeOffset = false;
                                this.exportedOffset = null;
                                this.strTip = "tip";
                                this.strMiddle = "middle";
                                (() => {
                                    this.includeOffset = withOffset;
                                    this.scale = scale;
                                    this.output = new java.io.PrintWriter(writer);
                                    this.field = field;
                                    let arrayComparator = (new com.vzome.core.generic.ArrayComparator());
                                    this.strutEnds = (new java.util.TreeSet((arrayComparator.getContentFirstArrayComparator())));
                                    this.panelVertices = (new java.util.TreeSet((arrayComparator.getLengthFirstArrayComparator())));
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    exportPoint(pt) {
                        this.vertices.add(pt);
                        this.ballLocations.add(pt);
                        if (this.includeOffset) {
                            this.exportedOffset = pt;
                        }
                    }
                    exportSegment(start, end) {
                        let ends = [start, end];
                        this.vertices.add(ends[0]);
                        this.vertices.add(ends[1]);
                        this.strutEnds.add(ends);
                    }
                    exportPolygon(corners) {
                        this.vertices.addAll(corners);
                        let cornerArray = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(corners.size());
                        corners.toArray(cornerArray);
                        this.panelVertices.add(cornerArray);
                    }
                    /**
                     * @param {java.lang.StringBuffer} buffer = Don't assume that buffer starts out empty. Results will be appended.
                     * @param {com.vzome.core.algebra.AlgebraicVector} vector = Value to be converted to a zero-padded 4D String which will be
                     * prefixed and/or padded with field specific zeroes
                     * depending on the number of dimensions in vector as follows:
                     * 1D : 0 X 0 0
                     * 2D : 0 X Y 0
                     * 3D : 0 X Y Z
                     * 4D : W X Y Z
                     * @param {*} scale
                     */
                    static appendVector(buffer, vector, scale) {
                        let zeroString = vector.getField().zero().toString(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT);
                        let dims = vector.dimension();
                        if (dims < 4) {
                            buffer.append(zeroString);
                            buffer.append(" ");
                        }
                        if (scale != null)
                            vector = vector.scale(scale);
                        vector.getVectorExpression$java_lang_StringBuffer$int(buffer, com.vzome.core.algebra.AlgebraicField.VEF_FORMAT);
                        for (let d = dims + 1; d < 4; d++) {
                            {
                                buffer.append(" ");
                                buffer.append(zeroString);
                            }
                            ;
                        }
                    }
                    static exportPolyhedron(polyhedron) {
                        let out = new java.io.StringWriter();
                        let exporter = new VefVectorExporter(out, polyhedron.getField());
                        let vertexList = polyhedron.getVertexList();
                        for (let index196 = polyhedron.getFaceSet().iterator(); index196.hasNext();) {
                            let face = index196.next();
                            {
                                let vertices = (new java.util.ArrayList(face.size()));
                                for (let i = 0; i < face.size(); i++) {
                                    {
                                        let vertexIndex = face.getVertex(i);
                                        vertices.add(vertexList.get(vertexIndex));
                                    }
                                    ;
                                }
                                exporter.exportPolygon(vertices);
                            }
                        }
                        exporter.finishExport();
                        return out.toString();
                    }
                    finishExport() {
                        this.sortedVertexList = (new java.util.ArrayList(this.vertices));
                        this.vertices = null;
                        let version = (this.exportedOffset == null) ? com.vzome.core.math.VefParser.VERSION_EXPLICIT_BALLS : com.vzome.core.math.VefParser.VERSION_EXPLICIT_OFFSET;
                        this.output.println$java_lang_Object("vZome VEF " + version + " field " + this.field.getName());
                        if (this.exportedOffset != null) {
                            let buf = new java.lang.StringBuffer();
                            buf.append("\noffset ");
                            VefVectorExporter.appendVector(buf, this.exportedOffset.negate(), null);
                            buf.append("\n");
                            this.output.println$java_lang_Object(buf.toString());
                        }
                        this.output.println$java_lang_Object("\n" + this.sortedVertexList.size());
                        {
                            let buf = new java.lang.StringBuffer();
                            for (let index197 = this.sortedVertexList.iterator(); index197.hasNext();) {
                                let vector = index197.next();
                                {
                                    VefVectorExporter.appendVector(buf, vector, this.scale);
                                    buf.append("\n");
                                }
                            }
                            buf.append("\n");
                            this.output.println$java_lang_Object(buf.toString());
                        }
                        ;
                        this.output.println$java_lang_Object("\n" + this.strutEnds.size());
                        for (let index198 = this.strutEnds.iterator(); index198.hasNext();) {
                            let ends = index198.next();
                            {
                                this.output.print(this.sortedVertexList.indexOf(ends[0]) + " ");
                                this.output.println$java_lang_Object(this.sortedVertexList.indexOf(ends[1]));
                            }
                        }
                        this.output.println$java_lang_Object("\n");
                        this.output.println$java_lang_Object("\n" + this.panelVertices.size());
                        for (let index199 = this.panelVertices.iterator(); index199.hasNext();) {
                            let corners = index199.next();
                            {
                                this.output.print(corners.length + "  ");
                                for (let index200 = 0; index200 < corners.length; index200++) {
                                    let corner = corners[index200];
                                    {
                                        this.output.print(this.sortedVertexList.indexOf(corner) + " ");
                                    }
                                }
                                this.output.println$();
                            }
                        }
                        this.output.println$java_lang_Object("\n");
                        this.output.println$java_lang_Object("\n" + this.ballLocations.size());
                        let i = 0;
                        for (let index201 = this.ballLocations.iterator(); index201.hasNext();) {
                            let ball = index201.next();
                            {
                                this.output.print(this.sortedVertexList.indexOf(ball) + " ");
                                if (++i % 10 === 0) {
                                    this.output.println$();
                                }
                            }
                        }
                        this.output.println$java_lang_Object("\n");
                        this.output.flush();
                    }
                }
                algebra.VefVectorExporter = VefVectorExporter;
                VefVectorExporter["__class"] = "com.vzome.core.algebra.VefVectorExporter";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Fields {
                    static rows(matrix) {
                        return matrix.length;
                    }
                    static columns(matrix) {
                        return matrix[0].length;
                    }
                    static matrixMultiplication(left, right, product) {
                        if (Fields.rows(right) !== Fields.columns(left))
                            throw new java.lang.IllegalArgumentException("matrices cannot be multiplied");
                        if (Fields.rows(product) !== Fields.rows(left))
                            throw new java.lang.IllegalArgumentException("product matrix has wrong number of rows");
                        if (Fields.columns(right) !== Fields.columns(product))
                            throw new java.lang.IllegalArgumentException("product matrix has wrong number of columns");
                        for (let i = 0; i < Fields.rows(product); i++) {
                            {
                                for (let j = 0; j < Fields.columns(product); j++) {
                                    {
                                        let sum = null;
                                        for (let j2 = 0; j2 < Fields.columns(left); j2++) {
                                            {
                                                let prod = left[i][j2].times(right[j2][j]);
                                                if (sum == null)
                                                    sum = prod;
                                                else
                                                    sum = sum.plus(prod);
                                            }
                                            ;
                                        }
                                        product[i][j] = sum;
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                    }
                    static gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A(matrix) {
                        return Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(matrix, matrix);
                    }
                    static gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(immutableMatrix, adjoined) {
                        let nRows = Fields.rows(immutableMatrix);
                        let matrix = Fields.copyOf(immutableMatrix);
                        let rank = 0;
                        for (let col = 0; col < Fields.columns(matrix); col++) {
                            {
                                let pivotRow = -1;
                                for (let row = rank; row < nRows; row++) {
                                    {
                                        let element = matrix[row][col];
                                        if (!element.isZero()) {
                                            pivotRow = row;
                                            break;
                                        }
                                    }
                                    ;
                                }
                                if (pivotRow >= 0) {
                                    if (pivotRow !== rank) {
                                        Fields.swap(matrix, rank, pivotRow);
                                        Fields.swap(adjoined, rank, pivotRow);
                                        pivotRow = rank;
                                    }
                                    let scalar = matrix[pivotRow][col];
                                    if (!scalar.isOne()) {
                                        scalar = scalar.reciprocal();
                                        Fields.scale(matrix[pivotRow], scalar);
                                        Fields.scale(adjoined[pivotRow], scalar);
                                    }
                                    for (let row = 0; row < nRows; row++) {
                                        {
                                            if (row !== pivotRow) {
                                                scalar = matrix[row][col];
                                                if (!scalar.isZero()) {
                                                    scalar = scalar.negate();
                                                    Fields.pivot(matrix, row, scalar, pivotRow);
                                                    Fields.pivot(adjoined, row, scalar, pivotRow);
                                                }
                                            }
                                        }
                                        ;
                                    }
                                    rank++;
                                }
                            }
                            ;
                        }
                        return rank;
                    }
                    static gaussJordanReduction(immutableMatrix, adjoined) {
                        if (((immutableMatrix != null && immutableMatrix instanceof Array && (immutableMatrix.length == 0 || immutableMatrix[0] == null || immutableMatrix[0] instanceof Array)) || immutableMatrix === null) && ((adjoined != null && adjoined instanceof Array && (adjoined.length == 0 || adjoined[0] == null || adjoined[0] instanceof Array)) || adjoined === null)) {
                            return com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A$com_vzome_core_algebra_Fields_Element_A_A(immutableMatrix, adjoined);
                        }
                        else if (((immutableMatrix != null && immutableMatrix instanceof Array && (immutableMatrix.length == 0 || immutableMatrix[0] == null || immutableMatrix[0] instanceof Array)) || immutableMatrix === null) && adjoined === undefined) {
                            return com.vzome.core.algebra.Fields.gaussJordanReduction$com_vzome_core_algebra_Fields_Element_A_A(immutableMatrix);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static copyOf(matrix) {
                        let nRows = Fields.rows(matrix);
                        let nCols = Fields.columns(matrix);
                        let copy = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(nRows);
                        for (let i = 0; i < nRows; i++) {
                            {
                                copy[i] = java.util.Arrays.copyOf(matrix[i], nCols);
                            }
                            ;
                        }
                        return copy;
                    }
                    /**
                     *
                     * @param {Array} array of elements to be swapped
                     * @param {number} r index of the first element to be swapped
                     * @param {number} s index of the second element to be swapped
                     * <br/>
                     * Note that since Java implements a multi-dimensional array as an array of arrays,
                     * the {@code array} parameter can be an {@code Object[][]} in which case
                     * entire rows are swapped rather than an element at a time.
                     * Besides being more efficient at run time, this also means
                     * that rows of multi-dimensional arrays do not necessarily have to be the same length.
                     * @private
                     */
                    static swap(array, r, s) {
                        let temp = array[r];
                        array[r] = array[s];
                        array[s] = temp;
                    }
                    static scale(array, scalar) {
                        for (let col = 0; col < array.length; col++) {
                            {
                                array[col] = scalar.times(array[col]);
                            }
                            ;
                        }
                    }
                    static pivot(matrix, row, scalar, rank) {
                        for (let col = 0; col < Fields.columns(matrix); col++) {
                            {
                                matrix[row][col] = matrix[row][col].plus(matrix[rank][col].times(scalar));
                            }
                            ;
                        }
                    }
                }
                algebra.Fields = Fields;
                Fields["__class"] = "com.vzome.core.algebra.Fields";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                let AlgebraicField;
                (function (AlgebraicField) {
                    AlgebraicField.DEFAULT_FORMAT = 0;
                    AlgebraicField.EXPRESSION_FORMAT = 1;
                    AlgebraicField.ZOMIC_FORMAT = 2;
                    AlgebraicField.VEF_FORMAT = 3;
                })(AlgebraicField = algebra.AlgebraicField || (algebra.AlgebraicField = {}));
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Bivector3d {
                    constructor(a, b, c) {
                        if (this.a === undefined)
                            this.a = null;
                        if (this.b === undefined)
                            this.b = null;
                        if (this.c === undefined)
                            this.c = null;
                        this.a = a;
                        this.b = b;
                        this.c = c;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let prime = 31;
                        let result = 1;
                        result = prime * result + ((this.a == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.a));
                        result = prime * result + ((this.b == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.b));
                        result = prime * result + ((this.c == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.c));
                        return result;
                    }
                    /**
                     *
                     * @param {*} obj
                     * @return {boolean}
                     */
                    equals(obj) {
                        if (this === obj) {
                            return true;
                        }
                        if (obj == null) {
                            return false;
                        }
                        if (this.constructor !== obj.constructor) {
                            return false;
                        }
                        let other = obj;
                        if (this.a == null) {
                            if (other.a != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.a, other.a)) {
                            return false;
                        }
                        if (this.b == null) {
                            if (other.b != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.b, other.b)) {
                            return false;
                        }
                        if (this.c == null) {
                            if (other.c != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.c, other.c)) {
                            return false;
                        }
                        return true;
                    }
                    /**
                     * The pseudoscalar is implied in the result.
                     * @param {com.vzome.core.algebra.Vector3d} v
                     * @return
                     * @return {*}
                     */
                    outer(v) {
                        let a = this.a['times$com_vzome_core_algebra_AlgebraicNumber'](v.c);
                        let b = this.b['times$com_vzome_core_algebra_AlgebraicNumber'](v.a);
                        let c = this.c['times$com_vzome_core_algebra_AlgebraicNumber'](v.b);
                        return a['plus$com_vzome_core_algebra_AlgebraicNumber'](b)['plus$com_vzome_core_algebra_AlgebraicNumber'](c);
                    }
                }
                algebra.Bivector3d = Bivector3d;
                Bivector3d["__class"] = "com.vzome.core.algebra.Bivector3d";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Trivector3dHomogeneous {
                    constructor(e123, e310, e320, e120, field) {
                        if (this.e123 === undefined)
                            this.e123 = null;
                        if (this.e310 === undefined)
                            this.e310 = null;
                        if (this.e320 === undefined)
                            this.e320 = null;
                        if (this.e120 === undefined)
                            this.e120 = null;
                        if (this.field === undefined)
                            this.field = null;
                        this.e123 = e123;
                        this.e310 = e310;
                        this.e320 = e320;
                        this.e120 = e120;
                        this.field = field;
                    }
                    dual() {
                        return new com.vzome.core.algebra.Vector3dHomogeneous(this.e320.negate(), this.e310, this.e120, this.e123.negate(), this.field);
                    }
                }
                algebra.Trivector3dHomogeneous = Trivector3dHomogeneous;
                Trivector3dHomogeneous["__class"] = "com.vzome.core.algebra.Trivector3dHomogeneous";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                let AlgebraicNumber;
                (function (AlgebraicNumber) {
                    class Views {
                        constructor() {
                        }
                    }
                    AlgebraicNumber.Views = Views;
                    Views["__class"] = "com.vzome.core.algebra.AlgebraicNumber.Views";
                })(AlgebraicNumber = algebra.AlgebraicNumber || (algebra.AlgebraicNumber = {}));
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Vector3d {
                    constructor(a, b, c) {
                        if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || a === null) && ((b != null && (b["__interfaces"] != null && b["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || b.constructor != null && b.constructor["__interfaces"] != null && b.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || b === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || c === null)) {
                            let __args = arguments;
                            if (this.a === undefined)
                                this.a = null;
                            if (this.b === undefined)
                                this.b = null;
                            if (this.c === undefined)
                                this.c = null;
                            if (this.a === undefined)
                                this.a = null;
                            if (this.b === undefined)
                                this.b = null;
                            if (this.c === undefined)
                                this.c = null;
                            (() => {
                                this.a = a;
                                this.b = b;
                                this.c = c;
                            })();
                        }
                        else if (((a != null && a instanceof com.vzome.core.algebra.AlgebraicVector) || a === null) && b === undefined && c === undefined) {
                            let __args = arguments;
                            let v = __args[0];
                            if (this.a === undefined)
                                this.a = null;
                            if (this.b === undefined)
                                this.b = null;
                            if (this.c === undefined)
                                this.c = null;
                            if (this.a === undefined)
                                this.a = null;
                            if (this.b === undefined)
                                this.b = null;
                            if (this.c === undefined)
                                this.c = null;
                            (() => {
                                this.a = v.getComponent(0);
                                this.b = v.getComponent(1);
                                this.c = v.getComponent(2);
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    outer(that) {
                        let a = this.a['times$com_vzome_core_algebra_AlgebraicNumber'](that.b)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.b['times$com_vzome_core_algebra_AlgebraicNumber'](that.a));
                        let b = this.b['times$com_vzome_core_algebra_AlgebraicNumber'](that.c)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.c['times$com_vzome_core_algebra_AlgebraicNumber'](that.b));
                        let c = this.c['times$com_vzome_core_algebra_AlgebraicNumber'](that.a)['minus$com_vzome_core_algebra_AlgebraicNumber'](this.a['times$com_vzome_core_algebra_AlgebraicNumber'](that.c));
                        return new com.vzome.core.algebra.Bivector3d(a, b, c);
                    }
                }
                algebra.Vector3d = Vector3d;
                Vector3d["__class"] = "com.vzome.core.algebra.Vector3d";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var algebra;
            (function (algebra) {
                class Quaternion {
                    constructor(field, vector) {
                        if (this.representation === undefined)
                            this.representation = null;
                        if (this.transpose === undefined)
                            this.transpose = null;
                        if (this.field === undefined)
                            this.field = null;
                        if (this.vector === undefined)
                            this.vector = null;
                        this.field = field;
                        this.vector = vector;
                        let w_offset = 0;
                        let factor = field['createRational$long'](0);
                        if (vector.dimension() > 3) {
                            factor = vector.getComponent(0);
                            w_offset = 1;
                        }
                        this.representation = field.identityMatrix(4).timesScalar(factor);
                        factor = vector.getComponent(0 + w_offset);
                        this.representation.setElement(1, 0, factor);
                        this.representation.setElement(3, 2, factor);
                        factor = factor.negate();
                        this.representation.setElement(0, 1, factor);
                        this.representation.setElement(2, 3, factor);
                        factor = vector.getComponent(1 + w_offset);
                        this.representation.setElement(1, 3, factor);
                        this.representation.setElement(2, 0, factor);
                        factor = factor.negate();
                        this.representation.setElement(3, 1, factor);
                        this.representation.setElement(0, 2, factor);
                        factor = vector.getComponent(2 + w_offset);
                        this.representation.setElement(3, 0, factor);
                        this.representation.setElement(2, 1, factor);
                        factor = factor.negate();
                        this.representation.setElement(1, 2, factor);
                        this.representation.setElement(0, 3, factor);
                        if (w_offset === 1)
                            factor = vector.getComponent(0);
                        else
                            factor = field['createRational$long'](0);
                        this.transpose = field.identityMatrix(4).timesScalar(factor);
                        factor = vector.getComponent(0 + w_offset);
                        this.transpose.setElement(0, 1, factor);
                        this.transpose.setElement(2, 3, factor);
                        factor = factor.negate();
                        this.transpose.setElement(1, 0, factor);
                        this.transpose.setElement(3, 2, factor);
                        factor = vector.getComponent(1 + w_offset);
                        this.transpose.setElement(3, 1, factor);
                        this.transpose.setElement(0, 2, factor);
                        factor = factor.negate();
                        this.transpose.setElement(1, 3, factor);
                        this.transpose.setElement(2, 0, factor);
                        factor = vector.getComponent(2 + w_offset);
                        this.transpose.setElement(1, 2, factor);
                        this.transpose.setElement(0, 3, factor);
                        factor = factor.negate();
                        this.transpose.setElement(3, 0, factor);
                        this.transpose.setElement(2, 1, factor);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return "Quaternion: " + this.vector.toString();
                    }
                    getVector() {
                        return this.vector;
                    }
                    /*private*/ conjugate(q) {
                        let result = this.field.origin(4);
                        result.setComponent(3, q.getComponent(3).negate());
                        result.setComponent(1, q.getComponent(1).negate());
                        result.setComponent(2, q.getComponent(2).negate());
                        result.setComponent(0, q.getComponent(0));
                        return result;
                    }
                    reflect(v) {
                        let reflection = this.rightMultiply(this.conjugate(v));
                        reflection = this.leftMultiply(reflection);
                        return reflection.negate();
                    }
                    /**
                     * Compute the product this * q.
                     * @param {com.vzome.core.algebra.AlgebraicVector} q
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    rightMultiply(q) {
                        return this.representation.timesColumn(q);
                    }
                    /**
                     * Compute the product q*this.
                     * This is computed using the identities:
                     *
                     * conjugate( q*this ) == conjugate( this ) * conjugate( q )
                     *
                     * q * this == conjugate( conjugate( this ) * conjugate( q ) )
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} q
                     * @return
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    leftMultiply(q) {
                        let result = this.conjugate(q);
                        result = this.transpose.timesColumn(result);
                        return this.conjugate(result);
                    }
                }
                algebra.Quaternion = Quaternion;
                Quaternion["__class"] = "com.vzome.core.algebra.Quaternion";
            })(algebra = core.algebra || (core.algebra = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var xml;
        (function (xml) {
            class DomUtils {
                static addAttribute(elem, name, value) {
                    elem.setAttribute(name, value);
                }
                static getFirstChildElement$org_w3c_dom_Element$java_lang_String(elem, name) {
                    let elems = elem.getElementsByTagName(name);
                    return elems.item(0);
                }
                static getFirstChildElement(elem, name) {
                    if (((elem != null && (elem["__interfaces"] != null && elem["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || elem.constructor != null && elem.constructor["__interfaces"] != null && elem.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || elem === null) && ((typeof name === 'string') || name === null)) {
                        return com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element$java_lang_String(elem, name);
                    }
                    else if (((elem != null && (elem["__interfaces"] != null && elem["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || elem.constructor != null && elem.constructor["__interfaces"] != null && elem.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || elem === null) && name === undefined) {
                        return com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element(elem);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static preserveSpace(contentElem) {
                    contentElem.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
                }
                static getFirstChildElement$org_w3c_dom_Element(parent) {
                    let children = parent.getChildNodes();
                    if (children.getLength() === 0)
                        return null;
                    for (let k = 0; k < children.getLength(); k++) {
                        {
                            let kid = children.item(k);
                            if (kid != null && (kid["__interfaces"] != null && kid["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || kid.constructor != null && kid.constructor["__interfaces"] != null && kid.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) {
                                return kid;
                            }
                        }
                        ;
                    }
                    return null;
                }
                static getChild(parent, i) {
                    let children = parent.getChildNodes();
                    if (children.getLength() === 0)
                        return null;
                    let count = 0;
                    for (let k = 0; k < children.getLength(); k++) {
                        {
                            let kid = children.item(k);
                            if (kid != null && (kid["__interfaces"] != null && kid["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || kid.constructor != null && kid.constructor["__interfaces"] != null && kid.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) {
                                if (count === i)
                                    return kid;
                                else
                                    ++count;
                            }
                        }
                        ;
                    }
                    return null;
                }
            }
            xml.DomUtils = DomUtils;
            DomUtils["__class"] = "com.vzome.xml.DomUtils";
        })(xml = vzome.xml || (vzome.xml = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var xml;
        (function (xml) {
            class ResourceLoader {
                static INJECTED_RESOURCES_$LI$() { if (ResourceLoader.INJECTED_RESOURCES == null)
                    ResourceLoader.INJECTED_RESOURCES = (new java.util.HashMap()); return ResourceLoader.INJECTED_RESOURCES; }
                ;
                static injectResource(path, content) {
                    ResourceLoader.INJECTED_RESOURCES_$LI$().put(path, content);
                }
                static hasInjectedResource(path) {
                    return ResourceLoader.INJECTED_RESOURCES_$LI$().containsKey(path);
                }
                static getInjectedResource(path) {
                    return ResourceLoader.INJECTED_RESOURCES_$LI$().get(path);
                }
                static loadStringResource(path) {
                    if (ResourceLoader.hasInjectedResource(path))
                        return ResourceLoader.getInjectedResource(path);
                    let input = ResourceLoader.getClassLoader().getResourceAsStream(path);
                    if (input == null)
                        return null;
                    let out = new java.io.ByteArrayOutputStream();
                    let buf = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(1024);
                    let num;
                    while (((num = input.read(buf, 0, 1024)) > 0)) {
                        out.write(buf, 0, num);
                    }
                    ;
                    input.close();
                    return new String(out.toByteArray());
                }
            }
            xml.ResourceLoader = ResourceLoader;
            ResourceLoader["__class"] = "com.vzome.xml.ResourceLoader";
        })(xml = vzome.xml || (vzome.xml = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var api;
        (function (api) {
            let Tool;
            (function (Tool) {
                let Kind;
                (function (Kind) {
                    Kind[Kind["SYMMETRY"] = 0] = "SYMMETRY";
                    Kind[Kind["TRANSFORM"] = 1] = "TRANSFORM";
                    Kind[Kind["LINEAR_MAP"] = 2] = "LINEAR_MAP";
                })(Kind = Tool.Kind || (Tool.Kind = {}));
            })(Tool = api.Tool || (api.Tool = {}));
        })(api = vzome.api || (vzome.api = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
var java;
(function (java) {
    var util;
    (function (util) {
        class UUID {
            constructor() {
                if (this.value === undefined)
                    this.value = null;
                this.value = /* toString */ ('' + (Math.random()));
            }
            static randomUUID() {
                return new UUID();
            }
            toString() {
                return this.value;
            }
        }
        util.UUID = UUID;
        UUID["__class"] = "java.util.UUID";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        class StringTokenizer {
            constructor(str, seps) {
                if (((typeof str === 'string') || str === null) && ((typeof seps === 'string') || seps === null)) {
                    let __args = arguments;
                    if (this.tokens === undefined)
                        this.tokens = null;
                    if (this.count === undefined)
                        this.count = 0;
                    if (this.tokens === undefined)
                        this.tokens = null;
                    if (this.count === undefined)
                        this.count = 0;
                    (() => {
                        let pattern = (seps == null) ? "\\s+" : "[" + seps + "]+";
                        let regExp = new RegExp(pattern);
                        let strs = this.splitRegExp(str, regExp);
                        let last = strs.length - 1;
                        if (strs[last] === "")
                            strs = java.util.Arrays.copyOf(strs, last);
                        this.count = strs.length;
                        this.tokens = java.util.Arrays.asList(strs).iterator();
                    })();
                }
                else if (((typeof str === 'string') || str === null) && seps === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let seps = null;
                        if (this.tokens === undefined)
                            this.tokens = null;
                        if (this.count === undefined)
                            this.count = 0;
                        if (this.tokens === undefined)
                            this.tokens = null;
                        if (this.count === undefined)
                            this.count = 0;
                        (() => {
                            let pattern = (seps == null) ? "\\s+" : "[" + seps + "]+";
                            let regExp = new RegExp(pattern);
                            let strs = this.splitRegExp(str, regExp);
                            let last = strs.length - 1;
                            if (strs[last] === "")
                                strs = java.util.Arrays.copyOf(strs, last);
                            this.count = strs.length;
                            this.tokens = java.util.Arrays.asList(strs).iterator();
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /*private*/ splitRegExp(str, regExp) {
                return str.split(regExp);
            }
            hasMoreTokens() {
                return this.tokens.hasNext();
            }
            nextToken() {
                return this.tokens.next();
            }
            countTokens() {
                return this.count;
            }
        }
        util.StringTokenizer = StringTokenizer;
        StringTokenizer["__class"] = "java.util.StringTokenizer";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        class Properties {
            getProperty(key) {
                return "";
            }
            load(inStream) {
            }
            isEmpty() {
                return true;
            }
        }
        util.Properties = Properties;
        Properties["__class"] = "java.util.Properties";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        class File {
            constructor(parent, name) {
            }
            exists() {
                return false;
            }
        }
        io.File = File;
        File["__class"] = "java.io.File";
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        class StringWriter extends java.io.Writer {
            toString() {
                return null;
            }
            flush() {
            }
            close() {
            }
            write(cbuf, off, len) {
            }
            constructor() {
                super();
            }
        }
        io.StringWriter = StringWriter;
        StringWriter["__class"] = "java.io.StringWriter";
        StringWriter["__interfaces"] = ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        class PrintWriter extends java.io.Writer {
            constructor(w) {
                super();
            }
            flush() {
            }
            close() {
            }
            write(cbuf, off, len) {
            }
            println$() {
            }
            print(x) {
            }
            println$java_lang_Object(x) {
            }
            println(x) {
                if (((x != null) || x === null)) {
                    return this.println$java_lang_Object(x);
                }
                else if (x === undefined) {
                    return this.println$();
                }
                else
                    throw new Error('invalid overload');
            }
        }
        io.PrintWriter = PrintWriter;
        PrintWriter["__class"] = "java.io.PrintWriter";
        PrintWriter["__interfaces"] = ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var beans;
    (function (beans) {
        class PropertyChangeSupport {
            constructor(a1) {
            }
            firePropertyChange(a1, a2, a3) {
            }
            addPropertyChangeListener(a1) {
            }
            removePropertyChangeListener(a1) {
            }
        }
        beans.PropertyChangeSupport = PropertyChangeSupport;
        PropertyChangeSupport["__class"] = "java.beans.PropertyChangeSupport";
    })(beans = java.beans || (java.beans = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        class FloatBuffer {
            put(offset, x) {
            }
        }
        nio.FloatBuffer = FloatBuffer;
        FloatBuffer["__class"] = "java.nio.FloatBuffer";
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var text;
    (function (text) {
        class NumberFormat {
            static getNumberInstance(us) {
                return new NumberFormat();
            }
            setMaximumFractionDigits(i) {
            }
            setMinimumFractionDigits(i) {
            }
            format(x) {
                return /* toString */ ('' + (x));
            }
        }
        text.NumberFormat = NumberFormat;
        NumberFormat["__class"] = "java.text.NumberFormat";
    })(text = java.text || (java.text = {}));
})(java || (java = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsSelection {
                constructor(field, adapter) {
                    if (this.adapter === undefined)
                        this.adapter = null;
                    if (this.field === undefined)
                        this.field = null;
                    this.field = field;
                    this.adapter = adapter;
                }
                setAdapter(adapter) {
                    this.adapter = adapter;
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    if (this.adapter == null)
                        return java.util.Collections.emptyIterator();
                    let f = (this.adapter["selectedIterator"]);
                    let jSiterator = f.apply(this.adapter);
                    return new JsSelection.JsSelection$0(this, jSiterator);
                }
                /**
                 *
                 */
                clear() {
                    (this.adapter["clearSelection"]).apply(this.adapter);
                }
                /**
                 *
                 * @param {*} man
                 * @return {boolean}
                 */
                manifestationSelected(man) {
                    let vectors = man.getVectors();
                    return (this.adapter["manifestationSelected"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {*} man
                 */
                select(man) {
                    let vectors = man.getVectors();
                    (this.adapter["select"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {*} man
                 */
                unselect(man) {
                    let vectors = man.getVectors();
                    (this.adapter["unselect"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return ((this.adapter["selectionSize"]).apply(this.adapter) | 0);
                }
                /**
                 *
                 */
                gatherGroup() {
                    (this.adapter["createGroup"]).apply(this.adapter);
                }
                /**
                 *
                 */
                scatterGroup() {
                    (this.adapter["disbandGroup"]).apply(this.adapter);
                }
                /**
                 *
                 */
                gatherGroup211() {
                    (this.adapter["createLegacyGroup"]).apply(this.adapter);
                }
                /**
                 *
                 */
                scatterGroup211() {
                    (this.adapter["disbandLegacyGroup"]).apply(this.adapter);
                }
                /**
                 *
                 * @param {*} man
                 */
                selectWithGrouping(man) {
                    if (man == null)
                        return;
                    let vectors = man.getVectors();
                    (this.adapter["selectWithGrouping"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {*} man
                 */
                unselectWithGrouping(man) {
                    if (man == null)
                        return;
                    let vectors = man.getVectors();
                    (this.adapter["unselectWithGrouping"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @return {boolean}
                 */
                isSelectionAGroup() {
                    return (this.adapter["selectionIsGroup"]).apply(this.adapter);
                }
                /**
                 *
                 * @param {*} bookmarkedSelection
                 */
                copy(bookmarkedSelection) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
            }
            jsweet.JsSelection = JsSelection;
            JsSelection["__class"] = "com.vzome.jsweet.JsSelection";
            JsSelection["__interfaces"] = ["com.vzome.core.editor.api.Selection", "java.lang.Iterable"];
            (function (JsSelection) {
                class JsSelection$0 {
                    constructor(__parent, jSiterator) {
                        this.jSiterator = jSiterator;
                        this.__parent = __parent;
                        this.peek = this.jSiterator.next();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        return !this.peek.done;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    next() {
                        let result = com.vzome.jsweet.JsManifestation.manifest(this.peek.value, this.__parent.field, this.__parent.adapter);
                        this.peek = this.jSiterator.next();
                        return result;
                    }
                }
                JsSelection.JsSelection$0 = JsSelection$0;
                JsSelection$0["__interfaces"] = ["java.util.Iterator"];
            })(JsSelection = jsweet.JsSelection || (jsweet.JsSelection = {}));
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsEditContext {
                constructor() {
                }
                /**
                 *
                 * @param {*} xml
                 * @return {com.vzome.core.editor.api.UndoableEdit}
                 */
                createEdit(xml) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {com.vzome.core.editor.api.UndoableEdit} edit
                 */
                performAndRecord(edit) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {string} cmdName
                 * @return {*}
                 */
                createLegacyCommand(cmdName) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
            }
            jsweet.JsEditContext = JsEditContext;
            JsEditContext["__class"] = "com.vzome.jsweet.JsEditContext";
            JsEditContext["__interfaces"] = ["com.vzome.core.editor.api.UndoableEdit.Context"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsRealizedModel {
                constructor(field, adapter) {
                    if (this.field === undefined)
                        this.field = null;
                    if (this.adapter === undefined)
                        this.adapter = null;
                    this.field = field;
                    this.adapter = adapter;
                }
                setAdapter(adapter) {
                    this.adapter = adapter;
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    let f = (this.adapter["allIterator"]);
                    let jSiterator = f.apply(this.adapter);
                    return new JsRealizedModel.JsRealizedModel$0(this, jSiterator);
                }
                /**
                 *
                 * @return {*}
                 */
                getField() {
                    return this.field;
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} c
                 * @return {*}
                 */
                findConstruction(c) {
                    if (c == null)
                        return null;
                    let vectors = com.vzome.jsweet.JsManifestation.canonicalizeConstruction(c);
                    if (vectors == null)
                        return null;
                    vectors = (this.adapter["findOrCreateManifestation"]).apply(this.adapter, [vectors]);
                    if (vectors == null)
                        return null;
                    return com.vzome.jsweet.JsManifestation.manifest(vectors, this.field, this.adapter);
                }
                /**
                 *
                 * @param {*} man
                 */
                remove(man) {
                    let vectors = man.getVectors();
                    (this.adapter["delete"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} c
                 * @return {*}
                 */
                getManifestation(c) {
                    return this.findConstruction(c);
                }
                /**
                 *
                 * @param {*} man
                 */
                show(man) {
                    let vectors = man.getVectors();
                    (this.adapter["showManifestation"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {*} man
                 */
                hide(man) {
                    let vectors = man.getVectors();
                    (this.adapter["hideManifestation"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {*} man
                 * @param {com.vzome.core.construction.Color} color
                 */
                setColor(man, color) {
                    man.setColor(color);
                }
                /**
                 *
                 * @param {*} man
                 */
                add(man) {
                    let vectors = man.getVectors();
                    (this.adapter["showManifestation"]).apply(this.adapter, [vectors]);
                }
                /**
                 *
                 * @param {*} m
                 * @return {*}
                 */
                findPerEditManifestation(m) {
                    return null;
                }
                /**
                 *
                 * @param {*} m
                 */
                addPerEditManifestation(m) {
                }
                /**
                 *
                 */
                clearPerEditManifestations() {
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} c
                 * @return {*}
                 */
                removeConstruction(c) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
            }
            jsweet.JsRealizedModel = JsRealizedModel;
            JsRealizedModel["__class"] = "com.vzome.jsweet.JsRealizedModel";
            JsRealizedModel["__interfaces"] = ["com.vzome.core.model.RealizedModel", "java.lang.Iterable"];
            (function (JsRealizedModel) {
                class JsRealizedModel$0 {
                    constructor(__parent, jSiterator) {
                        this.jSiterator = jSiterator;
                        this.__parent = __parent;
                        this.peek = this.jSiterator.next();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        return !this.peek.done;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    next() {
                        let result = com.vzome.jsweet.JsManifestation.manifest(this.peek.value, this.__parent.field, this.__parent.adapter);
                        this.peek = this.jSiterator.next();
                        return result;
                    }
                }
                JsRealizedModel.JsRealizedModel$0 = JsRealizedModel$0;
                JsRealizedModel$0["__interfaces"] = ["java.util.Iterator"];
            })(JsRealizedModel = jsweet.JsRealizedModel || (jsweet.JsRealizedModel = {}));
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsAlgebraicField {
                constructor(delegate) {
                    if (this.delegate === undefined)
                        this.delegate = null;
                    if (this.positivePowers === undefined)
                        this.positivePowers = null;
                    if (this.negativePowers === undefined)
                        this.negativePowers = null;
                    this.delegate = delegate;
                    let order = (delegate["order"]);
                    this.positivePowers = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(order - 1);
                    this.negativePowers = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(order - 1);
                }
                /**
                 *
                 * @return {string}
                 */
                getName() {
                    return (this.delegate["name"]);
                }
                /**
                 *
                 * @return {number}
                 */
                getOrder() {
                    return (this.delegate["order"]);
                }
                /**
                 *
                 * @return {number}
                 */
                getNumIrrationals() {
                    return this.getOrder() - 1;
                }
                add(v1, v2) {
                    let f = (this.delegate["plus"]);
                    return (f((v1), (v2)));
                }
                subtract(v1, v2) {
                    let f = (this.delegate["minus"]);
                    return (f((v1), (v2)));
                }
                multiply(v1, v2) {
                    let f = (this.delegate["times"]);
                    return (f((v1), (v2)));
                }
                evaluateNumber(factors) {
                    let f = (this.delegate["embed"]);
                    return (f((factors)));
                }
                reciprocal(factors) {
                    let f = (this.delegate["reciprocal"]);
                    return (f((factors)));
                }
                negate(factors) {
                    let f = (this.delegate["negate"]);
                    return (f((factors)));
                }
                /**
                 *
                 * @param {Array} trailingDivisorForm
                 * @return {*}
                 */
                createAlgebraicNumberFromTD(trailingDivisorForm) {
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, trailingDivisorForm);
                }
                createAlgebraicNumberFromPairs(pairs) {
                    let f = (this.delegate["createRationalFromPairs"]);
                    let frac = (f((pairs)));
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, frac);
                }
                createRational$long$long(numerator, denominator) {
                    let f = (this.delegate["createRational"]);
                    let frac = (f((numerator), (denominator)));
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, frac);
                }
                /**
                 *
                 * @param {number} numerator
                 * @param {number} denominator
                 * @return {*}
                 */
                createRational(numerator, denominator) {
                    if (((typeof numerator === 'number') || numerator === null) && ((typeof denominator === 'number') || denominator === null)) {
                        return this.createRational$long$long(numerator, denominator);
                    }
                    else if (((typeof numerator === 'number') || numerator === null) && denominator === undefined) {
                        return this.createRational$long(numerator);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {*}
                 */
                zero() {
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, (this.delegate["zero"]));
                }
                /**
                 *
                 * @return {*}
                 */
                one() {
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, (this.delegate["one"]));
                }
                /**
                 *
                 * @param {Array} nums
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                createVector(nums) {
                    let x = this.createAlgebraicNumberFromPairs(nums[0]);
                    let y = this.createAlgebraicNumberFromPairs(nums[1]);
                    let z = this.createAlgebraicNumberFromPairs(nums[2]);
                    return new com.vzome.core.algebra.AlgebraicVector(x, y, z);
                }
                /**
                 *
                 * @param {Array} nums
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                createVectorFromTDs(nums) {
                    let x = this.createAlgebraicNumberFromTD(nums[0]);
                    let y = this.createAlgebraicNumberFromTD(nums[1]);
                    let z = this.createAlgebraicNumberFromTD(nums[2]);
                    return new com.vzome.core.algebra.AlgebraicVector(x, y, z);
                }
                /**
                 *
                 * @param {number} dims
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                origin(dims) {
                    let zero = this.zero();
                    switch ((dims)) {
                        case 1:
                            return new com.vzome.core.algebra.AlgebraicVector(zero);
                        case 2:
                            return new com.vzome.core.algebra.AlgebraicVector(zero, zero);
                        case 3:
                            return new com.vzome.core.algebra.AlgebraicVector(zero, zero, zero);
                        case 4:
                            return new com.vzome.core.algebra.AlgebraicVector(zero, zero, zero, zero);
                        case 5:
                            return new com.vzome.core.algebra.AlgebraicVector(zero, zero, zero, zero, zero);
                        default:
                            return null;
                    }
                }
                /**
                 *
                 * @return {boolean}
                 */
                scale4dRoots() {
                    return false;
                }
                /**
                 *
                 * @return {boolean}
                 */
                doubleFrameVectors() {
                    return false;
                }
                /**
                 *
                 * @param {number} dims
                 * @param {number} axis
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                basisVector(dims, axis) {
                    let result = this.origin(dims);
                    return result.setComponent(axis, this.one());
                }
                createRational$long(wholeNumber) {
                    return this.createRational$long$long(wholeNumber, 1);
                }
                createPower$int(power) {
                    return this.createPower$int$int(power, 1);
                }
                createPower$int$int(power, irr) {
                    let one = this.one();
                    if (power === 0 || irr === 0)
                        return one;
                    irr -= 1;
                    if (power > 0) {
                        if (this.positivePowers[irr] == null)
                            this.positivePowers[irr] = (new java.util.ArrayList(8));
                        if (power >= this.positivePowers[irr].size()) {
                            if (this.positivePowers[irr].isEmpty()) {
                                this.positivePowers[irr].add(one);
                                this.positivePowers[irr].add(this.getUnitTerm(irr + 1));
                            }
                            let size = this.positivePowers[irr].size();
                            let irrat = this.positivePowers[irr].get(1);
                            let last = this.positivePowers[irr].get(size - 1);
                            for (let i = size; i <= power; i++) {
                                {
                                    let next = last['times$com_vzome_core_algebra_AlgebraicNumber'](irrat);
                                    this.positivePowers[irr].add(next);
                                    last = next;
                                }
                                ;
                            }
                        }
                        return this.positivePowers[irr].get(power);
                    }
                    else {
                        power = -power;
                        if (this.negativePowers[irr] == null)
                            this.negativePowers[irr] = (new java.util.ArrayList(8));
                        if (power >= this.negativePowers[irr].size()) {
                            if (this.negativePowers[irr].isEmpty()) {
                                this.negativePowers[irr].add(one);
                                this.negativePowers[irr].add(this.getUnitTerm(irr + 1).reciprocal());
                            }
                            let size = this.negativePowers[irr].size();
                            let irrat = this.negativePowers[irr].get(1);
                            let last = this.negativePowers[irr].get(size - 1);
                            for (let i = size; i <= power; i++) {
                                {
                                    let next = last['times$com_vzome_core_algebra_AlgebraicNumber'](irrat);
                                    this.negativePowers[irr].add(next);
                                    last = next;
                                }
                                ;
                            }
                        }
                        return this.negativePowers[irr].get(power);
                    }
                }
                /**
                 *
                 * @param {number} power
                 * @param {number} irr
                 * @return {*}
                 */
                createPower(power, irr) {
                    if (((typeof power === 'number') || power === null) && ((typeof irr === 'number') || irr === null)) {
                        return this.createPower$int$int(power, irr);
                    }
                    else if (((typeof power === 'number') || power === null) && irr === undefined) {
                        return this.createPower$int(power);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 * @param {number} n specifies the ordinal of the term in the AlgebraicNumber which will be set to one.
                 * When {@code n == 0}, the result is the same as {@code createRational(1)}.
                 * When {@code n == 1}, the result is the same as {@code createPower(1)}.
                 * When {@code n < 0}, the result will be {@code zero()}.
                 * When {@code n >= getOrder()}, an IndexOutOfBoundsException will be thrown.
                 * @return {*} an AlgebraicNumber with the factor specified by {@code n} set to one.
                 */
                getUnitTerm(n) {
                    if (n < 0) {
                        return this.zero();
                    }
                    let factors = this.zero().toTrailingDivisor();
                    factors[n] = 1;
                    return this.createAlgebraicNumber$int_A(factors);
                }
                createAlgebraicNumber$int_A(terms) {
                    return this.createAlgebraicNumber$int_A$int(terms, 1);
                }
                createAlgebraicNumber$int_A$int(numerators, denominator) {
                    let factors = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(numerators.length + 1);
                    java.lang.System.arraycopy(numerators, 0, factors, 0, numerators.length);
                    factors[numerators.length] = denominator;
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, factors);
                }
                /**
                 *
                 * @return {*}
                 */
                getGoldenRatio() {
                    let value = (this.delegate["goldenRatio"]);
                    if (value == null)
                        return null;
                    return new com.vzome.jsweet.JsAlgebraicNumber(this, value);
                }
                /**
                 *
                 * @param {number} dims
                 * @return {com.vzome.core.algebra.AlgebraicMatrix}
                 */
                identityMatrix(dims) {
                    let columns = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(dims);
                    for (let i = 0; i < columns.length; i++) {
                        {
                            columns[i] = this.basisVector(dims, i);
                        }
                        ;
                    }
                    return new com.vzome.core.algebra.AlgebraicMatrix(columns);
                }
                /**
                 * Modeled after AbstractAlgebraicField, with a switch from BigRationals to int[]s.
                 * @param {string} string
                 * @param {boolean} isRational
                 * @return {*}
                 */
                parseVefNumber(string, isRational) {
                    let pairs = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(this.getOrder() + 1);
                    if ((!isRational) && /* startsWith */ ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "(") && /* endsWith */ ((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(string, ")")) {
                        let tokens = new java.util.StringTokenizer(string.substring(1, string.length - 1), ",");
                        let numStack = (new java.util.Stack());
                        let denomStack = (new java.util.Stack());
                        while ((tokens.hasMoreTokens())) {
                            {
                                if (numStack.size() >= this.getOrder()) {
                                    throw new java.lang.RuntimeException("VEF format error: \"" + string + "\" has too many factors for " + this.getName() + " field");
                                }
                                let parts = tokens.nextToken().split("/");
                                numStack.push(javaemul.internal.IntegerHelper.parseInt(parts[0]));
                                denomStack.push((parts.length > 1) ? javaemul.internal.IntegerHelper.parseInt(parts[1]) : 1);
                            }
                        }
                        ;
                        let i = 0;
                        while ((!numStack.empty())) {
                            {
                                pairs[i++] = numStack.pop();
                                pairs[i++] = denomStack.pop();
                            }
                        }
                        ;
                    }
                    else {
                        let parts = string.split("/");
                        pairs[0] = javaemul.internal.IntegerHelper.parseInt(parts[0]);
                        pairs[1] = (parts.length > 1) ? javaemul.internal.IntegerHelper.parseInt(parts[1]) : 1;
                    }
                    return this.createAlgebraicNumberFromPairs(pairs);
                }
                /**
                 * Drop one coordinate from the 4D vector. If wFirst (the usual), then drop
                 * the first coordinate, taking the "imaginary part" of the vector. If
                 * !wFirst (for old VEF import, etc.), drop the last coordinate.
                 *
                 * @param {com.vzome.core.algebra.AlgebraicVector} source
                 * @param {boolean} wFirst
                 * @return
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                projectTo3d(source, wFirst) {
                    if (source.dimension() === 3)
                        return source;
                    else {
                        let result = this.origin(3);
                        for (let i = 0; i < 3; i++) {
                            result.setComponent(i, source.getComponent(wFirst ? i + 1 : i));
                        }
                        return result;
                    }
                }
                createAlgebraicNumber$int$int$int$int(ones, irrat, denominator, scalePower) {
                    let result = this.createAlgebraicNumberFromTD([ones, irrat, denominator]);
                    if (scalePower !== 0) {
                        let multiplier = this.createPower$int(scalePower);
                        return result['times$com_vzome_core_algebra_AlgebraicNumber'](multiplier);
                    }
                    else
                        return result;
                }
                /**
                 *
                 * @param {number} ones
                 * @param {number} irrat
                 * @param {number} denominator
                 * @param {number} scalePower
                 * @return {*}
                 */
                createAlgebraicNumber(ones, irrat, denominator, scalePower) {
                    if (((typeof ones === 'number') || ones === null) && ((typeof irrat === 'number') || irrat === null) && ((typeof denominator === 'number') || denominator === null) && ((typeof scalePower === 'number') || scalePower === null)) {
                        return this.createAlgebraicNumber$int$int$int$int(ones, irrat, denominator, scalePower);
                    }
                    else if (((ones != null && ones instanceof Array && (ones.length == 0 || ones[0] == null || (typeof ones[0] === 'number'))) || ones === null) && ((typeof irrat === 'number') || irrat === null) && denominator === undefined && scalePower === undefined) {
                        return this.createAlgebraicNumber$int_A$int(ones, irrat);
                    }
                    else if (((ones != null && ones instanceof Array && (ones.length == 0 || ones[0] == null || (typeof ones[0] === 'number'))) || ones === null) && irrat === undefined && denominator === undefined && scalePower === undefined) {
                        return this.createAlgebraicNumber$int_A(ones);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {string} nums
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                parseVector(nums) {
                    let tokens = new java.util.StringTokenizer(nums, " ");
                    let numToks = tokens.countTokens();
                    if (numToks % this.getOrder() !== 0)
                        throw new java.lang.IllegalStateException("Field order (" + this.getOrder() + ") does not divide token count: " + numToks + ", for \'" + nums + "\'");
                    let dims = (numToks / this.getOrder() | 0);
                    let coords = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(dims);
                    for (let i = 0; i < dims; i++) {
                        {
                            coords[i] = this.parseNumber$java_util_StringTokenizer(tokens);
                        }
                        ;
                    }
                    return new com.vzome.core.algebra.AlgebraicVector(coords);
                }
                parseNumber$java_lang_String(nums) {
                    let tokens = new java.util.StringTokenizer(nums, " ");
                    return this.parseNumber$java_util_StringTokenizer(tokens);
                }
                /**
                 *
                 * @param {string} nums
                 * @return {*}
                 */
                parseNumber(nums) {
                    if (((typeof nums === 'string') || nums === null)) {
                        return this.parseNumber$java_lang_String(nums);
                    }
                    else if (((nums != null && nums instanceof java.util.StringTokenizer) || nums === null)) {
                        return this.parseNumber$java_util_StringTokenizer(nums);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /*private*/ parseNumber$java_util_StringTokenizer(tokens) {
                    let order = this.getOrder();
                    let pairs = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(order * 2);
                    for (let i = 0; i < order; i++) {
                        {
                            let digit = tokens.nextToken();
                            let parts = digit.split("/");
                            pairs[i * 2] = javaemul.internal.IntegerHelper.parseInt(parts[0]);
                            if (parts.length > 1)
                                pairs[i * 2 + 1] = javaemul.internal.IntegerHelper.parseInt(parts[1]);
                            else
                                pairs[i * 2 + 1] = 1;
                        }
                        ;
                    }
                    return this.createAlgebraicNumberFromPairs(pairs);
                }
                /**
                 *
                 * @param {string} string
                 * @return {*}
                 */
                parseLegacyNumber(string) {
                    let div = 1;
                    if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "(")) {
                        let closeParen = string.indexOf(')');
                        div = javaemul.internal.IntegerHelper.parseInt(string.substring(closeParen + 2));
                        string = string.substring(1, closeParen);
                    }
                    let phis = 0;
                    let phiIndex = string.indexOf("phi");
                    if (phiIndex >= 0) {
                        let part = string.substring(0, phiIndex);
                        if (part.length === 0)
                            phis = 1;
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(part, "-"))
                            phis = -1;
                        else
                            phis = javaemul.internal.IntegerHelper.parseInt(part);
                        string = string.substring(phiIndex + 3);
                    }
                    let ones;
                    if (string.length === 0)
                        ones = 0;
                    else {
                        if ( /* startsWith */((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(string, "+"))
                            string = string.substring(1);
                        ones = javaemul.internal.IntegerHelper.parseInt(string);
                    }
                    return this.createAlgebraicNumber$int$int$int$int(ones, phis, div, 0);
                }
                /**
                 *
                 * @param {Array} nums
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                createIntegerVectorFromTDs(nums) {
                    let dims = nums.length;
                    let result = this.origin(dims);
                    for (let dim = 0; dim < dims; dim++) {
                        {
                            result.setComponent(dim, this.createAlgebraicNumberFromTD(nums[dim]));
                        }
                        ;
                    }
                    return result;
                }
                scaleBy(factors, whichIrrational) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {java.lang.StringBuffer} instances
                 * @param {number} w
                 */
                defineMultiplier(instances, w) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                getIrrational$int$int(i, format) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {number} i
                 * @param {number} format
                 * @return {string}
                 */
                getIrrational(i, format) {
                    if (((typeof i === 'number') || i === null) && ((typeof format === 'number') || format === null)) {
                        return this.getIrrational$int$int(i, format);
                    }
                    else if (((typeof i === 'number') || i === null) && format === undefined) {
                        return this.getIrrational$int(i);
                    }
                    else
                        throw new Error('invalid overload');
                }
                getIrrational$int(which) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {com.vzome.core.math.RealVector} target
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                nearestAlgebraicVector(target) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @return {*}
                 */
                getAffineScalar() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {Array} nums
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                createIntegerVector(nums) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {Array} data
                 * @return {com.vzome.core.algebra.AlgebraicMatrix}
                 */
                createMatrix(data) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @return {number}
                 */
                getNumMultipliers() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
            }
            jsweet.JsAlgebraicField = JsAlgebraicField;
            JsAlgebraicField["__class"] = "com.vzome.jsweet.JsAlgebraicField";
            JsAlgebraicField["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsManifestation {
                constructor(field, adapter, vectors) {
                    if (this.vectors === undefined)
                        this.vectors = null;
                    if (this.field === undefined)
                        this.field = null;
                    if (this.adapter === undefined)
                        this.adapter = null;
                    this.field = field;
                    this.adapter = adapter;
                    this.vectors = vectors;
                }
                getVectors() {
                    return this.vectors;
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Color}
                 */
                getColor() {
                    let colorful = (this.adapter["manifestationHasColor"]).apply(this.adapter, [this.vectors]);
                    if (!colorful)
                        return null;
                    let rgb = ((this.adapter["manifestationColor"]).apply(this.adapter, [this.vectors]) | 0);
                    return new com.vzome.core.construction.Color(rgb);
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Color} color
                 */
                setColor(color) {
                    if (color != null)
                        (this.adapter["setManifestationColor"]).apply(this.adapter, [this.vectors, color.getRGB()]);
                }
                /**
                 *
                 * @return {boolean}
                 */
                isRendered() {
                    return (this.adapter["manifestationRendered"]).apply(this.adapter, [this.vectors]);
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} mConstruction
                 */
                addConstruction(mConstruction) {
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} mConstruction
                 */
                removeConstruction(mConstruction) {
                }
                /**
                 *
                 * @return {boolean}
                 */
                isUnnecessary() {
                    return true;
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Construction}
                 */
                getFirstConstruction() {
                    return this.toConstruction();
                }
                static canonicalizeNumbers(...ns) {
                    return java.util.Arrays.stream(ns).map((n) => n.toTrailingDivisor()).toArray();
                }
                /**
                 * Note: this does NOT order the vectors canonically in the outermost array
                 * @param {Array} vs
                 * @return
                 * @return {Array}
                 */
                static canonicalizeVectors(...vs) {
                    return java.util.Arrays.stream(vs).map((v) => JsManifestation.canonicalizeNumbers.apply(this, v.getComponents())).toArray();
                }
                static canonicalizeConstruction(c) {
                    if (c != null && c instanceof com.vzome.core.construction.Point) {
                        let p = c;
                        return JsManifestation.canonicalizeVectors(p.getLocation());
                    }
                    else if (c != null && c instanceof com.vzome.core.construction.Segment) {
                        let s = c;
                        return JsManifestation.canonicalizeVectors(s.getStart(), s.getEnd());
                    }
                    else if (c != null && c instanceof com.vzome.core.construction.Polygon) {
                        return JsManifestation.canonicalizeVectors.apply(this, c.getVertices());
                    }
                    return null;
                }
                static manifest(vectors, field, adapter) {
                    switch ((vectors.length)) {
                        case 1:
                            return new com.vzome.jsweet.JsBall(field, adapter, vectors);
                        case 2:
                            return new com.vzome.jsweet.JsStrut(field, adapter, vectors);
                        default:
                            return new com.vzome.jsweet.JsPanel(field, adapter, vectors);
                    }
                }
                /**
                 *
                 * @param {boolean} b
                 */
                setHidden(b) {
                }
                /**
                 *
                 * @return {boolean}
                 */
                isHidden() {
                    return (this.adapter["manifestationHidden"]).apply(this.adapter, [this.vectors]);
                }
                /**
                 *
                 * @param {com.vzome.core.model.Group} container
                 */
                setContainer(container) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @return {com.vzome.core.model.Group}
                 */
                getContainer() {
                    let members = (this.adapter["getLargestGroup"]).apply(this.adapter, [this.vectors]);
                    if (members == null)
                        return null;
                    let group = new com.vzome.core.model.Group();
                    for (let i = 0; i < members.length; i++) {
                        {
                            group.add(JsManifestation.manifest(members[i], this.field, this.adapter));
                        }
                        ;
                    }
                    return group;
                }
                /**
                 *
                 * @return {*}
                 */
                getConstructions() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {*} doc
                 * @return {*}
                 */
                getXml(doc) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getCentroid() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
            }
            jsweet.JsManifestation = JsManifestation;
            JsManifestation["__class"] = "com.vzome.jsweet.JsManifestation";
            JsManifestation["__interfaces"] = ["com.vzome.core.model.GroupElement", "com.vzome.core.model.Manifestation"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsAlgebraicNumber {
                constructor(field, factors) {
                    if (this.field === undefined)
                        this.field = null;
                    if (this.factors === undefined)
                        this.factors = null;
                    this.field = field;
                    this.factors = (factors).slice();
                }
                /**
                 *
                 * @return {*}
                 */
                getField() {
                    return this.field;
                }
                /**
                 *
                 * @return {number}
                 */
                evaluate() {
                    return this.field.evaluateNumber(this.factors);
                }
                /**
                 *
                 * @return {Array}
                 */
                toTrailingDivisor() {
                    return (this.factors).slice();
                }
                plus$int(n) {
                    return n === 0 ? this : this.plus$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long(n));
                }
                plus$int$int(num, den) {
                    return this.plus$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long$long(num, den));
                }
                /**
                 *
                 * @param {number} num is the numerator of the rational value to be added
                 * @param {number} den is the denominator of the rational value to be added
                 * @return {*} this + (num / den)
                 */
                plus(num, den) {
                    if (((typeof num === 'number') || num === null) && ((typeof den === 'number') || den === null)) {
                        return this.plus$int$int(num, den);
                    }
                    else if (((num != null && (num["__interfaces"] != null && num["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || num.constructor != null && num.constructor["__interfaces"] != null && num.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || num === null) && den === undefined) {
                        return this.plus$com_vzome_core_algebra_AlgebraicNumber(num);
                    }
                    else if (((typeof num === 'number') || num === null) && den === undefined) {
                        return this.plus$int(num);
                    }
                    else
                        throw new Error('invalid overload');
                }
                plus$com_vzome_core_algebra_AlgebraicNumber(that) {
                    let factors = this.field.add(this.factors, that.factors);
                    return new JsAlgebraicNumber(this.field, factors);
                }
                minus$int(n) {
                    return n === 0 ? this : this.minus$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long(n));
                }
                minus$int$int(num, den) {
                    return this.minus$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long$long(num, den));
                }
                /**
                 *
                 * @param {number} num
                 * @param {number} den
                 * @return {*}
                 */
                minus(num, den) {
                    if (((typeof num === 'number') || num === null) && ((typeof den === 'number') || den === null)) {
                        return this.minus$int$int(num, den);
                    }
                    else if (((num != null && (num["__interfaces"] != null && num["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || num.constructor != null && num.constructor["__interfaces"] != null && num.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || num === null) && den === undefined) {
                        return this.minus$com_vzome_core_algebra_AlgebraicNumber(num);
                    }
                    else if (((typeof num === 'number') || num === null) && den === undefined) {
                        return this.minus$int(num);
                    }
                    else
                        throw new Error('invalid overload');
                }
                minus$com_vzome_core_algebra_AlgebraicNumber(that) {
                    let factors = this.field.subtract(this.factors, that.factors);
                    return new JsAlgebraicNumber(this.field, factors);
                }
                times$com_vzome_core_algebra_AlgebraicNumber(that) {
                    let factors = this.field.multiply(this.factors, that.factors);
                    return new JsAlgebraicNumber(this.field, factors);
                }
                dividedBy$int(divisor) {
                    return divisor === 1 ? this : this.times$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long$long(1, divisor));
                }
                dividedBy$int$int(num, den) {
                    return this.times$com_vzome_core_algebra_AlgebraicNumber(this.field.createRational$long$long(den, num));
                }
                /**
                 *
                 * @param {number} num
                 * @param {number} den
                 * @return {*}
                 */
                dividedBy(num, den) {
                    if (((typeof num === 'number') || num === null) && ((typeof den === 'number') || den === null)) {
                        return this.dividedBy$int$int(num, den);
                    }
                    else if (((num != null && (num["__interfaces"] != null && num["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || num.constructor != null && num.constructor["__interfaces"] != null && num.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || num === null) && den === undefined) {
                        return this.dividedBy$com_vzome_core_algebra_AlgebraicNumber(num);
                    }
                    else if (((typeof num === 'number') || num === null) && den === undefined) {
                        return this.dividedBy$int(num);
                    }
                    else
                        throw new Error('invalid overload');
                }
                dividedBy$com_vzome_core_algebra_AlgebraicNumber(that) {
                    let recip = this.field.reciprocal(that.factors);
                    let factors = this.field.multiply(this.factors, recip);
                    return new JsAlgebraicNumber(this.field, factors);
                }
                equals(that) {
                    return java.util.Arrays.equals(this.factors, that.factors);
                }
                /**
                 *
                 * @return {*}
                 */
                negate() {
                    let factors = this.field.negate(this.factors);
                    return new JsAlgebraicNumber(this.field, factors);
                }
                /**
                 *
                 * @return {boolean}
                 */
                isZero() {
                    for (let i = 0; i < this.factors.length - 1; i++) {
                        {
                            if (this.factors[i] !== 0)
                                return false;
                        }
                        ;
                    }
                    return true;
                }
                /**
                 *
                 * @return {boolean}
                 */
                isOne() {
                    if (this.factors[0] !== 1)
                        return false;
                    if (this.factors[this.factors.length - 1] !== 1)
                        return false;
                    for (let i = 1; i < this.factors.length - 1; i++) {
                        {
                            if (this.factors[i] !== 0)
                                return false;
                        }
                        ;
                    }
                    return true;
                }
                /**
                 *
                 * @return {*}
                 */
                reciprocal() {
                    return new JsAlgebraicNumber(this.field, this.field.reciprocal(this.factors));
                }
                /**
                 * @param {java.lang.StringBuffer} buf
                 * @param {number} format must be one of the following values.
                 * The result is formatted as follows:
                 * <br>
                 * {@code DEFAULT_FORMAT    // 4 + 3}<br>
                 * {@code EXPRESSION_FORMAT // 4 +3*phi}<br>
                 * {@code ZOMIC_FORMAT      // 4 3}<br>
                 * {@code VEF_FORMAT        // (3,4)}<br>
                 */
                getNumberExpression(buf, format) {
                    buf.append(this.toString(format));
                }
                /**
                 * @param {number} format must be one of the following values.
                 * The result is formatted as follows:
                 * <br>
                 * {@code DEFAULT_FORMAT    // 4 + 3}<br>
                 * {@code EXPRESSION_FORMAT // 4 +3*phi}<br>
                 * {@code ZOMIC_FORMAT      // 4 3}<br>
                 * {@code VEF_FORMAT        // (3,4)}
                 * @return {string}
                 */
                toString(format) {
                    return java.util.Arrays.toString(this.factors);
                }
                /**
                 *
                 * @param {*} other
                 * @return {number}
                 */
                compareTo(other) {
                    if (this === other) {
                        return 0;
                    }
                    if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(other, this)) {
                        return 0;
                    }
                    let d1 = this.evaluate();
                    let d2 = other.evaluate();
                    return /* compareTo */ ((o1, o2) => { if (o1 && o1.compareTo) {
                        return o1.compareTo(o2);
                    }
                    else {
                        return o1 < o2 ? -1 : o2 < o1 ? 1 : 0;
                    } })(d1, d2);
                }
                /**
                 *
                 * @param {*} other
                 * @return {boolean}
                 */
                greaterThan(other) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {*} other
                 * @return {boolean}
                 */
                lessThan(other) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {*} other
                 * @return {boolean}
                 */
                greaterThanOrEqualTo(other) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {*} other
                 * @return {boolean}
                 */
                lessThanOrEqualTo(other) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                times$int(n) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                times$int$int(num, den) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {number} num
                 * @param {number} den
                 * @return {*}
                 */
                times(num, den) {
                    if (((typeof num === 'number') || num === null) && ((typeof den === 'number') || den === null)) {
                        return this.times$int$int(num, den);
                    }
                    else if (((num != null && (num["__interfaces"] != null && num["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || num.constructor != null && num.constructor["__interfaces"] != null && num.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || num === null) && den === undefined) {
                        return this.times$com_vzome_core_algebra_AlgebraicNumber(num);
                    }
                    else if (((typeof num === 'number') || num === null) && den === undefined) {
                        return this.times$int(num);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {boolean}
                 */
                isRational() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @return {number}
                 */
                signum() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
            }
            jsweet.JsAlgebraicNumber = JsAlgebraicNumber;
            JsAlgebraicNumber["__class"] = "com.vzome.jsweet.JsAlgebraicNumber";
            JsAlgebraicNumber["__interfaces"] = ["com.vzome.core.algebra.Fields.Element", "com.vzome.core.algebra.AlgebraicNumber", "java.lang.Comparable"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsEditorModel {
                constructor(realizedModel, selection, kind, symmetries, symmetrySystems) {
                    if (this.realizedModel === undefined)
                        this.realizedModel = null;
                    if (this.selection === undefined)
                        this.selection = null;
                    if (this.kind === undefined)
                        this.kind = null;
                    if (this.symmetrySegment === undefined)
                        this.symmetrySegment = null;
                    if (this.symmetryCenter === undefined)
                        this.symmetryCenter = null;
                    if (this.symmetries === undefined)
                        this.symmetries = null;
                    if (this.symmetrySystems === undefined)
                        this.symmetrySystems = null;
                    this.realizedModel = realizedModel;
                    this.selection = selection;
                    this.kind = kind;
                    this.symmetries = symmetries;
                    this.symmetrySystems = symmetrySystems;
                    this.symmetryCenter = new com.vzome.core.construction.FreePoint(realizedModel.getField().origin(3));
                }
                setAdapter(adapter) {
                    this.realizedModel.setAdapter(adapter);
                    this.selection.setAdapter(adapter);
                }
                /**
                 *
                 * @return {*}
                 */
                getRealizedModel() {
                    return this.realizedModel;
                }
                /**
                 *
                 * @return {*}
                 */
                getSelection() {
                    return this.selection;
                }
                /**
                 *
                 * @return {*}
                 */
                get4dSymmetries() {
                    return this.kind;
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Segment}
                 */
                getSymmetrySegment() {
                    return this.symmetrySegment;
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Point}
                 */
                getCenterPoint() {
                    return this.symmetryCenter;
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} cons
                 * @return {boolean}
                 */
                hasFailedConstruction(cons) {
                    return false;
                }
                getSymmetrySystem$() {
                    return this.symmetries;
                }
                getSymmetrySystem$java_lang_String(name) {
                    return (this.symmetrySystems[name]);
                }
                /**
                 *
                 * @param {string} name
                 * @return {*}
                 */
                getSymmetrySystem(name) {
                    if (((typeof name === 'string') || name === null)) {
                        return this.getSymmetrySystem$java_lang_String(name);
                    }
                    else if (name === undefined) {
                        return this.getSymmetrySystem$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} cons
                 */
                addFailedConstruction(cons) {
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Construction} point
                 */
                setCenterPoint(point) {
                    this.symmetryCenter = point;
                }
                /**
                 *
                 * @param {com.vzome.core.construction.Segment} segment
                 */
                setSymmetrySegment(segment) {
                    this.symmetrySegment = segment;
                }
                /**
                 *
                 * @param {java.lang.Class} kind
                 * @return {com.vzome.core.construction.Construction}
                 */
                getSelectedConstruction(kind) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
            }
            jsweet.JsEditorModel = JsEditorModel;
            JsEditorModel["__class"] = "com.vzome.jsweet.JsEditorModel";
            JsEditorModel["__interfaces"] = ["com.vzome.core.editor.api.EditorModel", "com.vzome.core.editor.api.LegacyEditorModel", "com.vzome.core.editor.api.ImplicitSymmetryParameters", "com.vzome.core.editor.api.SymmetryAware"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsAdapter {
                static mapVectorToJava(vector, field) {
                    let ans = java.util.stream.Stream.of(vector).map((ints) => new com.vzome.jsweet.JsAlgebraicNumber(field, ints)).toArray();
                    return new com.vzome.core.algebra.AlgebraicVector(ans);
                }
                static mapVectorToJavascript(vector) {
                    return java.util.stream.Stream.of(vector.getComponents()).map((an) => an.toTrailingDivisor()).toArray();
                }
                static getZoneGrid(orbits, planeNormal) {
                    let gridPoints = (new java.util.ArrayList());
                    let field = orbits.getSymmetry().getField();
                    let normal = JsAdapter.mapVectorToJava(planeNormal, field);
                    let planeOrbits = new com.vzome.core.math.symmetry.PlaneOrbitSet(orbits.getOrbits(), normal);
                    for (let iterator = planeOrbits.zones(); iterator.hasNext();) {
                        {
                            let zone = iterator.next();
                            let orbit = zone.getDirection();
                            if (!orbit.isStandard())
                                continue;
                            let scale = orbit.getUnitLength();
                            for (let i = 0; i < 5; i++) {
                                {
                                    scale = scale['times$com_vzome_core_algebra_AlgebraicNumber'](field.createPower$int(1));
                                    let gridPoint = zone.normal().scale(scale);
                                    gridPoints.add(JsAdapter.mapVectorToJavascript(gridPoint));
                                }
                                ;
                            }
                        }
                        ;
                    }
                    return gridPoints.stream().toArray((size) => (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(size));
                }
            }
            jsweet.JsAdapter = JsAdapter;
            JsAdapter["__class"] = "com.vzome.jsweet.JsAdapter";
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                class OctahedralSymmetryPerspective extends com.vzome.core.kinds.AbstractSymmetryPerspective {
                    constructor(field) {
                        super(new com.vzome.core.math.symmetry.OctahedralSymmetry(field));
                        this.setDefaultGeometry(new com.vzome.core.viewing.OctahedralShapes("octahedral", "octahedra", this.symmetry));
                    }
                    /**
                     *
                     * @return {com.vzome.core.math.symmetry.OctahedralSymmetry}
                     */
                    getSymmetry() {
                        return this.symmetry;
                    }
                    /**
                     *
                     * @param {com.vzome.api.Tool.Kind} kind
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     * @return {*}
                     */
                    createToolFactories(kind, tools) {
                        let result = (new java.util.ArrayList());
                        switch ((kind)) {
                            case com.vzome.api.Tool.Kind.SYMMETRY:
                                result.add(new com.vzome.core.tools.OctahedralToolFactory(tools, this.symmetry));
                                result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, this.symmetry));
                                result.add(new com.vzome.core.tools.InversionTool.Factory(tools));
                                result.add(new com.vzome.core.tools.MirrorTool.Factory(tools));
                                result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry));
                                break;
                            case com.vzome.api.Tool.Kind.TRANSFORM:
                                result.add(new com.vzome.core.tools.ScalingTool.__com_vzome_core_tools_ScalingTool_Factory(tools, this.symmetry));
                                result.add(new com.vzome.core.tools.RotationTool.__com_vzome_core_tools_RotationTool_Factory(tools, this.symmetry));
                                result.add(new com.vzome.core.tools.TranslationTool.Factory(tools));
                                result.add(new com.vzome.core.tools.ProjectionTool.Factory(tools));
                                break;
                            case com.vzome.api.Tool.Kind.LINEAR_MAP:
                                result.add(new com.vzome.core.tools.LinearMapTool.Factory(tools, this.symmetry, false));
                                break;
                            default:
                                break;
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {com.vzome.api.Tool.Kind} kind
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     * @return {*}
                     */
                    predefineTools(kind, tools) {
                        let result = (new java.util.ArrayList());
                        switch ((kind)) {
                            case com.vzome.api.Tool.Kind.SYMMETRY:
                                result.add(new com.vzome.core.tools.OctahedralToolFactory(tools, this.symmetry).createPredefinedTool("octahedral around origin"));
                                result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, this.symmetry).createPredefinedTool("tetrahedral around origin"));
                                result.add(new com.vzome.core.tools.InversionTool.Factory(tools).createPredefinedTool("reflection through origin"));
                                result.add(new com.vzome.core.tools.MirrorTool.Factory(tools).createPredefinedTool("reflection through XY plane"));
                                result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, this.symmetry).createPredefinedTool("symmetry around green through origin"));
                                break;
                            case com.vzome.api.Tool.Kind.TRANSFORM:
                                result.add(new com.vzome.core.tools.ScalingTool.__com_vzome_core_tools_ScalingTool_Factory(tools, this.symmetry).createPredefinedTool("scale down"));
                                result.add(new com.vzome.core.tools.ScalingTool.__com_vzome_core_tools_ScalingTool_Factory(tools, this.symmetry).createPredefinedTool("scale up"));
                                result.add(new com.vzome.core.tools.RotationTool.__com_vzome_core_tools_RotationTool_Factory(tools, this.symmetry).createPredefinedTool("rotate around green through origin"));
                                result.add(new com.vzome.core.tools.TranslationTool.Factory(tools).createPredefinedTool("b1 move along +X"));
                                break;
                            default:
                                break;
                        }
                        return result;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getModelResourcePath() {
                        return "org/vorthmann/zome/app/octahedral-vef.vZome";
                    }
                }
                kinds.OctahedralSymmetryPerspective = OctahedralSymmetryPerspective;
                OctahedralSymmetryPerspective["__class"] = "com.vzome.core.kinds.OctahedralSymmetryPerspective";
                OctahedralSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.FieldApplication.SymmetryPerspective"];
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                class IcosahedralSymmetryPerspective extends com.vzome.core.kinds.AbstractSymmetryPerspective {
                    constructor(field) {
                        if (((field != null && (field["__interfaces"] != null && field["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let symm = new com.vzome.core.math.symmetry.IcosahedralSymmetry(field);
                                super(symm);
                                if (this.qSymmH4 === undefined)
                                    this.qSymmH4 = null;
                                if (this.qSymmH4_ROT === undefined)
                                    this.qSymmH4_ROT = null;
                                if (this.qSymmT2 === undefined)
                                    this.qSymmT2 = null;
                                if (this.cmdIcosasymm === undefined)
                                    this.cmdIcosasymm = null;
                                if (this.cmdTetrasymm === undefined)
                                    this.cmdTetrasymm = null;
                                if (this.cmdAxialsymm === undefined)
                                    this.cmdAxialsymm = null;
                                if (this.cmdH4symmetry === undefined)
                                    this.cmdH4symmetry = null;
                                if (this.cmdH4rotations === undefined)
                                    this.cmdH4rotations = null;
                                if (this.cmdIxTsymmetry === undefined)
                                    this.cmdIxTsymmetry = null;
                                if (this.cmdTxTsymmetry === undefined)
                                    this.cmdTxTsymmetry = null;
                                if (this.cmdVanOss600cell === undefined)
                                    this.cmdVanOss600cell = null;
                                if (this.qSymmH4 === undefined)
                                    this.qSymmH4 = null;
                                if (this.qSymmH4_ROT === undefined)
                                    this.qSymmH4_ROT = null;
                                if (this.qSymmT2 === undefined)
                                    this.qSymmT2 = null;
                                if (this.cmdIcosasymm === undefined)
                                    this.cmdIcosasymm = null;
                                if (this.cmdTetrasymm === undefined)
                                    this.cmdTetrasymm = null;
                                if (this.cmdAxialsymm === undefined)
                                    this.cmdAxialsymm = null;
                                if (this.cmdH4symmetry === undefined)
                                    this.cmdH4symmetry = null;
                                if (this.cmdH4rotations === undefined)
                                    this.cmdH4rotations = null;
                                if (this.cmdIxTsymmetry === undefined)
                                    this.cmdIxTsymmetry = null;
                                if (this.cmdTxTsymmetry === undefined)
                                    this.cmdTxTsymmetry = null;
                                if (this.cmdVanOss600cell === undefined)
                                    this.cmdVanOss600cell = null;
                                (() => {
                                    let icosadefaultShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "default", "solid connectors", this.symmetry);
                                    let lifelikeShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "lifelike", "lifelike", this.symmetry, icosadefaultShapes);
                                    let tinyShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "tiny", "tiny connectors", this.symmetry);
                                    let tinyDodecs = new com.vzome.core.viewing.ExportedVEFShapes(null, "dodecs", "small dodecahedra", "tiny dodecahedra", this.symmetry, tinyShapes);
                                    let bigZome = new com.vzome.core.viewing.ExportedVEFShapes(null, "bigzome", "Big Zome", this.symmetry, tinyShapes);
                                    let noTwist = new com.vzome.core.viewing.ExportedVEFShapes(null, "noTwist", "no-twist 121 zone", this.symmetry, true);
                                    let vienne2 = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne2", "Vienne", this.symmetry, icosadefaultShapes);
                                    let vienne3 = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne3", "Vienne lifelike", this.symmetry, vienne2);
                                    let vienne = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne", "Vienne 121 zone", this.symmetry, true);
                                    this.addShapes(icosadefaultShapes);
                                    this.addShapes(lifelikeShapes);
                                    this.addShapes(tinyShapes);
                                    this.addShapes(tinyDodecs);
                                    this.addShapes(bigZome);
                                    this.addShapes(noTwist);
                                    this.addShapes(vienne2);
                                    this.addShapes(vienne3);
                                    this.addShapes(vienne);
                                    this.setDefaultGeometry(icosadefaultShapes);
                                    let field = this.symmetry.getField();
                                    this.qSymmH4 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", field);
                                    this.qSymmH4_ROT = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H4_ROT", "com/vzome/core/math/symmetry/H4roots-rotationalSubgroup.vef", field);
                                    this.qSymmT2 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("2T", "com/vzome/core/math/symmetry/binaryTetrahedralGroup.vef", field);
                                    this.cmdIcosasymm = new com.vzome.core.commands.CommandSymmetry(this.symmetry);
                                    this.cmdTetrasymm = new com.vzome.core.commands.CommandTetrahedralSymmetry(this.symmetry);
                                    this.cmdAxialsymm = new com.vzome.core.commands.CommandAxialSymmetry(this.symmetry);
                                    this.cmdH4symmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4, this.qSymmH4);
                                    this.cmdH4rotations = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4_ROT, this.qSymmH4_ROT);
                                    this.cmdIxTsymmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4, this.qSymmT2);
                                    this.cmdTxTsymmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmT2, this.qSymmT2);
                                    this.cmdVanOss600cell = new com.vzome.core.commands.CommandVanOss600Cell();
                                })();
                            }
                        }
                        else if (((field != null && field instanceof com.vzome.core.math.symmetry.IcosahedralSymmetry) || field === null)) {
                            let __args = arguments;
                            let symm = __args[0];
                            super(symm);
                            if (this.qSymmH4 === undefined)
                                this.qSymmH4 = null;
                            if (this.qSymmH4_ROT === undefined)
                                this.qSymmH4_ROT = null;
                            if (this.qSymmT2 === undefined)
                                this.qSymmT2 = null;
                            if (this.cmdIcosasymm === undefined)
                                this.cmdIcosasymm = null;
                            if (this.cmdTetrasymm === undefined)
                                this.cmdTetrasymm = null;
                            if (this.cmdAxialsymm === undefined)
                                this.cmdAxialsymm = null;
                            if (this.cmdH4symmetry === undefined)
                                this.cmdH4symmetry = null;
                            if (this.cmdH4rotations === undefined)
                                this.cmdH4rotations = null;
                            if (this.cmdIxTsymmetry === undefined)
                                this.cmdIxTsymmetry = null;
                            if (this.cmdTxTsymmetry === undefined)
                                this.cmdTxTsymmetry = null;
                            if (this.cmdVanOss600cell === undefined)
                                this.cmdVanOss600cell = null;
                            if (this.qSymmH4 === undefined)
                                this.qSymmH4 = null;
                            if (this.qSymmH4_ROT === undefined)
                                this.qSymmH4_ROT = null;
                            if (this.qSymmT2 === undefined)
                                this.qSymmT2 = null;
                            if (this.cmdIcosasymm === undefined)
                                this.cmdIcosasymm = null;
                            if (this.cmdTetrasymm === undefined)
                                this.cmdTetrasymm = null;
                            if (this.cmdAxialsymm === undefined)
                                this.cmdAxialsymm = null;
                            if (this.cmdH4symmetry === undefined)
                                this.cmdH4symmetry = null;
                            if (this.cmdH4rotations === undefined)
                                this.cmdH4rotations = null;
                            if (this.cmdIxTsymmetry === undefined)
                                this.cmdIxTsymmetry = null;
                            if (this.cmdTxTsymmetry === undefined)
                                this.cmdTxTsymmetry = null;
                            if (this.cmdVanOss600cell === undefined)
                                this.cmdVanOss600cell = null;
                            (() => {
                                let icosadefaultShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "default", "solid connectors", this.symmetry);
                                let lifelikeShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "lifelike", "lifelike", this.symmetry, icosadefaultShapes);
                                let tinyShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "tiny", "tiny connectors", this.symmetry);
                                let tinyDodecs = new com.vzome.core.viewing.ExportedVEFShapes(null, "dodecs", "small dodecahedra", "tiny dodecahedra", this.symmetry, tinyShapes);
                                let bigZome = new com.vzome.core.viewing.ExportedVEFShapes(null, "bigzome", "Big Zome", this.symmetry, tinyShapes);
                                let noTwist = new com.vzome.core.viewing.ExportedVEFShapes(null, "noTwist", "no-twist 121 zone", this.symmetry, true);
                                let vienne2 = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne2", "Vienne", this.symmetry, icosadefaultShapes);
                                let vienne3 = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne3", "Vienne lifelike", this.symmetry, vienne2);
                                let vienne = new com.vzome.core.viewing.ExportedVEFShapes(null, "vienne", "Vienne 121 zone", this.symmetry, true);
                                this.addShapes(icosadefaultShapes);
                                this.addShapes(lifelikeShapes);
                                this.addShapes(tinyShapes);
                                this.addShapes(tinyDodecs);
                                this.addShapes(bigZome);
                                this.addShapes(noTwist);
                                this.addShapes(vienne2);
                                this.addShapes(vienne3);
                                this.addShapes(vienne);
                                this.setDefaultGeometry(icosadefaultShapes);
                                let field = this.symmetry.getField();
                                this.qSymmH4 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", field);
                                this.qSymmH4_ROT = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H4_ROT", "com/vzome/core/math/symmetry/H4roots-rotationalSubgroup.vef", field);
                                this.qSymmT2 = new com.vzome.core.math.symmetry.QuaternionicSymmetry("2T", "com/vzome/core/math/symmetry/binaryTetrahedralGroup.vef", field);
                                this.cmdIcosasymm = new com.vzome.core.commands.CommandSymmetry(this.symmetry);
                                this.cmdTetrasymm = new com.vzome.core.commands.CommandTetrahedralSymmetry(this.symmetry);
                                this.cmdAxialsymm = new com.vzome.core.commands.CommandAxialSymmetry(this.symmetry);
                                this.cmdH4symmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4, this.qSymmH4);
                                this.cmdH4rotations = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4_ROT, this.qSymmH4_ROT);
                                this.cmdIxTsymmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmH4, this.qSymmT2);
                                this.cmdTxTsymmetry = new com.vzome.core.commands.CommandQuaternionSymmetry(this.qSymmT2, this.qSymmT2);
                                this.cmdVanOss600cell = new com.vzome.core.commands.CommandVanOss600Cell();
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {com.vzome.core.math.symmetry.IcosahedralSymmetry}
                     */
                    getSymmetry() {
                        return this.symmetry;
                    }
                    /**
                     *
                     * @param {com.vzome.api.Tool.Kind} kind
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     * @return {*}
                     */
                    createToolFactories(kind, tools) {
                        let result = (new java.util.ArrayList());
                        let icosaSymm = this.getSymmetry();
                        switch ((kind)) {
                            case com.vzome.api.Tool.Kind.SYMMETRY:
                                result.add(new com.vzome.core.tools.IcosahedralToolFactory(tools, icosaSymm));
                                result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, icosaSymm));
                                result.add(new com.vzome.core.tools.InversionTool.Factory(tools));
                                result.add(new com.vzome.core.tools.MirrorTool.Factory(tools));
                                result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, icosaSymm));
                                break;
                            case com.vzome.api.Tool.Kind.TRANSFORM:
                                result.add(new com.vzome.core.tools.ScalingTool.__com_vzome_core_tools_ScalingTool_Factory(tools, icosaSymm));
                                result.add(new com.vzome.core.tools.RotationTool.__com_vzome_core_tools_RotationTool_Factory(tools, icosaSymm));
                                result.add(new com.vzome.core.tools.TranslationTool.Factory(tools));
                                result.add(new com.vzome.core.tools.ProjectionTool.Factory(tools));
                                break;
                            case com.vzome.api.Tool.Kind.LINEAR_MAP:
                                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, true, true, true));
                                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, true, false, true));
                                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, true, true, false));
                                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, true, false, false));
                                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, false, true, false));
                                result.add(new com.vzome.core.tools.AxialStretchTool.Factory(tools, icosaSymm, false, false, false));
                                result.add(new com.vzome.core.tools.LinearMapTool.Factory(tools, icosaSymm, false));
                                break;
                            default:
                                break;
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {com.vzome.api.Tool.Kind} kind
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     * @return {*}
                     */
                    predefineTools(kind, tools) {
                        let result = (new java.util.ArrayList());
                        let icosaSymm = this.getSymmetry();
                        switch ((kind)) {
                            case com.vzome.api.Tool.Kind.SYMMETRY:
                                result.add(new com.vzome.core.tools.IcosahedralToolFactory(tools, icosaSymm).createPredefinedTool("icosahedral around origin"));
                                result.add(new com.vzome.core.tools.TetrahedralToolFactory(tools, icosaSymm).createPredefinedTool("tetrahedral around origin"));
                                result.add(new com.vzome.core.tools.InversionTool.Factory(tools).createPredefinedTool("reflection through origin"));
                                result.add(new com.vzome.core.tools.MirrorTool.Factory(tools).createPredefinedTool("reflection through XY plane"));
                                result.add(new com.vzome.core.tools.AxialSymmetryToolFactory(tools, icosaSymm).createPredefinedTool("symmetry around red through origin"));
                                break;
                            case com.vzome.api.Tool.Kind.TRANSFORM:
                                result.add(new com.vzome.core.tools.ScalingTool.__com_vzome_core_tools_ScalingTool_Factory(tools, icosaSymm).createPredefinedTool("scale down"));
                                result.add(new com.vzome.core.tools.ScalingTool.__com_vzome_core_tools_ScalingTool_Factory(tools, icosaSymm).createPredefinedTool("scale up"));
                                result.add(new com.vzome.core.tools.RotationTool.__com_vzome_core_tools_RotationTool_Factory(tools, icosaSymm).createPredefinedTool("rotate around red through origin"));
                                result.add(new com.vzome.core.tools.TranslationTool.Factory(tools).createPredefinedTool("b1 move along +X"));
                                break;
                            default:
                                break;
                        }
                        return result;
                    }
                    /**
                     *
                     * @param {string} action
                     * @return {*}
                     */
                    getLegacyCommand(action) {
                        switch ((action)) {
                            case "icosasymm":
                                return this.cmdIcosasymm;
                            case "tetrasymm":
                                return this.cmdTetrasymm;
                            case "axialsymm":
                                return this.cmdAxialsymm;
                            case "h4symmetry":
                                return this.cmdH4symmetry;
                            case "h4rotations":
                                return this.cmdH4rotations;
                            case "IxTsymmetry":
                                return this.cmdIxTsymmetry;
                            case "TxTsymmetry":
                                return this.cmdTxTsymmetry;
                            case "vanOss600cell":
                                return this.cmdVanOss600cell;
                            default:
                                return super.getLegacyCommand(action);
                        }
                    }
                    getQuaternionSymmetry(name) {
                        switch ((name)) {
                            case "H_4":
                                return this.qSymmH4;
                            case "H4_ROT":
                                return this.qSymmH4_ROT;
                            case "2T":
                                return this.qSymmT2;
                            default:
                                return null;
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getModelResourcePath() {
                        return "org/vorthmann/zome/app/icosahedral-vef.vZome";
                    }
                }
                kinds.IcosahedralSymmetryPerspective = IcosahedralSymmetryPerspective;
                IcosahedralSymmetryPerspective["__class"] = "com.vzome.core.kinds.IcosahedralSymmetryPerspective";
                IcosahedralSymmetryPerspective["__interfaces"] = ["com.vzome.core.editor.FieldApplication.SymmetryPerspective"];
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var kinds;
            (function (kinds) {
                /**
                 * Everything here is stateless, or at worst, a cache (like Shapes).
                 * An instance of this can be shared by many DocumentModels.
                 * This is why it does not have tool factories, though it does
                 * dictate what tool factories will be present.
                 *
                 * @author vorth
                 * @param {*} field
                 * @class
                 * @extends com.vzome.core.kinds.DefaultFieldApplication
                 */
                class GoldenFieldApplication extends com.vzome.core.kinds.DefaultFieldApplication {
                    constructor(field) {
                        super(field);
                        if (this.icosahedralPerspective === undefined)
                            this.icosahedralPerspective = null;
                        this.h4Builder = null;
                        this.cmdTauDivide = new com.vzome.core.commands.CommandTauDivision();
                        this.icosahedralPerspective = new com.vzome.core.kinds.IcosahedralSymmetryPerspective(this.getField());
                        let octahedralPerspective = super.getDefaultSymmetryPerspective();
                        let symm = octahedralPerspective.getSymmetry();
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("yellow", 0, 4, [[0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]], true, false, this.getField()['createPower$int'](-1));
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("green", 1, 8, [[1, 1, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1]], true, true, this.getField()['createRational$long'](2));
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("lavender", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[2, 1, -1, 1], [0, 1, 1, 1], [2, 1, -1, 1]]);
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("olive", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 1, 1], [0, 1, 1, 1], [2, 1, -1, 1]]);
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("maroon", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 1, 1, 1], [3, 1, -1, 1], [1, 1, -1, 1]]);
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("brown", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 1, 1, 1], [-1, 1, 1, 1], [-2, 1, 2, 1]]);
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("red", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 1, 1], [1, 1, 0, 1], [0, 1, 0, 1]]);
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("purple", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 1, 1], [0, 1, 0, 1], [-1, 1, 0, 1]], false, false, this.getField()['createPower$int'](-1));
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("black", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 2, 0, 1], [0, 1, 1, 2], [-1, 2, 1, 2]], false, false, this.getField()['createRational$long'](2));
                        symm.createZoneOrbit$java_lang_String$int$int$int_A_A("turquoise", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 2, 1], [3, 1, 4, 1], [3, 1, 4, 1]]);
                        let defaultShapes = new com.vzome.core.viewing.ExportedVEFShapes(null, "octahedral", "trapezoids", symm, null);
                        octahedralPerspective.setDefaultGeometry(defaultShapes);
                        octahedralPerspective.addShapes(new com.vzome.core.viewing.ExportedVEFShapes(null, "octahedralFast", "small octahedra", symm, null));
                        octahedralPerspective.addShapes(new com.vzome.core.viewing.ExportedVEFShapes(null, "octahedralRealistic", "vZome logo", symm, defaultShapes));
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getSymmetryPerspectives() {
                        return java.util.Arrays.asList(this.icosahedralPerspective, super.getDefaultSymmetryPerspective());
                    }
                    /**
                     *
                     * @return {*}
                     */
                    getDefaultSymmetryPerspective() {
                        return this.icosahedralPerspective;
                    }
                    /**
                     *
                     * @param {string} symmName
                     * @return {*}
                     */
                    getSymmetryPerspective(symmName) {
                        switch ((symmName)) {
                            case "icosahedral":
                                return this.icosahedralPerspective;
                            default:
                                return super.getSymmetryPerspective(symmName);
                        }
                    }
                    /**
                     *
                     * @param {string} name
                     * @return {com.vzome.core.math.symmetry.QuaternionicSymmetry}
                     */
                    getQuaternionSymmetry(name) {
                        return this.icosahedralPerspective.getQuaternionSymmetry(name);
                    }
                    /**
                     *
                     * @param {*} toolFactories
                     * @param {com.vzome.core.editor.ToolsModel} tools
                     */
                    registerToolFactories(toolFactories, tools) {
                        super.registerToolFactories(toolFactories, tools);
                        let symm = this.icosahedralPerspective.getSymmetry();
                        toolFactories.put("AxialStretchTool", new com.vzome.core.tools.AxialStretchTool.Factory(tools, symm, false, false, false));
                        toolFactories.put("SymmetryTool", new com.vzome.core.tools.IcosahedralToolFactory(tools, symm));
                    }
                    /**
                     *
                     * @param {string} groupName
                     * @param {number} index
                     * @param {number} edgesToRender
                     * @param {Array} edgeScales
                     * @param {*} listener
                     */
                    constructPolytope(groupName, index, edgesToRender, edgeScales, listener) {
                        switch ((groupName)) {
                            case "H4":
                                if (this.h4Builder == null) {
                                    let qsymm = new com.vzome.core.math.symmetry.QuaternionicSymmetry("H_4", "com/vzome/core/math/symmetry/H4roots.vef", this.getField());
                                    this.h4Builder = new com.vzome.core.commands.CommandUniformH4Polytope(this.getField(), qsymm, 0);
                                }
                                this.h4Builder.generate(index, edgesToRender, edgeScales, listener);
                                break;
                            default:
                                super.constructPolytope(groupName, index, edgesToRender, edgeScales, listener);
                                break;
                        }
                    }
                    /**
                     *
                     * @param {string} action
                     * @return {*}
                     */
                    getLegacyCommand(action) {
                        switch ((action)) {
                            case "tauDivide":
                                return this.cmdTauDivide;
                            default:
                                return super.getLegacyCommand(action);
                        }
                    }
                }
                kinds.GoldenFieldApplication = GoldenFieldApplication;
                GoldenFieldApplication["__class"] = "com.vzome.core.kinds.GoldenFieldApplication";
                GoldenFieldApplication["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetries4D", "com.vzome.core.editor.FieldApplication"];
            })(kinds = core.kinds || (core.kinds = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var viewing;
            (function (viewing) {
                class OctahedralShapes extends com.vzome.core.viewing.AbstractShapes {
                    constructor(pkgName, name, symm) {
                        super(pkgName, name, null, symm);
                    }
                    /**
                     *
                     * @param {string} pkgName
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    buildConnectorShape(pkgName) {
                        let field = this.mSymmetry.getField();
                        let cube = new com.vzome.core.math.Polyhedron(field);
                        let scale = field['createPower$int'](-2);
                        scale = field['createRational$long'](2)['times$com_vzome_core_algebra_AlgebraicNumber'](scale);
                        let x = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                        let y = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
                        let z = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                        cube.addVertex(x.scale(scale));
                        cube.addVertex(x.negate().scale(scale));
                        cube.addVertex(y.scale(scale));
                        cube.addVertex(y.negate().scale(scale));
                        cube.addVertex(z.scale(scale));
                        cube.addVertex(z.negate().scale(scale));
                        let face = cube.newFace();
                        face.add(0);
                        face.add(2);
                        face.add(4);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(0);
                        face.add(5);
                        face.add(2);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(0);
                        face.add(3);
                        face.add(5);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(0);
                        face.add(4);
                        face.add(3);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(1);
                        face.add(4);
                        face.add(2);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(1);
                        face.add(2);
                        face.add(5);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(1);
                        face.add(5);
                        face.add(3);
                        cube.addFace(face);
                        face = cube.newFace();
                        face.add(1);
                        face.add(3);
                        face.add(4);
                        cube.addFace(face);
                        return cube;
                    }
                }
                viewing.OctahedralShapes = OctahedralShapes;
                OctahedralShapes["__class"] = "com.vzome.core.viewing.OctahedralShapes";
                OctahedralShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];
            })(viewing = core.viewing || (core.viewing = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     * @param {*} field
                     * @class
                     * @extends com.vzome.core.math.symmetry.AbstractSymmetry
                     */
                    class IcosahedralSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
                        constructor(field) {
                            super(60, field, "blue");
                            this.INCIDENCES = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                                return 0;
                            }
                            else {
                                let array = [];
                                for (let i = 0; i < dims[0]; i++) {
                                    array.push(allocate(dims.slice(1)));
                                }
                                return array;
                            } }; return allocate(dims); })([60, 3]);
                            this.IDENTITY = new com.vzome.core.math.symmetry.Permutation(this, null);
                            if (this.preferredAxis === undefined)
                                this.preferredAxis = null;
                            this.tetrahedralSubgroup = [null, null, null, null, null];
                            this.blueTetrahedral = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(60);
                            this.greenTetrahedral = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(60);
                            this.yellowTetrahedral = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(60);
                            for (let i = 0; i < this.INCIDENCES.length; i++) {
                                {
                                    this.INCIDENCES[i][0] = this.getPermutation(i).mapIndex(30);
                                    this.INCIDENCES[i][1] = this.getPermutation(i).mapIndex(45);
                                    this.INCIDENCES[i][2] = this.getPermutation(i).mapIndex(42);
                                }
                                ;
                            }
                            this.tetrahedralSubgroup[0] = this.closure([1, 15]);
                            this.tetrahedralSubgroup[1] = this.closure([11, 20]);
                            this.tetrahedralSubgroup[2] = this.closure([27, 58]);
                            this.tetrahedralSubgroup[3] = this.closure([17, 4]);
                            this.tetrahedralSubgroup[4] = this.closure([55, 14]);
                            let blueOrbit = this.getDirection("blue");
                            let yellowOrbit = this.getDirection("yellow");
                            for (let i = 0; i < 60; i++) {
                                {
                                    let blueZone = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, i);
                                    let yellowZone = yellowOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, i);
                                    for (let j = 0; j < this.tetrahedralSubgroup.length; j++) {
                                        {
                                            for (let k = 0; k < this.tetrahedralSubgroup[j].length; k++) {
                                                {
                                                    if (this.tetrahedralSubgroup[j][k] === blueZone.getRotation())
                                                        this.blueTetrahedral[i] = j;
                                                    if (this.tetrahedralSubgroup[j][k] === yellowZone.getRotation())
                                                        this.yellowTetrahedral[i] = j;
                                                }
                                                ;
                                            }
                                        }
                                        ;
                                    }
                                }
                                ;
                            }
                            let greenSeeds = [6, 9, 12, 0, 3];
                            for (let j = 0; j < this.tetrahedralSubgroup.length; j++) {
                                {
                                    let seedAxis = greenSeeds[j];
                                    for (let k = 0; k < this.tetrahedralSubgroup[j].length; k++) {
                                        {
                                            let mappedAxis = this.mOrientations[this.tetrahedralSubgroup[j][k]].mapIndex(seedAxis);
                                            this.greenTetrahedral[mappedAxis] = j;
                                        }
                                        ;
                                    }
                                }
                                ;
                            }
                        }
                        /**
                         *
                         * @param {number} orientation
                         * @return {Array}
                         */
                        getIncidentOrientations(orientation) {
                            return this.INCIDENCES[orientation];
                        }
                        /**
                         * Create a collection of blue-axis normals from a prototype,
                         * by applying known rotations.
                         * @param {com.vzome.core.math.symmetry.Direction} dir
                         * @param {number} prototype
                         * @param {number} rotated
                         * @param {com.vzome.core.algebra.AlgebraicVector} xyz
                         * @private
                         */
                        /*private*/ createBlueAxes(dir, prototype, rotated, xyz) {
                            let orientation = 0;
                            let reflect = [false, false, false];
                            for (let i = 0; i < 3; i++) {
                                {
                                    for (let k = 0; k < 2; k++) {
                                        {
                                            for (let l = 0; l < 2; l++) {
                                                {
                                                    let unit = this.mOrientations[orientation].mapIndex(prototype);
                                                    if (dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, unit) == null) {
                                                        let rot = this.mOrientations[orientation].mapIndex(rotated);
                                                        let rotation = this.getMapping(unit, rot);
                                                        let norm = this.mField.origin(3);
                                                        for (let m = 0; m < 3; m++) {
                                                            {
                                                                let offset = ((m + 3 - i) % 3);
                                                                if (reflect[m]) {
                                                                    norm.setComponent(m, xyz.getComponent(offset).negate());
                                                                }
                                                                else {
                                                                    norm.setComponent(m, xyz.getComponent(offset));
                                                                }
                                                            }
                                                            ;
                                                        }
                                                        dir.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(unit, rotation, norm);
                                                        dir.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(rot, rotation, norm);
                                                    }
                                                    orientation = this.mOrientations[45].mapIndex(orientation);
                                                    reflect[0] = !reflect[0];
                                                    reflect[2] = !reflect[2];
                                                }
                                                ;
                                            }
                                            orientation = this.mOrientations[15].mapIndex(orientation);
                                            reflect[1] = !reflect[1];
                                            reflect[2] = !reflect[2];
                                        }
                                        ;
                                    }
                                    orientation = this.mOrientations[1].mapIndex(orientation);
                                }
                                ;
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "icosahedral";
                        }
                        /**
                         *
                         * @return {Array}
                         */
                        getOrbitTriangle() {
                            let twice = this.mField['createRational$long'](2);
                            let blueVertex = this.getDirection("blue").getPrototype().scale(twice);
                            let redVertex = this.getDirection("red").getPrototype();
                            let phiInv = this.mField.getGoldenRatio().reciprocal();
                            let yellowVertex = this.getDirection("yellow").getPrototype().scale(phiInv);
                            return [blueVertex, redVertex, yellowVertex];
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.Symmetry.SpecialOrbit} which
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getSpecialOrbit(which) {
                            switch ((which)) {
                                case com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.BLUE:
                                    return this.getDirection("blue");
                                case com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.RED:
                                    return this.getDirection("red");
                                case com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.YELLOW:
                                    return this.getDirection("yellow");
                                default:
                                    return this.getDirection("black");
                            }
                        }
                        /**
                         *
                         * @param {string} frameColor
                         */
                        createFrameOrbit(frameColor) {
                            let xAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                            let dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(frameColor, 0, 15, xAxis, true, true, this.mField['createRational$long'](2));
                            dir.setScaleNames(["b0", "b1", "b2", "b3"]);
                            this.createBlueAxes(dir, 0, 15, xAxis);
                            this.createBlueAxes(dir, 9, 13, this.mField.createVector([[1, 2, 0, 1], [0, 1, 1, 2], [-1, 2, 1, 2]]));
                            this.createBlueAxes(dir, 6, 49, this.mField.createVector([[1, 2, 0, 1], [0, 1, 1, 2], [1, 2, -1, 2]]));
                            for (let p = 0; p < this.mOrientations.length; p++) {
                                {
                                    let x = this.mOrientations[p].mapIndex(0);
                                    let y = this.mOrientations[p].mapIndex(1);
                                    let z = this.mOrientations[p].mapIndex(2);
                                    this.mMatrices[p] = new com.vzome.core.algebra.AlgebraicMatrix(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, x).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, y).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, z).normal());
                                    let axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, p);
                                    let norm = this.mMatrices[p].timesColumn(xAxis);
                                    if (!norm.equals(axis.normal()))
                                        throw new java.lang.IllegalStateException("matrix wrong: " + p);
                                }
                                ;
                            }
                        }
                        /**
                         *
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getPreferredAxis() {
                            return this.preferredAxis;
                        }
                        /**
                         * @see com.vzome.core.math.symmetry.AbstractSymmetry#createOtherOrbits()
                         *
                         * @see com.vzome.core.algebra.AlgebraicField#createVector()
                         *
                         * @see com.vzome.core.math.symmetry.AbstractSymmetry#createZoneOrbit(String, int, int, AlgebraicVector, boolean, boolean, AlgebraicNumber)
                         */
                        createOtherOrbits() {
                            let dir;
                            dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("red", 0, 3, this.mField.createVector([[0, 1, 1, 1], [1, 1, 0, 1], [0, 1, 0, 1]]), true);
                            dir.setScaleNames(["r0", "r1", "r2", "r3"]);
                            this.preferredAxis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1);
                            dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("yellow", 0, 27, this.mField.createVector([[1, 1, 1, 1], [0, 1, 0, 1], [-1, 1, 0, 1]]), true, false, this.mField['createPower$int'](-1));
                            dir.setScaleNames(["y0", "y1", "y2", "y3"]);
                            dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("green", 6, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[1, 1, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1]]), true, true, this.mField['createRational$long'](2));
                            dir.setScaleNames(["g0", "g1", "g2", "g3"]);
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("orange", 6, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[1, 1, 0, 1], [0, 1, 1, 1], [0, 1, 0, 1]]));
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("purple", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[1, 1, 1, 1], [1, 1, 0, 1], [0, 1, 0, 1]]), false, false, this.mField['createPower$int'](-1));
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("black", 3, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[0, 1, 1, 1], [1, 1, 0, 1], [1, 1, -1, 1]]));
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("lavender", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[2, 1, -1, 1], [0, 1, 1, 1], [2, 1, -1, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("olive", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[0, 1, 1, 1], [0, 1, 1, 1], [2, 1, -1, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("maroon", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-1, 1, 1, 1], [3, 1, -1, 1], [1, 1, -1, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("rose", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[2, 1, -1, 1], [-1, 1, 2, 1], [0, 1, 0, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber("navy", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-1, 1, 2, 1], [1, 1, 1, 1], [0, 1, 0, 1]]), false, false, this.mField['createPower$int'](-1)).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("turquoise", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[2, 1, 0, 1], [2, 1, -1, 1], [-3, 1, 2, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("coral", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-3, 1, 3, 1], [0, 1, 0, 1], [1, 1, 0, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("sulfur", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-3, 1, 3, 1], [2, 1, -1, 1], [0, 1, 0, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("sand", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-2, 1, 2, 1], [-2, 1, 2, 1], [2, 1, 0, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("apple", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[5, 1, -3, 1], [1, 1, 0, 1], [0, 1, 1, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("cinnamon", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[5, 1, -3, 1], [2, 1, -1, 1], [2, 1, 0, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("spruce", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-3, 1, 2, 1], [-3, 1, 2, 1], [5, 1, -2, 1]])).withCorrection();
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector("brown", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, this.mField.createVector([[-1, 1, 1, 1], [-1, 1, 1, 1], [-2, 1, 2, 1]])).withCorrection();
                        }
                        /**
                         *
                         */
                        createInitialPermutations() {
                            let ORDER = 60;
                            this.mOrientations[0] = this.IDENTITY;
                            let map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(ORDER);
                            for (let i = 0; i < 15; i++) {
                                {
                                    map[i] = i + 15;
                                    map[i + 15] = i;
                                    map[i + 30] = i + 45;
                                    map[i + 45] = i + 30;
                                }
                                ;
                            }
                            this.mOrientations[15] = new com.vzome.core.math.symmetry.Permutation(this, map);
                            map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(ORDER);
                            let starts = [[0, 1, 2], [15, 46, 32], [16, 47, 30], [17, 45, 31]];
                            for (let index202 = 0; index202 < starts.length; index202++) {
                                let start = starts[index202];
                                {
                                    for (let j = 0; j < start.length; j++) {
                                        {
                                            for (let k = 0; k < 5; k++) {
                                                {
                                                    map[start[j] + k * 3] = start[(j + 1) % 3] + k * 3;
                                                }
                                                ;
                                            }
                                        }
                                        ;
                                    }
                                }
                            }
                            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
                            map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(ORDER);
                            let cycles = [[0, 3, 6, 9, 12], [30, 42, 39, 36, 33], [2, 21, 29, 55, 4], [5, 24, 17, 58, 7], [8, 27, 20, 46, 10], [11, 15, 23, 49, 13], [1, 14, 18, 26, 52], [16, 50, 57, 38, 40], [19, 53, 45, 41, 43], [22, 56, 48, 44, 31], [25, 59, 51, 32, 34], [28, 47, 54, 35, 37]];
                            for (let index203 = 0; index203 < cycles.length; index203++) {
                                let cycle = cycles[index203];
                                {
                                    for (let j = 0; j < cycle.length; j++) {
                                        {
                                            map[cycle[j]] = cycle[(j + 1) % 5];
                                        }
                                        ;
                                    }
                                }
                            }
                            this.mOrientations[3] = new com.vzome.core.math.symmetry.Permutation(this, map);
                        }
                        subgroup$java_lang_String(name) {
                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL, name))
                                return this.tetrahedralSubgroup[0];
                            return null;
                        }
                        /**
                         *
                         * @param {string} color
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getDirection(color) {
                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })("spring", color))
                                color = "apple";
                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })("tan", color))
                                color = "sand";
                            return super.getDirection(color);
                        }
                        subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis(name, zone) {
                            return this.subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis$boolean(name, zone, true);
                        }
                        subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis$boolean(name, zone, allowYellow) {
                            let orientation = zone.getOrientation();
                            let orbit = zone.getDirection();
                            let orbitName = orbit.getName();
                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(orbitName, "blue")) {
                                let subgroup = this.blueTetrahedral[orientation];
                                return this.tetrahedralSubgroup[subgroup];
                            }
                            else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(orbitName, "green")) {
                                let subgroup = this.greenTetrahedral[orientation];
                                return this.tetrahedralSubgroup[subgroup];
                            }
                            else if (allowYellow && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(orbitName, "yellow")) {
                                let subgroup = this.yellowTetrahedral[orientation];
                                return this.tetrahedralSubgroup[subgroup];
                            }
                            return null;
                        }
                        subgroup(name, zone, allowYellow) {
                            if (((typeof name === 'string') || name === null) && ((zone != null && zone instanceof com.vzome.core.math.symmetry.Axis) || zone === null) && ((typeof allowYellow === 'boolean') || allowYellow === null)) {
                                return this.subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis$boolean(name, zone, allowYellow);
                            }
                            else if (((typeof name === 'string') || name === null) && ((zone != null && zone instanceof com.vzome.core.math.symmetry.Axis) || zone === null) && allowYellow === undefined) {
                                return this.subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis(name, zone);
                            }
                            else if (((typeof name === 'string') || name === null) && zone === undefined && allowYellow === undefined) {
                                return this.subgroup$java_lang_String(name);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        blueTetrahedralFromGreen(greenIndex) {
                            let subgroup = this.greenTetrahedral[greenIndex];
                            for (let i = 0; i < this.blueTetrahedral.length; i++) {
                                {
                                    if (this.blueTetrahedral[i] === subgroup)
                                        return i;
                                }
                                ;
                            }
                            return 0;
                        }
                    }
                    symmetry.IcosahedralSymmetry = IcosahedralSymmetry;
                    IcosahedralSymmetry["__class"] = "com.vzome.core.math.symmetry.IcosahedralSymmetry";
                    IcosahedralSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "java.lang.Iterable", "com.vzome.core.math.symmetry.Embedding"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     *
                     * @param {*} field
                     * @class
                     * @extends com.vzome.core.math.symmetry.AbstractSymmetry
                     */
                    class OctahedralSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
                        constructor(field, frameColor) {
                            if (((field != null && (field["__interfaces"] != null && field["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((typeof frameColor === 'string') || frameColor === null)) {
                                let __args = arguments;
                                super(OctahedralSymmetry.ORDER, field, frameColor);
                                if (this.frameColor === undefined)
                                    this.frameColor = null;
                                if (this.tetrahedralSubgroup === undefined)
                                    this.tetrahedralSubgroup = null;
                                this.IDENTITY = new com.vzome.core.math.symmetry.Permutation(this, null);
                                if (this.frameColor === undefined)
                                    this.frameColor = null;
                                if (this.tetrahedralSubgroup === undefined)
                                    this.tetrahedralSubgroup = null;
                                (() => {
                                    this.frameColor = frameColor;
                                    this.tetrahedralSubgroup = this.closure([0, 2, 4]);
                                })();
                            }
                            else if (((field != null && (field["__interfaces"] != null && field["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && frameColor === undefined) {
                                let __args = arguments;
                                {
                                    let __args = arguments;
                                    let frameColor = "blue";
                                    super(OctahedralSymmetry.ORDER, field, frameColor);
                                    if (this.frameColor === undefined)
                                        this.frameColor = null;
                                    if (this.tetrahedralSubgroup === undefined)
                                        this.tetrahedralSubgroup = null;
                                    this.IDENTITY = new com.vzome.core.math.symmetry.Permutation(this, null);
                                    if (this.frameColor === undefined)
                                        this.frameColor = null;
                                    if (this.tetrahedralSubgroup === undefined)
                                        this.tetrahedralSubgroup = null;
                                    (() => {
                                        this.frameColor = frameColor;
                                        this.tetrahedralSubgroup = this.closure([0, 2, 4]);
                                    })();
                                }
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.Symmetry.SpecialOrbit} which
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getSpecialOrbit(which) {
                            switch ((which)) {
                                case com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.BLUE:
                                    return this.getDirection(this.frameColor);
                                case com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.RED:
                                    return this.getDirection("green");
                                case com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.YELLOW:
                                    return this.getDirection("yellow");
                                default:
                                    return null;
                            }
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        reverseOrbitTriangle() {
                            return true;
                        }
                        /**
                         *
                         * @return {Array}
                         */
                        getOrbitTriangle() {
                            let greenVertex = this.getDirection("green").getPrototype();
                            let blueVertex = this.getDirection("blue").getPrototype();
                            let yellowVertex = this.getDirection("yellow").getPrototype();
                            return [greenVertex, blueVertex, yellowVertex];
                        }
                        /**
                         *
                         */
                        createInitialPermutations() {
                            this.mOrientations[0] = this.IDENTITY;
                            let map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(OctahedralSymmetry.ORDER);
                            for (let i = 0; i < 6; i++) {
                                for (let j = 0; j < 4; j++) {
                                    map[i * 4 + j] = i * 4 + ((j + 1) % 4);
                                }
                                ;
                            }
                            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
                            map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(OctahedralSymmetry.ORDER);
                            let cycles = [[0, 4, 8], [1, 11, 17], [2, 16, 22], [3, 21, 5], [6, 20, 14], [7, 13, 9], [10, 12, 18], [19, 15, 23]];
                            for (let index204 = 0; index204 < cycles.length; index204++) {
                                let cycle = cycles[index204];
                                {
                                    for (let j = 0; j < cycle.length; j++) {
                                        {
                                            map[cycle[j]] = cycle[(j + 1) % 3];
                                        }
                                        ;
                                    }
                                }
                            }
                            this.mOrientations[4] = new com.vzome.core.math.symmetry.Permutation(this, map);
                            map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(OctahedralSymmetry.ORDER);
                            cycles = [[0, 5], [1, 8], [4, 9], [15, 20], [12, 19], [16, 23], [2, 17], [13, 10], [21, 6], [22, 3], [7, 14], [11, 18]];
                            for (let index205 = 0; index205 < cycles.length; index205++) {
                                let cycle = cycles[index205];
                                {
                                    for (let j = 0; j < cycle.length; j++) {
                                        {
                                            map[cycle[j]] = cycle[(j + 1) % 2];
                                        }
                                        ;
                                    }
                                }
                            }
                            this.mOrientations[5] = new com.vzome.core.math.symmetry.Permutation(this, map);
                        }
                        /**
                         *
                         */
                        createOtherOrbits() {
                            let xAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                            let yAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
                            let zAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                            let green = xAxis.plus(yAxis);
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("green", 1, 8, green, true);
                            let yellow = green.plus(zAxis);
                            this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean("yellow", 0, 4, yellow, true);
                        }
                        /**
                         *
                         * @param {string} frameColor
                         */
                        createFrameOrbit(frameColor) {
                            let xAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                            let yAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y);
                            let zAxis = this.mField.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                            let dir;
                            if (this.mField.doubleFrameVectors())
                                dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean$boolean$com_vzome_core_algebra_AlgebraicNumber(frameColor, 0, 1, xAxis, true, true, this.mField['createRational$long'](2));
                            else
                                dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(frameColor, 0, 1, xAxis, true);
                            this.createBasisAxes(dir, xAxis, 0);
                            this.createBasisAxes(dir, xAxis.negate(), 12);
                            this.createBasisAxes(dir, yAxis, 5);
                            this.createBasisAxes(dir, yAxis.negate(), 7);
                            this.createBasisAxes(dir, zAxis, 4);
                            this.createBasisAxes(dir, zAxis.negate(), 6);
                            for (let p = 0; p < OctahedralSymmetry.ORDER; p++) {
                                {
                                    let x = this.mOrientations[p].mapIndex(0);
                                    let y = this.mOrientations[p].mapIndex(8);
                                    let z = this.mOrientations[p].mapIndex(4);
                                    this.mMatrices[p] = new com.vzome.core.algebra.AlgebraicMatrix(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, x).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, y).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, z).normal());
                                    let axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, p);
                                    let norm = this.mMatrices[p].timesColumn(xAxis);
                                    if (!norm.equals(axis.normal()))
                                        throw new java.lang.IllegalStateException("matrix wrong: " + p);
                                }
                                ;
                            }
                        }
                        /*private*/ createBasisAxes(dir, norm, orientation) {
                            for (let i = 0; i < 4; i++) {
                                {
                                    let prototype = this.mOrientations[orientation].mapIndex(i);
                                    let rotatedPrototype = this.mOrientations[orientation].mapIndex((i + 1) % 4);
                                    let rotation = this.getMapping(prototype, rotatedPrototype);
                                    dir.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(prototype, rotation, norm);
                                }
                                ;
                            }
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "octahedral";
                        }
                        /**
                         *
                         * @param {string} name
                         * @return {Array}
                         */
                        subgroup(name) {
                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL, name))
                                return this.tetrahedralSubgroup;
                            return null;
                        }
                    }
                    OctahedralSymmetry.ORDER = 24;
                    symmetry.OctahedralSymmetry = OctahedralSymmetry;
                    OctahedralSymmetry["__class"] = "com.vzome.core.math.symmetry.OctahedralSymmetry";
                    OctahedralSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "java.lang.Iterable", "com.vzome.core.math.symmetry.Embedding"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     * @param {*} field
                     * @class
                     * @extends com.vzome.core.math.symmetry.AbstractSymmetry
                     */
                    class DodecagonalSymmetry extends com.vzome.core.math.symmetry.AbstractSymmetry {
                        constructor(field) {
                            super(DodecagonalSymmetry.ORDER, field, "blue");
                            this.IDENTITY = new com.vzome.core.math.symmetry.Permutation(this, null);
                        }
                        /**
                         *
                         */
                        createInitialPermutations() {
                            this.mOrientations[0] = this.IDENTITY;
                            let map = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(DodecagonalSymmetry.ORDER);
                            for (let i = 0; i < DodecagonalSymmetry.ORDER; i++) {
                                map[i] = (i + 1) % DodecagonalSymmetry.ORDER;
                            }
                            this.mOrientations[1] = new com.vzome.core.math.symmetry.Permutation(this, map);
                        }
                        /**
                         *
                         * @param {string} frameColor
                         */
                        createFrameOrbit(frameColor) {
                            let xAxis = this.mField.createVector([[1, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1]]);
                            let dir = this.createZoneOrbit$java_lang_String$int$int$com_vzome_core_algebra_AlgebraicVector$boolean(frameColor, 0, 15, xAxis, true);
                            dir.createAxis$int$int$com_vzome_core_algebra_AlgebraicVector(0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, xAxis);
                            dir.createAxis$int$int$int_A_A(1, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 1, 2], [1, 2, 0, 1], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(2, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 2, 0, 1], [0, 1, 1, 2], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(3, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 0, 1], [1, 1, 0, 1], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(4, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 2, 0, 1], [0, 1, 1, 2], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(5, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, -1, 2], [1, 2, 0, 1], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(6, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 1, 0, 1], [0, 1, 0, 1], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(7, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, -1, 2], [-1, 2, 0, 1], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(8, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[-1, 2, 0, 1], [0, 1, -1, 2], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(9, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 0, 1], [-1, 1, 0, 1], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(10, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 2, 0, 1], [0, 1, -1, 2], [0, 1, 0, 1]]);
                            dir.createAxis$int$int$int_A_A(11, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[0, 1, 1, 2], [-1, 2, 0, 1], [0, 1, 0, 1]]);
                            let zAxis = this.mField.createVector([[0, 1, 0, 1], [0, 1, 0, 1], [1, 1, 0, 1]]);
                            for (let p = 0; p < DodecagonalSymmetry.ORDER; p++) {
                                {
                                    let x = this.mOrientations[p].mapIndex(0);
                                    let y = this.mOrientations[p].mapIndex(3);
                                    this.mMatrices[p] = new com.vzome.core.algebra.AlgebraicMatrix(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, x).normal(), dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, y).normal(), zAxis);
                                    let axis = dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, p);
                                    let norm = this.mMatrices[p].timesColumn(xAxis);
                                    if (!norm.equals(axis.normal()))
                                        throw new java.lang.IllegalStateException("matrix wrong: " + p);
                                }
                                ;
                            }
                        }
                        /**
                         *
                         */
                        createOtherOrbits() {
                            this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("green", 0, com.vzome.core.math.symmetry.Symmetry.NO_ROTATION, [[1, 1, 1, 2], [1, 2, 0, 1], [0, 1, 0, 1]], true);
                            this.createZoneOrbit$java_lang_String$int$int$int_A_A$boolean("red", 0, 1, [[0, 1, 0, 1], [0, 1, 0, 1], [1, 1, 0, 1]], true);
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.symmetry.Symmetry.SpecialOrbit} which
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getSpecialOrbit(which) {
                            switch ((which)) {
                                case com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.BLUE:
                                    return this.getDirection("blue");
                                case com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.RED:
                                    return this.getDirection("red");
                                case com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.YELLOW:
                                    return this.getDirection("green");
                                default:
                                    return null;
                            }
                        }
                        /**
                         *
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getPreferredAxis() {
                            return this.getDirection("red").getAxis$int$int(0, 0);
                        }
                        /**
                         *
                         * @return {string}
                         */
                        getName() {
                            return "dodecagonal";
                        }
                        /**
                         *
                         * @param {string} name
                         * @return {Array}
                         */
                        subgroup(name) {
                            return null;
                        }
                    }
                    DodecagonalSymmetry.ORDER = 12;
                    symmetry.DodecagonalSymmetry = DodecagonalSymmetry;
                    DodecagonalSymmetry["__class"] = "com.vzome.core.math.symmetry.DodecagonalSymmetry";
                    DodecagonalSymmetry["__interfaces"] = ["com.vzome.core.math.symmetry.Symmetry", "java.lang.Iterable", "com.vzome.core.math.symmetry.Embedding"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class PlaneOrbitSet extends com.vzome.core.math.symmetry.OrbitSet {
                        constructor(delegate, normal) {
                            super(delegate.getSymmetry());
                            if (this.delegate === undefined)
                                this.delegate = null;
                            if (this.normal === undefined)
                                this.normal = null;
                            this.__zones = (new java.util.HashSet());
                            this.delegate = delegate;
                            this.normal = normal;
                            for (let index206 = delegate.iterator(); index206.hasNext();) {
                                let dir = index206.next();
                                {
                                    for (let index207 = dir.iterator(); index207.hasNext();) {
                                        let axis = index207.next();
                                        {
                                            if (axis.normal().dot(this.normal).isZero())
                                                this.__zones.add(axis);
                                        }
                                    }
                                }
                            }
                        }
                        zones() {
                            return this.__zones.iterator();
                        }
                        /**
                         *
                         * @param {com.vzome.core.math.RealVector} vector
                         * @return {com.vzome.core.math.symmetry.Axis}
                         */
                        getAxis(vector) {
                            if (com.vzome.core.math.RealVector.ORIGIN_$LI$().equals(vector)) {
                                return null;
                            }
                            let maxCosine = -1.0;
                            let closest = null;
                            for (let index208 = this.__zones.iterator(); index208.hasNext();) {
                                let axis = index208.next();
                                {
                                    let axisV = axis.normal().toRealVector();
                                    let cosine = vector.dot(axisV) / (vector.length() * axisV.length());
                                    if (cosine > maxCosine) {
                                        maxCosine = cosine;
                                        closest = axis;
                                    }
                                }
                            }
                            return closest;
                        }
                        /**
                         *
                         * @param {string} name
                         * @return {com.vzome.core.math.symmetry.Direction}
                         */
                        getDirection(name) {
                            return this.delegate.getDirection(name);
                        }
                    }
                    symmetry.PlaneOrbitSet = PlaneOrbitSet;
                    PlaneOrbitSet["__class"] = "com.vzome.core.math.symmetry.PlaneOrbitSet";
                    PlaneOrbitSet["__interfaces"] = ["java.lang.Cloneable", "java.util.SortedSet", "java.util.Collection", "java.util.Set", "java.util.NavigableSet", "java.lang.Iterable", "java.io.Serializable"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    class F4Group extends com.vzome.core.math.symmetry.B4Group {
                        constructor(field) {
                            super(field);
                            this.ROOTS = [null, null, null, null];
                            this.WEIGHTS = [null, null, null, null];
                            if (this.A === undefined)
                                this.A = null;
                            let one = field['createRational$long'](1);
                            let two = field['createRational$long'](2);
                            let three = field['createRational$long'](3);
                            let four = field['createRational$long'](4);
                            let neg_one = field['createRational$long'](-1);
                            let neg_two = field['createRational$long'](-2);
                            this.ROOTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.ROOTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, two);
                            this.ROOTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_two);
                            this.ROOTS[1] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
                            this.ROOTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, two);
                            this.ROOTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_two);
                            this.ROOTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Z4);
                            this.ROOTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, two);
                            this.ROOTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.W4);
                            this.ROOTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, neg_one);
                            this.ROOTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_one);
                            this.ROOTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_one);
                            this.WEIGHTS[0] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.WEIGHTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, two);
                            this.WEIGHTS[0].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, two);
                            this.WEIGHTS[1] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.Y4);
                            this.WEIGHTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.X4, two);
                            this.WEIGHTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, two);
                            this.WEIGHTS[1].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, four);
                            this.WEIGHTS[2] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, one);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, one);
                            this.WEIGHTS[2].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, three);
                            this.WEIGHTS[3] = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.W4);
                            this.WEIGHTS[3].setComponent(com.vzome.core.algebra.AlgebraicVector.W4, two);
                            if (field.scale4dRoots()) {
                                let scale = field['createPower$int'](1);
                                this.ROOTS[2] = this.ROOTS[2].scale(scale);
                                this.WEIGHTS[2] = this.WEIGHTS[2].scale(scale);
                            }
                            let half = field['createRational$long$long'](1, 2);
                            let neg_half = field['createRational$long$long'](-1, 2);
                            let col1 = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            col1.setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            col1.setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
                            col1.setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
                            col1.setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_half);
                            let col2 = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            col2.setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            col2.setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, half);
                            col2.setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_half);
                            col2.setComponent(com.vzome.core.algebra.AlgebraicVector.W4, half);
                            let col3 = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            col3.setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            col3.setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_half);
                            col3.setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, half);
                            col3.setComponent(com.vzome.core.algebra.AlgebraicVector.W4, half);
                            let col4 = field.basisVector(4, com.vzome.core.algebra.AlgebraicVector.X4);
                            col4.setComponent(com.vzome.core.algebra.AlgebraicVector.X4, half);
                            col4.setComponent(com.vzome.core.algebra.AlgebraicVector.Y4, neg_half);
                            col4.setComponent(com.vzome.core.algebra.AlgebraicVector.Z4, neg_half);
                            col4.setComponent(com.vzome.core.algebra.AlgebraicVector.W4, neg_half);
                            this.A = new com.vzome.core.algebra.AlgebraicMatrix(col1, col2, col3, col4);
                        }
                        /**
                         *
                         * @return {number}
                         */
                        getOrder() {
                            return 3 * super.getOrder();
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} model
                         * @param {number} element
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        groupAction(model, element) {
                            let b4Order = super.getOrder();
                            let aPower = (element / b4Order | 0);
                            let b4Element = element % b4Order;
                            switch ((aPower)) {
                                case 0:
                                    return super.groupAction(model, b4Element);
                                case 1:
                                    return super.groupAction(this.A.timesColumn(model), b4Element);
                                case 2:
                                    return super.groupAction(this.A.timesColumn(this.A.timesColumn(model)), b4Element);
                                default:
                                    break;
                            }
                            return null;
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getWeight(i) {
                            return this.WEIGHTS[i];
                        }
                        /**
                         *
                         * @param {number} i
                         * @return {com.vzome.core.algebra.AlgebraicVector}
                         */
                        getSimpleRoot(i) {
                            return this.ROOTS[i];
                        }
                    }
                    symmetry.F4Group = F4Group;
                    F4Group["__class"] = "com.vzome.core.math.symmetry.F4Group";
                    F4Group["__interfaces"] = ["com.vzome.core.math.symmetry.CoxeterGroup"];
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var viewing;
            (function (viewing) {
                /**
                 * @author vorth
                 * @param {java.io.File} prefsFolder
                 * @param {string} pkgName
                 * @param {string} name
                 * @param {string} alias
                 * @param {*} symm
                 * @param {com.vzome.core.viewing.AbstractShapes} fallback
                 * @class
                 * @extends com.vzome.core.viewing.AbstractShapes
                 */
                class ExportedVEFShapes extends com.vzome.core.viewing.AbstractShapes {
                    constructor(prefsFolder, pkgName, name, alias, symm, fallback) {
                        if (((prefsFolder != null && prefsFolder instanceof java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((typeof alias === 'string') || alias === null) && ((symm != null && (symm["__interfaces"] != null && symm["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0 || symm.constructor != null && symm.constructor["__interfaces"] != null && symm.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symm === null) && ((fallback != null && fallback instanceof com.vzome.core.viewing.AbstractShapes) || fallback === null)) {
                            let __args = arguments;
                            super(pkgName, name, alias, symm);
                            if (this.prefsFolder === undefined)
                                this.prefsFolder = null;
                            if (this.fallback === undefined)
                                this.fallback = null;
                            this.colors = new java.util.Properties();
                            if (this.prefsFolder === undefined)
                                this.prefsFolder = null;
                            if (this.fallback === undefined)
                                this.fallback = null;
                            (() => {
                                this.prefsFolder = prefsFolder;
                                this.fallback = fallback;
                                let colorProps = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                                try {
                                    let cl = this.constructor.getClassLoader();
                                    let inputStream = cl.getResourceAsStream(colorProps);
                                    if (inputStream != null)
                                        this.colors.load(inputStream);
                                }
                                catch (ioe) {
                                    if (ExportedVEFShapes.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                        ExportedVEFShapes.logger_$LI$().fine("problem with shape color properties: " + colorProps);
                                }
                                ;
                            })();
                        }
                        else if (((prefsFolder != null && prefsFolder instanceof java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((typeof alias === 'string') || alias === null) && ((symm != null && (symm["__interfaces"] != null && symm["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0 || symm.constructor != null && symm.constructor["__interfaces"] != null && symm.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symm === null) && fallback === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let fallback = new com.vzome.core.viewing.OctahedralShapes(__args[1], __args[2], __args[4]);
                                super(pkgName, name, alias, symm);
                                if (this.prefsFolder === undefined)
                                    this.prefsFolder = null;
                                if (this.fallback === undefined)
                                    this.fallback = null;
                                this.colors = new java.util.Properties();
                                if (this.prefsFolder === undefined)
                                    this.prefsFolder = null;
                                if (this.fallback === undefined)
                                    this.fallback = null;
                                (() => {
                                    this.prefsFolder = prefsFolder;
                                    this.fallback = fallback;
                                    let colorProps = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                                    try {
                                        let cl = this.constructor.getClassLoader();
                                        let inputStream = cl.getResourceAsStream(colorProps);
                                        if (inputStream != null)
                                            this.colors.load(inputStream);
                                    }
                                    catch (ioe) {
                                        if (ExportedVEFShapes.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                            ExportedVEFShapes.logger_$LI$().fine("problem with shape color properties: " + colorProps);
                                    }
                                    ;
                                })();
                            }
                        }
                        else if (((prefsFolder != null && prefsFolder instanceof java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((alias != null && (alias["__interfaces"] != null && alias["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0 || alias.constructor != null && alias.constructor["__interfaces"] != null && alias.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || alias === null) && ((symm != null && symm instanceof com.vzome.core.viewing.AbstractShapes) || symm === null) && fallback === undefined) {
                            let __args = arguments;
                            let symm = __args[3];
                            let fallback = __args[4];
                            {
                                let __args = arguments;
                                let alias = null;
                                super(pkgName, name, alias, symm);
                                if (this.prefsFolder === undefined)
                                    this.prefsFolder = null;
                                if (this.fallback === undefined)
                                    this.fallback = null;
                                this.colors = new java.util.Properties();
                                if (this.prefsFolder === undefined)
                                    this.prefsFolder = null;
                                if (this.fallback === undefined)
                                    this.fallback = null;
                                (() => {
                                    this.prefsFolder = prefsFolder;
                                    this.fallback = fallback;
                                    let colorProps = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                                    try {
                                        let cl = this.constructor.getClassLoader();
                                        let inputStream = cl.getResourceAsStream(colorProps);
                                        if (inputStream != null)
                                            this.colors.load(inputStream);
                                    }
                                    catch (ioe) {
                                        if (ExportedVEFShapes.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                            ExportedVEFShapes.logger_$LI$().fine("problem with shape color properties: " + colorProps);
                                    }
                                    ;
                                })();
                            }
                        }
                        else if (((prefsFolder != null && prefsFolder instanceof java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((alias != null && (alias["__interfaces"] != null && alias["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0 || alias.constructor != null && alias.constructor["__interfaces"] != null && alias.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || alias === null) && ((typeof symm === 'boolean') || symm === null) && fallback === undefined) {
                            let __args = arguments;
                            let symm = __args[3];
                            let useZomic = __args[4];
                            {
                                let __args = arguments;
                                let alias = null;
                                let fallback = new com.vzome.core.viewing.OctahedralShapes(__args[1], __args[2], __args[4]);
                                super(pkgName, name, alias, symm);
                                if (this.prefsFolder === undefined)
                                    this.prefsFolder = null;
                                if (this.fallback === undefined)
                                    this.fallback = null;
                                this.colors = new java.util.Properties();
                                if (this.prefsFolder === undefined)
                                    this.prefsFolder = null;
                                if (this.fallback === undefined)
                                    this.fallback = null;
                                (() => {
                                    this.prefsFolder = prefsFolder;
                                    this.fallback = fallback;
                                    let colorProps = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                                    try {
                                        let cl = this.constructor.getClassLoader();
                                        let inputStream = cl.getResourceAsStream(colorProps);
                                        if (inputStream != null)
                                            this.colors.load(inputStream);
                                    }
                                    catch (ioe) {
                                        if (ExportedVEFShapes.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                            ExportedVEFShapes.logger_$LI$().fine("problem with shape color properties: " + colorProps);
                                    }
                                    ;
                                })();
                            }
                        }
                        else if (((prefsFolder != null && prefsFolder instanceof java.io.File) || prefsFolder === null) && ((typeof pkgName === 'string') || pkgName === null) && ((typeof name === 'string') || name === null) && ((alias != null && (alias["__interfaces"] != null && alias["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0 || alias.constructor != null && alias.constructor["__interfaces"] != null && alias.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || alias === null) && symm === undefined && fallback === undefined) {
                            let __args = arguments;
                            let symm = __args[3];
                            {
                                let __args = arguments;
                                let alias = null;
                                {
                                    let __args = arguments;
                                    let fallback = new com.vzome.core.viewing.OctahedralShapes(__args[1], __args[2], __args[4]);
                                    super(pkgName, name, alias, symm);
                                    if (this.prefsFolder === undefined)
                                        this.prefsFolder = null;
                                    if (this.fallback === undefined)
                                        this.fallback = null;
                                    this.colors = new java.util.Properties();
                                    if (this.prefsFolder === undefined)
                                        this.prefsFolder = null;
                                    if (this.fallback === undefined)
                                        this.fallback = null;
                                    (() => {
                                        this.prefsFolder = prefsFolder;
                                        this.fallback = fallback;
                                        let colorProps = ExportedVEFShapes.MODEL_PREFIX + pkgName + "/colors.properties";
                                        try {
                                            let cl = this.constructor.getClassLoader();
                                            let inputStream = cl.getResourceAsStream(colorProps);
                                            if (inputStream != null)
                                                this.colors.load(inputStream);
                                        }
                                        catch (ioe) {
                                            if (ExportedVEFShapes.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                                ExportedVEFShapes.logger_$LI$().fine("problem with shape color properties: " + colorProps);
                                        }
                                        ;
                                    })();
                                }
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static INJECTED_$LI$() { if (ExportedVEFShapes.INJECTED == null)
                        ExportedVEFShapes.INJECTED = (new java.util.HashMap()); return ExportedVEFShapes.INJECTED; }
                    ;
                    static logger_$LI$() { if (ExportedVEFShapes.logger == null)
                        ExportedVEFShapes.logger = java.util.logging.Logger.getLogger("com.vzome.core.viewing.shapes"); return ExportedVEFShapes.logger; }
                    ;
                    static injectShapeVEF(key, vef) {
                        key = /* replace */ key.split("--").join("/");
                        ExportedVEFShapes.INJECTED_$LI$().put(key, vef);
                    }
                    /**
                     *
                     * @param {string} pkgName
                     * @return {com.vzome.core.math.Polyhedron}
                     */
                    buildConnectorShape(pkgName) {
                        let vefData = this.loadVefData(ExportedVEFShapes.NODE_MODEL);
                        if (vefData != null) {
                            let parser = new ExportedVEFShapes.VefToShape(this);
                            parser.parseVEF(vefData, this.mSymmetry.getField());
                            return parser.getConnectorPolyhedron();
                        }
                        if (this.fallback != null)
                            return this.fallback.buildConnectorShape(pkgName);
                        else
                            throw new java.lang.IllegalStateException("missing connector shape: " + pkgName);
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} dir
                     * @return {*}
                     */
                    createStrutGeometry(dir) {
                        let vefData = this.loadVefData(dir.getName());
                        if (vefData != null) {
                            let parser = new ExportedVEFShapes.VefToShape(this);
                            parser.parseVEF(vefData, this.mSymmetry.getField());
                            return parser.getStrutGeometry(dir.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0).normal());
                        }
                        else if (this.fallback != null)
                            return this.fallback.createStrutGeometry(dir);
                        else
                            return super.createStrutGeometry(dir);
                    }
                    loadVefData(name) {
                        if (ExportedVEFShapes.INJECTED_$LI$().containsKey(this.mPkgName + "-" + name))
                            return ExportedVEFShapes.INJECTED_$LI$().get(this.mPkgName + "-" + name);
                        let script = this.mPkgName + "/" + name + ".vef";
                        if (com.vzome.xml.ResourceLoader.hasInjectedResource(ExportedVEFShapes.MODEL_PREFIX + script))
                            return com.vzome.xml.ResourceLoader.getInjectedResource(ExportedVEFShapes.MODEL_PREFIX + script);
                        let shapeFile = new java.io.File(this.prefsFolder, "Shapes/" + script);
                        let stream = null;
                        try {
                            if (shapeFile.exists())
                                stream = new java.io.FileInputStream(shapeFile);
                            else {
                                script = ExportedVEFShapes.MODEL_PREFIX + script;
                                stream = this.constructor.getClassLoader().getResourceAsStream(script);
                                if (stream == null)
                                    return null;
                            }
                            let out = new java.io.ByteArrayOutputStream();
                            let buf = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(1024);
                            let num;
                            while (((num = stream.read(buf, 0, 1024)) > 0)) {
                                out.write(buf, 0, num);
                            }
                            ;
                            return new String(out.toByteArray());
                        }
                        catch (e) {
                            ExportedVEFShapes.logger_$LI$().fine("Failure loading VEF data from " + shapeFile);
                        }
                        finally {
                            if (stream != null)
                                try {
                                    stream.close();
                                }
                                catch (e) {
                                    console.error(e.message, e);
                                }
                            ;
                            ;
                        }
                        ;
                        return null;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasColors() {
                        return !this.colors.isEmpty();
                    }
                    /**
                     *
                     * @param {com.vzome.core.math.symmetry.Direction} dir
                     * @return {com.vzome.core.construction.Color}
                     */
                    getColor(dir) {
                        if (this.colors.isEmpty())
                            return null;
                        let dirName = (dir == null) ? ExportedVEFShapes.NODE_MODEL : dir.getName();
                        let colorString = this.colors.getProperty(dirName);
                        if (colorString == null)
                            return null;
                        return com.vzome.core.render.Colors.parseColor(colorString);
                    }
                }
                ExportedVEFShapes.MODEL_PREFIX = "com/vzome/core/parts/";
                ExportedVEFShapes.NODE_MODEL = "connector";
                viewing.ExportedVEFShapes = ExportedVEFShapes;
                ExportedVEFShapes["__class"] = "com.vzome.core.viewing.ExportedVEFShapes";
                ExportedVEFShapes["__interfaces"] = ["com.vzome.core.editor.api.Shapes"];
                (function (ExportedVEFShapes) {
                    class VefToShape extends com.vzome.core.math.VefParser {
                        constructor(__parent) {
                            super();
                            this.__parent = __parent;
                            this.tipVertexIndices = (new java.util.HashSet());
                            this.midpointVertexIndices = (new java.util.HashSet());
                            if (this.tipVertex === undefined)
                                this.tipVertex = null;
                            this.vertices = (new java.util.ArrayList());
                            this.faces = (new java.util.ArrayList());
                        }
                        getStrutGeometry(prototype) {
                            let tipAxis = this.__parent.mSymmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](this.tipVertex);
                            let midpoint = this.tipVertex.scale(this.__parent.mSymmetry.getField()['createRational$long$long'](1, 2));
                            let orientation = this.__parent.mSymmetry.inverse(tipAxis.getOrientation());
                            let adjustment = this.__parent.mSymmetry.getMatrix(orientation);
                            let newVertices = (new java.util.ArrayList());
                            for (let i = 0; i < this.vertices.size(); i++) {
                                {
                                    let originalVertex = this.vertices.get(i);
                                    if (this.tipVertexIndices.contains(i))
                                        originalVertex = originalVertex.minus(this.tipVertex);
                                    else if (this.midpointVertexIndices.contains(i))
                                        originalVertex = originalVertex.minus(midpoint);
                                    let adjustedVertex = adjustment.timesColumn(originalVertex);
                                    newVertices.add(adjustedVertex);
                                }
                                ;
                            }
                            return new com.vzome.core.viewing.ExportedVEFStrutGeometry(newVertices, this.faces, prototype, this.tipVertexIndices, this.midpointVertexIndices, this.__parent.mSymmetry.getField());
                        }
                        getConnectorPolyhedron() {
                            let result = new com.vzome.core.math.Polyhedron(this.__parent.mSymmetry.getField());
                            for (let index209 = this.vertices.iterator(); index209.hasNext();) {
                                let vertex = index209.next();
                                {
                                    result.addVertex(vertex);
                                }
                            }
                            for (let index210 = this.faces.iterator(); index210.hasNext();) {
                                let prototypeFace = index210.next();
                                {
                                    let face = result.newFace();
                                    face.addAll(prototypeFace);
                                    result.addFace(face);
                                }
                            }
                            return result;
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {Array} verts
                         */
                        addFace(index, verts) {
                            let face = (new java.util.ArrayList());
                            for (let i = 0; i < verts.length; i++) {
                                {
                                    let j = verts[i];
                                    face.add(j);
                                }
                                ;
                            }
                            this.faces.add(face);
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {com.vzome.core.algebra.AlgebraicVector} location
                         */
                        addVertex(index, location) {
                            let vertex = this.__parent.mSymmetry.getField().projectTo3d(location, this.wFirst());
                            this.vertices.add(vertex);
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {number} vertex
                         */
                        addBall(index, vertex) {
                            this.tipVertexIndices.add(vertex);
                        }
                        /**
                         *
                         * @param {java.util.StringTokenizer} tokens
                         */
                        endFile(tokens) {
                            if (!tokens.hasMoreTokens())
                                return;
                            let token = tokens.nextToken();
                            if (!((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })("tip", token))
                                throw new java.lang.IllegalStateException("VEF format error: token after face list (\"" + token + "\" should be \"tip\"");
                            try {
                                token = tokens.nextToken();
                            }
                            catch (e1) {
                                throw new java.lang.IllegalStateException("VEF format error: no tokens after \"tip\"");
                            }
                            ;
                            let tipIndex;
                            try {
                                tipIndex = javaemul.internal.IntegerHelper.parseInt(token);
                            }
                            catch (e) {
                                throw new java.lang.RuntimeException("VEF format error: strut tip vertex index (\"" + token + "\") must be an integer", e);
                            }
                            ;
                            this.tipVertex = this.vertices.get(tipIndex);
                            if (!tokens.hasMoreTokens())
                                return;
                            token = tokens.nextToken();
                            if (!((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })("middle", token))
                                throw new java.lang.IllegalStateException("VEF format error: token after tip vertex (\"" + token + "\" should be \"middle\"");
                            while ((tokens.hasMoreTokens())) {
                                {
                                    token = tokens.nextToken();
                                    let vertexIndex;
                                    try {
                                        vertexIndex = javaemul.internal.IntegerHelper.parseInt(token);
                                    }
                                    catch (e) {
                                        throw new java.lang.RuntimeException("VEF format error: middle vertex index (\"" + token + "\") must be an integer", e);
                                    }
                                    ;
                                    this.midpointVertexIndices.add(vertexIndex);
                                }
                            }
                            ;
                        }
                        /**
                         *
                         * @param {number} numVertices
                         */
                        startBalls(numVertices) {
                        }
                        /**
                         *
                         * @param {number} numEdges
                         */
                        startEdges(numEdges) {
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {number} v1
                         * @param {number} v2
                         */
                        addEdge(index, v1, v2) {
                        }
                        /**
                         *
                         * @param {number} numFaces
                         */
                        startFaces(numFaces) {
                        }
                        /**
                         *
                         * @param {number} numVertices
                         */
                        startVertices(numVertices) {
                        }
                    }
                    ExportedVEFShapes.VefToShape = VefToShape;
                    VefToShape["__class"] = "com.vzome.core.viewing.ExportedVEFShapes.VefToShape";
                })(ExportedVEFShapes = viewing.ExportedVEFShapes || (viewing.ExportedVEFShapes = {}));
            })(viewing = core.viewing || (core.viewing = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                var symmetry;
                (function (symmetry) {
                    /**
                     * @author Scott Vorthmann
                     * @param {string} name
                     * @param {string} rootsResource
                     * @param {*} field
                     * @class
                     */
                    class QuaternionicSymmetry {
                        constructor(name, rootsResource, field) {
                            if (this.mRoots === undefined)
                                this.mRoots = null;
                            if (this.mName === undefined)
                                this.mName = null;
                            this.mName = name;
                            try {
                                let vefData = com.vzome.xml.ResourceLoader.loadStringResource(rootsResource);
                                let parser = new QuaternionicSymmetry.RootParser(field);
                                parser.parseVEF(vefData, field);
                                this.mRoots = parser.getQuaternions();
                            }
                            catch (exc) {
                                console.error(exc.message, exc);
                            }
                            ;
                        }
                        getRoots() {
                            return this.mRoots;
                        }
                        getName() {
                            return this.mName;
                        }
                    }
                    symmetry.QuaternionicSymmetry = QuaternionicSymmetry;
                    QuaternionicSymmetry["__class"] = "com.vzome.core.math.symmetry.QuaternionicSymmetry";
                    (function (QuaternionicSymmetry) {
                        class RootParser extends com.vzome.core.math.VefParser {
                            constructor(field) {
                                super();
                                if (this.mRoots === undefined)
                                    this.mRoots = null;
                                if (this.__com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field === undefined)
                                    this.__com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field = null;
                                if (this.HALF === undefined)
                                    this.HALF = null;
                                this.__com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field = field;
                                this.HALF = field['createRational$long$long'](1, 2);
                            }
                            /**
                             *
                             * @param {number} numVertices
                             */
                            startVertices(numVertices) {
                                this.mRoots = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(numVertices);
                            }
                            getQuaternions() {
                                return this.mRoots;
                            }
                            /**
                             *
                             * @param {number} index
                             * @param {com.vzome.core.algebra.AlgebraicVector} location
                             */
                            addVertex(index, location) {
                                this.mRoots[index] = new com.vzome.core.algebra.Quaternion(this.__com_vzome_core_math_symmetry_QuaternionicSymmetry_RootParser_field, location.scale(this.HALF));
                            }
                            /**
                             *
                             * @param {number} numEdges
                             */
                            startEdges(numEdges) {
                            }
                            /**
                             *
                             * @param {number} index
                             * @param {number} v1
                             * @param {number} v2
                             */
                            addEdge(index, v1, v2) {
                            }
                            /**
                             *
                             * @param {number} numFaces
                             */
                            startFaces(numFaces) {
                            }
                            /**
                             *
                             * @param {number} index
                             * @param {Array} verts
                             */
                            addFace(index, verts) {
                            }
                            /**
                             *
                             * @param {number} index
                             * @param {number} vertex
                             */
                            addBall(index, vertex) {
                            }
                            /**
                             *
                             * @param {number} numVertices
                             */
                            startBalls(numVertices) {
                            }
                            /**
                             *
                             * @param {java.util.StringTokenizer} tokens
                             */
                            endFile(tokens) {
                            }
                        }
                        QuaternionicSymmetry.RootParser = RootParser;
                        RootParser["__class"] = "com.vzome.core.math.symmetry.QuaternionicSymmetry.RootParser";
                    })(QuaternionicSymmetry = symmetry.QuaternionicSymmetry || (symmetry.QuaternionicSymmetry = {}));
                })(symmetry = math.symmetry || (math.symmetry = {}));
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                class VefToPolyhedron extends com.vzome.core.math.VefParser {
                    constructor(polyhedron) {
                        super();
                        if (this.polyhedron === undefined)
                            this.polyhedron = null;
                        this.polyhedron = polyhedron;
                    }
                    static importPolyhedron(field, vef) {
                        let result = new com.vzome.core.math.Polyhedron(field);
                        let parser = new VefToPolyhedron(result);
                        parser.parseVEF(vef, field);
                        return result;
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {com.vzome.core.algebra.AlgebraicVector} location
                     */
                    addVertex(index, location) {
                        this.polyhedron.addVertex(this.getField().projectTo3d(location, true));
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {Array} verts
                     */
                    addFace(index, verts) {
                        let face = this.polyhedron.newFace();
                        for (let index211 = 0; index211 < verts.length; index211++) {
                            let i = verts[index211];
                            face.add(i);
                        }
                        this.polyhedron.addFace(face);
                    }
                    /**
                     *
                     * @param {number} numVertices
                     */
                    startVertices(numVertices) {
                    }
                    /**
                     *
                     * @param {number} numFaces
                     */
                    startFaces(numFaces) {
                    }
                    /**
                     *
                     * @param {number} numEdges
                     */
                    startEdges(numEdges) {
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {number} v1
                     * @param {number} v2
                     */
                    addEdge(index, v1, v2) {
                    }
                    /**
                     *
                     * @param {number} numVertices
                     */
                    startBalls(numVertices) {
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {number} vertex
                     */
                    addBall(index, vertex) {
                    }
                }
                math.VefToPolyhedron = VefToPolyhedron;
                VefToPolyhedron["__class"] = "com.vzome.core.math.VefToPolyhedron";
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class VefToModel extends com.vzome.core.math.VefParser {
                    constructor(projection, effects, scale, offset) {
                        super();
                        if (this.offset === undefined)
                            this.offset = null;
                        if (this.scale === undefined)
                            this.scale = null;
                        if (this.__com_vzome_core_construction_VefToModel_field === undefined)
                            this.__com_vzome_core_construction_VefToModel_field = null;
                        if (this.mProjection === undefined)
                            this.mProjection = null;
                        if (this.mVertices === undefined)
                            this.mVertices = null;
                        if (this.mEffects === undefined)
                            this.mEffects = null;
                        this.noBallsSection = true;
                        this.mEffects = effects;
                        this.__com_vzome_core_construction_VefToModel_field = scale.getField();
                        this.scale = scale;
                        this.offset = offset;
                        this.mProjection = projection == null ? new com.vzome.core.math.Projection.Default(this.__com_vzome_core_construction_VefToModel_field) : projection;
                        if (projection != null && VefToModel.logger_$LI$().isLoggable(java.util.logging.Level.FINEST)) {
                            VefToModel.logger_$LI$().finest("projection = " + projection.getProjectionName());
                        }
                    }
                    static logger_$LI$() { if (VefToModel.logger == null)
                        VefToModel.logger = java.util.logging.Logger.getLogger("com.vzome.core.construction.VefToModel"); return VefToModel.logger; }
                    ;
                    /**
                     *
                     * @param {number} numVertices
                     */
                    startVertices(numVertices) {
                        this.mVertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(numVertices);
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {com.vzome.core.algebra.AlgebraicVector} location
                     */
                    addVertex(index, location) {
                        VefToModel.logger_$LI$().finest("addVertex location = " + location.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
                        if (this.scale != null) {
                            location = location.scale(this.scale);
                            VefToModel.logger_$LI$().finest("scaled = " + location.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
                        }
                        location = this.mProjection.projectImage(location, this.wFirst());
                        VefToModel.logger_$LI$().finest("projected = " + location.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
                        if (this.offset != null) {
                            location = location.plus(this.offset);
                            VefToModel.logger_$LI$().finest("translated = " + location.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.VEF_FORMAT));
                        }
                        this.mVertices[index] = new com.vzome.core.construction.FreePoint(location);
                        this.mVertices[index].setIndex(index);
                    }
                    /**
                     *
                     * @param {number} numEdges
                     */
                    startEdges(numEdges) {
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {number} v1
                     * @param {number} v2
                     */
                    addEdge(index, v1, v2) {
                        let p1 = this.mVertices[v1];
                        let p2 = this.mVertices[v2];
                        if (p1 == null || p2 == null)
                            return;
                        let seg = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                        seg.setIndex(index);
                        this.mEffects.constructionAdded(seg);
                    }
                    /**
                     *
                     * @param {number} numFaces
                     */
                    startFaces(numFaces) {
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {Array} verts
                     */
                    addFace(index, verts) {
                        let points = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(verts.length);
                        for (let i = 0; i < verts.length; i++) {
                            points[i] = this.mVertices[verts[i]];
                        }
                        let panel = new com.vzome.core.construction.PolygonFromVertices(points);
                        panel.setIndex(index);
                        this.mEffects.constructionAdded(panel);
                    }
                    /**
                     *
                     * @param {number} index
                     * @param {number} vertex
                     */
                    addBall(index, vertex) {
                        this.mEffects.constructionAdded(this.mVertices[vertex]);
                    }
                    /**
                     *
                     * @param {number} numVertices
                     */
                    startBalls(numVertices) {
                        this.noBallsSection = false;
                    }
                    /**
                     *
                     * @param {java.util.StringTokenizer} tokens
                     */
                    endFile(tokens) {
                        if (this.noBallsSection) {
                            for (let index212 = 0; index212 < this.mVertices.length; index212++) {
                                let vertex = this.mVertices[index212];
                                {
                                    this.mEffects.constructionAdded(vertex);
                                }
                            }
                        }
                    }
                }
                construction.VefToModel = VefToModel;
                VefToModel["__class"] = "com.vzome.core.construction.VefToModel";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class Polygon extends com.vzome.core.construction.Construction {
                    constructor(field) {
                        super(field);
                        if (this.mVertices === undefined)
                            this.mVertices = null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return "polygon " + java.util.Arrays.toString(this.mVertices);
                    }
                    setStateVariable(vertices, impossible) {
                        if (impossible) {
                            if (this.isImpossible())
                                return false;
                            this.setImpossible(true);
                            return true;
                        }
                        this.mVertices = vertices;
                        this.setImpossible(false);
                        return true;
                    }
                    getXml$org_w3c_dom_Document(doc) {
                        let result = doc.createElement("polygon");
                        this.getXml$org_w3c_dom_Element$java_lang_String(result, "vertex");
                        return result;
                    }
                    getXml$org_w3c_dom_Element$java_lang_String(result, vertexChildName) {
                        for (let index213 = 0; index213 < this.mVertices.length; index213++) {
                            let vertex = this.mVertices[index213];
                            {
                                let child = result.getOwnerDocument().createElement(vertexChildName);
                                com.vzome.xml.DomUtils.addAttribute(child, "at", vertex.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                                result.appendChild(child);
                            }
                        }
                    }
                    getXml(result, vertexChildName) {
                        if (((result != null && (result["__interfaces"] != null && result["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || result.constructor != null && result.constructor["__interfaces"] != null && result.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) || result === null) && ((typeof vertexChildName === 'string') || vertexChildName === null)) {
                            return this.getXml$org_w3c_dom_Element$java_lang_String(result, vertexChildName);
                        }
                        else if (((result != null && (result["__interfaces"] != null && result["__interfaces"].indexOf("org.w3c.dom.Document") >= 0 || result.constructor != null && result.constructor["__interfaces"] != null && result.constructor["__interfaces"].indexOf("org.w3c.dom.Document") >= 0)) || result === null) && vertexChildName === undefined) {
                            return this.getXml$org_w3c_dom_Document(result);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        for (let index214 = 0; index214 < this.mVertices.length; index214++) {
                            let algebraicVector = this.mVertices[index214];
                            {
                                if (algebraicVector.dimension() !== 3)
                                    return false;
                            }
                        }
                        return true;
                    }
                    getVertexCount() {
                        return this.mVertices.length;
                    }
                    getVertex(i) {
                        return this.mVertices[i];
                    }
                    getNormal() {
                        return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.mVertices[0], this.mVertices[1], this.mVertices[2]);
                    }
                    getCentroid() {
                        return com.vzome.core.algebra.AlgebraicVectors.getCentroid(this.mVertices);
                    }
                    getVertices() {
                        return java.util.Arrays.copyOf(this.mVertices, this.mVertices.length);
                    }
                }
                construction.Polygon = Polygon;
                Polygon["__class"] = "com.vzome.core.construction.Polygon";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @extends com.vzome.core.construction.Construction
                 * @class
                 */
                class Transformation extends com.vzome.core.construction.Construction {
                    constructor(field) {
                        super(field);
                        if (this.mTransform === undefined)
                            this.mTransform = null;
                        if (this.mOffset === undefined)
                            this.mOffset = null;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        return true;
                    }
                    /**
                     *
                     * @param {*} that
                     * @return {boolean}
                     */
                    equals(that) {
                        if (this === that) {
                            return true;
                        }
                        if (that == null) {
                            return false;
                        }
                        if (!(that != null && that instanceof com.vzome.core.construction.Transformation)) {
                            return false;
                        }
                        let other = that;
                        if (this.mOffset == null) {
                            if (other.mOffset != null) {
                                return false;
                            }
                        }
                        else if (!this.mOffset.equals(other.mOffset)) {
                            return false;
                        }
                        if (this.mTransform == null) {
                            if (other.mTransform != null) {
                                return false;
                            }
                        }
                        else if (!this.mTransform.equals(other.mTransform)) {
                            return false;
                        }
                        return true;
                    }
                    setStateVariables(transform, offset, impossible) {
                        if (impossible) {
                            if (this.isImpossible())
                                return false;
                            this.setImpossible(true);
                            return true;
                        }
                        if (transform != null && transform.equals(this.mTransform) && offset.equals(this.mOffset) && !this.isImpossible())
                            return false;
                        this.mTransform = transform;
                        this.mOffset = offset;
                        this.setImpossible(false);
                        return true;
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        arg = arg.minus(this.mOffset);
                        arg = this.mTransform.timesColumn(arg);
                        arg = arg.plus(this.mOffset);
                        return arg;
                    }
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    transform$com_vzome_core_construction_Construction(c) {
                        if (c != null && c instanceof com.vzome.core.construction.Point) {
                            return new com.vzome.core.construction.TransformedPoint(this, c);
                        }
                        else if (c != null && c instanceof com.vzome.core.construction.Segment) {
                            return new com.vzome.core.construction.TransformedSegment(this, c);
                        }
                        else if (c != null && c instanceof com.vzome.core.construction.Polygon) {
                            return new com.vzome.core.construction.TransformedPolygon(this, c);
                        }
                        else {
                            return null;
                        }
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        let result = doc.createElement("transformation");
                        return result;
                    }
                }
                construction.Transformation = Transformation;
                Transformation["__class"] = "com.vzome.core.construction.Transformation";
                (function (Transformation) {
                    class Identity extends com.vzome.core.construction.Transformation {
                        transform$int_A(arg) {
                            return arg;
                        }
                        transform(arg) {
                            if (((arg != null && arg instanceof Array && (arg.length == 0 || arg[0] == null || (typeof arg[0] === 'number'))) || arg === null)) {
                                return this.transform$int_A(arg);
                            }
                            else if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                                super.transform(arg);
                            }
                            else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                                return this.transform$com_vzome_core_construction_Construction(arg);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        constructor(field) {
                            super(field);
                        }
                        attach() {
                        }
                        detach() {
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        mapParamsToState() {
                            return true;
                        }
                    }
                    Transformation.Identity = Identity;
                    Identity["__class"] = "com.vzome.core.construction.Transformation.Identity";
                })(Transformation = construction.Transformation || (construction.Transformation = {}));
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @extends com.vzome.core.construction.Construction
                 * @class
                 */
                class Segment extends com.vzome.core.construction.Construction {
                    constructor(field) {
                        super(field);
                        if (this.mStart === undefined)
                            this.mStart = null;
                        if (this.mOffset === undefined)
                            this.mOffset = null;
                        if (this.mEnd === undefined)
                            this.mEnd = null;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        return this.mStart.dimension() === 3 && this.mOffset.dimension() === 3;
                    }
                    setStateVariables(start, offset, impossible) {
                        if (impossible) {
                            if (this.isImpossible())
                                return false;
                            this.setImpossible(true);
                            return true;
                        }
                        if (offset.equals(this.mOffset) && !this.isImpossible() && start.equals(this.mStart))
                            return false;
                        this.mOffset = offset;
                        this.mStart = start;
                        this.mEnd = null;
                        this.setImpossible(false);
                        return true;
                    }
                    getStart() {
                        return this.mStart;
                    }
                    getEnd() {
                        if (this.mEnd == null)
                            this.mEnd = this.mStart.plus(this.mOffset);
                        return this.mEnd;
                    }
                    getOffset() {
                        return this.mOffset;
                    }
                    getCentroid() {
                        return com.vzome.core.algebra.AlgebraicVectors.getCentroid([this.mStart, this.mEnd]);
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        let result = doc.createElement("segment");
                        result.setAttribute("start", this.mStart.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                        result.setAttribute("end", this.getEnd().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                        return result;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return "segment from " + this.mStart + " to " + this.getEnd();
                    }
                }
                construction.Segment = Segment;
                Segment["__class"] = "com.vzome.core.construction.Segment";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @extends com.vzome.core.construction.Construction
                 * @class
                 */
                class Point extends com.vzome.core.construction.Construction {
                    constructor(field) {
                        super(field);
                        if (this.mLocation === undefined)
                            this.mLocation = null;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        return this.mLocation.dimension() === 3;
                    }
                    setStateVariable(loc, impossible) {
                        if (impossible) {
                            if (this.isImpossible())
                                return false;
                            this.setImpossible(true);
                            return true;
                        }
                        if (loc.equals(this.mLocation) && !this.isImpossible())
                            return false;
                        this.mLocation = loc;
                        this.setImpossible(false);
                        return true;
                    }
                    getLocation() {
                        return this.mLocation;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        let result = doc.createElement("point");
                        result.setAttribute("at", this.getLocation().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                        return result;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    toString() {
                        return "point at " + this.mLocation;
                    }
                }
                construction.Point = Point;
                Point["__class"] = "com.vzome.core.construction.Point";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class Marker extends com.vzome.core.construction.Construction {
                    constructor(target) {
                        super(target.field);
                        if (this.mTarget === undefined)
                            this.mTarget = null;
                        this.mTarget = target;
                    }
                    getTarget() {
                        return this.mTarget;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return false;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        let result = doc.createElement("marker");
                        return result;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        return this.mTarget.is3d();
                    }
                }
                construction.Marker = Marker;
                Marker["__class"] = "com.vzome.core.construction.Marker";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @extends com.vzome.core.construction.Construction
                 * @class
                 */
                class Plane extends com.vzome.core.construction.Construction {
                    constructor(field) {
                        super(field);
                        if (this.mBase === undefined)
                            this.mBase = null;
                        if (this.mNormal === undefined)
                            this.mNormal = null;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        return true;
                    }
                    setStateVariables(base, normal, impossible) {
                        if (impossible) {
                            if (this.isImpossible())
                                return false;
                            this.setImpossible(true);
                            return true;
                        }
                        if (normal.equals(this.mNormal) && !this.isImpossible() && base.equals(this.mBase))
                            return false;
                        normal = normal.projectTo3d(true);
                        this.mNormal = normal;
                        this.mBase = base.projectTo3d(true);
                        this.setImpossible(false);
                        return true;
                    }
                    getBase() {
                        return this.mBase;
                    }
                    getNormal() {
                        return this.mNormal;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        let result = doc.createElement("plane");
                        return result;
                    }
                    getHomogeneous() {
                        return null;
                    }
                }
                construction.Plane = Plane;
                Plane["__class"] = "com.vzome.core.construction.Plane";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @extends com.vzome.core.construction.Construction
                 * @class
                 */
                class Line extends com.vzome.core.construction.Construction {
                    constructor(field) {
                        super(field);
                        if (this.mDirection === undefined)
                            this.mDirection = null;
                        if (this.mStart === undefined)
                            this.mStart = null;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    is3d() {
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} start
                     * @param {com.vzome.core.algebra.AlgebraicVector} norm need not be normalized yet
                     * @return
                     * @param {boolean} impossible
                     * @return {boolean}
                     */
                    setStateVariables(start, norm, impossible) {
                        if (impossible) {
                            if (this.isImpossible())
                                return false;
                            this.setImpossible(true);
                            return true;
                        }
                        if (norm.equals(this.mDirection) && start.equals(this.mStart) && !this.isImpossible())
                            return false;
                        this.mDirection = norm;
                        this.mStart = start;
                        this.setImpossible(false);
                        return true;
                    }
                    getStart() {
                        return this.mStart;
                    }
                    /**
                     * @return {com.vzome.core.algebra.AlgebraicVector} a "unit" vector... always normalized
                     */
                    getDirection() {
                        return this.mDirection;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        let result = doc.createElement("line");
                        return result;
                    }
                    getHomogeneous() {
                        let v1 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mStart, this.getField());
                        let v2 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mStart.plus(this.mDirection), this.getField());
                        return v1.outer(v2);
                    }
                }
                construction.Line = Line;
                Line["__class"] = "com.vzome.core.construction.Line";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var generic;
            (function (generic) {
                /**
                 * @author David Hall
                 * @param {java.lang.Class} subClass
                 * @param {*} preTest
                 * @param {*} iterable
                 * @param {*} postTest
                 * @class
                 * @extends com.vzome.core.generic.FilteredIterator
                 */
                class SubClassIterator extends com.vzome.core.generic.FilteredIterator {
                    constructor(subClass, preTest, iterable, postTest) {
                        super((preTest), iterable, (postTest));
                        if (this.subClass === undefined)
                            this.subClass = null;
                        this.subClass = subClass;
                    }
                    /**
                     *
                     * @param {*} element
                     * @return {boolean}
                     */
                    preFilter(element) {
                        return (element != null && this.subClass.isAssignableFrom(element.constructor)) ? super.preFilter(element) : false;
                    }
                    /**
                     *
                     * @param {*} element
                     * @return {com.vzome.core.generic.SubClassIterator.T}
                     */
                    apply(element) {
                        return this.subClass.cast(element);
                    }
                }
                generic.SubClassIterator = SubClassIterator;
                SubClassIterator["__class"] = "com.vzome.core.generic.SubClassIterator";
                SubClassIterator["__interfaces"] = ["java.util.Iterator", "java.lang.Iterable"];
            })(generic = core.generic || (core.generic = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    /**
                     * @author David Hall
                     * @class
                     */
                    class Manifestations {
                        static visibleManifestations$java_lang_Iterable(manifestations) {
                            return new Manifestations.ManifestationIterator((man) => { return Manifestations.Filters.isVisible(man); }, manifestations, (null));
                        }
                        static visibleManifestations$java_util_function_Predicate$java_lang_Iterable(preTest, manifestations) {
                            return new Manifestations.ManifestationIterator((preTest), manifestations, (man) => { return Manifestations.Filters.isVisible(man); });
                        }
                        static visibleManifestations(preTest, manifestations) {
                            if (((typeof preTest === 'function' && preTest.length == 1) || preTest === null) && ((manifestations != null && (manifestations["__interfaces"] != null && manifestations["__interfaces"].indexOf("java.lang.Iterable") >= 0 || manifestations.constructor != null && manifestations.constructor["__interfaces"] != null && manifestations.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || manifestations === null)) {
                                return com.vzome.core.editor.api.Manifestations.visibleManifestations$java_util_function_Predicate$java_lang_Iterable(preTest, manifestations);
                            }
                            else if (((preTest != null && (preTest["__interfaces"] != null && preTest["__interfaces"].indexOf("java.lang.Iterable") >= 0 || preTest.constructor != null && preTest.constructor["__interfaces"] != null && preTest.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preTest === null) && ((typeof manifestations === 'function' && manifestations.length == 1) || manifestations === null)) {
                                return com.vzome.core.editor.api.Manifestations.visibleManifestations$java_lang_Iterable$java_util_function_Predicate(preTest, manifestations);
                            }
                            else if (((preTest != null && (preTest["__interfaces"] != null && preTest["__interfaces"].indexOf("java.lang.Iterable") >= 0 || preTest.constructor != null && preTest.constructor["__interfaces"] != null && preTest.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preTest === null) && manifestations === undefined) {
                                return com.vzome.core.editor.api.Manifestations.visibleManifestations$java_lang_Iterable(preTest);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static visibleManifestations$java_lang_Iterable$java_util_function_Predicate(manifestations, postTest) {
                            return new Manifestations.ManifestationIterator((man) => { return Manifestations.Filters.isVisible(man); }, manifestations, (postTest));
                        }
                        static getConnectors$java_lang_Iterable(manifestations) {
                            return new Manifestations.ConnectorIterator((null), manifestations, (null));
                        }
                        static getConnectors$java_lang_Iterable$java_util_function_Predicate(manifestations, postFilter) {
                            return new Manifestations.ConnectorIterator((null), manifestations, (postFilter));
                        }
                        static getConnectors$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter) {
                            return new Manifestations.ConnectorIterator((preFilter), manifestations, (postFilter));
                        }
                        static getConnectors(preFilter, manifestations, postFilter) {
                            if (((typeof preFilter === 'function' && preFilter.length == 1) || preFilter === null) && ((manifestations != null && (manifestations["__interfaces"] != null && manifestations["__interfaces"].indexOf("java.lang.Iterable") >= 0 || manifestations.constructor != null && manifestations.constructor["__interfaces"] != null && manifestations.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || manifestations === null) && ((typeof postFilter === 'function' && postFilter.length == 1) || postFilter === null)) {
                                return com.vzome.core.editor.api.Manifestations.getConnectors$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter);
                            }
                            else if (((preFilter != null && (preFilter["__interfaces"] != null && preFilter["__interfaces"].indexOf("java.lang.Iterable") >= 0 || preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && ((typeof manifestations === 'function' && manifestations.length == 1) || manifestations === null) && postFilter === undefined) {
                                return com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations);
                            }
                            else if (((preFilter != null && (preFilter["__interfaces"] != null && preFilter["__interfaces"].indexOf("java.lang.Iterable") >= 0 || preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && manifestations === undefined && postFilter === undefined) {
                                return com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(preFilter);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static getVisibleConnectors(manifestations, postFilter = null) {
                            return new Manifestations.ConnectorIterator((man) => { return Manifestations.Filters.isVisible(man); }, manifestations, (postFilter));
                        }
                        static getHiddenConnectors(manifestations, postFilter = null) {
                            return new Manifestations.ConnectorIterator((man) => { return Manifestations.Filters.isHidden(man); }, manifestations, (postFilter));
                        }
                        static getStruts$java_lang_Iterable(manifestations) {
                            return new Manifestations.StrutIterator((null), manifestations, (null));
                        }
                        static getStruts$java_lang_Iterable$java_util_function_Predicate(manifestations, postFilter) {
                            return new Manifestations.StrutIterator((null), manifestations, (postFilter));
                        }
                        static getStruts$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter) {
                            return new Manifestations.StrutIterator((preFilter), manifestations, (postFilter));
                        }
                        static getStruts(preFilter, manifestations, postFilter) {
                            if (((typeof preFilter === 'function' && preFilter.length == 1) || preFilter === null) && ((manifestations != null && (manifestations["__interfaces"] != null && manifestations["__interfaces"].indexOf("java.lang.Iterable") >= 0 || manifestations.constructor != null && manifestations.constructor["__interfaces"] != null && manifestations.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || manifestations === null) && ((typeof postFilter === 'function' && postFilter.length == 1) || postFilter === null)) {
                                return com.vzome.core.editor.api.Manifestations.getStruts$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter);
                            }
                            else if (((preFilter != null && (preFilter["__interfaces"] != null && preFilter["__interfaces"].indexOf("java.lang.Iterable") >= 0 || preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && ((typeof manifestations === 'function' && manifestations.length == 1) || manifestations === null) && postFilter === undefined) {
                                return com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations);
                            }
                            else if (((preFilter != null && (preFilter["__interfaces"] != null && preFilter["__interfaces"].indexOf("java.lang.Iterable") >= 0 || preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && manifestations === undefined && postFilter === undefined) {
                                return com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(preFilter);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static getVisibleStruts(manifestations, postFilter = null) {
                            return new Manifestations.StrutIterator((man) => { return Manifestations.Filters.isVisible(man); }, manifestations, (postFilter));
                        }
                        static getHiddenStruts(manifestations, postFilter = null) {
                            return new Manifestations.StrutIterator((man) => { return Manifestations.Filters.isHidden(man); }, manifestations, (postFilter));
                        }
                        static getPanels$java_lang_Iterable(manifestations) {
                            return new Manifestations.PanelIterator((null), manifestations, (null));
                        }
                        static getPanels$java_lang_Iterable$java_util_function_Predicate(manifestations, postFilter) {
                            return new Manifestations.PanelIterator((null), manifestations, (postFilter));
                        }
                        static getPanels$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter) {
                            return new Manifestations.PanelIterator((preFilter), manifestations, (postFilter));
                        }
                        static getPanels(preFilter, manifestations, postFilter) {
                            if (((typeof preFilter === 'function' && preFilter.length == 1) || preFilter === null) && ((manifestations != null && (manifestations["__interfaces"] != null && manifestations["__interfaces"].indexOf("java.lang.Iterable") >= 0 || manifestations.constructor != null && manifestations.constructor["__interfaces"] != null && manifestations.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || manifestations === null) && ((typeof postFilter === 'function' && postFilter.length == 1) || postFilter === null)) {
                                return com.vzome.core.editor.api.Manifestations.getPanels$java_util_function_Predicate$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations, postFilter);
                            }
                            else if (((preFilter != null && (preFilter["__interfaces"] != null && preFilter["__interfaces"].indexOf("java.lang.Iterable") >= 0 || preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && ((typeof manifestations === 'function' && manifestations.length == 1) || manifestations === null) && postFilter === undefined) {
                                return com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable$java_util_function_Predicate(preFilter, manifestations);
                            }
                            else if (((preFilter != null && (preFilter["__interfaces"] != null && preFilter["__interfaces"].indexOf("java.lang.Iterable") >= 0 || preFilter.constructor != null && preFilter.constructor["__interfaces"] != null && preFilter.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || preFilter === null) && manifestations === undefined && postFilter === undefined) {
                                return com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(preFilter);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        static getVisiblePanels(manifestations, postFilter = null) {
                            return new Manifestations.PanelIterator((man) => { return Manifestations.Filters.isVisible(man); }, manifestations, (postFilter));
                        }
                        static getHiddenPanels(manifestations, postFilter = null) {
                            return new Manifestations.PanelIterator((man) => { return Manifestations.Filters.isHidden(man); }, manifestations, (postFilter));
                        }
                    }
                    api.Manifestations = Manifestations;
                    Manifestations["__class"] = "com.vzome.core.editor.api.Manifestations";
                    (function (Manifestations) {
                        class ManifestationIterator extends com.vzome.core.generic.FilteredIterator {
                            constructor(preTest, manifestations, postTest) {
                                super((preTest), manifestations, (postTest));
                            }
                            apply$com_vzome_core_model_Manifestation(element) {
                                return element;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {*}
                             */
                            apply(element) {
                                if (((element != null && (element["__interfaces"] != null && element["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.apply$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)');
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                        }
                        Manifestations.ManifestationIterator = ManifestationIterator;
                        ManifestationIterator["__class"] = "com.vzome.core.editor.api.Manifestations.ManifestationIterator";
                        ManifestationIterator["__interfaces"] = ["java.util.Iterator", "java.lang.Iterable"];
                        class ConnectorIterator extends com.vzome.core.generic.FilteredIterator {
                            preFilter$com_vzome_core_model_Manifestation(element) {
                                return (element != null && (element != null && (element["__interfaces"] != null && element["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))) ? super.preFilter(element) : false;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {boolean}
                             */
                            preFilter(element) {
                                if (((element != null && (element["__interfaces"] != null && element["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.preFilter$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    super.preFilter(element);
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                            apply$com_vzome_core_model_Manifestation(element) {
                                return element;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {*}
                             */
                            apply(element) {
                                if (((element != null && (element["__interfaces"] != null && element["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.apply$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)');
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                            constructor(preFilter, manifestations, postFilter) {
                                super((preFilter), manifestations, (postFilter));
                            }
                        }
                        Manifestations.ConnectorIterator = ConnectorIterator;
                        ConnectorIterator["__class"] = "com.vzome.core.editor.api.Manifestations.ConnectorIterator";
                        ConnectorIterator["__interfaces"] = ["java.util.Iterator", "java.lang.Iterable"];
                        class StrutIterator extends com.vzome.core.generic.FilteredIterator {
                            preFilter$com_vzome_core_model_Manifestation(element) {
                                return (element != null && (element != null && (element["__interfaces"] != null && element["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))) ? super.preFilter(element) : false;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {boolean}
                             */
                            preFilter(element) {
                                if (((element != null && (element["__interfaces"] != null && element["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.preFilter$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    super.preFilter(element);
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                            apply$com_vzome_core_model_Manifestation(element) {
                                return element;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {*}
                             */
                            apply(element) {
                                if (((element != null && (element["__interfaces"] != null && element["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.apply$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)');
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                            constructor(preFilter, manifestations, postFilter) {
                                super((preFilter), manifestations, (postFilter));
                            }
                        }
                        Manifestations.StrutIterator = StrutIterator;
                        StrutIterator["__class"] = "com.vzome.core.editor.api.Manifestations.StrutIterator";
                        StrutIterator["__interfaces"] = ["java.util.Iterator", "java.lang.Iterable"];
                        class PanelIterator extends com.vzome.core.generic.FilteredIterator {
                            preFilter$com_vzome_core_model_Manifestation(element) {
                                return (element != null && (element != null && (element["__interfaces"] != null && element["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))) ? super.preFilter(element) : false;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {boolean}
                             */
                            preFilter(element) {
                                if (((element != null && (element["__interfaces"] != null && element["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.preFilter$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    super.preFilter(element);
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                            apply$com_vzome_core_model_Manifestation(element) {
                                return element;
                            }
                            /**
                             *
                             * @param {*} element
                             * @return {*}
                             */
                            apply(element) {
                                if (((element != null && (element["__interfaces"] != null && element["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || element.constructor != null && element.constructor["__interfaces"] != null && element.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || element === null)) {
                                    return this.apply$com_vzome_core_model_Manifestation(element);
                                }
                                else if (((element != null) || element === null)) {
                                    throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)');
                                }
                                else
                                    throw new Error('invalid overload');
                            }
                            constructor(preFilter, manifestations, postFilter) {
                                super((preFilter), manifestations, (postFilter));
                            }
                        }
                        Manifestations.PanelIterator = PanelIterator;
                        PanelIterator["__class"] = "com.vzome.core.editor.api.Manifestations.PanelIterator";
                        PanelIterator["__interfaces"] = ["java.util.Iterator", "java.lang.Iterable"];
                        class Filters {
                            constructor() {
                            }
                            static isRendered(man) {
                                return man.isRendered();
                            }
                            static isVisible(man) {
                                return !man.isHidden();
                            }
                            static isHidden(man) {
                                return man.isHidden();
                            }
                            static is(man) {
                                return true;
                            }
                        }
                        Manifestations.Filters = Filters;
                        Filters["__class"] = "com.vzome.core.editor.api.Manifestations.Filters";
                    })(Manifestations = api.Manifestations || (api.Manifestations = {}));
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class XmlSymmetryFormat extends com.vzome.core.commands.XmlSaveFormat {
                    constructor(version, capabilities) {
                        super(version, capabilities);
                        if (this.symmetries === undefined)
                            this.symmetries = null;
                    }
                    static __static_initialize() { if (!XmlSymmetryFormat.__static_initialized) {
                        XmlSymmetryFormat.__static_initialized = true;
                        XmlSymmetryFormat.__static_initializer_0();
                    } }
                    static __com_vzome_core_commands_XmlSymmetryFormat_logger_$LI$() { XmlSymmetryFormat.__static_initialize(); if (XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger == null)
                        XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger = java.util.logging.Logger.getLogger("com.vzome.core.commands.XmlSaveFormat"); return XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger; }
                    ;
                    static __static_initializer_0() {
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.0/", [com.vzome.core.commands.XmlSaveFormat.PROJECT_4D, com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.0.1/", [com.vzome.core.commands.XmlSaveFormat.PROJECT_4D, com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.0.2/", [com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.0.3/", [com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/2.1.0/", [com.vzome.core.commands.XmlSaveFormat.SELECTION_NOT_SAVED, com.vzome.core.commands.XmlSaveFormat.FORMAT_2_1_0]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/3.0.0/", [com.vzome.core.commands.XmlSaveFormat.GROUPING_IN_SELECTION]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/4.0.0/", [com.vzome.core.commands.XmlSaveFormat.RATIONAL_VECTORS, com.vzome.core.commands.XmlSaveFormat.GROUPING_IN_SELECTION]);
                        new XmlSymmetryFormat("http://tns.vorthmann.org/vZome/5.0.0/", [com.vzome.core.commands.XmlSaveFormat.RATIONAL_VECTORS, com.vzome.core.commands.XmlSaveFormat.COMPACTED_COMMAND_EDITS]);
                        new XmlSymmetryFormat(com.vzome.core.commands.XmlSaveFormat.CURRENT_FORMAT, [com.vzome.core.commands.XmlSaveFormat.RATIONAL_VECTORS, com.vzome.core.commands.XmlSaveFormat.COMPACTED_COMMAND_EDITS, com.vzome.core.commands.XmlSaveFormat.MULTIPLE_DESIGNS]);
                    }
                    static getFormat(namespace) {
                        return com.vzome.core.commands.XmlSaveFormat.FORMATS_$LI$().get(namespace);
                    }
                    initialize$com_vzome_core_algebra_AlgebraicField$com_vzome_core_math_symmetry_OrbitSet_Field$int$java_lang_String$java_util_Properties(field, symms, scale, writerVersion, props) {
                        super.initialize(field, scale, writerVersion, props);
                        this.symmetries = symms;
                    }
                    initialize(field, symms, scale, writerVersion, props) {
                        if (((field != null && (field["__interfaces"] != null && field["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((symms != null && (symms["__interfaces"] != null && symms["__interfaces"].indexOf("com.vzome.core.math.symmetry.OrbitSet.Field") >= 0 || symms.constructor != null && symms.constructor["__interfaces"] != null && symms.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.OrbitSet.Field") >= 0)) || symms === null) && ((typeof scale === 'number') || scale === null) && ((typeof writerVersion === 'string') || writerVersion === null) && ((props != null && props instanceof java.util.Properties) || props === null)) {
                            return this.initialize$com_vzome_core_algebra_AlgebraicField$com_vzome_core_math_symmetry_OrbitSet_Field$int$java_lang_String$java_util_Properties(field, symms, scale, writerVersion, props);
                        }
                        else if (((field != null && (field["__interfaces"] != null && field["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((typeof symms === 'number') || symms === null) && ((typeof scale === 'string') || scale === null) && ((writerVersion != null && writerVersion instanceof java.util.Properties) || writerVersion === null) && props === undefined) {
                            super.initialize(field, symms, scale, writerVersion);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    parseAlgebraicObject(valName, val) {
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(valName, "Symmetry")) {
                            let name = val.getAttribute("name");
                            return this.parseSymmetry(name);
                        }
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(valName, "QuaternionicSymmetry")) {
                            let name = val.getAttribute("name");
                            return this.getQuaternionicSymmetry(name);
                        }
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(valName, "Axis"))
                            return this.parseAxis(val, "symm", "dir", "index", "sense");
                        else {
                            return super.parseAlgebraicObject(valName, val);
                        }
                    }
                    getQuaternionicSymmetry(name) {
                        return this.symmetries.getQuaternionSet(name);
                    }
                    parseSymmetry(sname) {
                        let group = this.symmetries.getGroup(sname);
                        let symm = group.getSymmetry();
                        if (symm == null) {
                            XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger_$LI$().severe("UNSUPPORTED symmetry: " + sname);
                            throw new java.lang.IllegalStateException("no symmetry with name=" + sname);
                        }
                        else
                            return symm;
                    }
                    static serializeAxis(xml, symmAttr, dirAttr, indexAttr, senseAttr, axis) {
                        let str = axis.getDirection().getSymmetry().getName();
                        if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("icosahedral", str))
                            com.vzome.xml.DomUtils.addAttribute(xml, symmAttr, str);
                        str = axis.getDirection().getName();
                        if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("blue", str))
                            com.vzome.xml.DomUtils.addAttribute(xml, dirAttr, str);
                        com.vzome.xml.DomUtils.addAttribute(xml, indexAttr, /* toString */ ('' + (axis.getOrientation())));
                        if (axis.getSense() !== com.vzome.core.math.symmetry.Symmetry.PLUS)
                            com.vzome.xml.DomUtils.addAttribute(xml, "sense", "minus");
                        if (!axis.isOutbound())
                            com.vzome.xml.DomUtils.addAttribute(xml, "outbound", "false");
                    }
                    parseAxis(xml, symmAttr, dirAttr, indexAttr, senseAttr) {
                        let sname = xml.getAttribute(symmAttr);
                        if (sname == null || /* isEmpty */ (sname.length === 0))
                            sname = "icosahedral";
                        let group = this.symmetries.getGroup(sname);
                        let aname = xml.getAttribute(dirAttr);
                        if (aname == null || /* isEmpty */ (aname.length === 0))
                            aname = "blue";
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(aname, "tan"))
                            aname = "sand";
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(aname, "spring"))
                            aname = "apple";
                        let iname = xml.getAttribute(indexAttr);
                        let index = javaemul.internal.IntegerHelper.parseInt(iname);
                        let sense = com.vzome.core.math.symmetry.Symmetry.PLUS;
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("minus", xml.getAttribute(senseAttr))) {
                            sense = com.vzome.core.math.symmetry.Symmetry.MINUS;
                        }
                        let outbound = true;
                        let outs = xml.getAttribute("outbound");
                        if (outs != null && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(outs, "false"))
                            outbound = false;
                        let dir = group.getDirection(aname);
                        if (dir == null) {
                            let msg = "Unsupported direction \'" + aname + "\' in " + sname + " symmetry";
                            XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger_$LI$().severe(msg);
                            throw new java.lang.IllegalStateException(msg);
                        }
                        return dir.getAxis$int$int$boolean(sense, index, outbound);
                    }
                }
                XmlSymmetryFormat.__static_initialized = false;
                commands.XmlSymmetryFormat = XmlSymmetryFormat;
                XmlSymmetryFormat["__class"] = "com.vzome.core.commands.XmlSymmetryFormat";
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandFreePoint extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAMS_$LI$() { if (CommandFreePoint.PARAMS == null)
                        CommandFreePoint.PARAMS = []; return CommandFreePoint.PARAMS; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandFreePoint.PARAMS_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return null;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        let result = new com.vzome.core.construction.ConstructionList();
                        let loc = attributes.get("where");
                        let pt2 = new com.vzome.core.construction.FreePoint(loc);
                        effects.constructionAdded(pt2);
                        result.addConstruction(pt2);
                        return result;
                    }
                }
                commands.CommandFreePoint = CommandFreePoint;
                CommandFreePoint["__class"] = "com.vzome.core.commands.CommandFreePoint";
                CommandFreePoint["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandHide extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandHide.PARAM_SIGNATURE == null)
                        CommandHide.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Construction]]; return CommandHide.PARAM_SIGNATURE; }
                    ;
                    static ATTR_SIGNATURE_$LI$() { if (CommandHide.ATTR_SIGNATURE == null)
                        CommandHide.ATTR_SIGNATURE = []; return CommandHide.ATTR_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandHide.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return CommandHide.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        throw new commands.Command.Failure("CommandHide apply attempted");
                    }
                }
                commands.CommandHide = CommandHide;
                CommandHide["__class"] = "com.vzome.core.commands.CommandHide";
                CommandHide["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class CommandSetColor extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandSetColor.PARAM_SIGNATURE == null)
                        CommandSetColor.PARAM_SIGNATURE = []; return CommandSetColor.PARAM_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandSetColor.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return null;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        return parameters;
                    }
                }
                CommandSetColor.MANIFESTATION_ATTR = "manifestation.context";
                CommandSetColor.COLOR_ATTR = "color";
                commands.CommandSetColor = CommandSetColor;
                CommandSetColor["__class"] = "com.vzome.core.commands.CommandSetColor";
                CommandSetColor["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class GroupSelection extends com.vzome.core.editor.api.UndoableEdit {
                    constructor(editor) {
                        super();
                        if (this.mSelection === undefined)
                            this.mSelection = null;
                        this.mGrouping = false;
                        this.recursiveGroups = true;
                        this.unnecessary = false;
                        this.mSelection = editor.getSelection();
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        let mode = props.get("mode");
                        this.mGrouping = (mode == null) || /* isEmpty */ (mode.length === 0) || /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(mode, "group");
                        this.unnecessary = this.mGrouping === this.mSelection.isSelectionAGroup();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return this.unnecessary;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        let elem = doc.createElement("GroupSelection");
                        if (!this.mGrouping)
                            com.vzome.xml.DomUtils.addAttribute(elem, "grouping", "false");
                        return elem;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getDetailXml(doc) {
                        return this.getXml(doc);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        let grouping = xml.getAttribute("grouping");
                        this.mGrouping = (grouping == null) || /* isEmpty */ (grouping.length === 0) || /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(grouping, "true");
                        this.recursiveGroups = format.groupingRecursive();
                        context.performAndRecord(this);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isDestructive() {
                        return true;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isVisible() {
                        return true;
                    }
                    /**
                     *
                     */
                    redo() {
                        if (this.mGrouping)
                            if (this.recursiveGroups)
                                this.mSelection.gatherGroup();
                            else
                                this.mSelection.gatherGroup211();
                        else if (this.recursiveGroups)
                            this.mSelection.scatterGroup();
                        else
                            this.mSelection.scatterGroup211();
                    }
                    /**
                     *
                     */
                    undo() {
                        if (!this.mGrouping)
                            if (this.recursiveGroups)
                                this.mSelection.gatherGroup();
                            else
                                this.mSelection.gatherGroup211();
                        else if (this.recursiveGroups)
                            this.mSelection.scatterGroup();
                        else
                            this.mSelection.scatterGroup211();
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.unnecessary)
                            return;
                        this.redo();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return false;
                    }
                }
                edits.GroupSelection = GroupSelection;
                GroupSelection["__class"] = "com.vzome.core.edits.GroupSelection";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * Used by CommandEdit.
                 * @param {*} editor
                 * @param m
                 * @param {com.vzome.core.construction.Point} newCenter
                 * @class
                 * @extends com.vzome.core.editor.api.UndoableEdit
                 */
                class SymmetryCenterChange extends com.vzome.core.editor.api.UndoableEdit {
                    constructor(editor, newCenter) {
                        if (((editor != null && (editor["__interfaces"] != null && editor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0 || editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0)) || editor === null) && ((newCenter != null && newCenter instanceof com.vzome.core.construction.Point) || newCenter === null)) {
                            let __args = arguments;
                            super();
                            if (this.mOldCenter === undefined)
                                this.mOldCenter = null;
                            if (this.mNewCenter === undefined)
                                this.mNewCenter = null;
                            if (this.editor === undefined)
                                this.editor = null;
                            if (this.mOldCenter === undefined)
                                this.mOldCenter = null;
                            if (this.mNewCenter === undefined)
                                this.mNewCenter = null;
                            if (this.editor === undefined)
                                this.editor = null;
                            (() => {
                                this.mOldCenter = editor.getCenterPoint();
                                this.mNewCenter = newCenter;
                                this.editor = editor;
                            })();
                        }
                        else if (((editor != null && (editor["__interfaces"] != null && editor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0 || editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0)) || editor === null) && newCenter === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let newCenter = null;
                                super();
                                if (this.mOldCenter === undefined)
                                    this.mOldCenter = null;
                                if (this.mNewCenter === undefined)
                                    this.mNewCenter = null;
                                if (this.editor === undefined)
                                    this.editor = null;
                                if (this.mOldCenter === undefined)
                                    this.mOldCenter = null;
                                if (this.mNewCenter === undefined)
                                    this.mNewCenter = null;
                                if (this.editor === undefined)
                                    this.editor = null;
                                (() => {
                                    this.mOldCenter = editor.getCenterPoint();
                                    this.mNewCenter = newCenter;
                                    this.editor = editor;
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    configure(props) {
                        let man = props.get("picked");
                        if (man != null)
                            this.mNewCenter = man.getFirstConstruction();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return this.mNewCenter == null || this.mNewCenter.getLocation().equals(this.mOldCenter.getLocation());
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isVisible() {
                        return false;
                    }
                    /**
                     *
                     */
                    redo() {
                        if (this.isNoOp())
                            return;
                        this.editor.setCenterPoint(this.mNewCenter);
                    }
                    /**
                     *
                     */
                    undo() {
                        if (this.isNoOp())
                            return;
                        this.editor.setCenterPoint(this.mOldCenter);
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        let result = doc.createElement("SymmetryCenterChange");
                        com.vzome.core.commands.XmlSaveFormat.serializePoint(result, "new", this.mNewCenter);
                        return result;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getDetailXml(doc) {
                        return this.getXml(doc);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        if (format.rationalVectors()) {
                            this.mNewCenter = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "new");
                        }
                        else {
                            let attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                            let center = attrs.get("new");
                            this.mNewCenter = new com.vzome.core.construction.FreePoint(center.getLocation().projectTo3d(true));
                        }
                        context.performAndRecord(this);
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.mNewCenter == null) {
                            this.mNewCenter = this.editor.getSelectedConstruction(com.vzome.core.construction.Point);
                            if (this.mNewCenter == null)
                                throw new com.vzome.core.commands.Command.Failure("Selection is not a single ball.");
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isDestructive() {
                        return true;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return false;
                    }
                }
                edits.SymmetryCenterChange = SymmetryCenterChange;
                SymmetryCenterChange["__class"] = "com.vzome.core.edits.SymmetryCenterChange";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * Used by CommandEdit.
                 * @param {*} editor
                 * @param m
                 * @param {com.vzome.core.construction.Segment} newAxis
                 * @class
                 * @extends com.vzome.core.editor.api.UndoableEdit
                 */
                class SymmetryAxisChange extends com.vzome.core.editor.api.UndoableEdit {
                    constructor(editor, newAxis) {
                        if (((editor != null && (editor["__interfaces"] != null && editor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0 || editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0)) || editor === null) && ((newAxis != null && newAxis instanceof com.vzome.core.construction.Segment) || newAxis === null)) {
                            let __args = arguments;
                            super();
                            if (this.mOldAxis === undefined)
                                this.mOldAxis = null;
                            if (this.mNewAxis === undefined)
                                this.mNewAxis = null;
                            if (this.mEditor === undefined)
                                this.mEditor = null;
                            if (this.mOldAxis === undefined)
                                this.mOldAxis = null;
                            if (this.mNewAxis === undefined)
                                this.mNewAxis = null;
                            if (this.mEditor === undefined)
                                this.mEditor = null;
                            (() => {
                                this.mOldAxis = editor.getSymmetrySegment();
                                this.mNewAxis = newAxis;
                                this.mEditor = editor;
                            })();
                        }
                        else if (((editor != null && (editor["__interfaces"] != null && editor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0 || editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.ImplicitSymmetryParameters") >= 0)) || editor === null) && newAxis === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let newAxis = null;
                                super();
                                if (this.mOldAxis === undefined)
                                    this.mOldAxis = null;
                                if (this.mNewAxis === undefined)
                                    this.mNewAxis = null;
                                if (this.mEditor === undefined)
                                    this.mEditor = null;
                                if (this.mOldAxis === undefined)
                                    this.mOldAxis = null;
                                if (this.mNewAxis === undefined)
                                    this.mNewAxis = null;
                                if (this.mEditor === undefined)
                                    this.mEditor = null;
                                (() => {
                                    this.mOldAxis = editor.getSymmetrySegment();
                                    this.mNewAxis = newAxis;
                                    this.mEditor = editor;
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    configure(props) {
                        let man = props.get("picked");
                        if (man != null)
                            this.mNewAxis = man.getFirstConstruction();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isVisible() {
                        return false;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return this.mNewAxis == null || (this.mOldAxis != null && this.mNewAxis.getStart().equals(this.mOldAxis.getStart()) && this.mNewAxis.getEnd().equals(this.mOldAxis.getEnd()));
                    }
                    /**
                     *
                     */
                    redo() {
                        if (this.isNoOp())
                            return;
                        this.mEditor.setSymmetrySegment(this.mNewAxis);
                    }
                    /**
                     *
                     */
                    undo() {
                        if (this.isNoOp())
                            return;
                        this.mEditor.setSymmetrySegment(this.mOldAxis);
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        let result = doc.createElement("SymmetryAxisChange");
                        com.vzome.core.commands.XmlSaveFormat.serializeSegment(result, "start", "end", this.mNewAxis);
                        return result;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getDetailXml(doc) {
                        return this.getXml(doc);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        if (format.rationalVectors()) {
                            this.mNewAxis = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "start", "end");
                        }
                        else {
                            let attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                            this.mNewAxis = attrs.get("new");
                        }
                        context.performAndRecord(this);
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.mNewAxis == null) {
                            this.mNewAxis = this.mEditor.getSelectedConstruction(com.vzome.core.construction.Segment);
                            if (this.mNewAxis == null)
                                throw new com.vzome.core.commands.Command.Failure("Selection is not a single strut.");
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isDestructive() {
                        return true;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return false;
                    }
                }
                edits.SymmetryAxisChange = SymmetryAxisChange;
                SymmetryAxisChange["__class"] = "com.vzome.core.edits.SymmetryAxisChange";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor_3) {
                /**
                 * Just a marker in the history.
                 * @author Scott Vorthmann
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.UndoableEdit
                 */
                class EndBlock extends com.vzome.core.editor.api.UndoableEdit {
                    constructor(editor) {
                        super();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return false;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        return doc.createElement("EndBlock");
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getDetailXml(doc) {
                        return this.getXml(doc);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isVisible() {
                        return false;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isDestructive() {
                        return false;
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        context.performAndRecord(this);
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                    }
                    /**
                     *
                     */
                    perform() {
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return false;
                    }
                }
                editor_3.EndBlock = EndBlock;
                EndBlock["__class"] = "com.vzome.core.editor.EndBlock";
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor_4) {
                /**
                 * Just a marker in the history.
                 * @author Scott Vorthmann
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.UndoableEdit
                 */
                class BeginBlock extends com.vzome.core.editor.api.UndoableEdit {
                    constructor(editor) {
                        super();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return false;
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getXml(doc) {
                        return doc.createElement("BeginBlock");
                    }
                    /**
                     *
                     * @param {*} doc
                     * @return {*}
                     */
                    getDetailXml(doc) {
                        return this.getXml(doc);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isVisible() {
                        return false;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isDestructive() {
                        return false;
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        context.performAndRecord(this);
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     */
                    perform() {
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return false;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                    }
                }
                editor_4.BeginBlock = BeginBlock;
                BeginBlock["__class"] = "com.vzome.core.editor.BeginBlock";
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    class SideEffects extends com.vzome.core.editor.api.UndoableEdit {
                        constructor() {
                            super();
                            this.mItems = (new java.util.ArrayList());
                            this.redone = 0;
                        }
                        /**
                         *
                         * @param {*} doc
                         * @return {*}
                         */
                        getDetailXml(doc) {
                            let result = this.getXml(doc);
                            let effects = doc.createElement("effects");
                            for (let index215 = this.mItems.iterator(); index215.hasNext();) {
                                let se = index215.next();
                                {
                                    if (se != null) {
                                        let effect = se.getXml(doc);
                                        if (effect != null) {
                                            effects.appendChild(effect);
                                        }
                                    }
                                }
                            }
                            result.appendChild(effects);
                            return result;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isSticky() {
                            return false;
                        }
                        static BUG_ACCOMMODATION_LOGGER_$LI$() { if (SideEffects.BUG_ACCOMMODATION_LOGGER == null)
                            SideEffects.BUG_ACCOMMODATION_LOGGER = java.util.logging.Logger.getLogger("com.vzome.core.bug.accommodations"); return SideEffects.BUG_ACCOMMODATION_LOGGER; }
                        ;
                        static logBugAccommodation(accommodation) {
                            if (SideEffects.BUG_ACCOMMODATION_LOGGER_$LI$().isLoggable(java.util.logging.Level.WARNING))
                                SideEffects.BUG_ACCOMMODATION_LOGGER_$LI$().warning("ACCOMMODATION: " + accommodation);
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isVisible() {
                            return true;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isDestructive() {
                            return true;
                        }
                        plan(se) {
                            this.mItems.add(se);
                        }
                        /**
                         *
                         */
                        perform() {
                            this.redo();
                        }
                        fail(message) {
                            this.undo();
                            throw new com.vzome.core.commands.Command.Failure(message);
                        }
                        /**
                         *
                         * @param {*} props
                         */
                        configure(props) {
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        isNoOp() {
                            return this.mItems.size() === 0;
                        }
                        /**
                         *
                         */
                        redo() {
                            for (let i = this.redone; i < this.mItems.size(); i++) {
                                {
                                    let se = this.mItems.get(i);
                                    if (se != null)
                                        se.redo();
                                }
                                ;
                            }
                            this.redone = this.mItems.size();
                        }
                        /**
                         *
                         */
                        undo() {
                            for (let i = this.mItems.size(); i > 0; i--) {
                                {
                                    let se = this.mItems.get(i - 1);
                                    if (se != null)
                                        se.undo();
                                }
                                ;
                            }
                            this.redone = 0;
                        }
                        getEffects() {
                            return this.mItems.iterator();
                        }
                    }
                    api.SideEffects = SideEffects;
                    SideEffects["__class"] = "com.vzome.core.editor.api.SideEffects";
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_1) {
                class OctahedralToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools, symmetry, id = OctahedralToolFactory.ID, label = OctahedralToolFactory.LABEL, tooltip = OctahedralToolFactory.TOOLTIP2) {
                        super(tools, symmetry, id, label, tooltip);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 1 && balls === 1) || (total === 2 && balls === 1 && struts === 1);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.SymmetryTool(id, this.getSymmetry(), this.getToolsModel());
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        let symmetry = this.getSymmetry();
                        let total = this.getSelection().size();
                        if (symmetry != null && symmetry instanceof com.vzome.core.math.symmetry.IcosahedralSymmetry) {
                            if (total !== 2)
                                return false;
                            for (let index216 = selection.iterator(); index216.hasNext();) {
                                let man = index216.next();
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    let zone = symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](man.getOffset());
                                    if (zone == null)
                                        return false;
                                    switch ((zone.getDirection().getName())) {
                                        case "blue":
                                        case "green":
                                            return true;
                                        default:
                                            return false;
                                    }
                                }
                            }
                            return false;
                        }
                        else {
                            return total === 1;
                        }
                    }
                }
                OctahedralToolFactory.ID = "octahedral";
                OctahedralToolFactory.LABEL = "Create an octahedral symmetry tool";
                OctahedralToolFactory.TOOLTIP1 = "<p>Each tool produces up to 23 copies of the input<br>selection, using the rotation symmetries of a<br>cube or octahedron.  To create a tool, select a<br>ball that defines the center of symmetry, and<br>a single blue or green strut, defining one of<br>five possible orientations for the symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 48 symmetries of the octahedron, including<br>reflections.<br></p>";
                OctahedralToolFactory.TOOLTIP2 = "<p>Each tool produces up to 23 copies of the input<br>selection, using the rotation symmetries of a<br>cube or octahedron.  To create a tool, select a<br>ball that defines the center of symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 48 symmetries of the octahedron, including<br>reflections.<br></p>";
                tools_1.OctahedralToolFactory = OctahedralToolFactory;
                OctahedralToolFactory["__class"] = "com.vzome.core.tools.OctahedralToolFactory";
                OctahedralToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_2) {
                class IcosahedralToolFactory extends com.vzome.core.editor.AbstractToolFactory {
                    constructor(tools, symmetry) {
                        super(tools, symmetry, IcosahedralToolFactory.ID, IcosahedralToolFactory.LABEL, IcosahedralToolFactory.TOOLTIP);
                    }
                    /**
                     *
                     * @param {number} total
                     * @param {number} balls
                     * @param {number} struts
                     * @param {number} panels
                     * @return {boolean}
                     */
                    countsAreValid(total, balls, struts, panels) {
                        return (total === 1 && balls === 1);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.SymmetryTool(id, this.getSymmetry(), this.getToolsModel());
                    }
                    /**
                     *
                     * @param {*} selection
                     * @return {boolean}
                     */
                    bindParameters(selection) {
                        return selection.size() === 1 && (selection.iterator().next() != null && (selection.iterator().next()["__interfaces"] != null && selection.iterator().next()["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || selection.iterator().next().constructor != null && selection.iterator().next().constructor["__interfaces"] != null && selection.iterator().next().constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0));
                    }
                }
                IcosahedralToolFactory.ID = "icosahedral";
                IcosahedralToolFactory.LABEL = "Create an icosahedral symmetry tool";
                IcosahedralToolFactory.TOOLTIP = "<p>Each tool produces up to 59 copies of the input<br>selection, using the rotation symmetries of an<br>icosahedron.  To create a tool, select a single<br>ball that defines the center of symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 120 symmetries of the icosahedron, including<br>reflections.<br></p>";
                tools_2.IcosahedralToolFactory = IcosahedralToolFactory;
                IcosahedralToolFactory["__class"] = "com.vzome.core.tools.IcosahedralToolFactory";
                IcosahedralToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandLoad extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandLoad.PARAM_SIGNATURE == null)
                        CommandLoad.PARAM_SIGNATURE = []; return CommandLoad.PARAM_SIGNATURE; }
                    ;
                    static ATTR_SIGNATURE_$LI$() { if (CommandLoad.ATTR_SIGNATURE == null)
                        CommandLoad.ATTR_SIGNATURE = [[CommandLoad.XML_ATTR, "org.w3c.dom.Element"]]; return CommandLoad.ATTR_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandLoad.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return CommandLoad.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        let result = new com.vzome.core.construction.ConstructionList();
                        return result;
                    }
                }
                CommandLoad.XML_ATTR = "xml";
                commands.CommandLoad = CommandLoad;
                CommandLoad["__class"] = "com.vzome.core.commands.CommandLoad";
                CommandLoad["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var math;
            (function (math) {
                /**
                 * Construct a new vector from its coordinate values.
                 * @param {number} x
                 * @param {number} y
                 * @param {number} z
                 * @class
                 */
                class RealVector {
                    constructor(x, y, z) {
                        if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null) && ((typeof z === 'number') || z === null)) {
                            let __args = arguments;
                            if (this.x === undefined)
                                this.x = 0;
                            if (this.y === undefined)
                                this.y = 0;
                            if (this.z === undefined)
                                this.z = 0;
                            if (this.x === undefined)
                                this.x = 0;
                            if (this.y === undefined)
                                this.y = 0;
                            if (this.z === undefined)
                                this.z = 0;
                            (() => {
                                this.x = Math.fround(x);
                                this.y = Math.fround(y);
                                this.z = Math.fround(z);
                            })();
                        }
                        else if (x === undefined && y === undefined && z === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let x = 0.0;
                                let y = 0.0;
                                let z = 0.0;
                                if (this.x === undefined)
                                    this.x = 0;
                                if (this.y === undefined)
                                    this.y = 0;
                                if (this.z === undefined)
                                    this.z = 0;
                                if (this.x === undefined)
                                    this.x = 0;
                                if (this.y === undefined)
                                    this.y = 0;
                                if (this.z === undefined)
                                    this.z = 0;
                                (() => {
                                    this.x = Math.fround(x);
                                    this.y = Math.fround(y);
                                    this.z = Math.fround(z);
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static __static_initialize() { if (!RealVector.__static_initialized) {
                        RealVector.__static_initialized = true;
                        RealVector.__static_initializer_0();
                    } }
                    static ORIGIN_$LI$() { RealVector.__static_initialize(); if (RealVector.ORIGIN == null)
                        RealVector.ORIGIN = new RealVector(0.0, 0.0, 0.0); return RealVector.ORIGIN; }
                    ;
                    static FORMAT_$LI$() { RealVector.__static_initialize(); if (RealVector.FORMAT == null)
                        RealVector.FORMAT = java.text.NumberFormat.getNumberInstance(java.util.Locale.US); return RealVector.FORMAT; }
                    ;
                    static DIRECTION_0_$LI$() { RealVector.__static_initialize(); if (RealVector.DIRECTION_0 == null)
                        RealVector.DIRECTION_0 = new RealVector(10.0, 0.1, -0.1); return RealVector.DIRECTION_0; }
                    ;
                    static __static_initializer_0() {
                        RealVector.FORMAT_$LI$().setMaximumFractionDigits(5);
                        RealVector.FORMAT_$LI$().setMinimumFractionDigits(1);
                    }
                    /**
                     * Return a string representing this vector as XML attribute values.
                     * @return {string}
                     */
                    toXmlAttributes() {
                        return "x=\"" + RealVector.FORMAT_$LI$().format(this.x) + "\" y=\"" + RealVector.FORMAT_$LI$().format(this.y) + "\" z=\"" + RealVector.FORMAT_$LI$().format(this.z) + "\"";
                    }
                    toString$java_text_NumberFormat(format) {
                        return format.format(this.x) + "," + format.format(this.y) + "," + format.format(this.z);
                    }
                    /**
                     * Return a string representing this vector in the form "x,y,z".
                     * @param {java.text.NumberFormat} format
                     * @return {string}
                     */
                    toString(format) {
                        if (((format != null && format instanceof java.text.NumberFormat) || format === null)) {
                            return this.toString$java_text_NumberFormat(format);
                        }
                        else if (format === undefined) {
                            return this.toString$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    toString$() {
                        return RealVector.FORMAT_$LI$().format(this.x) + "," + RealVector.FORMAT_$LI$().format(this.y) + "," + RealVector.FORMAT_$LI$().format(this.z);
                    }
                    /**
                     * Return a string representing this vector in the form "x y z".
                     * @return {string}
                     */
                    spacedString() {
                        let result = RealVector.FORMAT_$LI$().format(this.x) + " " + RealVector.FORMAT_$LI$().format(this.y) + " " + RealVector.FORMAT_$LI$().format(this.z);
                        return result;
                    }
                    /**
                     * Return the sum of this vector plus the vector "other",
                     * as a new Vector3D.
                     * @param {com.vzome.core.math.RealVector} other
                     * @return {com.vzome.core.math.RealVector}
                     */
                    plus(other) {
                        return new RealVector(Math.fround(this.x + other.x), Math.fround(this.y + other.y), Math.fround(this.z + other.z));
                    }
                    /**
                     * Return the difference of this vector minus the vector "other",
                     * as a new Vector3D.
                     * @param {com.vzome.core.math.RealVector} other
                     * @return {com.vzome.core.math.RealVector}
                     */
                    minus(other) {
                        return new RealVector(Math.fround(this.x - other.x), Math.fround(this.y - other.y), Math.fround(this.z - other.z));
                    }
                    /**
                     * Return a new vector equal to this vector scaled by the given factor.
                     * @param {number} factor
                     * @return {com.vzome.core.math.RealVector}
                     */
                    scale(factor) {
                        return new RealVector(this.x * factor, this.y * factor, this.z * factor);
                    }
                    /**
                     * Return the scalar (dot) product with the other vector
                     * @param {com.vzome.core.math.RealVector} other
                     * @return {number}
                     */
                    dot(other) {
                        return Math.fround(Math.fround(Math.fround(this.x * other.x) + Math.fround(this.y * other.y)) + Math.fround(this.z * other.z));
                    }
                    cross(that) {
                        return new RealVector(Math.fround(Math.fround(this.y * that.z) - Math.fround(this.z * that.y)), Math.fround(Math.fround(this.z * that.x) - Math.fround(this.x * that.z)), Math.fround(Math.fround(this.x * that.y) - Math.fround(this.y * that.x)));
                    }
                    /**
                     * Return the length of this vector.
                     * @return {number}
                     */
                    length() {
                        return Math.sqrt(this.dot(this));
                    }
                    normalize() {
                        return this.scale(1.0 / this.length());
                    }
                    write(buf, offset) {
                        buf.put(offset, this.x);
                        buf.put(offset + 1, this.y);
                        buf.put(offset + 2, this.z);
                    }
                    /**
                     *
                     * @param {*} other
                     * @return {boolean}
                     */
                    equals(other) {
                        if (other == null) {
                            return false;
                        }
                        if (other === this) {
                            return true;
                        }
                        if (!(other != null && other instanceof com.vzome.core.math.RealVector))
                            return false;
                        let v = other;
                        return this.x === v.x && this.y === v.y && this.z === v.z;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let hash = 3;
                        hash = 41 * hash + ((javaemul.internal.DoubleHelper.doubleToLongBits(this.x) ^ (javaemul.internal.DoubleHelper.doubleToLongBits(this.x) >>> 32)) | 0);
                        hash = 41 * hash + ((javaemul.internal.DoubleHelper.doubleToLongBits(this.y) ^ (javaemul.internal.DoubleHelper.doubleToLongBits(this.y) >>> 32)) | 0);
                        hash = 41 * hash + ((javaemul.internal.DoubleHelper.doubleToLongBits(this.z) ^ (javaemul.internal.DoubleHelper.doubleToLongBits(this.z) >>> 32)) | 0);
                        return hash;
                    }
                    addTo(addend, sum) {
                        sum[0] = (Math.fround(addend[0] + this.x));
                        sum[1] = (Math.fround(addend[1] + this.y));
                        sum[2] = (Math.fround(addend[2] + this.z));
                    }
                    toArray(output) {
                        output[0] = this.x;
                        output[1] = this.y;
                        output[2] = this.z;
                    }
                }
                RealVector.__static_initialized = false;
                math.RealVector = RealVector;
                RealVector["__class"] = "com.vzome.core.math.RealVector";
            })(math = core.math || (core.math = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsPanel extends com.vzome.jsweet.JsManifestation {
                constructor(field, adapter, coords) {
                    super(field, adapter, coords);
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Construction}
                 */
                toConstruction() {
                    let projected = (new java.util.ArrayList());
                    for (let i = 0; i < this.vectors.length; i++) {
                        {
                            let pt = this.field.createVectorFromTDs(this.vectors[i]);
                            projected.add(new com.vzome.core.construction.FreePoint(this.field.projectTo3d(pt, true)));
                        }
                        ;
                    }
                    return new com.vzome.core.construction.PolygonFromVertices(projected);
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getLocation() {
                    return null;
                }
                getNormal$() {
                    return this.getZoneVector();
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getZoneVector() {
                    let v0 = this.field.createVectorFromTDs(this.vectors[0]);
                    let v1 = this.field.createVectorFromTDs(this.vectors[1]);
                    let v2 = this.field.createVectorFromTDs(this.vectors[2]);
                    return com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return new JsPanel.JsPanel$0(this);
                }
                /**
                 *
                 * @param {com.vzome.core.algebra.AlgebraicVector} vector
                 */
                setZoneVector(vector) {
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getFirstVertex() {
                    return this.field.createVectorFromTDs(this.vectors[0]);
                }
                /**
                 *
                 * @return {*}
                 */
                getVertices() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @return {number}
                 */
                getVertexCount() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                getNormal$com_vzome_core_math_symmetry_Embedding(embedding) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @param {*} embedding
                 * @return {com.vzome.core.math.RealVector}
                 */
                getNormal(embedding) {
                    if (((embedding != null && (embedding["__interfaces"] != null && embedding["__interfaces"].indexOf("com.vzome.core.math.symmetry.Embedding") >= 0 || embedding.constructor != null && embedding.constructor["__interfaces"] != null && embedding.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Embedding") >= 0)) || embedding === null)) {
                        return this.getNormal$com_vzome_core_math_symmetry_Embedding(embedding);
                    }
                    else if (embedding === undefined) {
                        return this.getNormal$();
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            jsweet.JsPanel = JsPanel;
            JsPanel["__class"] = "com.vzome.jsweet.JsPanel";
            JsPanel["__interfaces"] = ["com.vzome.core.model.GroupElement", "com.vzome.core.model.Panel", "com.vzome.core.model.Manifestation", "java.lang.Iterable"];
            (function (JsPanel) {
                class JsPanel$0 {
                    constructor(__parent) {
                        this.__parent = __parent;
                        this.i = 0;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        return this.i < this.__parent.vectors.length;
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    next() {
                        return this.__parent.field.createVectorFromTDs(this.__parent.vectors[this.i++]);
                    }
                }
                JsPanel.JsPanel$0 = JsPanel$0;
                JsPanel$0["__interfaces"] = ["java.util.Iterator"];
            })(JsPanel = jsweet.JsPanel || (jsweet.JsPanel = {}));
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsBall extends com.vzome.jsweet.JsManifestation {
                constructor(field, adapter, coords) {
                    super(field, adapter, coords);
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getLocation() {
                    return this.field.createVectorFromTDs(this.vectors[0]);
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Construction}
                 */
                toConstruction() {
                    return new com.vzome.core.construction.FreePoint(this.getLocation());
                }
                /**
                 *
                 * @param {*} other
                 * @return {number}
                 */
                compareTo(other) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
            }
            jsweet.JsBall = JsBall;
            JsBall["__class"] = "com.vzome.jsweet.JsBall";
            JsBall["__interfaces"] = ["com.vzome.core.model.GroupElement", "com.vzome.core.model.Connector", "java.lang.Comparable", "com.vzome.core.model.Manifestation"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var jsweet;
        (function (jsweet) {
            class JsStrut extends com.vzome.jsweet.JsManifestation {
                constructor(field, adapter, coords) {
                    super(field, adapter, coords);
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getLocation() {
                    return this.field.createVectorFromTDs(this.vectors[0]);
                }
                /**
                 *
                 * @return {com.vzome.core.construction.Construction}
                 */
                toConstruction() {
                    return new com.vzome.core.construction.SegmentJoiningPoints(new com.vzome.core.construction.FreePoint(this.getLocation()), new com.vzome.core.construction.FreePoint(this.getEnd()));
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getEnd() {
                    return this.field.createVectorFromTDs(this.vectors[1]);
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getOffset() {
                    let start = this.getLocation();
                    let end = this.getEnd();
                    return end.minus(start);
                }
                /**
                 *
                 * @param {com.vzome.core.algebra.AlgebraicVector} vector
                 */
                setZoneVector(vector) {
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getZoneVector() {
                    return this.getOffset();
                }
                /**
                 *
                 * @param {*} other
                 * @return {number}
                 */
                compareTo(other) {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getCanonicalLesserEnd() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
                /**
                 *
                 * @return {com.vzome.core.algebra.AlgebraicVector}
                 */
                getCanonicalGreaterEnd() {
                    throw new java.lang.RuntimeException("unimplemented");
                }
            }
            jsweet.JsStrut = JsStrut;
            JsStrut["__class"] = "com.vzome.jsweet.JsStrut";
            JsStrut["__interfaces"] = ["com.vzome.core.model.GroupElement", "com.vzome.core.model.Strut", "java.lang.Comparable", "com.vzome.core.model.Manifestation"];
        })(jsweet = vzome.jsweet || (vzome.jsweet = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} projection
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandImportVEFData extends com.vzome.core.commands.AbstractCommand {
                    constructor(projection) {
                        if (((projection != null && (projection["__interfaces"] != null && projection["__interfaces"].indexOf("com.vzome.core.math.Projection") >= 0 || projection.constructor != null && projection.constructor["__interfaces"] != null && projection.constructor["__interfaces"].indexOf("com.vzome.core.math.Projection") >= 0)) || projection === null)) {
                            let __args = arguments;
                            super();
                            if (this.mProjection === undefined)
                                this.mProjection = null;
                            this.quaternionVector = null;
                            if (this.mProjection === undefined)
                                this.mProjection = null;
                            (() => {
                                this.mProjection = projection;
                            })();
                        }
                        else if (projection === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let projection = null;
                                super();
                                if (this.mProjection === undefined)
                                    this.mProjection = null;
                                this.quaternionVector = null;
                                if (this.mProjection === undefined)
                                    this.mProjection = null;
                                (() => {
                                    this.mProjection = projection;
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandImportVEFData.PARAM_SIGNATURE == null)
                        CommandImportVEFData.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Construction]]; return CommandImportVEFData.PARAM_SIGNATURE; }
                    ;
                    static ATTR_SIGNATURE_$LI$() { if (CommandImportVEFData.ATTR_SIGNATURE == null)
                        CommandImportVEFData.ATTR_SIGNATURE = [[CommandImportVEFData.VEF_STRING_ATTR_NAME, String], [com.vzome.core.commands.Command.FIELD_ATTR_NAME, java.io.InputStream], [CommandImportVEFData.NO_INVERSION_ATTR_NAME, java.io.InputStream]]; return CommandImportVEFData.ATTR_SIGNATURE; }
                    ;
                    static logger_$LI$() { if (CommandImportVEFData.logger == null)
                        CommandImportVEFData.logger = java.util.logging.Logger.getLogger("com.vzome.core.commands.importVEF"); return CommandImportVEFData.logger; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandImportVEFData.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return CommandImportVEFData.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {string} attrName
                     * @return {boolean}
                     */
                    attributeIs3D(attrName) {
                        return !((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("symmetry.axis.segment", attrName);
                    }
                    /**
                     * Only called when migrating a 2.0 model file.
                     * @param {com.vzome.core.algebra.AlgebraicVector} offset
                     */
                    setQuaternion(offset) {
                        this.quaternionVector = offset;
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @return {com.vzome.core.commands.AttributeMap}
                     */
                    setXml(xml, format) {
                        let attrs = super.setXml(xml, format);
                        this.quaternionVector = format.parseRationalVector(xml, "quaternion");
                        return attrs;
                    }
                    /**
                     *
                     * @param {*} result
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     */
                    getXml(result, attributes) {
                        if (this.quaternionVector != null)
                            com.vzome.xml.DomUtils.addAttribute(result, "quaternion", this.quaternionVector.toParsableString());
                        super.getXml(result, attributes);
                    }
                    /**
                     *
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setFixedAttributes(attributes, format) {
                        if (!attributes.containsKey(CommandImportVEFData.FIELD_ATTR_NAME))
                            attributes.put(CommandImportVEFData.FIELD_ATTR_NAME, format.getField());
                        super.setFixedAttributes(attributes, format);
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        let result = new com.vzome.core.construction.ConstructionList();
                        let field = attributes.get(CommandImportVEFData.FIELD_ATTR_NAME);
                        if (field == null)
                            field = attributes.get(com.vzome.core.commands.Command.FIELD_ATTR_NAME);
                        let symmAxis = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                        let vefData = attributes.get(CommandImportVEFData.VEF_STRING_ATTR_NAME);
                        let noInversion = attributes.get(CommandImportVEFData.NO_INVERSION_ATTR_NAME);
                        let projection = this.mProjection;
                        if (projection == null) {
                            let quaternion = this.quaternionVector;
                            if (quaternion == null)
                                quaternion = (symmAxis == null) ? null : symmAxis.getOffset();
                            if (quaternion != null)
                                quaternion = quaternion.scale(field['createPower$int'](-5));
                            projection = quaternion == null ? null : new com.vzome.core.math.QuaternionProjection(field, null, quaternion);
                        }
                        if (noInversion != null && noInversion)
                            new CommandImportVEFData.VefToModelNoInversion(this, projection, field, effects).parseVEF(vefData, field);
                        else
                            new com.vzome.core.construction.VefToModel(projection, effects, field['createPower$int'](5), null).parseVEF(vefData, field);
                        return result;
                    }
                }
                CommandImportVEFData.X = 0;
                CommandImportVEFData.Y = 1;
                CommandImportVEFData.Z = 2;
                CommandImportVEFData.W = 3;
                CommandImportVEFData.VEF_STRING_ATTR_NAME = "org.vorthmann.zome.commands.CommandImportVEFData.vef.string";
                CommandImportVEFData.FIELD_ATTR_NAME = "org.vorthmann.zome.commands.CommandImportVEFData.field";
                CommandImportVEFData.NO_INVERSION_ATTR_NAME = "org.vorthmann.zome.commands.CommandImportVEFData.no.inversion";
                commands.CommandImportVEFData = CommandImportVEFData;
                CommandImportVEFData["__class"] = "com.vzome.core.commands.CommandImportVEFData";
                CommandImportVEFData["__interfaces"] = ["com.vzome.core.commands.Command"];
                (function (CommandImportVEFData) {
                    class VefToModelNoInversion extends com.vzome.core.construction.VefToModel {
                        constructor(__parent, projection, field, effects) {
                            super(projection, effects, field['createPower$int'](5), null);
                            this.__parent = __parent;
                            if (this.mProjected === undefined)
                                this.mProjected = null;
                            this.mUsedPoints = (new java.util.HashSet());
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {com.vzome.core.algebra.AlgebraicVector} location
                         */
                        addVertex(index, location) {
                            if (this.scale != null) {
                                location = location.scale(this.scale);
                            }
                            if (this.mProjection != null)
                                location = this.mProjection.projectImage(location, this.wFirst());
                            this.mVertices[index] = new com.vzome.core.construction.FreePoint(location);
                        }
                        /**
                         *
                         * @param {number} numEdges
                         */
                        startEdges(numEdges) {
                            this.mProjected = (function (dims) { let allocate = function (dims) { if (dims.length == 0) {
                                return null;
                            }
                            else {
                                let array = [];
                                for (let i = 0; i < dims[0]; i++) {
                                    array.push(allocate(dims.slice(1)));
                                }
                                return array;
                            } }; return allocate(dims); })([numEdges, 2]);
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {number} v1
                         * @param {number} v2
                         */
                        addEdge(index, v1, v2) {
                            let p1 = this.mVertices[v1];
                            let p2 = this.mVertices[v2];
                            if (p1 == null || p2 == null)
                                return;
                            let seg = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                            let pr1 = p1.getLocation().projectTo3d(this.wFirst()).negate();
                            let pr2 = p2.getLocation().projectTo3d(this.wFirst()).negate();
                            for (let i = 0; i < index; i++) {
                                {
                                    if (pr1.equals(this.mProjected[i][0]) && pr2.equals(this.mProjected[i][1]))
                                        return;
                                    if (pr2.equals(this.mProjected[i][0]) && pr1.equals(this.mProjected[i][1]))
                                        return;
                                }
                                ;
                            }
                            this.mProjected[index][0] = pr1.negate();
                            this.mProjected[index][1] = pr2.negate();
                            this.mEffects.constructionAdded(seg);
                            this.mUsedPoints.add(p1);
                            this.mUsedPoints.add(p2);
                        }
                        /**
                         *
                         */
                        endEdges() {
                            for (let index217 = this.mUsedPoints.iterator(); index217.hasNext();) {
                                let point = index217.next();
                                {
                                    this.mEffects.constructionAdded(point);
                                }
                            }
                        }
                    }
                    CommandImportVEFData.VefToModelNoInversion = VefToModelNoInversion;
                    VefToModelNoInversion["__class"] = "com.vzome.core.commands.CommandImportVEFData.VefToModelNoInversion";
                })(CommandImportVEFData = commands.CommandImportVEFData || (commands.CommandImportVEFData = {}));
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class PolygonFromVertices extends com.vzome.core.construction.Polygon {
                    constructor(points) {
                        if (((points != null && (points["__interfaces"] != null && points["__interfaces"].indexOf("java.util.List") >= 0 || points.constructor != null && points.constructor["__interfaces"] != null && points.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || points === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let vertices = points.toArray((s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(points.size()));
                                super(vertices.length === 0 ? null : vertices[0].field);
                                if (this.__com_vzome_core_construction_PolygonFromVertices_mVertices === undefined)
                                    this.__com_vzome_core_construction_PolygonFromVertices_mVertices = null;
                                if (this.__com_vzome_core_construction_PolygonFromVertices_mVertices === undefined)
                                    this.__com_vzome_core_construction_PolygonFromVertices_mVertices = null;
                                (() => {
                                    this.__com_vzome_core_construction_PolygonFromVertices_mVertices = vertices;
                                    this.mapParamsToState();
                                })();
                            }
                        }
                        else if (((points != null && points instanceof Array && (points.length == 0 || points[0] == null || (points[0] != null && points[0] instanceof com.vzome.core.construction.Point))) || points === null)) {
                            let __args = arguments;
                            let vertices = __args[0];
                            super(vertices.length === 0 ? null : vertices[0].field);
                            if (this.__com_vzome_core_construction_PolygonFromVertices_mVertices === undefined)
                                this.__com_vzome_core_construction_PolygonFromVertices_mVertices = null;
                            if (this.__com_vzome_core_construction_PolygonFromVertices_mVertices === undefined)
                                this.__com_vzome_core_construction_PolygonFromVertices_mVertices = null;
                            (() => {
                                this.__com_vzome_core_construction_PolygonFromVertices_mVertices = vertices;
                                this.mapParamsToState();
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        let locs = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.__com_vzome_core_construction_PolygonFromVertices_mVertices.length);
                        for (let i = 0; i < this.__com_vzome_core_construction_PolygonFromVertices_mVertices.length; i++) {
                            locs[i] = this.__com_vzome_core_construction_PolygonFromVertices_mVertices[i].getLocation();
                        }
                        return this.setStateVariable(locs, false);
                    }
                }
                construction.PolygonFromVertices = PolygonFromVertices;
                PolygonFromVertices["__class"] = "com.vzome.core.construction.PolygonFromVertices";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Transformation} transform
                 * @param {com.vzome.core.construction.Polygon} prototype
                 * @class
                 * @extends com.vzome.core.construction.Polygon
                 */
                class TransformedPolygon extends com.vzome.core.construction.Polygon {
                    constructor(transform, prototype) {
                        super(prototype.field);
                        if (this.mTransform === undefined)
                            this.mTransform = null;
                        if (this.mPrototype === undefined)
                            this.mPrototype = null;
                        this.mTransform = transform;
                        this.mPrototype = prototype;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        let vertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.mPrototype.getVertexCount());
                        for (let i = 0; i < vertices.length; i++) {
                            {
                                vertices[i] = this.mTransform.transform$com_vzome_core_algebra_AlgebraicVector(this.mPrototype.getVertex(i));
                            }
                            ;
                        }
                        return this.setStateVariable(vertices, false);
                    }
                }
                construction.TransformedPolygon = TransformedPolygon;
                TransformedPolygon["__class"] = "com.vzome.core.construction.TransformedPolygon";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.algebra.Quaternion} leftQuaternion
                 * @param {com.vzome.core.algebra.Quaternion} rightQuaternion
                 * @param {com.vzome.core.construction.Polygon} prototype
                 * @class
                 * @extends com.vzome.core.construction.Polygon
                 */
                class PolygonRotated4D extends com.vzome.core.construction.Polygon {
                    constructor(leftQuaternion, rightQuaternion, prototype) {
                        super(prototype.field);
                        if (this.mLeftQuaternion === undefined)
                            this.mLeftQuaternion = null;
                        if (this.mRightQuaternion === undefined)
                            this.mRightQuaternion = null;
                        if (this.mPrototype === undefined)
                            this.mPrototype = null;
                        this.mLeftQuaternion = leftQuaternion;
                        this.mRightQuaternion = rightQuaternion;
                        this.mPrototype = prototype;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mPrototype.isImpossible())
                            return this.setStateVariable(null, true);
                        let vertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(this.mPrototype.getVertexCount());
                        for (let i = 0; i < vertices.length; i++) {
                            {
                                let loc = this.mRightQuaternion.leftMultiply(this.mPrototype.getVertex(i));
                                loc = this.mLeftQuaternion.rightMultiply(loc);
                                vertices[i] = loc;
                            }
                            ;
                        }
                        return this.setStateVariable(vertices, false);
                    }
                }
                construction.PolygonRotated4D = PolygonRotated4D;
                PolygonRotated4D["__class"] = "com.vzome.core.construction.PolygonRotated4D";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class MatrixTransformation extends com.vzome.core.construction.Transformation {
                    constructor(matrix, center) {
                        super(center.getField());
                        this.setStateVariables(matrix, center, false);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return true;
                    }
                }
                construction.MatrixTransformation = MatrixTransformation;
                MatrixTransformation["__class"] = "com.vzome.core.construction.MatrixTransformation";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param prototype
                 * @param {com.vzome.core.construction.Plane} projectionPlane
                 * @param {com.vzome.core.construction.Line} projectionLine
                 * @class
                 * @extends com.vzome.core.construction.Transformation
                 * @author Scott Vorthmann
                 */
                class PlaneProjection extends com.vzome.core.construction.Transformation {
                    constructor(projectionPlane, projectionLine) {
                        super(projectionPlane.field);
                        if (this.projectionPlane === undefined)
                            this.projectionPlane = null;
                        if (this.projectionVector === undefined)
                            this.projectionVector = null;
                        this.projectionPlane = projectionPlane;
                        if (projectionLine == null)
                            this.projectionVector = projectionPlane.getNormal();
                        else
                            this.projectionVector = projectionLine.getDirection();
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.projectionPlane.isImpossible())
                            this.setStateVariables(null, null, true);
                        let loc = this.projectionPlane.getBase();
                        return this.setStateVariables(null, loc, false);
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        let line = new com.vzome.core.construction.LineFromPointAndVector(arg, this.projectionVector);
                        let point = new com.vzome.core.construction.LinePlaneIntersectionPoint(this.projectionPlane, line);
                        return point.getLocation();
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    transform$com_vzome_core_construction_Construction(c) {
                        if (c != null && c instanceof com.vzome.core.construction.Segment) {
                            if (com.vzome.core.algebra.AlgebraicVectors.areParallel(this.projectionVector, c.getOffset())) {
                                return new com.vzome.core.construction.LinePlaneIntersectionPoint(this.projectionPlane, new com.vzome.core.construction.LineExtensionOfSegment(c));
                            }
                        }
                        else if (c != null && c instanceof com.vzome.core.construction.Polygon) {
                            let p = c;
                            let points = (new java.util.ArrayList(1 + p.getVertexCount()));
                            points.add(p.getVertex(0).plus(this.projectionVector));
                            for (let i = 0; i < p.getVertexCount(); i++) {
                                {
                                    points.add(p.getVertex(i));
                                }
                                ;
                            }
                            if (com.vzome.core.algebra.AlgebraicVectors.areCoplanar(points)) {
                                p = super.transform$com_vzome_core_construction_Construction(p);
                                let min = p.getVertex(0);
                                let max = min;
                                for (let i = 1; i < p.getVertexCount(); i++) {
                                    {
                                        let v = p.getVertex(i);
                                        if (v.compareTo(min) === -1) {
                                            min = v;
                                        }
                                        if (v.compareTo(max) === 1) {
                                            max = v;
                                        }
                                    }
                                    ;
                                }
                                let p1 = new com.vzome.core.construction.FreePoint(min);
                                let p2 = new com.vzome.core.construction.FreePoint(max);
                                return new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                            }
                        }
                        return super.transform$com_vzome_core_construction_Construction(c);
                    }
                }
                construction.PlaneProjection = PlaneProjection;
                PlaneProjection["__class"] = "com.vzome.core.construction.PlaneProjection";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class Scaling extends com.vzome.core.construction.Transformation {
                    constructor(s1, s2, center, symmetry) {
                        super(s1.field);
                        if (this.s1 === undefined)
                            this.s1 = null;
                        if (this.s2 === undefined)
                            this.s2 = null;
                        if (this.center === undefined)
                            this.center = null;
                        if (this.symmetry === undefined)
                            this.symmetry = null;
                        this.mOffset = this.field.projectTo3d(center.getLocation(), true);
                        this.s1 = s1;
                        this.s2 = s2;
                        this.center = center;
                        this.symmetry = symmetry;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        let zone1 = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](this.s1.getOffset());
                        let zone2 = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](this.s2.getOffset());
                        let orbit = zone1.getDirection();
                        if (orbit !== zone2.getDirection())
                            return this.setStateVariables(null, null, true);
                        let len1 = zone1.getLength(this.s1.getOffset());
                        let len2 = zone2.getLength(this.s2.getOffset());
                        let scale = len2['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](len1);
                        let transform = new com.vzome.core.algebra.AlgebraicMatrix(this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X).scale(scale), this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y).scale(scale), this.field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).scale(scale));
                        return this.setStateVariables(transform, this.center.getLocation(), false);
                    }
                }
                construction.Scaling = Scaling;
                Scaling["__class"] = "com.vzome.core.construction.Scaling";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param prototype
                 * @param {*} symm
                 * @param {number} orientation
                 * @param {com.vzome.core.construction.Point} center
                 * @class
                 * @extends com.vzome.core.construction.Transformation
                 * @author Scott Vorthmann
                 */
                class SymmetryTransformation extends com.vzome.core.construction.Transformation {
                    constructor(symm, orientation, center) {
                        super(center.field);
                        if (this.mCenter === undefined)
                            this.mCenter = null;
                        if (this.mSymmetry === undefined)
                            this.mSymmetry = null;
                        if (this.mOrientation === undefined)
                            this.mOrientation = 0;
                        this.mSymmetry = symm;
                        this.mOrientation = orientation;
                        this.mCenter = center;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mCenter.isImpossible())
                            return this.setStateVariables(null, null, true);
                        let loc = this.mCenter.getLocation().projectTo3d(true);
                        let matrix = this.mSymmetry.getMatrix(this.mOrientation);
                        return this.setStateVariables(matrix, loc, false);
                    }
                }
                construction.SymmetryTransformation = SymmetryTransformation;
                SymmetryTransformation["__class"] = "com.vzome.core.construction.SymmetryTransformation";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class PointToPointTranslation extends com.vzome.core.construction.Transformation {
                    constructor(p1, p2) {
                        super(p1.field);
                        this.mOffset = this.field.projectTo3d(p2.getLocation().minus(p1.getLocation()), true);
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        return arg.plus(this.mOffset);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return this.setStateVariables(null, null, false);
                    }
                }
                construction.PointToPointTranslation = PointToPointTranslation;
                PointToPointTranslation["__class"] = "com.vzome.core.construction.PointToPointTranslation";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * This assumes that the starting basis is the usual X,Y,Z basis
                 * @param {boolean} originalScaling
                 * @param prototype
                 * @param {com.vzome.core.construction.Segment} newX
                 * @param {com.vzome.core.construction.Segment} newY
                 * @param {com.vzome.core.construction.Segment} newZ
                 * @param {com.vzome.core.construction.Point} kernel
                 * @class
                 * @extends com.vzome.core.construction.Transformation
                 * @author Scott Vorthmann
                 */
                class ChangeOfBasis extends com.vzome.core.construction.Transformation {
                    constructor(newX, newY, newZ, kernel, originalScaling) {
                        if (((newX != null && newX instanceof com.vzome.core.construction.Segment) || newX === null) && ((newY != null && newY instanceof com.vzome.core.construction.Segment) || newY === null) && ((newZ != null && newZ instanceof com.vzome.core.construction.Segment) || newZ === null) && ((kernel != null && kernel instanceof com.vzome.core.construction.Point) || kernel === null) && ((typeof originalScaling === 'boolean') || originalScaling === null)) {
                            let __args = arguments;
                            super(newX.field);
                            if (this.mOld === undefined)
                                this.mOld = null;
                            if (this.mNew === undefined)
                                this.mNew = null;
                            if (this.mKernel === undefined)
                                this.mKernel = null;
                            if (this.scale === undefined)
                                this.scale = null;
                            if (this.mOld === undefined)
                                this.mOld = null;
                            if (this.mNew === undefined)
                                this.mNew = null;
                            if (this.mKernel === undefined)
                                this.mKernel = null;
                            if (this.scale === undefined)
                                this.scale = null;
                            (() => {
                                this.mNew = [newX, newY, newZ];
                                this.mOld = null;
                                this.mKernel = kernel;
                                if (originalScaling)
                                    this.scale = this.field['createPower$int'](-5);
                                else
                                    this.scale = this.field['createRational$long$long'](1, 2)['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createPower$int'](-3));
                                this.mapParamsToState();
                            })();
                        }
                        else if (((newX != null && newX instanceof Array && (newX.length == 0 || newX[0] == null || (newX[0] != null && newX[0] instanceof com.vzome.core.construction.Segment))) || newX === null) && ((newY != null && newY instanceof Array && (newY.length == 0 || newY[0] == null || (newY[0] != null && newY[0] instanceof com.vzome.core.construction.Segment))) || newY === null) && ((newZ != null && newZ instanceof com.vzome.core.construction.Point) || newZ === null) && kernel === undefined && originalScaling === undefined) {
                            let __args = arguments;
                            let oldBasis = __args[0];
                            let newBasis = __args[1];
                            let kernel = __args[2];
                            super(oldBasis[0].field);
                            if (this.mOld === undefined)
                                this.mOld = null;
                            if (this.mNew === undefined)
                                this.mNew = null;
                            if (this.mKernel === undefined)
                                this.mKernel = null;
                            if (this.scale === undefined)
                                this.scale = null;
                            if (this.mOld === undefined)
                                this.mOld = null;
                            if (this.mNew === undefined)
                                this.mNew = null;
                            if (this.mKernel === undefined)
                                this.mKernel = null;
                            if (this.scale === undefined)
                                this.scale = null;
                            (() => {
                                this.mOld = oldBasis;
                                this.mNew = newBasis;
                                this.mKernel = kernel;
                                this.scale = this.field['createRational$long'](2)['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createPower$int'](-7));
                                this.mapParamsToState();
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        let loc = this.mKernel.getLocation();
                        if (this.mOld != null) {
                            let oldCommon = ChangeOfBasis.findCommonVertex(this.mOld);
                            let offsets = [null, null, null];
                            for (let i = 0; i < offsets.length; i++) {
                                {
                                    offsets[i] = this.mOld[i].getOffset().scale(this.scale);
                                    if (oldCommon.equals(this.mOld[i].getEnd()))
                                        offsets[i] = offsets[i].negate();
                                }
                                ;
                            }
                            let oldMatrix = new com.vzome.core.algebra.AlgebraicMatrix(offsets);
                            let newCommon = ChangeOfBasis.findCommonVertex(this.mNew);
                            for (let i = 0; i < offsets.length; i++) {
                                {
                                    offsets[i] = this.mNew[i].getOffset().scale(this.scale);
                                    if (newCommon.equals(this.mNew[i].getEnd()))
                                        offsets[i] = offsets[i].negate();
                                }
                                ;
                            }
                            let newMatrix = new com.vzome.core.algebra.AlgebraicMatrix(offsets);
                            let transform = newMatrix.times(oldMatrix.inverse());
                            return this.setStateVariables(transform, loc, false);
                        }
                        else {
                            let transform = new com.vzome.core.algebra.AlgebraicMatrix(this.mNew[0].getOffset().scale(this.scale), this.mNew[1].getOffset().scale(this.scale), this.mNew[2].getOffset().scale(this.scale));
                            return this.setStateVariables(transform, loc, false);
                        }
                    }
                    /*private*/ static findCommonVertex(basis) {
                        let common = basis[0].getStart();
                        if (common.equals(basis[1].getStart()) || common.equals(basis[1].getEnd()))
                            return common;
                        else {
                            common = basis[0].getEnd();
                            if (common.equals(basis[1].getStart()) || common.equals(basis[1].getEnd()))
                                return common;
                            else
                                return null;
                        }
                    }
                }
                construction.ChangeOfBasis = ChangeOfBasis;
                ChangeOfBasis["__class"] = "com.vzome.core.construction.ChangeOfBasis";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class Translation extends com.vzome.core.construction.Transformation {
                    constructor(offset) {
                        super(offset.getField());
                        if (this.mOffset === undefined)
                            this.mOffset = null;
                        this.mOffset = offset;
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        arg = arg.plus(this.mOffset);
                        return arg;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return this.setStateVariables(null, null, false);
                    }
                }
                construction.Translation = Translation;
                Translation["__class"] = "com.vzome.core.construction.Translation";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param prototype
                 * @param {com.vzome.core.construction.Plane} mirror
                 * @class
                 * @extends com.vzome.core.construction.Transformation
                 * @author Scott Vorthmann
                 */
                class PlaneReflection extends com.vzome.core.construction.Transformation {
                    constructor(mirror) {
                        super(mirror.field);
                        if (this.mMirror === undefined)
                            this.mMirror = null;
                        if (this.mNormal === undefined)
                            this.mNormal = null;
                        if (this.mBase === undefined)
                            this.mBase = null;
                        if (this.mNormDotReciprocal === undefined)
                            this.mNormDotReciprocal = null;
                        this.mMirror = mirror;
                        this.mNormal = mirror.getNormal();
                        this.mBase = mirror.getBase();
                        this.mNormDotReciprocal = this.mNormal.dot(this.mNormal).reciprocal();
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mMirror.isImpossible())
                            this.setStateVariables(null, null, true);
                        let loc = this.mMirror.getBase();
                        return this.setStateVariables(null, loc, false);
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        arg = arg.minus(this.mBase);
                        let xy = arg.dot(this.mNormal);
                        xy = xy['times$com_vzome_core_algebra_AlgebraicNumber'](this.field['createRational$long'](2));
                        arg = arg.minus(this.mNormal.scale(xy['times$com_vzome_core_algebra_AlgebraicNumber'](this.mNormDotReciprocal)));
                        return arg.plus(this.mBase);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                construction.PlaneReflection = PlaneReflection;
                PlaneReflection["__class"] = "com.vzome.core.construction.PlaneReflection";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class MoveAndRotate extends com.vzome.core.construction.Transformation {
                    constructor(rotation, start, end) {
                        super(start.getField());
                        if (this.rotation === undefined)
                            this.rotation = null;
                        if (this.translation === undefined)
                            this.translation = null;
                        this.rotation = new com.vzome.core.construction.MatrixTransformation(rotation, start);
                        this.translation = new com.vzome.core.construction.Translation(end.minus(start));
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return this.rotation.mapParamsToState() && this.translation.mapParamsToState();
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        return this.translation.transform$com_vzome_core_algebra_AlgebraicVector(this.rotation.transform$com_vzome_core_algebra_AlgebraicVector(arg));
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                construction.MoveAndRotate = MoveAndRotate;
                MoveAndRotate["__class"] = "com.vzome.core.construction.MoveAndRotate";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param prototype
                 * @param {com.vzome.core.construction.Point} center
                 * @class
                 * @extends com.vzome.core.construction.Transformation
                 * @author Scott Vorthmann
                 */
                class PointReflection extends com.vzome.core.construction.Transformation {
                    constructor(center) {
                        super(center.field);
                        if (this.mCenter === undefined)
                            this.mCenter = null;
                        this.mCenter = center;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mCenter.isImpossible())
                            this.setStateVariables(null, null, true);
                        let loc = this.mCenter.getLocation().projectTo3d(true);
                        return this.setStateVariables(null, loc, false);
                    }
                    transform$com_vzome_core_algebra_AlgebraicVector(arg) {
                        arg = arg.minus(this.mOffset);
                        arg = this.mOffset.minus(arg);
                        return arg;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} arg
                     * @return {com.vzome.core.algebra.AlgebraicVector}
                     */
                    transform(arg) {
                        if (((arg != null && arg instanceof com.vzome.core.algebra.AlgebraicVector) || arg === null)) {
                            return this.transform$com_vzome_core_algebra_AlgebraicVector(arg);
                        }
                        else if (((arg != null && arg instanceof com.vzome.core.construction.Construction) || arg === null)) {
                            return this.transform$com_vzome_core_construction_Construction(arg);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                construction.PointReflection = PointReflection;
                PointReflection["__class"] = "com.vzome.core.construction.PointReflection";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Line} l3
                 * @param {*} len
                 * @class
                 * @extends com.vzome.core.construction.Segment
                 */
                class SegmentOnLine extends com.vzome.core.construction.Segment {
                    constructor(l3, len) {
                        super(l3.field);
                        if (this.mLine === undefined)
                            this.mLine = null;
                        if (this.mLength === undefined)
                            this.mLength = null;
                        this.mLine = l3;
                        this.mLength = len;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mLine.isImpossible())
                            return this.setStateVariables(null, null, true);
                        let offset = this.getOffset().scale(this.mLength);
                        return this.setStateVariables(this.mLine.getStart(), offset, false);
                    }
                }
                construction.SegmentOnLine = SegmentOnLine;
                SegmentOnLine["__class"] = "com.vzome.core.construction.SegmentOnLine";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Transformation} transform
                 * @param {com.vzome.core.construction.Segment} prototype
                 * @class
                 * @extends com.vzome.core.construction.Segment
                 */
                class TransformedSegment extends com.vzome.core.construction.Segment {
                    constructor(transform, prototype) {
                        super(prototype.field);
                        if (this.mTransform === undefined)
                            this.mTransform = null;
                        if (this.mPrototype === undefined)
                            this.mPrototype = null;
                        this.mTransform = transform;
                        this.mPrototype = prototype;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mTransform.isImpossible() || this.mPrototype.isImpossible())
                            return this.setStateVariables(null, null, true);
                        let loc = this.mTransform.transform$com_vzome_core_algebra_AlgebraicVector(this.mPrototype.getStart().projectTo3d(true));
                        let end = this.mTransform.transform$com_vzome_core_algebra_AlgebraicVector(this.mPrototype.getEnd().projectTo3d(true));
                        return this.setStateVariables(loc, end.minus(loc), false);
                    }
                }
                construction.TransformedSegment = TransformedSegment;
                TransformedSegment["__class"] = "com.vzome.core.construction.TransformedSegment";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Point} p1
                 * @param {com.vzome.core.construction.Point} p2
                 * @class
                 * @extends com.vzome.core.construction.Segment
                 */
                class SegmentJoiningPoints extends com.vzome.core.construction.Segment {
                    constructor(p1, p2) {
                        super(p1.field);
                        if (this.__com_vzome_core_construction_SegmentJoiningPoints_mStart === undefined)
                            this.__com_vzome_core_construction_SegmentJoiningPoints_mStart = null;
                        if (this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd === undefined)
                            this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd = null;
                        this.__com_vzome_core_construction_SegmentJoiningPoints_mStart = p1;
                        this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd = p2;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.__com_vzome_core_construction_SegmentJoiningPoints_mStart.isImpossible() || this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd.isImpossible())
                            return this.setStateVariables(null, null, true);
                        let startV = this.__com_vzome_core_construction_SegmentJoiningPoints_mStart.getLocation();
                        let endV = this.__com_vzome_core_construction_SegmentJoiningPoints_mEnd.getLocation();
                        if (startV.dimension() === 3 || endV.dimension() === 3) {
                            startV = startV.projectTo3d(true);
                            endV = endV.projectTo3d(true);
                        }
                        let offset = endV.minus(startV);
                        return this.setStateVariables(startV, offset, false);
                    }
                }
                construction.SegmentJoiningPoints = SegmentJoiningPoints;
                SegmentJoiningPoints["__class"] = "com.vzome.core.construction.SegmentJoiningPoints";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Segment} s1
                 * @param {com.vzome.core.construction.Segment} s2
                 * @class
                 * @extends com.vzome.core.construction.Segment
                 */
                class SegmentCrossProduct extends com.vzome.core.construction.Segment {
                    constructor(s1, s2) {
                        super(s1.field);
                        if (this.seg1 === undefined)
                            this.seg1 = null;
                        if (this.seg2 === undefined)
                            this.seg2 = null;
                        this.seg1 = s1;
                        this.seg2 = s2;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.seg1.isImpossible() || this.seg2.isImpossible()) {
                            return this.setStateVariables(null, null, true);
                        }
                        let v2 = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.seg1.getOffset(), this.seg2.getOffset()).scale(this.field['createPower$int'](-4)).scale(this.field['createRational$long$long'](1, 2));
                        return this.setStateVariables(this.seg1.getEnd(), v2, false);
                    }
                }
                construction.SegmentCrossProduct = SegmentCrossProduct;
                SegmentCrossProduct["__class"] = "com.vzome.core.construction.SegmentCrossProduct";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.algebra.Quaternion} leftQuaternion
                 * @param {com.vzome.core.algebra.Quaternion} rightQuaternion
                 * @param {com.vzome.core.construction.Segment} prototype
                 * @class
                 * @extends com.vzome.core.construction.Segment
                 */
                class SegmentRotated4D extends com.vzome.core.construction.Segment {
                    constructor(leftQuaternion, rightQuaternion, prototype) {
                        super(prototype.field);
                        if (this.mLeftQuaternion === undefined)
                            this.mLeftQuaternion = null;
                        if (this.mRightQuaternion === undefined)
                            this.mRightQuaternion = null;
                        if (this.mPrototype === undefined)
                            this.mPrototype = null;
                        this.mLeftQuaternion = leftQuaternion;
                        this.mRightQuaternion = rightQuaternion;
                        this.mPrototype = prototype;
                        this.mapParamsToState();
                    }
                    static logger_$LI$() { if (SegmentRotated4D.logger == null)
                        SegmentRotated4D.logger = java.util.logging.Logger.getLogger("com.vzome.core.4d"); return SegmentRotated4D.logger; }
                    ;
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mPrototype.isImpossible())
                            return this.setStateVariables(null, null, true);
                        let loc = this.mPrototype.getStart();
                        loc = loc.inflateTo4d$boolean(true);
                        loc = this.mRightQuaternion.leftMultiply(loc);
                        loc = this.mLeftQuaternion.rightMultiply(loc);
                        let end = this.mPrototype.getEnd();
                        end = end.inflateTo4d$boolean(true);
                        end = this.mRightQuaternion.leftMultiply(end);
                        end = this.mLeftQuaternion.rightMultiply(end);
                        if (SegmentRotated4D.logger_$LI$().isLoggable(java.util.logging.Level.FINER)) {
                            SegmentRotated4D.logger_$LI$().finer("------------------- SegmentRotated4D");
                            SegmentRotated4D.logger_$LI$().finer("left:    " + this.mLeftQuaternion.toString());
                            SegmentRotated4D.logger_$LI$().finer("right:   " + this.mRightQuaternion.toString());
                            SegmentRotated4D.logger_$LI$().finer("start: " + this.mPrototype.getStart().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT));
                            SegmentRotated4D.logger_$LI$().finer("end:   " + this.mPrototype.getEnd().getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT));
                            SegmentRotated4D.logger_$LI$().finer("new start: " + loc.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT));
                            SegmentRotated4D.logger_$LI$().finer("new end:   " + end.getVectorExpression$int(com.vzome.core.algebra.AlgebraicField.EXPRESSION_FORMAT));
                        }
                        return this.setStateVariables(loc, end.minus(loc), false);
                    }
                }
                construction.SegmentRotated4D = SegmentRotated4D;
                SegmentRotated4D["__class"] = "com.vzome.core.construction.SegmentRotated4D";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class PolygonPolygonProjectionToSegment extends com.vzome.core.construction.Segment {
                    constructor(polygon0, polygon1) {
                        super(polygon0.getField());
                        this.polygons = [null, null];
                        this.polygons[0] = polygon0;
                        this.polygons[1] = polygon1;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.polygons[0].isImpossible() || this.polygons[1].isImpossible()) {
                            return this.setStateVariables(null, null, true);
                        }
                        if (com.vzome.core.algebra.AlgebraicVectors.areParallel(this.polygons[0].getNormal(), this.polygons[1].getNormal())) {
                            return this.setStateVariables(null, null, true);
                        }
                        let intersections = (new java.util.HashSet(2));
                        for (let poly = 0; poly < 2; poly++) {
                            {
                                let edgePolygon = this.polygons[poly];
                                let planePolygon = this.polygons[(poly + 1) % 2];
                                let centroid = planePolygon.getCentroid();
                                let normal = planePolygon.getNormal();
                                let nVertices = edgePolygon.getVertexCount();
                                for (let i = 0; i < nVertices; i++) {
                                    {
                                        let lineStart = edgePolygon.getVertex(i);
                                        let lineDirection = lineStart.minus(edgePolygon.getVertex((i + 1) % nVertices));
                                        if (!lineDirection.isOrigin()) {
                                            let intersection = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(lineStart, lineDirection, centroid, normal);
                                            if (intersection != null) {
                                                intersections.add(intersection);
                                                if (intersections.size() === 2) {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    ;
                                }
                                if (intersections.size() === 2) {
                                    break;
                                }
                            }
                            ;
                        }
                        if (intersections.size() !== 2) {
                            for (let poly = 0; poly < 2; poly++) {
                                {
                                    let edgePolygon = this.polygons[poly];
                                    let planePolygon = this.polygons[(poly + 1) % 2];
                                    let centroid = planePolygon.getCentroid();
                                    let normal = planePolygon.getNormal();
                                    let lineStart = edgePolygon.getCentroid();
                                    for (let i = 0; i < edgePolygon.getVertexCount(); i++) {
                                        {
                                            let lineDirection = lineStart.minus(edgePolygon.getVertex(i));
                                            if (!lineDirection.isOrigin()) {
                                                let intersection = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(lineStart, lineDirection, centroid, normal);
                                                if (intersection != null) {
                                                    intersections.add(intersection);
                                                    if (intersections.size() === 2) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        ;
                                    }
                                    if (intersections.size() === 2) {
                                        break;
                                    }
                                }
                                ;
                            }
                        }
                        if (intersections.size() !== 2) {
                            return this.setStateVariables(null, null, true);
                        }
                        let v0 = null;
                        let v1 = null;
                        for (let index218 = intersections.iterator(); index218.hasNext();) {
                            let v = index218.next();
                            {
                                if (v0 == null) {
                                    v0 = v;
                                }
                                else {
                                    v1 = v;
                                }
                            }
                        }
                        let intersectionLine = new com.vzome.core.construction.LineExtensionOfSegment(new com.vzome.core.construction.SegmentJoiningPoints(new com.vzome.core.construction.FreePoint(v0), new com.vzome.core.construction.FreePoint(v1)));
                        let projections = (new java.util.TreeSet());
                        for (let poly = 0; poly < 2; poly++) {
                            {
                                let polygon = this.polygons[poly];
                                let v2 = v0.plus(polygon.getNormal());
                                let vProjection = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, v2);
                                for (let i = 0; i < polygon.getVertexCount(); i++) {
                                    {
                                        let vertex = polygon.getVertex(i);
                                        if (com.vzome.core.algebra.AlgebraicVectors.areCollinear$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(v0, v1, vertex)) {
                                            projections.add(vertex);
                                        }
                                        else {
                                            let projectionLine = new com.vzome.core.construction.LineFromPointAndVector(vertex, vProjection);
                                            let projection = new com.vzome.core.construction.LineLineIntersectionPoint(intersectionLine, projectionLine);
                                            projections.add(projection.getLocation());
                                        }
                                    }
                                    ;
                                }
                            }
                            ;
                        }
                        let start = null;
                        let offset = null;
                        let n = 0;
                        for (let index219 = projections.iterator(); index219.hasNext();) {
                            let v = index219.next();
                            {
                                if (n === 0) {
                                    start = v;
                                }
                                else if (n === projections.size() - 1) {
                                    offset = v.minus(start);
                                }
                                n++;
                            }
                        }
                        return this.setStateVariables(start, offset, (start == null || offset == null));
                    }
                }
                construction.PolygonPolygonProjectionToSegment = PolygonPolygonProjectionToSegment;
                PolygonPolygonProjectionToSegment["__class"] = "com.vzome.core.construction.PolygonPolygonProjectionToSegment";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param step
                 * @param {com.vzome.core.construction.Point} start
                 * @param {com.vzome.core.math.symmetry.Axis} axis
                 * @param {*} length
                 * @class
                 * @extends com.vzome.core.construction.Segment
                 * @author Scott Vorthmann
                 */
                class AnchoredSegment extends com.vzome.core.construction.Segment {
                    constructor(axis, length, start) {
                        super(start.field);
                        if (this.mAnchor === undefined)
                            this.mAnchor = null;
                        if (this.mAxis === undefined)
                            this.mAxis = null;
                        if (this.mLength === undefined)
                            this.mLength = null;
                        this.mAnchor = start;
                        this.mAxis = axis;
                        this.mLength = length;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mAnchor.isImpossible() || this.mLength.isZero())
                            return this.setStateVariables(null, null, true);
                        let gv = this.mAnchor.getLocation().projectTo3d(true);
                        let offset = this.mAxis.normal().scale(this.mLength);
                        return this.setStateVariables(gv, offset, false);
                    }
                    getAxis() {
                        return this.mAxis;
                    }
                    getLength() {
                        return this.mLength;
                    }
                    getUnitVector() {
                        return this.mAxis.normal();
                    }
                }
                construction.AnchoredSegment = AnchoredSegment;
                AnchoredSegment["__class"] = "com.vzome.core.construction.AnchoredSegment";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandLinePlaneIntersect extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandLinePlaneIntersect.PARAM_SIGNATURE == null)
                        CommandLinePlaneIntersect.PARAM_SIGNATURE = [["panel", com.vzome.core.construction.Polygon], ["segment", com.vzome.core.construction.Segment]]; return CommandLinePlaneIntersect.PARAM_SIGNATURE; }
                    ;
                    static ATTR_SIGNATURE_$LI$() { if (CommandLinePlaneIntersect.ATTR_SIGNATURE == null)
                        CommandLinePlaneIntersect.ATTR_SIGNATURE = []; return CommandLinePlaneIntersect.ATTR_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandLinePlaneIntersect.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return CommandLinePlaneIntersect.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        let result = new com.vzome.core.construction.ConstructionList();
                        if (parameters == null || parameters.size() !== 2)
                            throw new commands.Command.Failure("Intersection requires a panel and a strut.");
                        try {
                            let panel;
                            let segment;
                            let first = parameters.get(0);
                            if (first != null && first instanceof com.vzome.core.construction.Polygon) {
                                panel = first;
                                segment = parameters.get(1);
                            }
                            else {
                                segment = first;
                                panel = parameters.get(1);
                            }
                            let plane = new com.vzome.core.construction.PlaneExtensionOfPolygon(panel);
                            let line = new com.vzome.core.construction.LineExtensionOfSegment(segment);
                            let point = new com.vzome.core.construction.LinePlaneIntersectionPoint(plane, line);
                            result.addConstruction(point);
                            effects.constructionAdded(point);
                        }
                        catch (e) {
                            throw new commands.Command.Failure("Intersection requires a panel and a strut.");
                        }
                        ;
                        return result;
                    }
                }
                commands.CommandLinePlaneIntersect = CommandLinePlaneIntersect;
                CommandLinePlaneIntersect["__class"] = "com.vzome.core.commands.CommandLinePlaneIntersect";
                CommandLinePlaneIntersect["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class CommandObliquePentagon extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandObliquePentagon.PARAM_SIGNATURE == null)
                        CommandObliquePentagon.PARAM_SIGNATURE = [["segment1", com.vzome.core.construction.Segment], ["segment2", com.vzome.core.construction.Segment]]; return CommandObliquePentagon.PARAM_SIGNATURE; }
                    ;
                    static ATTR_SIGNATURE_$LI$() { if (CommandObliquePentagon.ATTR_SIGNATURE == null)
                        CommandObliquePentagon.ATTR_SIGNATURE = []; return CommandObliquePentagon.ATTR_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandObliquePentagon.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return CommandObliquePentagon.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        throw new commands.Command.Failure("Oblique pentagon should never be called.");
                    }
                }
                commands.CommandObliquePentagon = CommandObliquePentagon;
                CommandObliquePentagon["__class"] = "com.vzome.core.commands.CommandObliquePentagon";
                CommandObliquePentagon["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandMidpoint extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandMidpoint.PARAM_SIGNATURE == null)
                        CommandMidpoint.PARAM_SIGNATURE = [["segment", com.vzome.core.construction.Segment]]; return CommandMidpoint.PARAM_SIGNATURE; }
                    ;
                    static ATTR_SIGNATURE_$LI$() { if (CommandMidpoint.ATTR_SIGNATURE == null)
                        CommandMidpoint.ATTR_SIGNATURE = []; return CommandMidpoint.ATTR_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandMidpoint.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return CommandMidpoint.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        let result = new com.vzome.core.construction.ConstructionList();
                        if (parameters == null || parameters.size() !== 1)
                            throw new commands.Command.Failure("Midpoint can only apply to a single strut.");
                        try {
                            let segment = parameters.get(0);
                            let midpoint = new com.vzome.core.construction.SegmentMidpoint(segment);
                            result.addConstruction(midpoint);
                            effects.constructionAdded(midpoint);
                        }
                        catch (e) {
                            throw new commands.Command.Failure("Midpoint can only apply to a strut.");
                        }
                        ;
                        return result;
                    }
                }
                commands.CommandMidpoint = CommandMidpoint;
                CommandMidpoint["__class"] = "com.vzome.core.commands.CommandMidpoint";
                CommandMidpoint["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.algebra.Quaternion} leftQuaternion
                 * @param {com.vzome.core.algebra.Quaternion} rightQuaternion
                 * @param {com.vzome.core.construction.Point} prototype
                 * @class
                 * @extends com.vzome.core.construction.Point
                 */
                class PointRotated4D extends com.vzome.core.construction.Point {
                    constructor(leftQuaternion, rightQuaternion, prototype) {
                        super(prototype.field);
                        if (this.mLeftQuaternion === undefined)
                            this.mLeftQuaternion = null;
                        if (this.mRightQuaternion === undefined)
                            this.mRightQuaternion = null;
                        if (this.mPrototype === undefined)
                            this.mPrototype = null;
                        this.mLeftQuaternion = leftQuaternion;
                        this.mRightQuaternion = rightQuaternion;
                        this.mPrototype = prototype;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mPrototype.isImpossible())
                            return this.setStateVariable(null, true);
                        let field = this.mPrototype.getField();
                        let loc = field.origin(4);
                        let loc3d = this.mPrototype.getLocation();
                        loc = loc3d.inflateTo4d$boolean(true);
                        loc = this.mRightQuaternion.leftMultiply(loc);
                        loc = this.mLeftQuaternion.rightMultiply(loc);
                        return this.setStateVariable(loc, false);
                    }
                }
                construction.PointRotated4D = PointRotated4D;
                PointRotated4D["__class"] = "com.vzome.core.construction.PointRotated4D";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class LineLineIntersectionPoint extends com.vzome.core.construction.Point {
                    constructor(line1, line2) {
                        super(line1.field);
                        if (this.line1 === undefined)
                            this.line1 = null;
                        if (this.line2 === undefined)
                            this.line2 = null;
                        this.line1 = line1;
                        this.line2 = line2;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        let p1 = this.line1.getStart();
                        let p21 = this.line1.getDirection();
                        let p3 = this.line2.getStart();
                        let p43 = this.line2.getDirection();
                        if (p1.equals(p3))
                            return this.setStateVariable(p1, false);
                        let p2 = p1.plus(p21);
                        if (p2.equals(p3))
                            return this.setStateVariable(p2, false);
                        let p4 = p3.plus(p43);
                        if (p1.equals(p4))
                            return this.setStateVariable(p1, false);
                        if (p2.equals(p4))
                            return this.setStateVariable(p2, false);
                        let p13 = p1.minus(p3);
                        let d1343 = p13.dot(p43);
                        let d4321 = p43.dot(p21);
                        let d1321 = p13.dot(p21);
                        let d4343 = p43.dot(p43);
                        let d2121 = p21.dot(p21);
                        let denom = d2121['times$com_vzome_core_algebra_AlgebraicNumber'](d4343)['minus$com_vzome_core_algebra_AlgebraicNumber'](d4321['times$com_vzome_core_algebra_AlgebraicNumber'](d4321));
                        if (denom.isZero())
                            return this.setStateVariable(null, true);
                        let numer = d1343['times$com_vzome_core_algebra_AlgebraicNumber'](d4321)['minus$com_vzome_core_algebra_AlgebraicNumber'](d1321['times$com_vzome_core_algebra_AlgebraicNumber'](d4343));
                        let mua = numer['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](denom);
                        let mub = d1343['plus$com_vzome_core_algebra_AlgebraicNumber'](d4321['times$com_vzome_core_algebra_AlgebraicNumber'](mua))['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](d4343);
                        let pa = p1.plus(p21.scale(mua));
                        let pb = p3.plus(p43.scale(mub));
                        if (!pa.equals(pb))
                            return this.setStateVariable(null, true);
                        return this.setStateVariable(pb, false);
                    }
                }
                construction.LineLineIntersectionPoint = LineLineIntersectionPoint;
                LineLineIntersectionPoint["__class"] = "com.vzome.core.construction.LineLineIntersectionPoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Transformation} transform
                 * @param {com.vzome.core.construction.Point} prototype
                 * @class
                 * @extends com.vzome.core.construction.Point
                 */
                class TransformedPoint extends com.vzome.core.construction.Point {
                    constructor(transform, prototype) {
                        super(prototype.field);
                        if (this.mTransform === undefined)
                            this.mTransform = null;
                        if (this.mPrototype === undefined)
                            this.mPrototype = null;
                        this.mTransform = transform;
                        this.mPrototype = prototype;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mTransform.isImpossible() || this.mPrototype.isImpossible())
                            return this.setStateVariable(null, true);
                        let loc = this.mTransform.transform$com_vzome_core_algebra_AlgebraicVector(this.mPrototype.getLocation());
                        return this.setStateVariable(loc, false);
                    }
                }
                construction.TransformedPoint = TransformedPoint;
                TransformedPoint["__class"] = "com.vzome.core.construction.TransformedPoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param loc
                 * @param {com.vzome.core.construction.Segment} seg
                 * @class
                 * @extends com.vzome.core.construction.Point
                 * @author Scott Vorthmann
                 */
                class SegmentMidpoint extends com.vzome.core.construction.Point {
                    constructor(seg) {
                        super(seg.field);
                        if (this.mSegment === undefined)
                            this.mSegment = null;
                        this.mSegment = seg;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mSegment.isImpossible())
                            return this.setStateVariable(null, true);
                        let half = this.field['createRational$long$long'](1, 2);
                        let loc = this.mSegment.getStart();
                        loc = loc.plus(this.mSegment.getOffset().scale(half));
                        return this.setStateVariable(loc, false);
                    }
                }
                construction.SegmentMidpoint = SegmentMidpoint;
                SegmentMidpoint["__class"] = "com.vzome.core.construction.SegmentMidpoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param {com.vzome.core.algebra.AlgebraicVector} loc
                 * @class
                 * @extends com.vzome.core.construction.Point
                 * @author Scott Vorthmann
                 */
                class FreePoint extends com.vzome.core.construction.Point {
                    constructor(loc) {
                        super(loc.getField());
                        this.setStateVariable(loc, false);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        return true;
                    }
                }
                construction.FreePoint = FreePoint;
                FreePoint["__class"] = "com.vzome.core.construction.FreePoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Polygon} polygon
                 * @param {number} index
                 * @class
                 * @extends com.vzome.core.construction.Point
                 */
                class PolygonVertex extends com.vzome.core.construction.Point {
                    constructor(polygon, index) {
                        super(polygon.field);
                        if (this.polygon === undefined)
                            this.polygon = null;
                        if (this.index === undefined)
                            this.index = 0;
                        this.polygon = polygon;
                        this.index = index;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.polygon.isImpossible()) {
                            return this.setStateVariable(null, true);
                        }
                        let loc = this.polygon.getVertex(this.index);
                        return this.setStateVariable(loc, false);
                    }
                }
                construction.PolygonVertex = PolygonVertex;
                PolygonVertex["__class"] = "com.vzome.core.construction.PolygonVertex";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param loc
                 * @param {com.vzome.core.construction.Segment} seg
                 * @class
                 * @extends com.vzome.core.construction.Point
                 * @author Scott Vorthmann
                 */
                class SegmentTauDivision extends com.vzome.core.construction.Point {
                    constructor(seg) {
                        super(seg.field);
                        if (this.mSegment === undefined)
                            this.mSegment = null;
                        if (this.shrink === undefined)
                            this.shrink = null;
                        this.mSegment = seg;
                        this.shrink = this.field['createPower$int'](-1);
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mSegment.isImpossible())
                            return this.setStateVariable(null, true);
                        let loc = this.mSegment.getStart();
                        let off = this.mSegment.getOffset().scale(this.shrink);
                        loc = loc.plus(off);
                        return this.setStateVariable(loc, false);
                    }
                }
                construction.SegmentTauDivision = SegmentTauDivision;
                SegmentTauDivision["__class"] = "com.vzome.core.construction.SegmentTauDivision";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                class LinePlaneIntersectionPoint extends com.vzome.core.construction.Point {
                    constructor(plane, line) {
                        super(line.field);
                        if (this.mPlane === undefined)
                            this.mPlane = null;
                        if (this.mLine === undefined)
                            this.mLine = null;
                        this.mPlane = plane;
                        this.mLine = line;
                        this.mapParamsToState();
                    }
                    /**
                     * From Vince, GA4CG, p. 196.
                     *
                     * @author Scott Vorthmann
                     * @return {boolean}
                     */
                    mapParamsToState_usingGA() {
                        if (this.mPlane.isImpossible() || this.mLine.isImpossible())
                            return this.setStateVariable(null, true);
                        let plane = this.mPlane.getHomogeneous();
                        let line = this.mLine.getHomogeneous();
                        let intersection = plane.dual().dot(line);
                        if (!intersection.exists())
                            return this.setStateVariable(null, true);
                        return this.setStateVariable(intersection.getVector(), false);
                    }
                    /**
                     * from http://astronomy.swin.edu.au/~pbourke/geometry/planeline/:
                     *
                     *
                     * The equation of a plane (points P are on the plane with normal N and point P3 on the plane) can be written as
                     *
                     * N dot (P - P3) = 0
                     *
                     * The equation of the line (points P on the line passing through points P1 and P2) can be written as
                     *
                     * P = P1 + u (P2 - P1)
                     *
                     * The intersection of these two occurs when
                     *
                     * N dot (P1 + u (P2 - P1)) = N dot P3
                     *
                     * Solving for u gives
                     *
                     * u = ( N dot (P3-P1) ) / ( N dot (P2-P1) )
                     *
                     * If the denominator is zero, the line is parallel to the plane.
                     *
                     * @author Scott Vorthmann
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mPlane.isImpossible() || this.mLine.isImpossible())
                            return this.setStateVariable(null, true);
                        let p1 = this.mLine.getStart();
                        let p1p2 = this.mLine.getDirection();
                        let n = this.mPlane.getNormal();
                        let p3 = this.mPlane.getBase();
                        let p = com.vzome.core.algebra.AlgebraicVectors.getLinePlaneIntersection(p1, p1p2, p3, n);
                        if (p == null)
                            return this.setStateVariable(null, true);
                        else
                            return this.setStateVariable(p, false);
                    }
                }
                construction.LinePlaneIntersectionPoint = LinePlaneIntersectionPoint;
                LinePlaneIntersectionPoint["__class"] = "com.vzome.core.construction.LinePlaneIntersectionPoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {Array} points
                 * @class
                 * @extends com.vzome.core.construction.Point
                 */
                class CentroidPoint extends com.vzome.core.construction.Point {
                    constructor(points) {
                        super(points[0].field);
                        if (this.mPoints === undefined)
                            this.mPoints = null;
                        this.mPoints = points;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        let centroid = this.mPoints[0].getLocation();
                        let num = 1;
                        for (let i = 1; i < this.mPoints.length; i++) {
                            {
                                centroid = centroid.plus(this.mPoints[i].getLocation());
                                num++;
                            }
                            ;
                        }
                        centroid = centroid.scale(this.field['createRational$long$long'](1, num));
                        return this.setStateVariable(centroid, false);
                    }
                }
                construction.CentroidPoint = CentroidPoint;
                CentroidPoint["__class"] = "com.vzome.core.construction.CentroidPoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Segment} seg
                 * @param {boolean} start
                 * @class
                 * @extends com.vzome.core.construction.Point
                 */
                class SegmentEndPoint extends com.vzome.core.construction.Point {
                    constructor(seg, start) {
                        if (((seg != null && seg instanceof com.vzome.core.construction.Segment) || seg === null) && ((typeof start === 'boolean') || start === null)) {
                            let __args = arguments;
                            super(seg.field);
                            if (this.mSegment === undefined)
                                this.mSegment = null;
                            this.start = false;
                            if (this.mSegment === undefined)
                                this.mSegment = null;
                            (() => {
                                this.mSegment = seg;
                                this.start = start;
                                this.mapParamsToState();
                            })();
                        }
                        else if (((seg != null && seg instanceof com.vzome.core.construction.Segment) || seg === null) && start === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let start = false;
                                super(seg.field);
                                if (this.mSegment === undefined)
                                    this.mSegment = null;
                                this.start = false;
                                if (this.mSegment === undefined)
                                    this.mSegment = null;
                                (() => {
                                    this.mSegment = seg;
                                    this.start = start;
                                    this.mapParamsToState();
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mSegment.isImpossible())
                            return this.setStateVariable(null, true);
                        let loc = this.start ? this.mSegment.getStart() : this.mSegment.getEnd();
                        return this.setStateVariable(loc, false);
                    }
                }
                construction.SegmentEndPoint = SegmentEndPoint;
                SegmentEndPoint["__class"] = "com.vzome.core.construction.SegmentEndPoint";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandJoinPoints extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandJoinPoints.PARAM_SIGNATURE == null)
                        CommandJoinPoints.PARAM_SIGNATURE = [["start", com.vzome.core.construction.Point], ["end", com.vzome.core.construction.Point]]; return CommandJoinPoints.PARAM_SIGNATURE; }
                    ;
                    static ATTR_SIGNATURE_$LI$() { if (CommandJoinPoints.ATTR_SIGNATURE == null)
                        CommandJoinPoints.ATTR_SIGNATURE = []; return CommandJoinPoints.ATTR_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandJoinPoints.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return CommandJoinPoints.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    ordersSelection() {
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        let result = new com.vzome.core.construction.ConstructionList();
                        if (parameters == null || parameters.size() !== 2)
                            throw new commands.Command.Failure("parameters must be two points");
                        try {
                            let pt1 = parameters.get(0);
                            let pt2 = parameters.get(1);
                            let segment = new com.vzome.core.construction.SegmentJoiningPoints(pt1, pt2);
                            result.addConstruction(segment);
                            effects.constructionAdded(segment);
                        }
                        catch (e) {
                            throw new commands.Command.Failure("parameters must be two points");
                        }
                        ;
                        return result;
                    }
                }
                commands.CommandJoinPoints = CommandJoinPoints;
                CommandJoinPoints["__class"] = "com.vzome.core.commands.CommandJoinPoints";
                CommandJoinPoints["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandTransform extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setFixedAttributes(attributes, format) {
                        if (format.getScale() !== 0)
                            attributes.put(CommandTransform.SCALE_ATTR_NAME, format.getScale());
                        super.setFixedAttributes(attributes, format);
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        return null;
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandTransform.PARAM_SIGNATURE == null)
                        CommandTransform.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Construction]]; return CommandTransform.PARAM_SIGNATURE; }
                    ;
                    static ATTR_SIGNATURE_$LI$() { if (CommandTransform.ATTR_SIGNATURE == null)
                        CommandTransform.ATTR_SIGNATURE = [[CommandTransform.SYMMETRY_CENTER_ATTR_NAME, com.vzome.core.construction.Point]]; return CommandTransform.ATTR_SIGNATURE; }
                    ;
                    static AXIS_ATTR_SIGNATURE_$LI$() { if (CommandTransform.AXIS_ATTR_SIGNATURE == null)
                        CommandTransform.AXIS_ATTR_SIGNATURE = [[CommandTransform.SYMMETRY_CENTER_ATTR_NAME, com.vzome.core.construction.Point], [CommandTransform.SYMMETRY_AXIS_ATTR_NAME, com.vzome.core.construction.Segment]]; return CommandTransform.AXIS_ATTR_SIGNATURE; }
                    ;
                    static GROUP_ATTR_SIGNATURE_$LI$() { if (CommandTransform.GROUP_ATTR_SIGNATURE == null)
                        CommandTransform.GROUP_ATTR_SIGNATURE = [[CommandTransform.SYMMETRY_CENTER_ATTR_NAME, com.vzome.core.construction.Point], [CommandTransform.SYMMETRY_GROUP_ATTR_NAME, "com.vzome.core.math.symmetry.Symmetry"]]; return CommandTransform.GROUP_ATTR_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandTransform.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return CommandTransform.AXIS_ATTR_SIGNATURE_$LI$();
                    }
                    transform(params, transform, effects) {
                        let output = new com.vzome.core.construction.ConstructionList();
                        effects.constructionAdded(transform);
                        for (let index220 = 0; index220 < params.length; index220++) {
                            let param = params[index220];
                            {
                                let result = transform.transform$com_vzome_core_construction_Construction(param);
                                if (result == null)
                                    continue;
                                effects.constructionAdded(result);
                                output.addConstruction(result);
                            }
                        }
                        return output;
                    }
                }
                CommandTransform.SYMMETRY_GROUP_ATTR_NAME = "symmetry.group";
                CommandTransform.SYMMETRY_CENTER_ATTR_NAME = "symmetry.center";
                CommandTransform.SYMMETRY_AXIS_ATTR_NAME = "symmetry.axis.segment";
                CommandTransform.SCALE_ATTR_NAME = "scale.factor";
                commands.CommandTransform = CommandTransform;
                CommandTransform["__class"] = "com.vzome.core.commands.CommandTransform";
                CommandTransform["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandBuildAnchoredSegment extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     */
                    getXml(xml, attributes) {
                        com.vzome.core.commands.XmlSymmetryFormat.serializeAxis(xml, "symm", "dir", "index", "sense", attributes.get("axis"));
                        com.vzome.core.commands.XmlSaveFormat.serializeNumber(xml, "len", attributes.get("length"));
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @return {com.vzome.core.commands.AttributeMap}
                     */
                    setXml(xml, format) {
                        let attrs = super.setXml(xml, format);
                        if (format.commandEditsCompacted()) {
                            attrs.put("axis", format.parseAxis(xml, "symm", "dir", "index", "sense"));
                            attrs.put("length", format.parseNumber(xml, "len"));
                        }
                        return attrs;
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandBuildAnchoredSegment.PARAM_SIGNATURE == null)
                        CommandBuildAnchoredSegment.PARAM_SIGNATURE = [["start", com.vzome.core.construction.Point]]; return CommandBuildAnchoredSegment.PARAM_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandBuildAnchoredSegment.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return null;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        let result = new com.vzome.core.construction.ConstructionList();
                        if (parameters == null || parameters.size() !== 1)
                            throw new commands.Command.Failure("start parameter must be a single point");
                        let c = parameters.get(0);
                        if (!(c != null && c instanceof com.vzome.core.construction.Point))
                            throw new commands.Command.Failure("start parameter must be a single point");
                        let pt1 = c;
                        let axis = attrs.get(CommandBuildAnchoredSegment.AXIS_ATTR);
                        let len = attrs.get(CommandBuildAnchoredSegment.LENGTH_ATTR);
                        let segment = new com.vzome.core.construction.AnchoredSegment(axis, len, pt1);
                        effects.constructionAdded(segment);
                        result.addConstruction(segment);
                        let pt2 = new com.vzome.core.construction.SegmentEndPoint(segment);
                        effects.constructionAdded(pt2);
                        result.addConstruction(pt2);
                        return result;
                    }
                }
                CommandBuildAnchoredSegment.AXIS_ATTR = "axis";
                CommandBuildAnchoredSegment.LENGTH_ATTR = "length";
                commands.CommandBuildAnchoredSegment = CommandBuildAnchoredSegment;
                CommandBuildAnchoredSegment["__class"] = "com.vzome.core.commands.CommandBuildAnchoredSegment";
                CommandBuildAnchoredSegment["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandTauDivision extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandTauDivision.PARAM_SIGNATURE == null)
                        CommandTauDivision.PARAM_SIGNATURE = [["start", com.vzome.core.construction.Point], ["end", com.vzome.core.construction.Point]]; return CommandTauDivision.PARAM_SIGNATURE; }
                    ;
                    static ATTR_SIGNATURE_$LI$() { if (CommandTauDivision.ATTR_SIGNATURE == null)
                        CommandTauDivision.ATTR_SIGNATURE = []; return CommandTauDivision.ATTR_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandTauDivision.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return CommandTauDivision.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    ordersSelection() {
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        let result = new com.vzome.core.construction.ConstructionList();
                        if (parameters == null || parameters.size() !== 2)
                            throw new commands.Command.Failure("Tau division applies to two balls.");
                        try {
                            let start = parameters.get(0);
                            let end = parameters.get(1);
                            let join = new com.vzome.core.construction.SegmentJoiningPoints(start, end);
                            let midpoint = new com.vzome.core.construction.SegmentTauDivision(join);
                            result.addConstruction(midpoint);
                            effects.constructionAdded(midpoint);
                        }
                        catch (e) {
                            throw new commands.Command.Failure("Tau division applies to two balls.");
                        }
                        ;
                        return result;
                    }
                }
                commands.CommandTauDivision = CommandTauDivision;
                CommandTauDivision["__class"] = "com.vzome.core.commands.CommandTauDivision";
                CommandTauDivision["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class CommandPolygon extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandPolygon.PARAM_SIGNATURE == null)
                        CommandPolygon.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Point]]; return CommandPolygon.PARAM_SIGNATURE; }
                    ;
                    static ATTR_SIGNATURE_$LI$() { if (CommandPolygon.ATTR_SIGNATURE == null)
                        CommandPolygon.ATTR_SIGNATURE = []; return CommandPolygon.ATTR_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandPolygon.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return CommandPolygon.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    ordersSelection() {
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        let points = (new java.util.ArrayList());
                        {
                            let array222 = parameters.getConstructions();
                            for (let index221 = 0; index221 < array222.length; index221++) {
                                let param = array222[index221];
                                {
                                    if (param != null && param instanceof com.vzome.core.construction.Point) {
                                        points.add(param);
                                    }
                                }
                            }
                        }
                        let errorMsg = null;
                        if (points.size() < 3) {
                            errorMsg = "A polygon requires at least three vertices.";
                        }
                        else if (points.get(0).is3d() && points.get(1).is3d() && points.get(1).is3d()) {
                            let normal = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(points.get(0).getLocation(), points.get(1).getLocation(), points.get(2).getLocation());
                            if (normal.isOrigin()) {
                                errorMsg = "First 3 points cannot be collinear.";
                            }
                            else {
                                let base = null;
                                for (let index223 = points.iterator(); index223.hasNext();) {
                                    let point = index223.next();
                                    {
                                        if (base == null) {
                                            base = point.getLocation();
                                        }
                                        else {
                                            if (!point.getLocation().minus(base).dot(normal).isZero()) {
                                                errorMsg = "Points are not coplanar.";
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (errorMsg != null && attrs.get(com.vzome.core.commands.Command.LOADING_FROM_FILE) == null) {
                            throw new commands.Command.Failure(errorMsg);
                        }
                        let poly = new com.vzome.core.construction.PolygonFromVertices(points);
                        if (errorMsg != null) {
                            poly.setFailed();
                        }
                        else {
                            effects.constructionAdded(poly);
                        }
                        let result = new com.vzome.core.construction.ConstructionList();
                        result.addConstruction(poly);
                        return result;
                    }
                }
                commands.CommandPolygon = CommandPolygon;
                CommandPolygon["__class"] = "com.vzome.core.commands.CommandPolygon";
                CommandPolygon["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.AbstractCommand
                 */
                class CommandCentroid extends com.vzome.core.commands.AbstractCommand {
                    constructor() {
                        super();
                    }
                    static PARAM_SIGNATURE_$LI$() { if (CommandCentroid.PARAM_SIGNATURE == null)
                        CommandCentroid.PARAM_SIGNATURE = [[com.vzome.core.commands.Command.GENERIC_PARAM_NAME, com.vzome.core.construction.Point]]; return CommandCentroid.PARAM_SIGNATURE; }
                    ;
                    static ATTR_SIGNATURE_$LI$() { if (CommandCentroid.ATTR_SIGNATURE == null)
                        CommandCentroid.ATTR_SIGNATURE = []; return CommandCentroid.ATTR_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getParameterSignature() {
                        return CommandCentroid.PARAM_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return CommandCentroid.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attrs
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attrs, effects) {
                        let result = new com.vzome.core.construction.ConstructionList();
                        if (parameters == null || parameters.size() === 0)
                            throw new commands.Command.Failure("Select two or more balls to compute their centroid.");
                        let params = parameters.getConstructions();
                        let verticesList = (new java.util.ArrayList());
                        for (let index224 = 0; index224 < params.length; index224++) {
                            let param = params[index224];
                            {
                                if (param != null && param instanceof com.vzome.core.construction.Point) {
                                    verticesList.add(param);
                                }
                            }
                        }
                        if (verticesList.isEmpty())
                            throw new commands.Command.Failure("Select two or more balls to compute their centroid.");
                        let points = [];
                        let centroid = new com.vzome.core.construction.CentroidPoint(verticesList.toArray(points));
                        effects.constructionAdded(centroid);
                        result.addConstruction(centroid);
                        return result;
                    }
                }
                commands.CommandCentroid = CommandCentroid;
                CommandCentroid["__class"] = "com.vzome.core.commands.CommandCentroid";
                CommandCentroid["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Point} intersection
                 * @param {com.vzome.core.construction.Segment} normal
                 * @class
                 * @extends com.vzome.core.construction.Plane
                 */
                class PlaneFromNormalSegment extends com.vzome.core.construction.Plane {
                    constructor(intersection, normal) {
                        super(intersection.field);
                        if (this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal === undefined)
                            this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal = null;
                        if (this.mIntersection === undefined)
                            this.mIntersection = null;
                        this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal = normal;
                        this.mIntersection = intersection;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal.isImpossible() || this.mIntersection.isImpossible())
                            return this.setStateVariables(null, null, true);
                        return this.setStateVariables(this.mIntersection.getLocation(), this.__com_vzome_core_construction_PlaneFromNormalSegment_mNormal.getOffset(), false);
                    }
                }
                construction.PlaneFromNormalSegment = PlaneFromNormalSegment;
                PlaneFromNormalSegment["__class"] = "com.vzome.core.construction.PlaneFromNormalSegment";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Polygon} polygon
                 * @class
                 * @extends com.vzome.core.construction.Plane
                 */
                class PlaneExtensionOfPolygon extends com.vzome.core.construction.Plane {
                    constructor(polygon) {
                        super(polygon.field);
                        if (this.mPolygon === undefined)
                            this.mPolygon = null;
                        this.mPolygon = polygon;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mPolygon.isImpossible()) {
                            return this.setStateVariables(null, null, true);
                        }
                        return this.setStateVariables(this.mPolygon.getVertex(0), this.mPolygon.getNormal(), false);
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.Trivector3dHomogeneous}
                     */
                    getHomogeneous() {
                        let v1 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mPolygon.getVertex(0), this.getField());
                        let v2 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mPolygon.getVertex(1), this.getField());
                        let v3 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mPolygon.getVertex(2), this.getField());
                        return v1.outer(v2).outer(v3);
                    }
                }
                construction.PlaneExtensionOfPolygon = PlaneExtensionOfPolygon;
                PlaneExtensionOfPolygon["__class"] = "com.vzome.core.construction.PlaneExtensionOfPolygon";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.algebra.AlgebraicVector} point
                 * @param {com.vzome.core.algebra.AlgebraicVector} normal
                 * @class
                 * @extends com.vzome.core.construction.Plane
                 */
                class PlaneFromPointAndNormal extends com.vzome.core.construction.Plane {
                    constructor(point, normal) {
                        super(point.getField());
                        if (this.normal === undefined)
                            this.normal = null;
                        if (this.point === undefined)
                            this.point = null;
                        this.point = point;
                        this.normal = normal;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.normal.isOrigin())
                            return this.setStateVariables(null, null, true);
                        return this.setStateVariables(this.point, this.normal, false);
                    }
                }
                construction.PlaneFromPointAndNormal = PlaneFromPointAndNormal;
                PlaneFromPointAndNormal["__class"] = "com.vzome.core.construction.PlaneFromPointAndNormal";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @param step
                 * @param start
                 * @param end
                 * @param {com.vzome.core.construction.Line} l1
                 * @param {com.vzome.core.construction.Line} l2
                 * @param {com.vzome.core.construction.Point} p
                 * @class
                 * @extends com.vzome.core.construction.Line
                 * @author Scott Vorthmann
                 */
                class PerpendicularLine extends com.vzome.core.construction.Line {
                    constructor(l1, l2, p) {
                        super(l1.field);
                        if (this.mLine1 === undefined)
                            this.mLine1 = null;
                        if (this.mLine2 === undefined)
                            this.mLine2 = null;
                        if (this.mPoint === undefined)
                            this.mPoint = null;
                        this.mLine1 = l1;
                        this.mLine2 = l2;
                        this.mPoint = p;
                        this.mapParamsToState();
                    }
                    /**
                     * returns true if something changed.
                     * @return
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mLine1.isImpossible() || this.mLine2.isImpossible() || this.mPoint.isImpossible()) {
                            return this.setStateVariables(null, null, true);
                        }
                        let normal = com.vzome.core.algebra.AlgebraicVectors.getNormal$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(this.mLine1.getDirection(), this.mLine2.getDirection());
                        return this.setStateVariables(this.mPoint.getLocation(), normal, normal.isOrigin());
                    }
                }
                construction.PerpendicularLine = PerpendicularLine;
                PerpendicularLine["__class"] = "com.vzome.core.construction.PerpendicularLine";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.construction.Segment} seg
                 * @class
                 * @extends com.vzome.core.construction.Line
                 */
                class LineExtensionOfSegment extends com.vzome.core.construction.Line {
                    constructor(seg) {
                        super(seg.field);
                        if (this.mSegment === undefined)
                            this.mSegment = null;
                        this.mSegment = seg;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.mSegment.isImpossible())
                            return this.setStateVariables(null, null, true);
                        return this.setStateVariables(this.mSegment.getStart(), this.mSegment.getOffset(), false);
                    }
                    /**
                     *
                     * @return {com.vzome.core.algebra.Bivector3dHomogeneous}
                     */
                    getHomogeneous() {
                        let v1 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mSegment.getStart(), this.getField());
                        let v2 = new com.vzome.core.algebra.Vector3dHomogeneous(this.mSegment.getEnd(), this.getField());
                        return v1.outer(v2);
                    }
                }
                construction.LineExtensionOfSegment = LineExtensionOfSegment;
                LineExtensionOfSegment["__class"] = "com.vzome.core.construction.LineExtensionOfSegment";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var construction;
            (function (construction) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.algebra.AlgebraicVector} point
                 * @param {com.vzome.core.algebra.AlgebraicVector} direction
                 * @class
                 * @extends com.vzome.core.construction.Line
                 */
                class LineFromPointAndVector extends com.vzome.core.construction.Line {
                    constructor(point, direction) {
                        super(point.getField());
                        if (this.point === undefined)
                            this.point = null;
                        if (this.direction === undefined)
                            this.direction = null;
                        this.point = point;
                        this.direction = direction;
                        this.mapParamsToState();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    mapParamsToState() {
                        if (this.direction.isOrigin())
                            return this.setStateVariables(null, null, true);
                        return this.setStateVariables(this.point, this.direction, false);
                    }
                }
                construction.LineFromPointAndVector = LineFromPointAndVector;
                LineFromPointAndVector["__class"] = "com.vzome.core.construction.LineFromPointAndVector";
            })(construction = core.construction || (core.construction = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    class ChangeSelection extends com.vzome.core.editor.api.SideEffects {
                        constructor(selection) {
                            super();
                            if (this.mSelection === undefined)
                                this.mSelection = null;
                            if (this.groupingDoneInSelection === undefined)
                                this.groupingDoneInSelection = false;
                            this.orderedSelection = false;
                            this.selectionEffects = null;
                            this.mSelection = selection;
                            this.groupingDoneInSelection = false;
                        }
                        static logger_$LI$() { if (ChangeSelection.logger == null)
                            ChangeSelection.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor.ChangeSelection"); return ChangeSelection.logger; }
                        ;
                        setOrderedSelection(orderedSelection) {
                            this.orderedSelection = orderedSelection;
                        }
                        /**
                         *
                         */
                        undo() {
                            if (this.orderedSelection) {
                                let stack = (new java.util.ArrayDeque());
                                this.selectionEffects = stack;
                                super.undo();
                                this.mSelection.clear();
                                this.selectionEffects = null;
                                while ((!stack.isEmpty())) {
                                    {
                                        let se = stack.pop();
                                        se.undo();
                                    }
                                }
                                ;
                            }
                            else
                                super.undo();
                        }
                        getXmlAttributes(element) {
                        }
                        setXmlAttributes(xml, format) {
                        }
                        /**
                         *
                         * @param {*} doc
                         * @return {*}
                         */
                        getXml(doc) {
                            let result = doc.createElement(this.getXmlElementName());
                            if (this.groupingDoneInSelection)
                                com.vzome.xml.DomUtils.addAttribute(result, "grouping", "2.1.1");
                            this.getXmlAttributes(result);
                            return result;
                        }
                        adjustSelection(man, action) {
                            switch ((action)) {
                                case com.vzome.core.editor.api.ActionEnum.SELECT:
                                    this.select$com_vzome_core_model_Manifestation(man);
                                    break;
                                case com.vzome.core.editor.api.ActionEnum.DESELECT:
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                    break;
                                case com.vzome.core.editor.api.ActionEnum.IGNORE:
                                    break;
                                default:
                                    ChangeSelection.logger_$LI$().warning("unexpected action: " + com.vzome.core.editor.api.ActionEnum["_$wrappers"][action].toString());
                                    break;
                            }
                        }
                        /**
                         * Any subclass can override to alter loading, or migrate (insert other edits), etc.
                         * ALWAYS DO SOME INSERT, or all trace of the command will disappear!
                         * @param {*} xml
                         * @param {com.vzome.core.commands.XmlSaveFormat} format
                         * @param {*} context
                         */
                        loadAndPerform(xml, format, context) {
                            let grouping = xml.getAttribute("grouping");
                            if (this.groupingAware() && (format.groupingDoneInSelection() || /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })("2.1.1", grouping)))
                                this.groupingDoneInSelection = true;
                            this.setXmlAttributes(xml, format);
                            context.performAndRecord(this);
                        }
                        groupingAware() {
                            return false;
                        }
                        unselect$com_vzome_core_model_Manifestation(man) {
                            this.unselect$com_vzome_core_model_Manifestation$boolean(man, false);
                        }
                        unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups) {
                            if (this.groupingDoneInSelection) {
                                this.plan(new ChangeSelection.SelectManifestation(this, man, false));
                                return;
                            }
                            if (man == null) {
                                api.SideEffects.logBugAccommodation("null manifestation");
                                return;
                            }
                            if (!this.mSelection.manifestationSelected(man))
                                return;
                            let group = ignoreGroups ? null : com.vzome.core.editor.api.Selection.biggestGroup(man);
                            if (group == null)
                                this.plan(new ChangeSelection.SelectManifestation(this, man, false));
                            else
                                this.unselectGroup(group);
                        }
                        unselect(man, ignoreGroups) {
                            if (((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                                return this.unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups);
                            }
                            else if (((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                                return this.unselect$com_vzome_core_model_Manifestation(man);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        select$com_vzome_core_model_Manifestation(man) {
                            this.select$com_vzome_core_model_Manifestation$boolean(man, false);
                        }
                        recordSelected(man) {
                            if (!this.mSelection.manifestationSelected(man))
                                return;
                            this.plan(new ChangeSelection.RecordSelectedManifestation(this, man));
                        }
                        select$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups) {
                            if (this.groupingDoneInSelection) {
                                this.plan(new ChangeSelection.SelectManifestation(this, man, true));
                                return;
                            }
                            if (man == null) {
                                api.SideEffects.logBugAccommodation("null manifestation");
                                return;
                            }
                            if (this.mSelection.manifestationSelected(man))
                                return;
                            let group = ignoreGroups ? null : com.vzome.core.editor.api.Selection.biggestGroup(man);
                            if (group == null)
                                this.plan(new ChangeSelection.SelectManifestation(this, man, true));
                            else
                                this.selectGroup(group);
                        }
                        select(man, ignoreGroups) {
                            if (((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                                return this.select$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups);
                            }
                            else if (((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                                return this.select$com_vzome_core_model_Manifestation(man);
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        selectGroup(group) {
                            for (let index225 = group.iterator(); index225.hasNext();) {
                                let next = index225.next();
                                {
                                    if (next != null && next instanceof com.vzome.core.model.Group)
                                        this.selectGroup(next);
                                    else
                                        this.plan(new ChangeSelection.SelectManifestation(this, next, true));
                                }
                            }
                        }
                        unselectGroup(group) {
                            for (let index226 = group.iterator(); index226.hasNext();) {
                                let next = index226.next();
                                {
                                    if (next != null && next instanceof com.vzome.core.model.Group)
                                        this.unselectGroup(next);
                                    else
                                        this.plan(new ChangeSelection.SelectManifestation(this, next, false));
                                }
                            }
                        }
                        getSelectedConnectors() {
                            return com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(this.mSelection);
                        }
                        getSelectedStruts() {
                            return com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(this.mSelection);
                        }
                        getSelectedPanels() {
                            return com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.mSelection);
                        }
                        getLastSelectedManifestation() {
                            let last = null;
                            for (let index227 = this.mSelection.iterator(); index227.hasNext();) {
                                let man = index227.next();
                                {
                                    last = man;
                                }
                            }
                            return last;
                        }
                        getLastSelectedConnector() {
                            let last = null;
                            for (let index228 = this.getSelectedConnectors().iterator(); index228.hasNext();) {
                                let connector = index228.next();
                                {
                                    last = connector;
                                }
                            }
                            return last;
                        }
                        getLastSelectedStrut() {
                            let last = null;
                            for (let index229 = this.getSelectedStruts().iterator(); index229.hasNext();) {
                                let strut = index229.next();
                                {
                                    last = strut;
                                }
                            }
                            return last;
                        }
                        getLastSelectedPanel() {
                            let last = null;
                            for (let index230 = this.getSelectedPanels().iterator(); index230.hasNext();) {
                                let panel = index230.next();
                                {
                                    last = panel;
                                }
                            }
                            return last;
                        }
                        unselectAll() {
                            let anySelected = false;
                            for (let index231 = this.mSelection.iterator(); index231.hasNext();) {
                                let man = index231.next();
                                {
                                    anySelected = true;
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                }
                            }
                            if (anySelected) {
                                this.redo();
                            }
                            return anySelected;
                        }
                        unselectConnectors() {
                            let anySelected = false;
                            for (let index232 = this.getSelectedConnectors().iterator(); index232.hasNext();) {
                                let connector = index232.next();
                                {
                                    anySelected = true;
                                    this.unselect$com_vzome_core_model_Manifestation(connector);
                                }
                            }
                            if (anySelected) {
                                this.redo();
                            }
                            return anySelected;
                        }
                        unselectStruts() {
                            let anySelected = false;
                            for (let index233 = this.getSelectedStruts().iterator(); index233.hasNext();) {
                                let strut = index233.next();
                                {
                                    anySelected = true;
                                    this.unselect$com_vzome_core_model_Manifestation(strut);
                                }
                            }
                            if (anySelected) {
                                this.redo();
                            }
                            return anySelected;
                        }
                        unselectPanels() {
                            let anySelected = false;
                            for (let index234 = this.getSelectedPanels().iterator(); index234.hasNext();) {
                                let panel = index234.next();
                                {
                                    anySelected = true;
                                    this.unselect$com_vzome_core_model_Manifestation(panel);
                                }
                            }
                            if (anySelected) {
                                this.redo();
                            }
                            return anySelected;
                        }
                    }
                    api.ChangeSelection = ChangeSelection;
                    ChangeSelection["__class"] = "com.vzome.core.editor.api.ChangeSelection";
                    (function (ChangeSelection) {
                        class SelectManifestation {
                            constructor(__parent, man, value) {
                                this.__parent = __parent;
                                if (this.mMan === undefined)
                                    this.mMan = null;
                                if (this.mOn === undefined)
                                    this.mOn = false;
                                this.mMan = man;
                                this.mOn = value;
                                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().finest("constructing SelectManifestation");
                            }
                            /**
                             *
                             */
                            redo() {
                                if (this.__parent.groupingDoneInSelection) {
                                    if (this.mOn)
                                        this.__parent.mSelection.selectWithGrouping(this.mMan);
                                    else
                                        this.__parent.mSelection.unselectWithGrouping(this.mMan);
                                }
                                else if (this.mOn)
                                    this.__parent.mSelection.select(this.mMan);
                                else
                                    this.__parent.mSelection.unselect(this.mMan);
                            }
                            /**
                             *
                             */
                            undo() {
                                if (this.__parent.groupingDoneInSelection) {
                                    if (this.mOn)
                                        this.__parent.mSelection.unselectWithGrouping(this.mMan);
                                    else
                                        this.__parent.mSelection.selectWithGrouping(this.mMan);
                                }
                                else if (this.mOn)
                                    this.__parent.mSelection.unselect(this.mMan);
                                else if (this.__parent.selectionEffects != null) {
                                    this.__parent.selectionEffects.push(this);
                                }
                                else
                                    this.__parent.mSelection.select(this.mMan);
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                let result = this.mOn ? doc.createElement("select") : doc.createElement("deselect");
                                if (this.mMan != null) {
                                    let man = this.mMan.getXml(doc);
                                    result.appendChild(man);
                                }
                                return result;
                            }
                        }
                        ChangeSelection.SelectManifestation = SelectManifestation;
                        SelectManifestation["__class"] = "com.vzome.core.editor.api.ChangeSelection.SelectManifestation";
                        SelectManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffects.SideEffect"];
                        class RecordSelectedManifestation {
                            constructor(__parent, man) {
                                this.__parent = __parent;
                                if (this.mMan === undefined)
                                    this.mMan = null;
                                this.mMan = man;
                                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().finest("constructing RecordSelectedManifestation");
                            }
                            /**
                             *
                             */
                            redo() {
                                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().finest("redoing RecordSelectedManifestation");
                            }
                            /**
                             *
                             */
                            undo() {
                                com.vzome.core.editor.api.ChangeSelection.logger_$LI$().finest("undoing RecordSelectedManifestation");
                                if (this.__parent.selectionEffects == null)
                                    this.__parent.mSelection.select(this.mMan);
                                else
                                    this.__parent.selectionEffects.push(this);
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                return doc.createElement("recordSelected");
                            }
                        }
                        ChangeSelection.RecordSelectedManifestation = RecordSelectedManifestation;
                        RecordSelectedManifestation["__class"] = "com.vzome.core.editor.api.ChangeSelection.RecordSelectedManifestation";
                        RecordSelectedManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffects.SideEffect"];
                    })(ChangeSelection = api.ChangeSelection || (api.ChangeSelection = {}));
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_3) {
                class TetrahedralToolFactory extends com.vzome.core.tools.OctahedralToolFactory {
                    constructor(tools, symmetry) {
                        super(tools, symmetry, TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_ID, TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_LABEL, "icosahedral" === symmetry.getName() ? TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_TOOLTIP1 : TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_TOOLTIP2);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        if (!((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(id, "tetrahedral"))
                            id = "tetrahedral." + id;
                        return new com.vzome.core.tools.SymmetryTool(id, this.getSymmetry(), this.getToolsModel());
                    }
                }
                TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_ID = "tetrahedral";
                TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_LABEL = "Create a tetrahedral symmetry tool";
                TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_TOOLTIP1 = "<p>Each tool produces up to 11 copies of the input<br>selection, using the rotation symmetries of a<br>tetrahedron.  To create a tool, select a ball<br>that defines the center of symmetry, and a single<br>blue or green strut, defining one of five<br>possible orientations for the symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 24 symmetries of the tetrahedron, including<br>reflections.<br></p>";
                TetrahedralToolFactory.__com_vzome_core_tools_TetrahedralToolFactory_TOOLTIP2 = "<p>Each tool produces up to 11 copies of the input<br>selection, using the rotation symmetries of a<br>tetrahedron.  To create a tool, select a ball<br>that defines the center of symmetry.<br><br>Combine with a point reflection tool to achieve<br>all 24 symmetries of the tetrahedron, including<br>reflections.<br></p>";
                tools_3.TetrahedralToolFactory = TetrahedralToolFactory;
                TetrahedralToolFactory["__class"] = "com.vzome.core.tools.TetrahedralToolFactory";
                TetrahedralToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                class CommandVanOss600Cell extends com.vzome.core.commands.CommandImportVEFData {
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        try {
                            let input = this.constructor.getClassLoader().getResourceAsStream("com/vzome/core/commands/600cell.vef");
                            let out = new java.io.ByteArrayOutputStream();
                            let buf = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(1024);
                            let num;
                            while (((num = input.read(buf, 0, 1024)) > 0)) {
                                out.write(buf, 0, num);
                            }
                            ;
                            let vefData = new String(out.toByteArray());
                            let result = new com.vzome.core.construction.ConstructionList();
                            let field = attributes.get(com.vzome.core.commands.CommandImportVEFData.FIELD_ATTR_NAME);
                            if (field == null)
                                field = attributes.get(com.vzome.core.commands.Command.FIELD_ATTR_NAME);
                            new CommandVanOss600Cell.VefToModel(this, null, effects).parseVEF(vefData, field);
                            return result;
                        }
                        catch (exc) {
                            throw new com.vzome.core.commands.Command.Failure(exc);
                        }
                        ;
                    }
                    constructor() {
                        super();
                    }
                }
                commands.CommandVanOss600Cell = CommandVanOss600Cell;
                CommandVanOss600Cell["__class"] = "com.vzome.core.commands.CommandVanOss600Cell";
                CommandVanOss600Cell["__interfaces"] = ["com.vzome.core.commands.Command"];
                (function (CommandVanOss600Cell) {
                    class VefToModel extends com.vzome.core.math.VefParser {
                        constructor(__parent, quaternion, effects) {
                            super();
                            this.__parent = __parent;
                            if (this.mQuaternion === undefined)
                                this.mQuaternion = null;
                            if (this.mProjection === undefined)
                                this.mProjection = null;
                            if (this.mVertices === undefined)
                                this.mVertices = null;
                            if (this.mEffects === undefined)
                                this.mEffects = null;
                            if (this.mLocations === undefined)
                                this.mLocations = null;
                            this.mQuaternion = null;
                            this.mEffects = effects;
                        }
                        /**
                         *
                         * @param {number} numVertices
                         */
                        startVertices(numVertices) {
                            this.mVertices = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(numVertices);
                            this.mLocations = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(numVertices);
                            this.mProjection = null;
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {com.vzome.core.algebra.AlgebraicVector} location
                         */
                        addVertex(index, location) {
                            this.mLocations[index] = location;
                        }
                        /**
                         *
                         */
                        endVertices() {
                            let field = this.getField();
                            let half = field['createRational$long$long'](1, 2);
                            let quarter = field['createRational$long$long'](1, 4);
                            let centroid = this.mLocations[0].plus(this.mLocations[48]).plus(this.mLocations[50]).plus(this.mLocations[64]).scale(quarter);
                            let edgeCenter = this.mLocations[0].plus(this.mLocations[48]).scale(half);
                            let vertex = this.mLocations[50];
                            let edgeToVertex = vertex.minus(edgeCenter);
                            let edgeToCenter = centroid.minus(edgeCenter);
                            let symmCenter1 = edgeCenter.plus(edgeToCenter.scale(field['createAlgebraicNumber$int$int$int$int'](0, 3, 5, 0)));
                            let symmCenter2 = edgeCenter.plus(edgeToVertex.scale(field['createAlgebraicNumber$int$int$int$int'](0, 2, 5, 0)));
                            let direction = symmCenter2.minus(symmCenter1);
                            let target = symmCenter1.plus(direction.scale(field['createAlgebraicNumber$int$int$int$int'](0, 1, 1, 0)));
                            this.mProjection = new com.vzome.core.math.QuaternionProjection(field, null, target);
                            let power5 = field['createPower$int'](5);
                            for (let i = 0; i < this.mLocations.length; i++) {
                                {
                                    let location = this.mLocations[i].scale(power5);
                                    location = this.mProjection.projectImage(location, this.wFirst());
                                    this.mVertices[i] = new com.vzome.core.construction.FreePoint(location);
                                    this.mEffects.constructionAdded(this.mVertices[i]);
                                }
                                ;
                            }
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {number} v1
                         * @param {number} v2
                         */
                        addEdge(index, v1, v2) {
                            if (2 === 1)
                                return;
                            let p1 = this.mVertices[v1];
                            let p2 = this.mVertices[v2];
                            if (p1 == null || p2 == null) {
                                console.info("skipping " + v1 + " " + v2);
                                return;
                            }
                            let seg = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                            this.mEffects.constructionAdded(seg);
                        }
                        /**
                         *
                         * @param {number} numEdges
                         */
                        startEdges(numEdges) {
                        }
                        /**
                         *
                         * @param {number} numFaces
                         */
                        startFaces(numFaces) {
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {Array} verts
                         */
                        addFace(index, verts) {
                        }
                        /**
                         *
                         * @param {number} index
                         * @param {number} vertex
                         */
                        addBall(index, vertex) {
                        }
                        /**
                         *
                         * @param {number} numVertices
                         */
                        startBalls(numVertices) {
                        }
                    }
                    CommandVanOss600Cell.VefToModel = VefToModel;
                    VefToModel["__class"] = "com.vzome.core.commands.CommandVanOss600Cell.VefToModel";
                })(CommandVanOss600Cell = commands.CommandVanOss600Cell || (commands.CommandVanOss600Cell = {}));
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} field
                 * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} qsymm
                 * @param {number} index
                 * @class
                 * @extends com.vzome.core.commands.CommandTransform
                 */
                class CommandUniformH4Polytope extends com.vzome.core.commands.CommandTransform {
                    constructor(field, qsymm, index) {
                        if (((field != null && (field["__interfaces"] != null && field["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0 || field.constructor != null && field.constructor["__interfaces"] != null && field.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicField") >= 0)) || field === null) && ((qsymm != null && qsymm instanceof com.vzome.core.math.symmetry.QuaternionicSymmetry) || qsymm === null) && ((typeof index === 'number') || index === null)) {
                            let __args = arguments;
                            super();
                            if (this.mRoots === undefined)
                                this.mRoots = null;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.symm === undefined)
                                this.symm = null;
                            this.h4Symms = (new java.util.HashMap());
                            this.mPolytopeIndex = -1;
                            this.quaternionVector = null;
                            if (this.mRoots === undefined)
                                this.mRoots = null;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.symm === undefined)
                                this.symm = null;
                            (() => {
                                this.mPolytopeIndex = index;
                                this.field = field;
                                this.symm = new CommandUniformH4Polytope.H4Symmetry(field);
                                this.mRoots = qsymm.getRoots();
                            })();
                        }
                        else if (field === undefined && qsymm === undefined && index === undefined) {
                            let __args = arguments;
                            super();
                            if (this.mRoots === undefined)
                                this.mRoots = null;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.symm === undefined)
                                this.symm = null;
                            this.h4Symms = (new java.util.HashMap());
                            this.mPolytopeIndex = -1;
                            this.quaternionVector = null;
                            if (this.mRoots === undefined)
                                this.mRoots = null;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.symm === undefined)
                                this.symm = null;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setFixedAttributes(attributes, format) {
                        super.setFixedAttributes(attributes, format);
                        this.field = format.getField();
                        this.symm = this.h4Symms.get(this.field);
                        if (this.symm == null) {
                            this.symm = new CommandUniformH4Polytope.H4Symmetry(this.field);
                            this.h4Symms.put(this.field, this.symm);
                        }
                        this.mRoots = format.getQuaternionicSymmetry("H_4").getRoots();
                    }
                    static logger_$LI$() { if (CommandUniformH4Polytope.logger == null)
                        CommandUniformH4Polytope.logger = java.util.logging.Logger.getLogger("com.vzome.core.commands.h4polytope"); return CommandUniformH4Polytope.logger; }
                    ;
                    /**
                     * Only called when migrating a 2.0 model file.
                     * @param {com.vzome.core.algebra.AlgebraicVector} offset
                     */
                    setQuaternion(offset) {
                        this.quaternionVector = offset;
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @return {com.vzome.core.commands.AttributeMap}
                     */
                    setXml(xml, format) {
                        let attrs = super.setXml(xml, format);
                        this.quaternionVector = format.parseRationalVector(xml, "quaternion");
                        return attrs;
                    }
                    /**
                     *
                     * @param {*} result
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     */
                    getXml(result, attributes) {
                        if (this.quaternionVector != null)
                            com.vzome.xml.DomUtils.addAttribute(result, "quaternion", this.quaternionVector.toParsableString());
                        super.getXml(result, attributes);
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return com.vzome.core.commands.CommandTransform.GROUP_ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {string} attrName
                     * @return {boolean}
                     */
                    attributeIs3D(attrName) {
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("symmetry.axis.segment", attrName))
                            return false;
                        else
                            return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        let SCALE_DOWN_5 = this.field['createPower$int'](-5);
                        let proj = new com.vzome.core.math.Projection.Default(this.field);
                        let leftQuat = null;
                        let rightQuat = null;
                        if (parameters.size() === 0) {
                            rightQuat = this.quaternionVector;
                            let symmAxis = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                            if (rightQuat == null)
                                rightQuat = (symmAxis == null) ? null : symmAxis.getOffset();
                            if (rightQuat != null)
                                rightQuat = rightQuat.scale(SCALE_DOWN_5);
                        }
                        else {
                            let numSegs = 0;
                            for (let index235 = parameters.iterator(); index235.hasNext();) {
                                let cons = index235.next();
                                {
                                    if (cons != null && cons instanceof com.vzome.core.construction.Segment) {
                                        let seg = cons;
                                        if (++numSegs === 1)
                                            rightQuat = seg.getOffset().scale(SCALE_DOWN_5);
                                        else if (numSegs === 2)
                                            leftQuat = seg.getOffset().scale(SCALE_DOWN_5);
                                        else
                                            throw new com.vzome.core.commands.Command.Failure("Too many struts to specify quaternion multiplication.");
                                    }
                                }
                            }
                        }
                        if (rightQuat != null)
                            proj = new com.vzome.core.math.QuaternionProjection(this.field, leftQuat, rightQuat);
                        if (this.mPolytopeIndex < 0) {
                            let indexObj = attributes.get(CommandUniformH4Polytope.POLYTOPE_INDEX_ATTR_NAME);
                            this.mPolytopeIndex = indexObj;
                        }
                        else
                            attributes.put(CommandUniformH4Polytope.POLYTOPE_INDEX_ATTR_NAME, this.mPolytopeIndex);
                        this.generate(this.mPolytopeIndex, this.mPolytopeIndex, null, new CommandUniformH4Polytope.ConstructionChangesAdapter(effects, proj, this.field['createPower$int'](5)));
                        return new com.vzome.core.construction.ConstructionList();
                    }
                    generate(index, renderEdges, edgeScales, listener) {
                        let reflections = [null, null, null, null];
                        let prototype = this.symm.getPrototype(index);
                        if (edgeScales != null) {
                            prototype = this.field.origin(4);
                            for (let b = 0; b < 4; b++) {
                                {
                                    let mask = 1 << b;
                                    let test = index & mask;
                                    if (test !== 0) {
                                        let contribution = this.symm.getCoRoot(b).scale(edgeScales[b]);
                                        prototype = prototype.plus(contribution);
                                    }
                                }
                                ;
                            }
                        }
                        for (let mirror = 0; mirror < 4; mirror++) {
                            if ((renderEdges & (1 << mirror)) !== 0)
                                reflections[mirror] = this.symm.reflect(mirror, prototype);
                            ;
                        }
                        for (let index236 = 0; index236 < this.mRoots.length; index236++) {
                            let outerRoot = this.mRoots[index236];
                            {
                                for (let index237 = 0; index237 < this.mRoots.length; index237++) {
                                    let innerRoot = this.mRoots[index237];
                                    {
                                        let vertex = outerRoot.rightMultiply(prototype);
                                        vertex = innerRoot.leftMultiply(vertex);
                                        let p1 = listener.addVertex(vertex);
                                        for (let mirror = 0; mirror < 4; mirror++) {
                                            {
                                                if (reflections[mirror] != null) {
                                                    let other = outerRoot.rightMultiply(reflections[mirror]);
                                                    other = innerRoot.leftMultiply(other);
                                                    if (!other.equals(vertex)) {
                                                        let p2 = listener.addVertex(other);
                                                        listener.addEdge(p1, p2);
                                                    }
                                                }
                                            }
                                            ;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                CommandUniformH4Polytope.POLYTOPE_INDEX_ATTR_NAME = "polytope.index";
                commands.CommandUniformH4Polytope = CommandUniformH4Polytope;
                CommandUniformH4Polytope["__class"] = "com.vzome.core.commands.CommandUniformH4Polytope";
                CommandUniformH4Polytope["__interfaces"] = ["com.vzome.core.commands.Command"];
                (function (CommandUniformH4Polytope) {
                    class H4Symmetry {
                        constructor(field) {
                            this.mPrototypes = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(15);
                            this.mMirrors = [null, null, null, null];
                            this.coRoots = [null, null, null, null];
                            let ONE = field['createRational$long'](1);
                            let NEG_ONE = field['createRational$long'](-1);
                            let TWO = field['createRational$long'](2);
                            let A = field['createAlgebraicNumber$int$int$int$int'](1, -1, 1, 0);
                            let B = field['createAlgebraicNumber$int$int$int$int'](0, 1, 1, 0);
                            let temp = field.origin(4);
                            temp.setComponent(1, A['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](TWO));
                            temp.setComponent(2, ONE['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](TWO));
                            temp.setComponent(3, B['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](TWO));
                            this.mMirrors[3] = new com.vzome.core.algebra.Quaternion(field, temp);
                            temp = field.origin(4);
                            temp.setComponent(3, NEG_ONE);
                            this.mMirrors[2] = new com.vzome.core.algebra.Quaternion(field, temp);
                            temp = field.origin(4);
                            temp.setComponent(1, ONE['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](TWO));
                            temp.setComponent(2, NEG_ONE['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](TWO));
                            temp.setComponent(3, ONE['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](TWO));
                            temp.setComponent(0, NEG_ONE['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](TWO));
                            this.mMirrors[1] = new com.vzome.core.algebra.Quaternion(field, temp);
                            temp = field.origin(4);
                            temp.setComponent(0, ONE);
                            this.mMirrors[0] = new com.vzome.core.algebra.Quaternion(field, temp);
                            let B2 = field['createAlgebraicNumber$int$int$int$int'](0, 2, 1, 0);
                            this.coRoots[3] = field.origin(4);
                            this.coRoots[3].setComponent(1, B2);
                            this.coRoots[3].setComponent(2, B2);
                            this.coRoots[2] = field.origin(4);
                            this.coRoots[2].setComponent(1, B2['plus$com_vzome_core_algebra_AlgebraicNumber'](ONE));
                            this.coRoots[2].setComponent(2, B['plus$com_vzome_core_algebra_AlgebraicNumber'](TWO));
                            this.coRoots[2].setComponent(3, A);
                            this.coRoots[1] = field.origin(4);
                            this.coRoots[1].setComponent(1, B2);
                            this.coRoots[1].setComponent(2, TWO);
                            this.coRoots[0] = field.origin(4);
                            this.coRoots[0].setComponent(1, B);
                            this.coRoots[0].setComponent(2, ONE);
                            this.coRoots[0].setComponent(0, A.negate());
                            if (com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().isLoggable(java.util.logging.Level.FINE))
                                for (let i = 0; i < 4; i++) {
                                    {
                                        let buf = new java.lang.StringBuffer();
                                        this.coRoots[i].getVectorExpression$java_lang_StringBuffer$int(buf, com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT);
                                        com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().fine(buf.toString());
                                    }
                                    ;
                                }
                            let origin = field.origin(4);
                            for (let index = 1; index <= 15; index++) {
                                {
                                    let vertex = origin;
                                    for (let b = 0; b < 4; b++) {
                                        {
                                            let mask = 1 << b;
                                            let test = index & mask;
                                            if (test !== 0) {
                                                vertex = vertex.plus(this.coRoots[b]);
                                            }
                                        }
                                        ;
                                    }
                                    this.mPrototypes[index - 1] = vertex;
                                }
                                ;
                            }
                        }
                        getPrototype(index) {
                            return this.mPrototypes[index - 1];
                        }
                        reflect(mirror, prototype) {
                            return this.mMirrors[mirror].reflect(prototype);
                        }
                        getCoRoot(i) {
                            return this.coRoots[i];
                        }
                    }
                    CommandUniformH4Polytope.H4Symmetry = H4Symmetry;
                    H4Symmetry["__class"] = "com.vzome.core.commands.CommandUniformH4Polytope.H4Symmetry";
                    class ConstructionChangesAdapter {
                        constructor(effects, proj, scale) {
                            this.vertices = (new java.util.HashMap());
                            if (this.effects === undefined)
                                this.effects = null;
                            if (this.proj === undefined)
                                this.proj = null;
                            if (this.scale === undefined)
                                this.scale = null;
                            this.edges = (new java.util.HashSet());
                            this.effects = effects;
                            this.proj = proj;
                            this.scale = scale;
                        }
                        /**
                         *
                         * @param {*} v1
                         * @param {*} v2
                         * @return {*}
                         */
                        addEdge(v1, v2) {
                            let p1 = v1;
                            let p2 = v2;
                            let edge = new CommandUniformH4Polytope.Edge(p1.getIndex(), p2.getIndex());
                            if (this.edges.contains(edge))
                                return null;
                            this.edges.add(edge);
                            this.effects.constructionAdded(new com.vzome.core.construction.SegmentJoiningPoints(p1, p2));
                            return edge;
                        }
                        /**
                         *
                         * @param {Array} vertices
                         * @return {*}
                         */
                        addFace(vertices) {
                            return null;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vertex
                         * @return {*}
                         */
                        addVertex(vertex) {
                            let p = this.vertices.get(vertex);
                            if (p == null) {
                                let projected = vertex;
                                com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().finer("before   : ");
                                this.printGoldenVector(projected);
                                if (this.proj != null)
                                    projected = this.proj.projectImage(projected, true);
                                com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().finer("projected: ");
                                this.printGoldenVector(projected);
                                projected = projected.scale(this.scale);
                                com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().finer("scaled   : ");
                                this.printGoldenVector(projected);
                                p = new com.vzome.core.construction.FreePoint(projected);
                                p.setIndex(this.vertices.size());
                                this.effects.constructionAdded(p);
                                this.vertices.put(vertex, p);
                            }
                            return p;
                        }
                        printGoldenVector(gv) {
                            if (com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().isLoggable(java.util.logging.Level.FINER)) {
                                let buf = new java.lang.StringBuffer();
                                gv.getVectorExpression$java_lang_StringBuffer$int(buf, com.vzome.core.algebra.AlgebraicField.DEFAULT_FORMAT);
                                com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$().finer(buf.toString());
                            }
                        }
                    }
                    CommandUniformH4Polytope.ConstructionChangesAdapter = ConstructionChangesAdapter;
                    ConstructionChangesAdapter["__class"] = "com.vzome.core.commands.CommandUniformH4Polytope.ConstructionChangesAdapter";
                    ConstructionChangesAdapter["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];
                    class Edge {
                        constructor(p1, p2) {
                            if (this.p1 === undefined)
                                this.p1 = 0;
                            if (this.p2 === undefined)
                                this.p2 = 0;
                            this.p1 = p1;
                            this.p2 = p2;
                        }
                        /**
                         *
                         * @param {*} obj
                         * @return {boolean}
                         */
                        equals(obj) {
                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(this, obj))
                                return true;
                            if (!(obj != null && obj instanceof com.vzome.core.commands.CommandUniformH4Polytope.Edge))
                                return false;
                            let that = obj;
                            if (this.p1 === that.p1 && this.p2 === that.p2)
                                return true;
                            if (this.p1 === that.p2 && this.p2 === that.p1)
                                return true;
                            return false;
                        }
                        /**
                         *
                         * @return {number}
                         */
                        hashCode() {
                            return this.p1 ^ this.p2;
                        }
                    }
                    CommandUniformH4Polytope.Edge = Edge;
                    Edge["__class"] = "com.vzome.core.commands.CommandUniformH4Polytope.Edge";
                })(CommandUniformH4Polytope = commands.CommandUniformH4Polytope || (commands.CommandUniformH4Polytope = {}));
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} symmetry
                 * @class
                 * @extends com.vzome.core.commands.CommandTransform
                 */
                class CommandSymmetry extends com.vzome.core.commands.CommandTransform {
                    constructor(symmetry) {
                        if (((symmetry != null && (symmetry["__interfaces"] != null && symmetry["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0 || symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null)) {
                            let __args = arguments;
                            super();
                            if (this.mSymmetry === undefined)
                                this.mSymmetry = null;
                            if (this.mSymmetry === undefined)
                                this.mSymmetry = null;
                            (() => {
                                this.mSymmetry = symmetry;
                            })();
                        }
                        else if (symmetry === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let symmetry = null;
                                super();
                                if (this.mSymmetry === undefined)
                                    this.mSymmetry = null;
                                if (this.mSymmetry === undefined)
                                    this.mSymmetry = null;
                                (() => {
                                    this.mSymmetry = symmetry;
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return com.vzome.core.commands.CommandTransform.GROUP_ATTR_SIGNATURE_$LI$();
                    }
                    setSymmetry(attributes) {
                        if (this.mSymmetry == null)
                            this.mSymmetry = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME);
                        else if (!attributes.containsKey(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME))
                            attributes.put(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME, this.mSymmetry);
                        if (this.mSymmetry == null)
                            throw new java.lang.IllegalStateException("null symmetry no longer supported");
                        let center = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME);
                        return center;
                    }
                    /**
                     *
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setFixedAttributes(attributes, format) {
                        if (!attributes.containsKey(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME)) {
                            let icosahedralSymmetry = format.parseSymmetry("icosahedral");
                            attributes.put(com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME, icosahedralSymmetry);
                        }
                        super.setFixedAttributes(attributes, format);
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        let center = this.setSymmetry(attributes);
                        let params = parameters.getConstructions();
                        let output = new com.vzome.core.construction.ConstructionList();
                        for (let index238 = 0; index238 < params.length; index238++) {
                            let param = params[index238];
                            {
                                output.addConstruction(param);
                            }
                        }
                        for (let i = 1; i < this.mSymmetry.getChiralOrder(); i++) {
                            {
                                let transform = new com.vzome.core.construction.SymmetryTransformation(this.mSymmetry, i, center);
                                output.addAll(this.transform(params, transform, effects));
                            }
                            ;
                        }
                        return output;
                    }
                }
                commands.CommandSymmetry = CommandSymmetry;
                CommandSymmetry["__class"] = "com.vzome.core.commands.CommandSymmetry";
                CommandSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} left
                 * @param {com.vzome.core.math.symmetry.QuaternionicSymmetry} right
                 * @class
                 * @extends com.vzome.core.commands.CommandTransform
                 */
                class CommandQuaternionSymmetry extends com.vzome.core.commands.CommandTransform {
                    constructor(left, right) {
                        if (((left != null && left instanceof com.vzome.core.math.symmetry.QuaternionicSymmetry) || left === null) && ((right != null && right instanceof com.vzome.core.math.symmetry.QuaternionicSymmetry) || right === null)) {
                            let __args = arguments;
                            super();
                            if (this.mLeft === undefined)
                                this.mLeft = null;
                            if (this.mRight === undefined)
                                this.mRight = null;
                            if (this.mLeft === undefined)
                                this.mLeft = null;
                            if (this.mRight === undefined)
                                this.mRight = null;
                            (() => {
                                this.mLeft = left;
                                this.mRight = right;
                            })();
                        }
                        else if (left === undefined && right === undefined) {
                            let __args = arguments;
                            super();
                            if (this.mLeft === undefined)
                                this.mLeft = null;
                            if (this.mRight === undefined)
                                this.mRight = null;
                            if (this.mLeft === undefined)
                                this.mLeft = null;
                            if (this.mRight === undefined)
                                this.mRight = null;
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setFixedAttributes(attributes, format) {
                        super.setFixedAttributes(attributes, format);
                        if (!attributes.containsKey(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$())) {
                            this.mLeft = format.getQuaternionicSymmetry("H_4");
                            attributes.put(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$(), this.mLeft);
                        }
                        if (!attributes.containsKey(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME)) {
                            this.mRight = format.getQuaternionicSymmetry("H_4");
                            attributes.put(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME, this.mRight);
                        }
                    }
                    static LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$() { if (CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME == null)
                        CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME = com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME; return CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return com.vzome.core.commands.CommandTransform.GROUP_ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        if (this.mLeft == null)
                            this.mLeft = attributes.get(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$());
                        else if (!attributes.containsKey(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$()))
                            attributes.put(CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$(), this.mLeft);
                        if (this.mRight == null)
                            this.mRight = attributes.get(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME);
                        else if (!attributes.containsKey(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME))
                            attributes.put(CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME, this.mRight);
                        let leftRoots = this.mLeft.getRoots();
                        let rightRoots = this.mRight.getRoots();
                        let params = parameters.getConstructions();
                        let output = new com.vzome.core.construction.ConstructionList();
                        for (let index239 = 0; index239 < params.length; index239++) {
                            let param = params[index239];
                            {
                                output.addConstruction(param);
                            }
                        }
                        for (let index240 = 0; index240 < leftRoots.length; index240++) {
                            let leftRoot = leftRoots[index240];
                            {
                                for (let index241 = 0; index241 < rightRoots.length; index241++) {
                                    let rightRoot = rightRoots[index241];
                                    {
                                        for (let index242 = 0; index242 < params.length; index242++) {
                                            let param = params[index242];
                                            {
                                                let result = null;
                                                if (param != null && param instanceof com.vzome.core.construction.Point) {
                                                    result = new com.vzome.core.construction.PointRotated4D(leftRoot, rightRoot, param);
                                                }
                                                else if (param != null && param instanceof com.vzome.core.construction.Segment) {
                                                    result = new com.vzome.core.construction.SegmentRotated4D(leftRoot, rightRoot, param);
                                                }
                                                else if (param != null && param instanceof com.vzome.core.construction.Polygon) {
                                                    result = new com.vzome.core.construction.PolygonRotated4D(leftRoot, rightRoot, param);
                                                }
                                                else {
                                                }
                                                if (result == null)
                                                    continue;
                                                effects.constructionAdded(result);
                                                output.addConstruction(result);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return output;
                    }
                }
                CommandQuaternionSymmetry.RIGHT_SYMMETRY_GROUP_ATTR_NAME = "right.symmetry.group";
                commands.CommandQuaternionSymmetry = CommandQuaternionSymmetry;
                CommandQuaternionSymmetry["__class"] = "com.vzome.core.commands.CommandQuaternionSymmetry";
                CommandQuaternionSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.CommandTransform
                 */
                class CommandTranslate extends com.vzome.core.commands.CommandTransform {
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        let norm = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                        if (norm == null) {
                            throw new com.vzome.core.commands.Command.Failure("no symmetry axis provided");
                        }
                        let params = parameters.getConstructions();
                        let field = norm.getField();
                        let offset = field.projectTo3d(norm.getOffset(), true);
                        let transform = new com.vzome.core.construction.Translation(offset);
                        return this.transform(params, transform, effects);
                    }
                    constructor() {
                        super();
                    }
                }
                commands.CommandTranslate = CommandTranslate;
                CommandTranslate["__class"] = "com.vzome.core.commands.CommandTranslate";
                CommandTranslate["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.CommandTransform
                 */
                class CommandCentralSymmetry extends com.vzome.core.commands.CommandTransform {
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return com.vzome.core.commands.CommandTransform.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        let output = new com.vzome.core.construction.ConstructionList();
                        let center = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME);
                        let params = parameters.getConstructions();
                        for (let index243 = 0; index243 < params.length; index243++) {
                            let param = params[index243];
                            {
                                output.addConstruction(param);
                            }
                        }
                        let transform = new com.vzome.core.construction.PointReflection(center);
                        effects.constructionAdded(transform);
                        return this.transform(params, transform, effects);
                    }
                    constructor() {
                        super();
                    }
                }
                commands.CommandCentralSymmetry = CommandCentralSymmetry;
                CommandCentralSymmetry["__class"] = "com.vzome.core.commands.CommandCentralSymmetry";
                CommandCentralSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.CommandTransform
                 */
                class CommandMirrorSymmetry extends com.vzome.core.commands.CommandTransform {
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        let center = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME);
                        let norm = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                        if (norm == null) {
                            throw new com.vzome.core.commands.Command.Failure("no symmetry axis provided");
                        }
                        let params = parameters.getConstructions();
                        let mirror = new com.vzome.core.construction.PlaneFromNormalSegment(center, norm);
                        effects.constructionAdded(mirror);
                        let transform = new com.vzome.core.construction.PlaneReflection(mirror);
                        return this.transform(params, transform, effects);
                    }
                    constructor() {
                        super();
                    }
                }
                commands.CommandMirrorSymmetry = CommandMirrorSymmetry;
                CommandMirrorSymmetry["__class"] = "com.vzome.core.commands.CommandMirrorSymmetry";
                CommandMirrorSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ValidateSelection extends com.vzome.core.editor.api.ChangeSelection {
                    /**
                     *
                     */
                    perform() {
                        if (this.mSelection.size() === 0)
                            throw new com.vzome.core.commands.Command.Failure("selection is empty");
                    }
                    constructor(editor) {
                        super(editor.getSelection());
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ValidateSelection";
                    }
                }
                edits.ValidateSelection = ValidateSelection;
                ValidateSelection["__class"] = "com.vzome.core.edits.ValidateSelection";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class InvertSelection extends com.vzome.core.editor.api.ChangeSelection {
                    constructor(editor) {
                        super(editor.getSelection());
                        if (this.mManifestations === undefined)
                            this.mManifestations = null;
                        this.mManifestations = editor.getRealizedModel();
                    }
                    /**
                     *
                     */
                    perform() {
                        for (let index244 = this.mManifestations.iterator(); index244.hasNext();) {
                            let m = index244.next();
                            {
                                if (m.isRendered()) {
                                    if (this.mSelection.manifestationSelected(m))
                                        this.unselect$com_vzome_core_model_Manifestation(m);
                                    else
                                        this.select$com_vzome_core_model_Manifestation(m);
                                }
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "InvertSelection";
                    }
                }
                edits.InvertSelection = InvertSelection;
                InvertSelection["__class"] = "com.vzome.core.edits.InvertSelection";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * Used by CommandEdit.
                 * @param {*} editor
                 * @param {*} m
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeSelection
                 */
                class SelectManifestation extends com.vzome.core.editor.api.ChangeSelection {
                    constructor(editor, m) {
                        if (((editor != null && (editor["__interfaces"] != null && editor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0 || editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && ((m != null && (m["__interfaces"] != null && m["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || m === null)) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                super(editor.getSelection());
                                if (this.mManifestation === undefined)
                                    this.mManifestation = null;
                                if (this.construction === undefined)
                                    this.construction = null;
                                if (this.mRealized === undefined)
                                    this.mRealized = null;
                                if (this.mReplace === undefined)
                                    this.mReplace = false;
                                if (this.mManifestation === undefined)
                                    this.mManifestation = null;
                                if (this.construction === undefined)
                                    this.construction = null;
                                if (this.mRealized === undefined)
                                    this.mRealized = null;
                                if (this.mReplace === undefined)
                                    this.mReplace = false;
                                (() => {
                                    this.mRealized = editor.getRealizedModel();
                                })();
                            }
                            (() => {
                                this.mManifestation = m;
                                if (this.mManifestation != null) {
                                    this.construction = this.mManifestation.toConstruction();
                                }
                            })();
                        }
                        else if (((editor != null && (editor["__interfaces"] != null && editor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0 || editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && m === undefined) {
                            let __args = arguments;
                            super(editor.getSelection());
                            if (this.mManifestation === undefined)
                                this.mManifestation = null;
                            if (this.construction === undefined)
                                this.construction = null;
                            if (this.mRealized === undefined)
                                this.mRealized = null;
                            if (this.mReplace === undefined)
                                this.mReplace = false;
                            if (this.mManifestation === undefined)
                                this.mManifestation = null;
                            if (this.construction === undefined)
                                this.construction = null;
                            if (this.mRealized === undefined)
                                this.mRealized = null;
                            if (this.mReplace === undefined)
                                this.mReplace = false;
                            (() => {
                                this.mRealized = editor.getRealizedModel();
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    configure(props) {
                        let mode = props.get("mode");
                        this.mReplace = /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("replace", mode);
                        this.mManifestation = props.get("picked");
                        if (this.mManifestation != null) {
                            this.construction = this.mManifestation.toConstruction();
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.mReplace) {
                            for (let index245 = this.mSelection.iterator(); index245.hasNext();) {
                                let man = index245.next();
                                {
                                    this.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                                }
                            }
                            this.select$com_vzome_core_model_Manifestation(this.mManifestation);
                        }
                        else if (this.mSelection.manifestationSelected(this.mManifestation))
                            this.unselect$com_vzome_core_model_Manifestation(this.mManifestation);
                        else
                            this.select$com_vzome_core_model_Manifestation(this.mManifestation);
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} result
                     */
                    getXmlAttributes(result) {
                        if (this.construction != null && this.construction instanceof com.vzome.core.construction.Point)
                            com.vzome.core.commands.XmlSaveFormat.serializePoint(result, "point", this.construction);
                        else if (this.construction != null && this.construction instanceof com.vzome.core.construction.Segment)
                            com.vzome.core.commands.XmlSaveFormat.serializeSegment(result, "startSegment", "endSegment", this.construction);
                        else if (this.construction != null && this.construction instanceof com.vzome.core.construction.Polygon)
                            com.vzome.core.commands.XmlSaveFormat.serializePolygon(result, "polygonVertex", this.construction);
                        if (this.mReplace)
                            com.vzome.xml.DomUtils.addAttribute(result, "replace", "true");
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        if (format.rationalVectors()) {
                            this.construction = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "point");
                            if (this.construction == null)
                                this.construction = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "startSegment", "endSegment");
                            if (this.construction == null) {
                                let kid = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element$java_lang_String(xml, "polygon");
                                if (kid != null)
                                    this.construction = format.parsePolygon$org_w3c_dom_Element$java_lang_String(kid, "vertex");
                                else
                                    this.construction = format.parsePolygon$org_w3c_dom_Element$java_lang_String(xml, "polygonVertex");
                            }
                        }
                        else {
                            let attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                            this.construction = attrs.get("manifestation");
                            let replaceVal = attrs.get("replace");
                            if (replaceVal != null && replaceVal)
                                this.mReplace = true;
                        }
                        this.mManifestation = this.mRealized.getManifestation(this.construction);
                        if (this.mManifestation == null && format.rationalVectors() && (this.construction != null && this.construction instanceof com.vzome.core.construction.Polygon)) {
                            this.construction = format.parsePolygonReversed(xml, "polygonVertex");
                            this.mManifestation = this.mRealized.getManifestation(this.construction);
                            if (this.mManifestation != null)
                                SideEffects.logBugAccommodation("reverse-oriented polygon");
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SelectManifestation";
                    }
                }
                edits.SelectManifestation = SelectManifestation;
                SelectManifestation["__class"] = "com.vzome.core.edits.SelectManifestation";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * This class is designed to be a generalized replacement for the legacy DeselectByClass
                 * It allows balls, struts and/or panels to be selected, deselected or ignored by class
                 * It can be used in place of DeselectByClass including the ability to parse the legacy XML.
                 * DeselectByClass has been renamed as AdjustSelectionByClass and modified with the additional functionality.
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeSelection
                 */
                class AdjustSelectionByClass extends com.vzome.core.editor.api.ChangeSelection {
                    constructor(editor) {
                        super(editor.getSelection());
                        this.ballAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                        this.strutAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                        this.panelAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                        if (this.editor === undefined)
                            this.editor = null;
                        this.editor = editor;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        let mode = props.get("mode");
                        if (mode != null)
                            switch ((mode)) {
                                case "selectBalls":
                                    this.ballAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                                    break;
                                case "selectStruts":
                                    this.strutAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                                    break;
                                case "selectPanels":
                                    this.panelAction = com.vzome.core.editor.api.ActionEnum.SELECT;
                                    break;
                                case "deselectBalls":
                                case "unselectBalls":
                                    this.ballAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                    break;
                                case "deselectStruts":
                                    this.strutAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                    break;
                                case "deselectPanels":
                                    this.panelAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                    break;
                                case "unselectStruts":
                                case "unselectStrutsAndPanels":
                                    this.strutAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                    this.panelAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                    break;
                            }
                    }
                    /**
                     *
                     */
                    perform() {
                        let whichManifestationSet = (this.ballAction === com.vzome.core.editor.api.ActionEnum.SELECT || this.strutAction === com.vzome.core.editor.api.ActionEnum.SELECT || this.panelAction === com.vzome.core.editor.api.ActionEnum.SELECT) ? this.editor.getRealizedModel() : this.mSelection;
                        for (let index246 = whichManifestationSet.iterator(); index246.hasNext();) {
                            let man = index246.next();
                            {
                                if (man.isRendered()) {
                                    if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        this.adjustSelection(man, this.ballAction);
                                    }
                                    else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                        this.adjustSelection(man, this.strutAction);
                                    }
                                    else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                        this.adjustSelection(man, this.panelAction);
                                    }
                                }
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("balls", com.vzome.core.editor.api.ActionEnum["_$wrappers"][this.ballAction].toString());
                        element.setAttribute("struts", com.vzome.core.editor.api.ActionEnum["_$wrappers"][this.strutAction].toString());
                        element.setAttribute("panels", com.vzome.core.editor.api.ActionEnum["_$wrappers"][this.panelAction].toString());
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(xml.getLocalName(), "DeselectByClass")) {
                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(xml.getAttribute("class"), "balls")) {
                                this.ballAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                this.strutAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                                this.panelAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                            }
                            else {
                                this.ballAction = com.vzome.core.editor.api.ActionEnum.IGNORE;
                                this.strutAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                                this.panelAction = com.vzome.core.editor.api.ActionEnum.DESELECT;
                            }
                        }
                        else {
                            this.ballAction = /* Enum.valueOf */ com.vzome.core.editor.api.ActionEnum[xml.getAttribute("balls")];
                            this.strutAction = /* Enum.valueOf */ com.vzome.core.editor.api.ActionEnum[xml.getAttribute("struts")];
                            this.panelAction = /* Enum.valueOf */ com.vzome.core.editor.api.ActionEnum[xml.getAttribute("panels")];
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "AdjustSelectionByClass";
                    }
                }
                edits.AdjustSelectionByClass = AdjustSelectionByClass;
                AdjustSelectionByClass["__class"] = "com.vzome.core.edits.AdjustSelectionByClass";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectAll extends com.vzome.core.editor.api.ChangeSelection {
                    constructor(editor) {
                        super(editor.getSelection());
                        for (let index247 = editor.getRealizedModel().iterator(); index247.hasNext();) {
                            let m = index247.next();
                            {
                                if (m.isRendered()) {
                                    if (!this.mSelection.manifestationSelected(m))
                                        this.select$com_vzome_core_model_Manifestation$boolean(m, true);
                                }
                            }
                        }
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SelectAll";
                    }
                }
                edits.SelectAll = SelectAll;
                SelectAll["__class"] = "com.vzome.core.edits.SelectAll";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectNeighbors extends com.vzome.core.editor.api.ChangeSelection {
                    constructor(editor) {
                        super(editor.getSelection());
                        if (this.editor === undefined)
                            this.editor = null;
                        this.withPanels = false;
                        this.editor = editor;
                    }
                    perform() {
                        let model = this.editor.getRealizedModel();
                        let panels = (new java.util.HashSet());
                        let struts = (new java.util.HashSet());
                        let balls = (new java.util.HashSet());
                        for (let index248 = this.mSelection.iterator(); index248.hasNext();) {
                            let man = index248.next();
                            {
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))
                                    struts.add(man);
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))
                                    balls.add(man);
                                else if (this.withPanels && (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)))
                                    panels.add(man);
                            }
                        }
                        for (let index249 = balls.iterator(); index249.hasNext();) {
                            let ball = index249.next();
                            {
                                let loc = ball.getLocation();
                                for (let index250 = model.iterator(); index250.hasNext();) {
                                    let man = index250.next();
                                    {
                                        if (!man.isRendered())
                                            continue;
                                        if ((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) && !struts.contains(man)) {
                                            let strut = man;
                                            if (loc.equals(strut.getLocation()) || loc.equals(strut.getEnd()))
                                                this.select$com_vzome_core_model_Manifestation(strut);
                                        }
                                        else if (this.withPanels && (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) && !panels.contains(man)) {
                                            let panel = man;
                                            for (let index251 = panel.iterator(); index251.hasNext();) {
                                                let vertex = index251.next();
                                                {
                                                    if (loc.equals(vertex)) {
                                                        this.select$com_vzome_core_model_Manifestation(panel);
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        for (let index252 = struts.iterator(); index252.hasNext();) {
                            let strut = index252.next();
                            {
                                let loc = strut.getLocation();
                                let end = strut.getEnd();
                                for (let index253 = model.iterator(); index253.hasNext();) {
                                    let man = index253.next();
                                    {
                                        if (!man.isRendered())
                                            continue;
                                        if ((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) && !balls.contains(man)) {
                                            let bloc = man.getLocation();
                                            if (bloc.equals(loc) || bloc.equals(end))
                                                this.select$com_vzome_core_model_Manifestation(man);
                                        }
                                    }
                                }
                            }
                        }
                        if (this.withPanels) {
                            for (let index254 = panels.iterator(); index254.hasNext();) {
                                let panel = index254.next();
                                {
                                    for (let index255 = panel.iterator(); index255.hasNext();) {
                                        let loc = index255.next();
                                        {
                                            for (let index256 = model.iterator(); index256.hasNext();) {
                                                let man = index256.next();
                                                {
                                                    if (man.isRendered()) {
                                                        if ((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) && !balls.contains(man)) {
                                                            let bloc = man.getLocation();
                                                            if (bloc.equals(loc)) {
                                                                this.select$com_vzome_core_model_Manifestation(man);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        super.perform();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SelectNeighbors";
                    }
                }
                edits.SelectNeighbors = SelectNeighbors;
                SelectNeighbors["__class"] = "com.vzome.core.edits.SelectNeighbors";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class DeselectAll extends com.vzome.core.editor.api.ChangeSelection {
                    constructor(editor) {
                        super(editor.getSelection());
                        for (let index257 = this.mSelection.iterator(); index257.hasNext();) {
                            let man = index257.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                            }
                        }
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "DeselectAll";
                    }
                }
                edits.DeselectAll = DeselectAll;
                DeselectAll["__class"] = "com.vzome.core.edits.DeselectAll";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                var api;
                (function (api) {
                    class ChangeManifestations extends com.vzome.core.editor.api.ChangeSelection {
                        constructor(editorModel) {
                            super(editorModel.getSelection());
                            if (this.mManifestations === undefined)
                                this.mManifestations = null;
                            this.mManifestations = editorModel.getRealizedModel();
                            this.mManifestations.clearPerEditManifestations();
                        }
                        /**
                         *
                         */
                        redo() {
                            this.mManifestations.clearPerEditManifestations();
                            super.redo();
                        }
                        /**
                         *
                         */
                        undo() {
                            this.mManifestations.clearPerEditManifestations();
                            super.undo();
                        }
                        getManifestation(c) {
                            return this.mManifestations.getManifestation(c);
                        }
                        manifestConstruction(c) {
                            let m = this.mManifestations.findConstruction(c);
                            if (m == null)
                                return null;
                            let made = this.mManifestations.findPerEditManifestation(m);
                            if (made != null)
                                return made;
                            if (m.isUnnecessary()) {
                                this.mManifestations.addPerEditManifestation(m);
                                this.plan(new ChangeManifestations.ManifestConstruction(this, c, m, true));
                            }
                            else {
                                if (!m.isRendered())
                                    this.plan(new ChangeManifestations.RenderManifestation(this, m, true));
                            }
                            return m;
                        }
                        unmanifestConstruction(c) {
                            let m = this.mManifestations.removeConstruction(c);
                            if (m == null)
                                return null;
                            this.plan(new ChangeManifestations.ManifestConstruction(this, c, m, false));
                            return m;
                        }
                        deleteManifestation(man) {
                            this.plan(new ChangeManifestations.DeleteManifestation(this, man));
                        }
                        showManifestation(m) {
                            this.plan(new ChangeManifestations.RenderManifestation(this, m, true));
                        }
                        hideManifestation(m) {
                            this.plan(new ChangeManifestations.RenderManifestation(this, m, false));
                        }
                        colorManifestation(m, color) {
                            this.plan(new ChangeManifestations.ColorManifestation(this, m, color));
                        }
                        hideConnectors() {
                            for (let index258 = com.vzome.core.editor.api.Manifestations.getVisibleConnectors(this.mManifestations).iterator(); index258.hasNext();) {
                                let connector = index258.next();
                                this.hideManifestation(connector);
                            }
                        }
                        showConnectors() {
                            for (let index259 = com.vzome.core.editor.api.Manifestations.getHiddenConnectors(this.mManifestations).iterator(); index259.hasNext();) {
                                let connector = index259.next();
                                this.showManifestation(connector);
                            }
                        }
                        hideStruts() {
                            for (let index260 = com.vzome.core.editor.api.Manifestations.getVisibleStruts(this.mManifestations).iterator(); index260.hasNext();) {
                                let strut = index260.next();
                                this.hideManifestation(strut);
                            }
                        }
                        showStruts() {
                            for (let index261 = com.vzome.core.editor.api.Manifestations.getHiddenStruts(this.mManifestations).iterator(); index261.hasNext();) {
                                let strut = index261.next();
                                this.showManifestation(strut);
                            }
                        }
                        hidePanels() {
                            for (let index262 = com.vzome.core.editor.api.Manifestations.getVisiblePanels(this.mManifestations).iterator(); index262.hasNext();) {
                                let panel = index262.next();
                                this.hideManifestation(panel);
                            }
                        }
                        showPanels() {
                            for (let index263 = com.vzome.core.editor.api.Manifestations.getHiddenPanels(this.mManifestations).iterator(); index263.hasNext();) {
                                let panel = index263.next();
                                this.showManifestation(panel);
                            }
                        }
                        showsManifestation(man) {
                            for (let iterator = this.getEffects(); iterator.hasNext();) {
                                {
                                    let effect = iterator.next();
                                    if (effect != null && effect instanceof com.vzome.core.editor.api.ChangeManifestations.ManifestConstruction) {
                                        let show = effect;
                                        if (show.showsManifestation(man))
                                            return true;
                                    }
                                    else if (effect != null && effect instanceof com.vzome.core.editor.api.ChangeManifestations.RenderManifestation) {
                                        let show = effect;
                                        if (show.showsManifestation(man))
                                            return true;
                                    }
                                }
                                ;
                            }
                            return false;
                        }
                        getRenderedSelection() {
                            return com.vzome.core.editor.api.Manifestations.visibleManifestations$java_lang_Iterable$java_util_function_Predicate(this.mSelection, (man) => { return com.vzome.core.editor.api.Manifestations.Filters.isRendered(man); });
                        }
                        getConnectors() {
                            return com.vzome.core.editor.api.Manifestations.getConnectors$java_lang_Iterable(this.mManifestations);
                        }
                        getStruts() {
                            return com.vzome.core.editor.api.Manifestations.getStruts$java_lang_Iterable(this.mManifestations);
                        }
                        getPanels() {
                            return com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.mManifestations);
                        }
                        getVisibleConnectors$() {
                            return com.vzome.core.editor.api.Manifestations.getVisibleConnectors(this.mManifestations);
                        }
                        getVisibleStruts$() {
                            return com.vzome.core.editor.api.Manifestations.getVisibleStruts(this.mManifestations);
                        }
                        getVisiblePanels$() {
                            return com.vzome.core.editor.api.Manifestations.getVisiblePanels(this.mManifestations);
                        }
                        getVisibleConnectors$java_util_function_Predicate(postFilter) {
                            return com.vzome.core.editor.api.Manifestations.getVisibleConnectors(this.mManifestations, (postFilter));
                        }
                        getVisibleConnectors(postFilter) {
                            if (((typeof postFilter === 'function' && postFilter.length == 1) || postFilter === null)) {
                                return this.getVisibleConnectors$java_util_function_Predicate(postFilter);
                            }
                            else if (postFilter === undefined) {
                                return this.getVisibleConnectors$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        getVisibleStruts$java_util_function_Predicate(postFilter) {
                            return com.vzome.core.editor.api.Manifestations.getVisibleStruts(this.mManifestations, (postFilter));
                        }
                        getVisibleStruts(postFilter) {
                            if (((typeof postFilter === 'function' && postFilter.length == 1) || postFilter === null)) {
                                return this.getVisibleStruts$java_util_function_Predicate(postFilter);
                            }
                            else if (postFilter === undefined) {
                                return this.getVisibleStruts$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                        getVisiblePanels$java_util_function_Predicate(postFilter) {
                            return com.vzome.core.editor.api.Manifestations.getVisiblePanels(this.mManifestations, (postFilter));
                        }
                        getVisiblePanels(postFilter) {
                            if (((typeof postFilter === 'function' && postFilter.length == 1) || postFilter === null)) {
                                return this.getVisiblePanels$java_util_function_Predicate(postFilter);
                            }
                            else if (postFilter === undefined) {
                                return this.getVisiblePanels$();
                            }
                            else
                                throw new Error('invalid overload');
                        }
                    }
                    api.ChangeManifestations = ChangeManifestations;
                    ChangeManifestations["__class"] = "com.vzome.core.editor.api.ChangeManifestations";
                    (function (ChangeManifestations) {
                        class ManifestConstruction {
                            constructor(__parent, construction, manifestation, showing) {
                                this.__parent = __parent;
                                if (this.mManifestation === undefined)
                                    this.mManifestation = null;
                                if (this.mConstruction === undefined)
                                    this.mConstruction = null;
                                if (this.mShowing === undefined)
                                    this.mShowing = false;
                                this.mConstruction = construction;
                                this.mManifestation = manifestation;
                                this.mShowing = showing;
                            }
                            /**
                             *
                             */
                            redo() {
                                if (this.mShowing) {
                                    if (this.mManifestation.isUnnecessary())
                                        this.__parent.mManifestations.add(this.mManifestation);
                                    this.__parent.mManifestations.show(this.mManifestation);
                                    this.mManifestation.addConstruction(this.mConstruction);
                                }
                                else {
                                    this.mManifestation.removeConstruction(this.mConstruction);
                                    if (this.mManifestation.isUnnecessary()) {
                                        this.__parent.mManifestations.hide(this.mManifestation);
                                        this.__parent.mManifestations.remove(this.mManifestation);
                                    }
                                }
                            }
                            /**
                             *
                             */
                            undo() {
                                if (this.mShowing) {
                                    this.mManifestation.removeConstruction(this.mConstruction);
                                    if (this.mManifestation.isUnnecessary()) {
                                        this.__parent.mManifestations.hide(this.mManifestation);
                                        this.__parent.mManifestations.remove(this.mManifestation);
                                    }
                                }
                                else {
                                    if (this.mManifestation.isUnnecessary())
                                        this.__parent.mManifestations.add(this.mManifestation);
                                    this.__parent.mManifestations.show(this.mManifestation);
                                    this.mManifestation.addConstruction(this.mConstruction);
                                }
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                let result = this.mShowing ? doc.createElement("mshow") : doc.createElement("mhide");
                                let man = this.mConstruction.getXml(doc);
                                result.appendChild(man);
                                return result;
                            }
                            showsManifestation(man) {
                                return this.mShowing && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(this.mManifestation, man);
                            }
                        }
                        ChangeManifestations.ManifestConstruction = ManifestConstruction;
                        ManifestConstruction["__class"] = "com.vzome.core.editor.api.ChangeManifestations.ManifestConstruction";
                        ManifestConstruction["__interfaces"] = ["com.vzome.core.editor.api.SideEffects.SideEffect"];
                        class RenderManifestation {
                            constructor(__parent, manifestation, showing) {
                                this.__parent = __parent;
                                if (this.mManifestation === undefined)
                                    this.mManifestation = null;
                                if (this.mShowing === undefined)
                                    this.mShowing = false;
                                this.mManifestation = manifestation;
                                this.mShowing = showing;
                            }
                            /**
                             *
                             */
                            redo() {
                                this.mManifestation.setHidden(!this.mShowing);
                                if (this.mShowing)
                                    this.__parent.mManifestations.show(this.mManifestation);
                                else
                                    this.__parent.mManifestations.hide(this.mManifestation);
                            }
                            /**
                             *
                             */
                            undo() {
                                this.mManifestation.setHidden(this.mShowing);
                                if (this.mShowing)
                                    this.__parent.mManifestations.hide(this.mManifestation);
                                else
                                    this.__parent.mManifestations.show(this.mManifestation);
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                let result = this.mShowing ? doc.createElement("show") : doc.createElement("hide");
                                let man = this.mManifestation.getXml(doc);
                                result.appendChild(man);
                                return result;
                            }
                            showsManifestation(man) {
                                return this.mShowing && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(this.mManifestation, man);
                            }
                        }
                        ChangeManifestations.RenderManifestation = RenderManifestation;
                        RenderManifestation["__class"] = "com.vzome.core.editor.api.ChangeManifestations.RenderManifestation";
                        RenderManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffects.SideEffect"];
                        class DeleteManifestation {
                            constructor(__parent, manifestation) {
                                this.__parent = __parent;
                                if (this.mManifestation === undefined)
                                    this.mManifestation = null;
                                this.mManifestation = manifestation;
                            }
                            /**
                             *
                             */
                            redo() {
                                this.mManifestation.setHidden(true);
                                this.__parent.mManifestations.hide(this.mManifestation);
                                this.__parent.mManifestations.remove(this.mManifestation);
                            }
                            /**
                             *
                             */
                            undo() {
                                this.__parent.mManifestations.add(this.mManifestation);
                                this.__parent.mManifestations.show(this.mManifestation);
                                this.mManifestation.setHidden(false);
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                let result = doc.createElement("delete");
                                let man = this.mManifestation.getXml(doc);
                                result.appendChild(man);
                                return result;
                            }
                        }
                        ChangeManifestations.DeleteManifestation = DeleteManifestation;
                        DeleteManifestation["__class"] = "com.vzome.core.editor.api.ChangeManifestations.DeleteManifestation";
                        DeleteManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffects.SideEffect"];
                        class ColorManifestation {
                            constructor(__parent, manifestation, color) {
                                this.__parent = __parent;
                                if (this.mManifestation === undefined)
                                    this.mManifestation = null;
                                if (this.oldColor === undefined)
                                    this.oldColor = null;
                                if (this.newColor === undefined)
                                    this.newColor = null;
                                this.mManifestation = manifestation;
                                this.newColor = color;
                                this.oldColor = manifestation.getColor();
                            }
                            /**
                             *
                             */
                            redo() {
                                this.__parent.mManifestations.setColor(this.mManifestation, this.newColor);
                            }
                            /**
                             *
                             */
                            undo() {
                                this.__parent.mManifestations.setColor(this.mManifestation, this.oldColor);
                            }
                            /**
                             *
                             * @param {*} doc
                             * @return {*}
                             */
                            getXml(doc) {
                                let result = doc.createElement("color");
                                com.vzome.xml.DomUtils.addAttribute(result, "rgb", this.newColor.toString());
                                let man = this.mManifestation.getXml(doc);
                                result.appendChild(man);
                                return result;
                            }
                        }
                        ChangeManifestations.ColorManifestation = ColorManifestation;
                        ColorManifestation["__class"] = "com.vzome.core.editor.api.ChangeManifestations.ColorManifestation";
                        ColorManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffects.SideEffect"];
                    })(ChangeManifestations = api.ChangeManifestations || (api.ChangeManifestations = {}));
                })(api = editor.api || (editor.api = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} symmetry
                 * @class
                 * @extends com.vzome.core.commands.CommandSymmetry
                 */
                class CommandTetrahedralSymmetry extends com.vzome.core.commands.CommandSymmetry {
                    constructor(symmetry = null) {
                        super(symmetry);
                    }
                    static ATTR_SIGNATURE_$LI$() { if (CommandTetrahedralSymmetry.ATTR_SIGNATURE == null)
                        CommandTetrahedralSymmetry.ATTR_SIGNATURE = [[com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME, com.vzome.core.construction.Point], [com.vzome.core.commands.CommandTransform.SYMMETRY_GROUP_ATTR_NAME, "com.vzome.core.math.symmetry.Symmetry"], [CommandTetrahedralSymmetry.SUBGROUP_ATTR_NAME, [].constructor]]; return CommandTetrahedralSymmetry.ATTR_SIGNATURE; }
                    ;
                    /**
                     *
                     * @return {Array}
                     */
                    getAttributeSignature() {
                        return CommandTetrahedralSymmetry.ATTR_SIGNATURE_$LI$();
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        let center = this.setSymmetry(attributes);
                        let closure = this.mSymmetry.subgroup(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL);
                        let params = parameters.getConstructions();
                        let output = new com.vzome.core.construction.ConstructionList();
                        for (let index264 = 0; index264 < params.length; index264++) {
                            let param = params[index264];
                            {
                                output.addConstruction(param);
                            }
                        }
                        for (let i = 1; i < closure.length; i++) {
                            {
                                let transform = new com.vzome.core.construction.SymmetryTransformation(this.mSymmetry, closure[i], center);
                                output.addAll(this.transform(params, transform, effects));
                            }
                            ;
                        }
                        return output;
                    }
                }
                CommandTetrahedralSymmetry.SUBGROUP_ATTR_NAME = "symmetry.permutations";
                commands.CommandTetrahedralSymmetry = CommandTetrahedralSymmetry;
                CommandTetrahedralSymmetry["__class"] = "com.vzome.core.commands.CommandTetrahedralSymmetry";
                CommandTetrahedralSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @class
                 * @extends com.vzome.core.commands.CommandSymmetry
                 */
                class CommandRotate extends com.vzome.core.commands.CommandSymmetry {
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        let center = this.setSymmetry(attributes);
                        let norm = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                        if (norm == null) {
                            throw new com.vzome.core.commands.Command.Failure("no symmetry axis provided");
                        }
                        let params = parameters.getConstructions();
                        let output = new com.vzome.core.construction.ConstructionList();
                        let vector = norm.getOffset();
                        vector = norm.getField().projectTo3d(vector, true);
                        let axis = this.mSymmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
                        let rotation = axis.getRotation();
                        let transform = new com.vzome.core.construction.SymmetryTransformation(this.mSymmetry, rotation, center);
                        effects.constructionAdded(transform);
                        output.addAll(this.transform(params, transform, effects));
                        return output;
                    }
                    constructor() {
                        super();
                    }
                }
                commands.CommandRotate = CommandRotate;
                CommandRotate["__class"] = "com.vzome.core.commands.CommandRotate";
                CommandRotate["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var commands;
            (function (commands) {
                /**
                 * @author Scott Vorthmann
                 * @param {*} symmetry
                 * @class
                 * @extends com.vzome.core.commands.CommandSymmetry
                 */
                class CommandAxialSymmetry extends com.vzome.core.commands.CommandSymmetry {
                    constructor(symmetry = null) {
                        super(symmetry);
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.ConstructionList} parameters
                     * @param {com.vzome.core.commands.AttributeMap} attributes
                     * @param {*} effects
                     * @return {com.vzome.core.construction.ConstructionList}
                     */
                    apply(parameters, attributes, effects) {
                        this.setSymmetry(attributes);
                        let norm = attributes.get(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME);
                        if (norm == null) {
                            throw new com.vzome.core.commands.Command.Failure("no symmetry axis provided");
                        }
                        let output = new com.vzome.core.construction.ConstructionList();
                        let vector = norm.getOffset();
                        vector = norm.getField().projectTo3d(vector, true);
                        let axis = this.mSymmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
                        let rotation = axis.getRotationPermutation();
                        if (rotation == null) {
                            throw new com.vzome.core.commands.Command.Failure("symmetry axis does not support axial symmetry");
                        }
                        let order = rotation.getOrder();
                        let rotate = new com.vzome.core.commands.CommandRotate();
                        for (let i = 1; i < order; i++) {
                            {
                                for (let index265 = parameters.iterator(); index265.hasNext();) {
                                    let param = index265.next();
                                    {
                                        output.addConstruction(param);
                                    }
                                }
                                parameters = rotate.apply(parameters, attributes, effects);
                            }
                            ;
                        }
                        for (let index266 = parameters.iterator(); index266.hasNext();) {
                            let param = index266.next();
                            {
                                output.addConstruction(param);
                            }
                        }
                        return output;
                    }
                }
                commands.CommandAxialSymmetry = CommandAxialSymmetry;
                CommandAxialSymmetry["__class"] = "com.vzome.core.commands.CommandAxialSymmetry";
                CommandAxialSymmetry["__interfaces"] = ["com.vzome.core.commands.Command"];
            })(commands = core.commands || (core.commands = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class PanelPanelIntersection extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        let panel0 = null;
                        let panel1 = null;
                        let nPanels = 0;
                        for (let index267 = this.mSelection.iterator(); index267.hasNext();) {
                            let man = index267.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    switch ((nPanels++)) {
                                        case 0:
                                            panel0 = man;
                                            break;
                                        case 1:
                                            panel1 = man;
                                            break;
                                        default:
                                            break;
                                    }
                                }
                            }
                        }
                        if (nPanels !== 2) {
                            let msg;
                            switch ((nPanels)) {
                                case 0:
                                    msg = "No panels are selected.";
                                    break;
                                case 1:
                                    msg = "One panel is selected.";
                                    break;
                                default:
                                    msg = nPanels + " panels are selected.";
                                    break;
                            }
                            this.fail(msg + " Two are required.");
                        }
                        if (com.vzome.core.algebra.AlgebraicVectors.areParallel(panel0['getNormal$'](), panel1['getNormal$']())) {
                            let vertices = (new java.util.ArrayList());
                            {
                                let array269 = [panel0, panel1];
                                for (let index268 = 0; index268 < array269.length; index268++) {
                                    let panel = array269[index268];
                                    {
                                        for (let index270 = panel.iterator(); index270.hasNext();) {
                                            let v = index270.next();
                                            {
                                                vertices.add(v);
                                            }
                                        }
                                    }
                                }
                            }
                            this.fail("Panels are " + (com.vzome.core.algebra.AlgebraicVectors.areCoplanar(vertices) ? "coplanar" : "parallel") + ".");
                        }
                        this.redo();
                        let segment = new com.vzome.core.construction.PolygonPolygonProjectionToSegment(PanelPanelIntersection.polygonFromPanel(panel0), PanelPanelIntersection.polygonFromPanel(panel1));
                        let start = new com.vzome.core.construction.FreePoint(segment.getStart());
                        let end = new com.vzome.core.construction.FreePoint(segment.getEnd());
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(start));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(end));
                        this.redo();
                    }
                    /*private*/ static polygonFromPanel(panel) {
                        let vertices = (new java.util.ArrayList(panel.getVertexCount()));
                        for (let index271 = panel.iterator(); index271.hasNext();) {
                            let vector = index271.next();
                            {
                                vertices.add(new com.vzome.core.construction.FreePoint(vector));
                            }
                        }
                        return new com.vzome.core.construction.PolygonFromVertices(vertices);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return /* getSimpleName */ (c => c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))(this.constructor);
                    }
                }
                edits.PanelPanelIntersection = PanelPanelIntersection;
                PanelPanelIntersection["__class"] = "com.vzome.core.edits.PanelPanelIntersection";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class JoinPoints extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        this.joinMode = JoinPoints.JoinModeEnum.CLOSED_LOOP;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        let mode = props.get("mode");
                        if (mode != null)
                            this.joinMode = /* Enum.valueOf */ JoinPoints.JoinModeEnum[mode];
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.joinMode === JoinPoints.JoinModeEnum.CLOSED_LOOP) {
                        }
                        else {
                            element.setAttribute(JoinPoints.ATTRNAME_CLOSEDLOOP, "false");
                            if (this.joinMode !== JoinPoints.JoinModeEnum.CHAIN_BALLS)
                                element.setAttribute(JoinPoints.ATTRNAME_JOINMODE, /* Enum.name */ com.vzome.core.edits.JoinPoints.JoinModeEnum[this.joinMode]);
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        let attr = xml.getAttribute(JoinPoints.ATTRNAME_JOINMODE);
                        if (attr != null && !(attr.length === 0)) {
                            this.joinMode = /* Enum.valueOf */ JoinPoints.JoinModeEnum[attr];
                        }
                        else {
                            attr = xml.getAttribute(JoinPoints.ATTRNAME_CLOSEDLOOP);
                            if (attr != null && !(attr.length === 0)) {
                                this.joinMode = javaemul.internal.BooleanHelper.parseBoolean(attr) ? JoinPoints.JoinModeEnum.CLOSED_LOOP : JoinPoints.JoinModeEnum.CHAIN_BALLS;
                            }
                            else {
                                this.joinMode = JoinPoints.JoinModeEnum.CLOSED_LOOP;
                            }
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        let inputs = (new java.util.ArrayList());
                        if (this.joinMode !== JoinPoints.JoinModeEnum.ALL_POSSIBLE)
                            this.setOrderedSelection(true);
                        for (let index272 = this.mSelection.iterator(); index272.hasNext();) {
                            let man = index272.next();
                            {
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    inputs.add(man.getFirstConstruction());
                                }
                                this.unselect$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        this.redo();
                        let last = inputs.size() - 1;
                        if (last > 0) {
                            let points = inputs.toArray([]);
                            switch ((this.joinMode)) {
                                case com.vzome.core.edits.JoinPoints.JoinModeEnum.CHAIN_BALLS:
                                    for (let i = 0; i < last; i++) {
                                        {
                                            this.addSegment(points, i, i + 1);
                                        }
                                        ;
                                    }
                                    break;
                                case com.vzome.core.edits.JoinPoints.JoinModeEnum.CLOSED_LOOP:
                                    for (let i = 0; i < last; i++) {
                                        {
                                            this.addSegment(points, i, i + 1);
                                        }
                                        ;
                                    }
                                    if (last > 1) {
                                        this.addSegment(points, last, 0);
                                    }
                                    break;
                                case com.vzome.core.edits.JoinPoints.JoinModeEnum.ALL_TO_FIRST:
                                    for (let i = 1; i <= last; i++) {
                                        {
                                            this.addSegment(points, 0, i);
                                        }
                                        ;
                                    }
                                    break;
                                case com.vzome.core.edits.JoinPoints.JoinModeEnum.ALL_TO_LAST:
                                    for (let i = 0; i < last; i++) {
                                        {
                                            this.addSegment(points, i, last);
                                        }
                                        ;
                                    }
                                    break;
                                case com.vzome.core.edits.JoinPoints.JoinModeEnum.ALL_POSSIBLE:
                                    for (let start = 0; start < last; start++) {
                                        {
                                            for (let end = start + 1; end <= last; end++) {
                                                {
                                                    this.addSegment(points, start, end);
                                                }
                                                ;
                                            }
                                        }
                                        ;
                                    }
                                    break;
                                default:
                                    throw new com.vzome.core.commands.Command.Failure("Unsupported JoinModeEnum: " + com.vzome.core.edits.JoinPoints.JoinModeEnum["_$wrappers"][this.joinMode].toString());
                            }
                            this.redo();
                        }
                    }
                    addSegment(points, start, end) {
                        if ((start !== end) && !(points[start].getLocation().equals(points[end].getLocation()))) {
                            let segment = new com.vzome.core.construction.SegmentJoiningPoints(points[start], points[end]);
                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "JoinPoints";
                    }
                }
                JoinPoints.ATTRNAME_CLOSEDLOOP = "closedLoop";
                JoinPoints.ATTRNAME_JOINMODE = "joinMode";
                edits.JoinPoints = JoinPoints;
                JoinPoints["__class"] = "com.vzome.core.edits.JoinPoints";
                (function (JoinPoints) {
                    let JoinModeEnum;
                    (function (JoinModeEnum) {
                        JoinModeEnum[JoinModeEnum["CHAIN_BALLS"] = 0] = "CHAIN_BALLS";
                        JoinModeEnum[JoinModeEnum["CLOSED_LOOP"] = 1] = "CLOSED_LOOP";
                        JoinModeEnum[JoinModeEnum["ALL_TO_FIRST"] = 2] = "ALL_TO_FIRST";
                        JoinModeEnum[JoinModeEnum["ALL_TO_LAST"] = 3] = "ALL_TO_LAST";
                        JoinModeEnum[JoinModeEnum["ALL_POSSIBLE"] = 4] = "ALL_POSSIBLE";
                    })(JoinModeEnum = JoinPoints.JoinModeEnum || (JoinPoints.JoinModeEnum = {}));
                })(JoinPoints = edits.JoinPoints || (edits.JoinPoints = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ShowNormals extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        let SCALE_DOWN = this.mManifestations.getField()['createAlgebraicNumber$int$int$int$int'](1, 0, 2, -3);
                        this.unselectConnectors();
                        this.unselectStruts();
                        for (let index273 = com.vzome.core.editor.api.Manifestations.getPanels$java_lang_Iterable(this.mSelection).iterator(); index273.hasNext();) {
                            let panel = index273.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(panel);
                                let centroid = panel.getCentroid();
                                let tip = centroid.plus(panel['getNormal$']().scale(SCALE_DOWN));
                                let p1 = new com.vzome.core.construction.FreePoint(centroid);
                                let p2 = new com.vzome.core.construction.FreePoint(tip);
                                let s = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p1));
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p2));
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(s));
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return ShowNormals.NAME;
                    }
                }
                ShowNormals.NAME = "ShowNormals";
                edits.ShowNormals = ShowNormals;
                ShowNormals["__class"] = "com.vzome.core.edits.ShowNormals";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ShowPoint extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.point === undefined)
                            this.point = null;
                        if (this.parameters === undefined)
                            this.parameters = null;
                        this.parameters = editor;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        switch (props.get("mode")) {
                            case "origin":
                                let origin = this.mManifestations.getField().origin(3);
                                this.point = new com.vzome.core.construction.FreePoint(origin);
                                break;
                            case "symmCenter":
                                this.point = this.parameters.getCenterPoint();
                                break;
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        this.manifestConstruction(this.point);
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    getXmlAttributes(xml) {
                        com.vzome.core.commands.XmlSaveFormat.serializePoint(xml, "point", this.point);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        if (format.commandEditsCompacted())
                            this.point = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "point");
                        else {
                            let attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                            this.point = attrs.get("point");
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ShowPoint";
                    }
                }
                edits.ShowPoint = ShowPoint;
                ShowPoint["__class"] = "com.vzome.core.edits.ShowPoint";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * This is only used when opening legacy files.  The UI and controllers now use the generic Polytope4d.
                 * @author Scott Vorthmann
                 * @param {*} editorModel
                 * @param {com.vzome.core.construction.Segment} symmAxis
                 * @param {number} index
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class B4Polytope extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editorModel, symmAxis, index) {
                        if (((editorModel != null && (editorModel["__interfaces"] != null && editorModel["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0 || editorModel.constructor != null && editorModel.constructor["__interfaces"] != null && editorModel.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editorModel === null) && ((symmAxis != null && symmAxis instanceof com.vzome.core.construction.Segment) || symmAxis === null) && ((typeof index === 'number') || index === null)) {
                            let __args = arguments;
                            super(editorModel);
                            if (this.index === undefined)
                                this.index = 0;
                            if (this.proj === undefined)
                                this.proj = null;
                            if (this.symmAxis === undefined)
                                this.symmAxis = null;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.index === undefined)
                                this.index = 0;
                            if (this.proj === undefined)
                                this.proj = null;
                            if (this.symmAxis === undefined)
                                this.symmAxis = null;
                            if (this.field === undefined)
                                this.field = null;
                            (() => {
                                this.field = this.mManifestations.getField();
                                this.index = index;
                                this.symmAxis = symmAxis;
                            })();
                        }
                        else if (((editorModel != null && (editorModel["__interfaces"] != null && editorModel["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0 || editorModel.constructor != null && editorModel.constructor["__interfaces"] != null && editorModel.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editorModel === null) && symmAxis === undefined && index === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let symmAxis = null;
                                let index = 0;
                                super(editorModel);
                                if (this.index === undefined)
                                    this.index = 0;
                                if (this.proj === undefined)
                                    this.proj = null;
                                if (this.symmAxis === undefined)
                                    this.symmAxis = null;
                                if (this.field === undefined)
                                    this.field = null;
                                if (this.index === undefined)
                                    this.index = 0;
                                if (this.proj === undefined)
                                    this.proj = null;
                                if (this.symmAxis === undefined)
                                    this.symmAxis = null;
                                if (this.field === undefined)
                                    this.field = null;
                                (() => {
                                    this.field = this.mManifestations.getField();
                                    this.index = index;
                                    this.symmAxis = symmAxis;
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "B4Polytope";
                    }
                    /**
                     *
                     * @param {*} result
                     */
                    getXmlAttributes(result) {
                        com.vzome.xml.DomUtils.addAttribute(result, "dynkin", /* toString */ ('' + (this.index)));
                        if (this.symmAxis != null)
                            com.vzome.core.commands.XmlSaveFormat.serializeSegment(result, "start", "end", this.symmAxis);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        let binary = xml.getAttribute("dynkin");
                        this.index = javaemul.internal.IntegerHelper.parseInt(binary, 2);
                        if (format.commandEditsCompacted())
                            this.symmAxis = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "start", "end");
                        else {
                            let attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                            this.symmAxis = attrs.get("rotation");
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.symmAxis == null)
                            this.proj = new com.vzome.core.math.Projection.Default(this.field);
                        else {
                            let scale = this.field['createPower$int'](-5);
                            this.proj = new com.vzome.core.math.QuaternionProjection(this.field, null, this.symmAxis.getOffset().scale(scale));
                        }
                        let edgeScales = [null, null, null, null];
                        for (let i = 0; i < edgeScales.length; i++) {
                            {
                                edgeScales[i] = this.field['createPower$int'](0);
                            }
                            ;
                        }
                        let group = new com.vzome.core.math.symmetry.B4Group(this.field);
                        com.vzome.core.math.symmetry.WythoffConstruction.constructPolytope(group, this.index, this.index, edgeScales, group, new B4Polytope.WythoffListener(this, this.field));
                        this.redo();
                    }
                }
                edits.B4Polytope = B4Polytope;
                B4Polytope["__class"] = "com.vzome.core.edits.B4Polytope";
                (function (B4Polytope) {
                    class WythoffListener {
                        constructor(__parent, field) {
                            this.__parent = __parent;
                            this.numVertices = 0;
                            if (this.scale === undefined)
                                this.scale = null;
                            this.scale = field['createPower$int'](5);
                        }
                        /**
                         *
                         * @param {*} p1
                         * @param {*} p2
                         * @return {*}
                         */
                        addEdge(p1, p2) {
                            let edge = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                            this.__parent.manifestConstruction(edge);
                            return edge;
                        }
                        /**
                         *
                         * @param {Array} vertices
                         * @return {*}
                         */
                        addFace(vertices) {
                            return null;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vertex
                         * @return {*}
                         */
                        addVertex(vertex) {
                            let projected = vertex;
                            if (this.__parent.proj != null)
                                projected = this.__parent.proj.projectImage(vertex, true);
                            let p = new com.vzome.core.construction.FreePoint(projected.scale(this.scale));
                            p.setIndex(this.numVertices++);
                            this.__parent.manifestConstruction(p);
                            return p;
                        }
                    }
                    B4Polytope.WythoffListener = WythoffListener;
                    WythoffListener["__class"] = "com.vzome.core.edits.B4Polytope.WythoffListener";
                    WythoffListener["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];
                })(B4Polytope = edits.B4Polytope || (edits.B4Polytope = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class CrossProduct extends com.vzome.core.editor.api.ChangeManifestations {
                    /**
                     *
                     */
                    perform() {
                        let p1 = null;
                        let p2 = null;
                        let s1 = null;
                        let success = false;
                        this.setOrderedSelection(true);
                        for (let index274 = this.mSelection.iterator(); index274.hasNext();) {
                            let man = index274.next();
                            {
                                if (success) {
                                    this.recordSelected(man);
                                }
                                else {
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                    if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        let nextPoint = man.getFirstConstruction();
                                        if (p1 == null) {
                                            p1 = nextPoint;
                                        }
                                        else if (s1 == null) {
                                            p2 = nextPoint;
                                            s1 = new com.vzome.core.construction.SegmentJoiningPoints(p1, nextPoint);
                                        }
                                        else if (!success) {
                                            let segment = new com.vzome.core.construction.SegmentJoiningPoints(p2, nextPoint);
                                            segment = new com.vzome.core.construction.SegmentCrossProduct(s1, segment);
                                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                                            let endpt = new com.vzome.core.construction.SegmentEndPoint(segment);
                                            this.manifestConstruction(endpt);
                                            success = true;
                                        }
                                        else
                                            this.recordSelected(man);
                                    }
                                }
                            }
                        }
                        if (!success)
                            throw new com.vzome.core.commands.Command.Failure("cross-product requires three selected vertices");
                        this.redo();
                    }
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "CrossProduct";
                    }
                }
                edits.CrossProduct = CrossProduct;
                CrossProduct["__class"] = "com.vzome.core.edits.CrossProduct";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ShowHidden extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        for (let index275 = this.mManifestations.iterator(); index275.hasNext();) {
                            let m = index275.next();
                            {
                                if (m.isHidden()) {
                                    this.showManifestation(m);
                                    this.select$com_vzome_core_model_Manifestation(m);
                                }
                                else if (this.mSelection.manifestationSelected(m))
                                    this.unselect$com_vzome_core_model_Manifestation(m);
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ShowHidden";
                    }
                }
                edits.ShowHidden = ShowHidden;
                ShowHidden["__class"] = "com.vzome.core.edits.ShowHidden";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class PolarZonohedron extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.symmetry === undefined)
                            this.symmetry = null;
                        if (this.editor === undefined)
                            this.editor = null;
                        this.editor = editor;
                        this.symmetry = editor['getSymmetrySystem$']();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "PolarZonohedron";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.symmetry != null) {
                            com.vzome.xml.DomUtils.addAttribute(element, "symmetry", this.symmetry.getName());
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.symmetry = this.editor['getSymmetrySystem$java_lang_String'](xml.getAttribute("symmetry"));
                    }
                    /**
                     *
                     */
                    perform() {
                        let errorMsg = new java.lang.StringBuilder();
                        errorMsg.append("The Polar Zonohedron command requires either of the following selections:\n\n1) Two non-collinear struts with a common end point.\n   The first strut must have more than 2-fold rotational symmetry.\n   The second strut will be rotated around the first.\n\n2) Any three or more struts having a common end point.\n");
                        let struts = (new java.util.ArrayList());
                        for (let index276 = this.mSelection.iterator(); index276.hasNext();) {
                            let man = index276.next();
                            {
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    struts.add(man);
                                }
                                this.unselect$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        if (struts.size() < 2) {
                            errorMsg.append(struts.size() === 1 ? "\nonly one strut is selected." : "\nno struts are selected.");
                            this.fail(errorMsg.toString());
                        }
                        let common = struts.size() === 2 ? this.useRotationalSymmetry(struts, errorMsg) : this.useRadialSelection(struts);
                        if (common == null) {
                            this.fail(errorMsg.append("\nselected struts do not have a common end point").toString());
                        }
                        let L1 = 0;
                        let L2 = 1;
                        let layers = struts.size();
                        let offsets = (new java.util.ArrayList(layers));
                        let vertices = [null, null];
                        vertices[L1] = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(layers);
                        for (let i = 0; i < layers; i++) {
                            {
                                let strut = struts.get(i);
                                let start = strut.getLocation();
                                let end = strut.getEnd();
                                let offset = strut.getOffset();
                                if (start.equals(common)) {
                                    vertices[L1][i] = end;
                                    offsets.add(offset);
                                }
                                else {
                                    vertices[L1][i] = start;
                                    offsets.add(offset.negate());
                                }
                            }
                            ;
                        }
                        for (let layer = 1; layer < layers; layer++) {
                            {
                                vertices[L2] = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(layers);
                                for (let i = 0; i < layers; i++) {
                                    {
                                        let off = (i + layer) % layers;
                                        let offset = offsets.get(off);
                                        let v1 = vertices[L1][i];
                                        let v2 = v1.plus(offset);
                                        let v3 = vertices[L1][(i + 1) % layers];
                                        let v0 = v3.minus(offset);
                                        vertices[L2][i] = v2;
                                        let p0 = new com.vzome.core.construction.FreePoint(v0);
                                        let p1 = new com.vzome.core.construction.FreePoint(v1);
                                        let p2 = new com.vzome.core.construction.FreePoint(v2);
                                        let p3 = new com.vzome.core.construction.FreePoint(v3);
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p0));
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p1));
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p2));
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p3));
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p1, p2)));
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p2, p3)));
                                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p0, p1, p2, p3])));
                                    }
                                    ;
                                }
                                vertices[L1] = vertices[L2];
                            }
                            ;
                        }
                        this.redo();
                    }
                    static getCommonEndpoint(strut1, strut2) {
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(strut1, strut2)) {
                            throw new java.lang.IllegalArgumentException("Identical struts have both end points in common.");
                        }
                        let start1 = strut1.getLocation();
                        let end1 = strut1.getEnd();
                        let start2 = strut2.getLocation();
                        let end2 = strut2.getEnd();
                        if (start1.equals(start2) || start1.equals(end2))
                            return start1;
                        if (end1.equals(start2) || end1.equals(end2))
                            return end1;
                        return null;
                    }
                    /*private*/ useRotationalSymmetry(struts, errorMsg) {
                        let axisStrut = struts.get(0);
                        let axisSegment = axisStrut.getFirstConstruction();
                        let v1 = axisSegment.getOffset();
                        v1 = axisSegment.getField().projectTo3d(v1, true);
                        let axis1 = this.symmetry.getAxis(v1);
                        if (axis1 == null) {
                            this.fail(errorMsg.append("\nfirst selected strut is not an axis of rotational symmetry").toString());
                        }
                        let perm = axis1.getRotationPermutation();
                        if (perm == null) {
                            this.fail(errorMsg.append("\nfirst selected strut is not an axis of rotation").toString());
                        }
                        let rotation = perm.mapIndex(0);
                        let order = perm.getOrder();
                        if (order <= 2) {
                            this.fail(errorMsg.append("\nfirst selected strut has " + order + "-fold symmetry").toString());
                        }
                        let spokeStrut = struts.get(1);
                        let spokeSegment = spokeStrut.getFirstConstruction();
                        let v2 = spokeSegment.getOffset();
                        if (v1.equals(v2) || v1.equals(v2.negate())) {
                            this.fail(errorMsg.append("\nselected struts are collinear").toString());
                        }
                        let common = PolarZonohedron.getCommonEndpoint(axisStrut, spokeStrut);
                        if (common == null) {
                            this.fail(errorMsg.append("\nselected struts do not have a common end point").toString());
                        }
                        let s1 = axisSegment.getStart();
                        let e1 = axisSegment.getEnd();
                        let center = new com.vzome.core.construction.SegmentEndPoint(axisSegment, common.equals(e1));
                        let s2 = spokeSegment.getStart();
                        let e2 = spokeSegment.getEnd();
                        if (common.equals(s1)) {
                            if (common.equals(e2)) {
                                v2 = v2.negate();
                                e2 = s2;
                                s2 = common;
                            }
                        }
                        else {
                            v1 = v1.negate();
                            e1 = s1;
                            s1 = common;
                            if (common.equals(e2)) {
                                v2 = v2.negate();
                                e2 = s2;
                                s2 = common;
                            }
                        }
                        this.redo();
                        struts.remove(axisStrut);
                        this.select$com_vzome_core_model_Manifestation(spokeStrut);
                        let p0 = new com.vzome.core.construction.FreePoint(s2);
                        let p1 = new com.vzome.core.construction.FreePoint(e2);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p0));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p1));
                        for (let i = 0; i < order - 1; i++) {
                            {
                                let transform = new com.vzome.core.construction.SymmetryTransformation(this.symmetry.getSymmetry(), rotation, center);
                                rotation = perm.mapIndex(rotation);
                                let ball = this.manifestConstruction(new com.vzome.core.construction.TransformedPoint(transform, p1));
                                let strut = this.manifestConstruction(new com.vzome.core.construction.TransformedSegment(transform, spokeSegment));
                                struts.add(strut);
                                this.select$com_vzome_core_model_Manifestation(ball);
                                this.select$com_vzome_core_model_Manifestation(strut);
                            }
                            ;
                        }
                        this.redo();
                        return common;
                    }
                    /*private*/ useRadialSelection(struts) {
                        let first = struts.get(0);
                        let common = PolarZonohedron.getCommonEndpoint(first, struts.get(1));
                        if (common == null) {
                            return null;
                        }
                        for (let i = 1; i < struts.size(); i++) {
                            {
                                if (!common.equals(PolarZonohedron.getCommonEndpoint(first, struts.get(i)))) {
                                    return null;
                                }
                            }
                            ;
                        }
                        this.redo();
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.FreePoint(common)));
                        for (let index277 = struts.iterator(); index277.hasNext();) {
                            let strut = index277.next();
                            {
                                this.select$com_vzome_core_model_Manifestation(strut);
                                let start = strut.getLocation();
                                if (common.equals(start)) {
                                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.FreePoint(strut.getEnd())));
                                }
                                else {
                                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.FreePoint(start)));
                                }
                            }
                        }
                        this.redo();
                        return common;
                    }
                }
                edits.PolarZonohedron = PolarZonohedron;
                PolarZonohedron["__class"] = "com.vzome.core.edits.PolarZonohedron";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class TransformSelection extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor, transform) {
                        super(editor);
                        if (this.transform === undefined)
                            this.transform = null;
                        this.transform = transform;
                    }
                    /**
                     *
                     */
                    perform() {
                        let inputs = (new java.util.ArrayList());
                        for (let index278 = this.mSelection.iterator(); index278.hasNext();) {
                            let man = index278.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                inputs.add(man);
                            }
                        }
                        this.redo();
                        for (let index279 = inputs.iterator(); index279.hasNext();) {
                            let m = index279.next();
                            {
                                if (!m.isRendered())
                                    continue;
                                let c = m.getFirstConstruction();
                                let result = this.transform.transform$com_vzome_core_construction_Construction(c);
                                this.select$com_vzome_core_model_Manifestation$boolean(this.manifestConstruction(result), true);
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "TransformSelection";
                    }
                }
                edits.TransformSelection = TransformSelection;
                TransformSelection["__class"] = "com.vzome.core.edits.TransformSelection";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class Polytope4d extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor, symmetries, quaternion, index, groupName, edgesToRender, edgeScales, renderGroupName) {
                        if (((editor != null && (editor["__interfaces"] != null && editor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0 || editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && ((symmetries != null && (symmetries["__interfaces"] != null && symmetries["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetries4D") >= 0 || symmetries.constructor != null && symmetries.constructor["__interfaces"] != null && symmetries.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetries4D") >= 0)) || symmetries === null) && ((quaternion != null && quaternion instanceof com.vzome.core.algebra.AlgebraicVector) || quaternion === null) && ((typeof index === 'number') || index === null) && ((typeof groupName === 'string') || groupName === null) && ((typeof edgesToRender === 'number') || edgesToRender === null) && ((edgeScales != null && edgeScales instanceof Array && (edgeScales.length == 0 || edgeScales[0] == null || (edgeScales[0] != null && (edgeScales[0]["__interfaces"] != null && edgeScales[0]["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || edgeScales[0].constructor != null && edgeScales[0].constructor["__interfaces"] != null && edgeScales[0].constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)))) || edgeScales === null) && ((typeof renderGroupName === 'string') || renderGroupName === null)) {
                            let __args = arguments;
                            super(editor);
                            if (this.index === undefined)
                                this.index = 0;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.proj === undefined)
                                this.proj = null;
                            if (this.quaternion === undefined)
                                this.quaternion = null;
                            if (this.groupName === undefined)
                                this.groupName = null;
                            if (this.renderGroupName === undefined)
                                this.renderGroupName = null;
                            if (this.symmetries === undefined)
                                this.symmetries = null;
                            this.edgesToRender = 15;
                            this.edgeScales = [null, null, null, null];
                            if (this.index === undefined)
                                this.index = 0;
                            if (this.field === undefined)
                                this.field = null;
                            if (this.proj === undefined)
                                this.proj = null;
                            if (this.quaternion === undefined)
                                this.quaternion = null;
                            if (this.groupName === undefined)
                                this.groupName = null;
                            if (this.renderGroupName === undefined)
                                this.renderGroupName = null;
                            if (this.symmetries === undefined)
                                this.symmetries = null;
                            (() => {
                                this.symmetries = symmetries;
                                this.field = editor.getRealizedModel().getField();
                                this.index = index;
                                this.quaternion = quaternion;
                                this.groupName = groupName;
                                this.renderGroupName = renderGroupName;
                                this.edgesToRender = edgesToRender;
                                if (edgeScales != null)
                                    this.edgeScales = edgeScales;
                                else
                                    for (let i = 0; i < this.edgeScales.length; i++) {
                                        {
                                            this.edgeScales[i] = this.field['createPower$int'](0);
                                        }
                                        ;
                                    }
                            })();
                        }
                        else if (((editor != null && (editor["__interfaces"] != null && editor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0 || editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && ((symmetries != null && (symmetries["__interfaces"] != null && symmetries["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetries4D") >= 0 || symmetries.constructor != null && symmetries.constructor["__interfaces"] != null && symmetries.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetries4D") >= 0)) || symmetries === null) && ((quaternion != null && quaternion instanceof com.vzome.core.construction.Segment) || quaternion === null) && ((typeof index === 'number') || index === null) && ((typeof groupName === 'string') || groupName === null) && edgesToRender === undefined && edgeScales === undefined && renderGroupName === undefined) {
                            let __args = arguments;
                            let symmAxis = __args[2];
                            {
                                let __args = arguments;
                                let quaternion = (symmAxis == null) ? null : symmAxis.getOffset().inflateTo4d$();
                                let edgesToRender = __args[3];
                                let edgeScales = null;
                                let renderGroupName = __args[4];
                                super(editor);
                                if (this.index === undefined)
                                    this.index = 0;
                                if (this.field === undefined)
                                    this.field = null;
                                if (this.proj === undefined)
                                    this.proj = null;
                                if (this.quaternion === undefined)
                                    this.quaternion = null;
                                if (this.groupName === undefined)
                                    this.groupName = null;
                                if (this.renderGroupName === undefined)
                                    this.renderGroupName = null;
                                if (this.symmetries === undefined)
                                    this.symmetries = null;
                                this.edgesToRender = 15;
                                this.edgeScales = [null, null, null, null];
                                if (this.index === undefined)
                                    this.index = 0;
                                if (this.field === undefined)
                                    this.field = null;
                                if (this.proj === undefined)
                                    this.proj = null;
                                if (this.quaternion === undefined)
                                    this.quaternion = null;
                                if (this.groupName === undefined)
                                    this.groupName = null;
                                if (this.renderGroupName === undefined)
                                    this.renderGroupName = null;
                                if (this.symmetries === undefined)
                                    this.symmetries = null;
                                (() => {
                                    this.symmetries = symmetries;
                                    this.field = editor.getRealizedModel().getField();
                                    this.index = index;
                                    this.quaternion = quaternion;
                                    this.groupName = groupName;
                                    this.renderGroupName = renderGroupName;
                                    this.edgesToRender = edgesToRender;
                                    if (edgeScales != null)
                                        this.edgeScales = edgeScales;
                                    else
                                        for (let i = 0; i < this.edgeScales.length; i++) {
                                            {
                                                this.edgeScales[i] = this.field['createPower$int'](0);
                                            }
                                            ;
                                        }
                                })();
                            }
                        }
                        else if (((editor != null && (editor["__interfaces"] != null && editor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0 || editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null) && symmetries === undefined && quaternion === undefined && index === undefined && groupName === undefined && edgesToRender === undefined && edgeScales === undefined && renderGroupName === undefined) {
                            let __args = arguments;
                            {
                                let __args = arguments;
                                let symmetries = __args[0].get4dSymmetries();
                                let symmAxis = null;
                                let index = 0;
                                let groupName = null;
                                {
                                    let __args = arguments;
                                    let quaternion = (symmAxis == null) ? null : symmAxis.getOffset().inflateTo4d$();
                                    let edgesToRender = __args[3];
                                    let edgeScales = null;
                                    let renderGroupName = __args[4];
                                    super(editor);
                                    if (this.index === undefined)
                                        this.index = 0;
                                    if (this.field === undefined)
                                        this.field = null;
                                    if (this.proj === undefined)
                                        this.proj = null;
                                    if (this.quaternion === undefined)
                                        this.quaternion = null;
                                    if (this.groupName === undefined)
                                        this.groupName = null;
                                    if (this.renderGroupName === undefined)
                                        this.renderGroupName = null;
                                    if (this.symmetries === undefined)
                                        this.symmetries = null;
                                    this.edgesToRender = 15;
                                    this.edgeScales = [null, null, null, null];
                                    if (this.index === undefined)
                                        this.index = 0;
                                    if (this.field === undefined)
                                        this.field = null;
                                    if (this.proj === undefined)
                                        this.proj = null;
                                    if (this.quaternion === undefined)
                                        this.quaternion = null;
                                    if (this.groupName === undefined)
                                        this.groupName = null;
                                    if (this.renderGroupName === undefined)
                                        this.renderGroupName = null;
                                    if (this.symmetries === undefined)
                                        this.symmetries = null;
                                    (() => {
                                        this.symmetries = symmetries;
                                        this.field = editor.getRealizedModel().getField();
                                        this.index = index;
                                        this.quaternion = quaternion;
                                        this.groupName = groupName;
                                        this.renderGroupName = renderGroupName;
                                        this.edgesToRender = edgesToRender;
                                        if (edgeScales != null)
                                            this.edgeScales = edgeScales;
                                        else
                                            for (let i = 0; i < this.edgeScales.length; i++) {
                                                {
                                                    this.edgeScales[i] = this.field['createPower$int'](0);
                                                }
                                                ;
                                            }
                                    })();
                                }
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {*} params
                     */
                    configure(params) {
                        this.groupName = params.get("groupName");
                        this.renderGroupName = params.get("renderGroupName");
                        this.index = (params.get("index") | 0);
                        this.edgesToRender = (params.get("edgesToRender") | 0);
                        this.edgeScales = params.get("edgeScales");
                        this.quaternion = params.get("quaternion");
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "Polytope4d";
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    getXmlAttributes(xml) {
                        if (this.quaternion != null)
                            com.vzome.xml.DomUtils.addAttribute(xml, "quaternion", this.quaternion.toParsableString());
                        com.vzome.xml.DomUtils.addAttribute(xml, "group", this.groupName);
                        com.vzome.xml.DomUtils.addAttribute(xml, "wythoff", /* toString */ ('' + (this.index)));
                        if (this.edgesToRender !== 15)
                            com.vzome.xml.DomUtils.addAttribute(xml, "renderEdges", /* toString */ ('' + (this.edgesToRender)));
                        if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.renderGroupName, this.groupName))
                            com.vzome.xml.DomUtils.addAttribute(xml, "renderGroup", this.renderGroupName);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        let binary = xml.getAttribute("wythoff");
                        this.index = javaemul.internal.IntegerHelper.parseInt(binary, 2);
                        let renderString = xml.getAttribute("renderEdges");
                        this.edgesToRender = (renderString == null || /* isEmpty */ (renderString.length === 0)) ? this.index : javaemul.internal.IntegerHelper.parseInt(renderString, 2);
                        this.groupName = xml.getAttribute("group");
                        let rgString = xml.getAttribute("renderGroup");
                        this.renderGroupName = (rgString == null || /* isEmpty */ (rgString.length === 0)) ? this.groupName : rgString;
                        let quatString = xml.getAttribute("quaternion");
                        if (quatString != null && !((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("", quatString)) {
                            if ( /* contains */(quatString.indexOf("+") != -1)) {
                                quatString = /* replace */ quatString.split(',').join(' ');
                                quatString = /* replace */ quatString.split('(').join(' ');
                                quatString = /* replace */ quatString.split(')').join(' ');
                                quatString = /* replace */ quatString.split('+').join(' ');
                                let irrat = this.field['getIrrational$int'](0).charAt(0);
                                quatString = /* replace */ quatString.split(irrat).join(' ');
                                quatString = quatString + " 0 0 0";
                            }
                            this.quaternion = this.field.parseVector(quatString);
                        }
                        else {
                            let segment = null;
                            if (format.commandEditsCompacted())
                                segment = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "start", "end");
                            else {
                                let attrs = format.loadCommandAttributes$org_w3c_dom_Element(xml);
                                segment = attrs.get("rotation");
                            }
                            if (segment != null)
                                this.quaternion = segment.getOffset().inflateTo4d$();
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.quaternion == null)
                            this.proj = new com.vzome.core.math.Projection.Default(this.field);
                        else
                            this.proj = new com.vzome.core.math.QuaternionProjection(this.field, null, this.quaternion.scale(this.field['createPower$int'](-5)));
                        this.symmetries.constructPolytope(this.groupName, this.index, this.edgesToRender, this.edgeScales, new Polytope4d.WythoffListener(this));
                        this.redo();
                    }
                    static getSupportedGroups() {
                        return ["A4", "B4/C4", "D4", "F4", "H4"];
                    }
                }
                edits.Polytope4d = Polytope4d;
                Polytope4d["__class"] = "com.vzome.core.edits.Polytope4d";
                (function (Polytope4d) {
                    class WythoffListener {
                        constructor(__parent) {
                            this.__parent = __parent;
                            this.numVertices = 0;
                            this.vertices = (new java.util.HashMap());
                        }
                        /**
                         *
                         * @param {*} p1
                         * @param {*} p2
                         * @return {*}
                         */
                        addEdge(p1, p2) {
                            let edge = new com.vzome.core.construction.SegmentJoiningPoints(p1, p2);
                            this.__parent.manifestConstruction(edge);
                            return edge;
                        }
                        /**
                         *
                         * @param {Array} vertices
                         * @return {*}
                         */
                        addFace(vertices) {
                            return null;
                        }
                        /**
                         *
                         * @param {com.vzome.core.algebra.AlgebraicVector} vertex
                         * @return {*}
                         */
                        addVertex(vertex) {
                            let p = this.vertices.get(vertex.toString());
                            if (p == null) {
                                let projected = vertex;
                                if (this.__parent.proj != null)
                                    projected = this.__parent.proj.projectImage(vertex, true);
                                projected = projected.scale(this.__parent.field['createPower$int'](5));
                                p = new com.vzome.core.construction.FreePoint(projected);
                                p.setIndex(this.numVertices++);
                                this.__parent.manifestConstruction(p);
                                this.vertices.put(vertex.toString(), p);
                            }
                            return p;
                        }
                    }
                    Polytope4d.WythoffListener = WythoffListener;
                    WythoffListener["__class"] = "com.vzome.core.edits.Polytope4d.WythoffListener";
                    WythoffListener["__interfaces"] = ["com.vzome.core.math.symmetry.WythoffConstruction.Listener"];
                })(Polytope4d = edits.Polytope4d || (edits.Polytope4d = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ShowVertices extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        for (let index280 = this.mSelection.iterator(); index280.hasNext();) {
                            let man = index280.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    let s = man.getFirstConstruction();
                                    let start = new com.vzome.core.construction.SegmentEndPoint(s, true);
                                    this.manifestConstruction(start);
                                    let end = new com.vzome.core.construction.SegmentEndPoint(s, false);
                                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(end));
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    let polygon = man.getFirstConstruction();
                                    for (let i = 0; i < polygon.getVertexCount(); i++) {
                                        {
                                            let v = new com.vzome.core.construction.PolygonVertex(polygon, i);
                                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(v));
                                        }
                                        ;
                                    }
                                }
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return ShowVertices.NAME;
                    }
                }
                ShowVertices.NAME = "ShowVertices";
                edits.ShowVertices = ShowVertices;
                ShowVertices["__class"] = "com.vzome.core.edits.ShowVertices";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class JoinSkewLines extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        let errorMsg = new java.lang.StringBuilder();
                        errorMsg.append("This command requires two non-parallel struts.\n");
                        let s0 = null;
                        let s1 = null;
                        let qty = 0;
                        for (let index281 = this.mSelection.iterator(); index281.hasNext();) {
                            let man = index281.next();
                            {
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    switch ((qty)) {
                                        case 0:
                                            s0 = man;
                                            break;
                                        case 1:
                                            s1 = man;
                                            break;
                                        default:
                                            errorMsg.append("\ntoo many struts are selected.");
                                            this.fail(errorMsg.toString());
                                    }
                                    qty++;
                                }
                                this.unselect$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        if (qty < 2) {
                            errorMsg.append(qty === 1 ? "\nonly one strut is selected." : "\nno struts are selected.");
                            this.fail(errorMsg.toString());
                        }
                        let u = s0.getOffset();
                        let v = s1.getOffset();
                        let p0 = s0.getLocation();
                        let q0 = s1.getLocation();
                        let uuA = u.dot(u);
                        let uvB = u.dot(v);
                        let vvC = v.dot(v);
                        let denD = uuA['times$com_vzome_core_algebra_AlgebraicNumber'](vvC)['minus$com_vzome_core_algebra_AlgebraicNumber'](uvB['times$com_vzome_core_algebra_AlgebraicNumber'](uvB));
                        if (denD.isZero()) {
                            errorMsg.append("\nstruts are parallel.");
                            this.fail(errorMsg.toString());
                        }
                        this.redo();
                        let w = p0.minus(q0);
                        let uwD = u.dot(w);
                        let vwE = v.dot(w);
                        let sc = (uvB['times$com_vzome_core_algebra_AlgebraicNumber'](vwE)['minus$com_vzome_core_algebra_AlgebraicNumber'](vvC['times$com_vzome_core_algebra_AlgebraicNumber'](uwD)))['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](denD);
                        let tc = (uuA['times$com_vzome_core_algebra_AlgebraicNumber'](vwE)['minus$com_vzome_core_algebra_AlgebraicNumber'](uvB['times$com_vzome_core_algebra_AlgebraicNumber'](uwD)))['dividedBy$com_vzome_core_algebra_AlgebraicNumber'](denD);
                        let w0 = p0.plus(u.scale(sc));
                        let pw0 = new com.vzome.core.construction.FreePoint(w0);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(pw0));
                        let w1 = q0.plus(v.scale(tc));
                        if (!w1.equals(w0)) {
                            let pw1 = new com.vzome.core.construction.FreePoint(w1);
                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(pw1));
                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(pw0, pw1)));
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return JoinSkewLines.NAME;
                    }
                }
                JoinSkewLines.NAME = "JoinSkewLines";
                edits.JoinSkewLines = JoinSkewLines;
                JoinSkewLines["__class"] = "com.vzome.core.edits.JoinSkewLines";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class NewCentroid extends com.vzome.core.editor.api.ChangeManifestations {
                    /**
                     *
                     */
                    perform() {
                        let verticesList = (new java.util.ArrayList());
                        for (let index282 = this.mSelection.iterator(); index282.hasNext();) {
                            let man = index282.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                let construction = man.toConstruction();
                                if (construction != null && construction instanceof com.vzome.core.construction.Point) {
                                    let nextPoint = construction;
                                    verticesList.add(nextPoint);
                                }
                            }
                        }
                        if (verticesList.size() < 2)
                            throw new com.vzome.core.commands.Command.Failure("Select at least two balls to compute the centroid.");
                        let points = [];
                        let centroid = new com.vzome.core.construction.CentroidPoint(verticesList.toArray(points));
                        this.manifestConstruction(centroid);
                        this.redo();
                    }
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "NewCentroid";
                    }
                }
                edits.NewCentroid = NewCentroid;
                NewCentroid["__class"] = "com.vzome.core.edits.NewCentroid";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class LinePlaneIntersect extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    /**
                     *
                     */
                    perform() {
                        let panel = null;
                        let strut = null;
                        let p0 = null;
                        let p1 = null;
                        let p2 = null;
                        for (let index283 = this.mSelection.iterator(); index283.hasNext();) {
                            let man = index283.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if ((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) && (p2 == null)) {
                                    let nextPoint = man.getFirstConstruction();
                                    if (p0 == null)
                                        p0 = nextPoint;
                                    else if (p1 == null)
                                        p1 = nextPoint;
                                    else if (p2 == null)
                                        p2 = nextPoint;
                                }
                                else if ((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) && (strut == null)) {
                                    strut = man;
                                }
                                else if ((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) && panel == null) {
                                    panel = man;
                                }
                            }
                        }
                        let point = null;
                        let plane = null;
                        let line = new com.vzome.core.construction.LineFromPointAndVector(strut.getLocation(), strut.getZoneVector());
                        if (p2 != null && panel == null) {
                            let points = [p0, p1, p2];
                            let polygon = new com.vzome.core.construction.PolygonFromVertices(points);
                            plane = new com.vzome.core.construction.PlaneExtensionOfPolygon(polygon);
                        }
                        else if (strut != null && panel != null) {
                            plane = new com.vzome.core.construction.PlaneFromPointAndNormal(panel.getFirstVertex(), panel.getZoneVector());
                        }
                        if (plane != null && !plane.isImpossible()) {
                            point = new com.vzome.core.construction.LinePlaneIntersectionPoint(plane, line);
                            if (!point.isImpossible())
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(point));
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "LinePlaneIntersect";
                    }
                }
                edits.LinePlaneIntersect = LinePlaneIntersect;
                LinePlaneIntersect["__class"] = "com.vzome.core.edits.LinePlaneIntersect";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectByBoundary extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     * @param {string} message
                     */
                    fail(message) {
                        let errorMsg = new java.lang.StringBuilder();
                        let usage = this.usage();
                        if (usage != null) {
                            errorMsg.append(usage);
                        }
                        if (message != null) {
                            if (errorMsg.length() > 0) {
                                errorMsg.append("\n");
                            }
                            errorMsg.append(message);
                        }
                        super.fail(errorMsg.toString());
                    }
                    /**
                     *
                     */
                    perform() {
                        let errMsg = this.setBoundary();
                        if (errMsg != null) {
                            this.fail(errMsg);
                        }
                        this.unselectAll();
                        this.selectBoundedManifestations();
                        this.redo();
                    }
                    selectBoundedManifestations() {
                        for (let index284 = this.getConnectors().iterator(); index284.hasNext();) {
                            let connector = index284.next();
                            {
                                if (this.boundaryContains$com_vzome_core_model_Connector(connector)) {
                                    this.select$com_vzome_core_model_Manifestation(connector);
                                }
                            }
                        }
                        for (let index285 = this.getStruts().iterator(); index285.hasNext();) {
                            let strut = index285.next();
                            {
                                if (this.boundaryContains$com_vzome_core_model_Strut(strut)) {
                                    this.select$com_vzome_core_model_Manifestation(strut);
                                }
                            }
                        }
                        for (let index286 = this.getPanels().iterator(); index286.hasNext();) {
                            let panel = index286.next();
                            {
                                if (this.boundaryContains$com_vzome_core_model_Panel(panel)) {
                                    this.select$com_vzome_core_model_Manifestation(panel);
                                }
                            }
                        }
                    }
                    boundaryContains$com_vzome_core_model_Connector(connector) {
                        return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(connector.getLocation());
                    }
                    boundaryContains(connector) {
                        if (((connector != null && (connector["__interfaces"] != null && connector["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || connector.constructor != null && connector.constructor["__interfaces"] != null && connector.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || connector === null)) {
                            return this.boundaryContains$com_vzome_core_model_Connector(connector);
                        }
                        else if (((connector != null && (connector["__interfaces"] != null && connector["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || connector.constructor != null && connector.constructor["__interfaces"] != null && connector.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || connector === null)) {
                            return this.boundaryContains$com_vzome_core_model_Strut(connector);
                        }
                        else if (((connector != null && (connector["__interfaces"] != null && connector["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || connector.constructor != null && connector.constructor["__interfaces"] != null && connector.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || connector === null)) {
                            return this.boundaryContains$com_vzome_core_model_Panel(connector);
                        }
                        else if (((connector != null && connector instanceof com.vzome.core.algebra.AlgebraicVector) || connector === null)) {
                            return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(connector);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /*private*/ boundaryContains$com_vzome_core_model_Strut(strut) {
                        return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(strut.getLocation()) && this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(strut.getEnd());
                    }
                    /*private*/ boundaryContains$com_vzome_core_model_Panel(panel) {
                        for (let index287 = panel.iterator(); index287.hasNext();) {
                            let vertex = index287.next();
                            {
                                if (!this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(vertex)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    boundaryContains$com_vzome_core_algebra_AlgebraicVector(v) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
                }
                edits.SelectByBoundary = SelectByBoundary;
                SelectByBoundary["__class"] = "com.vzome.core.edits.SelectByBoundary";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ConvexHull extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    getSelectedVertexSet(unselectAll) {
                        let vertexSet = (new java.util.HashSet());
                        for (let index288 = this.mSelection.iterator(); index288.hasNext();) {
                            let man = index288.next();
                            {
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    vertexSet.add(man.getLocation());
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    vertexSet.add(man.getLocation());
                                    vertexSet.add(man.getEnd());
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    for (let index289 = man.iterator(); index289.hasNext();) {
                                        let vertex = index289.next();
                                        {
                                            vertexSet.add(vertex);
                                        }
                                    }
                                }
                                if (unselectAll) {
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                }
                            }
                        }
                        return vertexSet;
                    }
                }
                edits.ConvexHull = ConvexHull;
                ConvexHull["__class"] = "com.vzome.core.edits.ConvexHull";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class AffinePentagon extends com.vzome.core.editor.api.ChangeManifestations {
                    /**
                     *
                     */
                    perform() {
                        let errorMsg = "Affine pentagon command requires two selected struts with a common vertex.";
                        let strut1 = null;
                        let strut2 = null;
                        for (let index290 = this.mSelection.iterator(); index290.hasNext();) {
                            let man = index290.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (strut1 == null) {
                                        strut1 = man;
                                    }
                                    else if (strut2 == null) {
                                        strut2 = man;
                                    }
                                }
                            }
                        }
                        this.redo();
                        if (strut1 == null || strut2 == null) {
                            this.fail(errorMsg);
                        }
                        let field = strut1.getLocation().getField();
                        let s1 = strut1.getFirstConstruction();
                        let s2 = strut2.getFirstConstruction();
                        this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s1, true));
                        this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s1, false));
                        this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s2, true));
                        this.manifestConstruction(new com.vzome.core.construction.SegmentEndPoint(s2, false));
                        this.redo();
                        let offset1 = s1.getOffset();
                        let offset2 = s2.getOffset();
                        let v1 = null;
                        let v2 = null;
                        {
                            let s1s = s1.getStart();
                            let s1e = s1.getEnd();
                            let s2s = s2.getStart();
                            let s2e = s2.getEnd();
                            if (s1s.equals(s2s)) {
                                v1 = s1e;
                                v2 = s2e;
                            }
                            else if (s1e.equals(s2s)) {
                                v1 = s1s;
                                v2 = s2e;
                                offset1 = offset1.negate();
                            }
                            else if (s1e.equals(s2e)) {
                                v1 = s1s;
                                v2 = s2s;
                                offset2 = offset2.negate();
                                offset1 = offset1.negate();
                            }
                            else if (s1s.equals(s2e)) {
                                v1 = s1e;
                                v2 = s2s;
                                offset2 = offset2.negate();
                            }
                            else {
                                this.fail(errorMsg);
                            }
                        }
                        ;
                        let p1 = null;
                        let p2 = null;
                        for (let index291 = this.mManifestations.iterator(); index291.hasNext();) {
                            let m = index291.next();
                            {
                                if (m != null && (m["__interfaces"] != null && m["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || m.constructor != null && m.constructor["__interfaces"] != null && m.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    let loc = m.getLocation();
                                    if (loc.equals(v1))
                                        p1 = m.getFirstConstruction();
                                    else if (loc.equals(v2))
                                        p2 = m.getFirstConstruction();
                                }
                            }
                        }
                        let phi = field['createPower$int'](1);
                        let transform = new com.vzome.core.construction.Translation(offset1.scale(phi));
                        let p3 = new com.vzome.core.construction.TransformedPoint(transform, p2);
                        this.manifestConstruction(p3);
                        transform = new com.vzome.core.construction.Translation(offset2.scale(phi));
                        let p4 = new com.vzome.core.construction.TransformedPoint(transform, p1);
                        this.manifestConstruction(p4);
                        let segment = new com.vzome.core.construction.SegmentJoiningPoints(p1, p3);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                        segment = new com.vzome.core.construction.SegmentJoiningPoints(p2, p4);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                        segment = new com.vzome.core.construction.SegmentJoiningPoints(p3, p4);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(segment));
                        this.redo();
                    }
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "AffinePentagon";
                    }
                }
                edits.AffinePentagon = AffinePentagon;
                AffinePentagon["__class"] = "com.vzome.core.edits.AffinePentagon";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class StrutCreation extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(anchor, axis, len, editor) {
                        if (((anchor != null && anchor instanceof com.vzome.core.construction.Point) || anchor === null) && ((axis != null && axis instanceof com.vzome.core.math.symmetry.Axis) || axis === null) && ((len != null && (len["__interfaces"] != null && len["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0 || len.constructor != null && len.constructor["__interfaces"] != null && len.constructor["__interfaces"].indexOf("com.vzome.core.algebra.AlgebraicNumber") >= 0)) || len === null) && ((editor != null && (editor["__interfaces"] != null && editor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0 || editor.constructor != null && editor.constructor["__interfaces"] != null && editor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || editor === null)) {
                            let __args = arguments;
                            super(editor);
                            if (this.mAnchor === undefined)
                                this.mAnchor = null;
                            if (this.mAxis === undefined)
                                this.mAxis = null;
                            if (this.mLength === undefined)
                                this.mLength = null;
                            if (this.mAnchor === undefined)
                                this.mAnchor = null;
                            if (this.mAxis === undefined)
                                this.mAxis = null;
                            if (this.mLength === undefined)
                                this.mLength = null;
                            (() => {
                                this.mAnchor = anchor;
                                this.mAxis = axis;
                                this.mLength = len;
                            })();
                        }
                        else if (((anchor != null && (anchor["__interfaces"] != null && anchor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0 || anchor.constructor != null && anchor.constructor["__interfaces"] != null && anchor.constructor["__interfaces"].indexOf("com.vzome.core.editor.api.EditorModel") >= 0)) || anchor === null) && axis === undefined && len === undefined && editor === undefined) {
                            let __args = arguments;
                            let editor = __args[0];
                            {
                                let __args = arguments;
                                let anchor = null;
                                let axis = null;
                                let len = null;
                                super(editor);
                                if (this.mAnchor === undefined)
                                    this.mAnchor = null;
                                if (this.mAxis === undefined)
                                    this.mAxis = null;
                                if (this.mLength === undefined)
                                    this.mLength = null;
                                if (this.mAnchor === undefined)
                                    this.mAnchor = null;
                                if (this.mAxis === undefined)
                                    this.mAxis = null;
                                if (this.mLength === undefined)
                                    this.mLength = null;
                                (() => {
                                    this.mAnchor = anchor;
                                    this.mAxis = axis;
                                    this.mLength = len;
                                })();
                            }
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @param {*} params
                     */
                    configure(params) {
                        this.mAnchor = params.get("anchor");
                        this.mAxis = params.get("zone");
                        this.mLength = params.get("length");
                    }
                    /**
                     *
                     */
                    perform() {
                        let segment = new com.vzome.core.construction.AnchoredSegment(this.mAxis, this.mLength, this.mAnchor);
                        this.manifestConstruction(segment);
                        let point = new com.vzome.core.construction.SegmentEndPoint(segment);
                        this.manifestConstruction(point);
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    getXmlAttributes(xml) {
                        com.vzome.core.commands.XmlSaveFormat.serializePoint(xml, "anchor", this.mAnchor);
                        com.vzome.core.commands.XmlSymmetryFormat.serializeAxis(xml, "symm", "dir", "index", "sense", this.mAxis);
                        com.vzome.core.commands.XmlSaveFormat.serializeNumber(xml, "len", this.mLength);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        if (format.rationalVectors()) {
                            this.mAnchor = format.parsePoint$org_w3c_dom_Element$java_lang_String(xml, "anchor");
                            this.mAxis = format.parseAxis(xml, "symm", "dir", "index", "sense");
                            this.mLength = format.parseNumber(xml, "len");
                        }
                        else {
                            let attrs = format.loadCommandAttributes$org_w3c_dom_Element$boolean(xml, true);
                            this.mAnchor = attrs.get("anchor");
                            this.mAxis = attrs.get("axis");
                            this.mLength = attrs.get("len");
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "StrutCreation";
                    }
                }
                edits.StrutCreation = StrutCreation;
                StrutCreation["__class"] = "com.vzome.core.edits.StrutCreation";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class StrutIntersection extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     */
                    perform() {
                        let s1 = null;
                        let s2 = null;
                        for (let index292 = this.mSelection.iterator(); index292.hasNext();) {
                            let man = index292.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))
                                    if (s1 == null)
                                        s1 = man;
                                    else if (s2 == null)
                                        s2 = man;
                                    else
                                        throw new com.vzome.core.commands.Command.Failure("only two struts are allowed");
                            }
                        }
                        if (s1 == null || s2 == null)
                            throw new com.vzome.core.commands.Command.Failure("two struts are required");
                        let l1 = new com.vzome.core.construction.LineFromPointAndVector(s1.getLocation(), s1.getZoneVector());
                        let l2 = new com.vzome.core.construction.LineFromPointAndVector(s2.getLocation(), s2.getZoneVector());
                        let point = new com.vzome.core.construction.LineLineIntersectionPoint(l1, l2);
                        if (point.isImpossible())
                            throw new com.vzome.core.commands.Command.Failure("lines are parallel or non-intersecting");
                        let ball = this.manifestConstruction(point);
                        this.select$com_vzome_core_model_Manifestation(ball);
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "StrutIntersection";
                    }
                }
                edits.StrutIntersection = StrutIntersection;
                StrutIntersection["__class"] = "com.vzome.core.edits.StrutIntersection";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * Work in progress, to help someone create correctly oriented surfaces for vZome part export,
                 * or for StL 3D printing export.
                 *
                 * @author Scott Vorthmann
                 * @param {*} singlePanel
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class ReversePanel extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(singlePanel, editor) {
                        super(editor);
                        if (this.panel === undefined)
                            this.panel = null;
                        if (singlePanel != null)
                            this.panel = singlePanel;
                        else
                            this.panel = null;
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.panel != null) {
                            if (this.mSelection.manifestationSelected(this.panel))
                                this.unselect$com_vzome_core_model_Manifestation(this.panel);
                            let polygon = this.panel.getFirstConstruction();
                            this.unmanifestConstruction(polygon);
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ReversePanel";
                    }
                }
                edits.ReversePanel = ReversePanel;
                ReversePanel["__class"] = "com.vzome.core.edits.ReversePanel";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class MapToColor extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.colorMapper === undefined)
                            this.colorMapper = null;
                        if (this.editor === undefined)
                            this.editor = null;
                        this.editor = editor;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        let colorMapperName = props.get("mode");
                        let symmetry = this.editor['getSymmetrySystem$']();
                        if (colorMapperName != null)
                            this.colorMapper = com.vzome.core.edits.ManifestationColorMappers.getColorMapper$java_lang_String$com_vzome_core_editor_api_OrbitSource(colorMapperName, symmetry);
                    }
                    /**
                     * Either configure() or setXmlAttributes() is always called before perform()
                     */
                    perform() {
                        if (this.colorMapper.requiresOrderedSelection()) {
                            this.setOrderedSelection(true);
                        }
                        this.colorMapper.initialize(this.getRenderedSelection());
                        for (let index293 = this.getRenderedSelection().iterator(); index293.hasNext();) {
                            let man = index293.next();
                            {
                                this.plan(new MapToColor.ColorMapManifestation(this, man, this.colorMapper.apply$com_vzome_core_model_Manifestation(man)));
                                this.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} result
                     */
                    getXmlAttributes(result) {
                        result.setAttribute(MapToColor.COLORMAPPER_ATTR_NAME, this.colorMapper.getName());
                        this.colorMapper.getXmlAttributes(result);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        let symmetry = this.editor['getSymmetrySystem$java_lang_String'](xml.getAttribute("symmetry"));
                        let colorMapperName = xml.getAttribute(MapToColor.COLORMAPPER_ATTR_NAME);
                        this.colorMapper = com.vzome.core.edits.ManifestationColorMappers.getColorMapper$java_lang_String$com_vzome_core_editor_api_OrbitSource(colorMapperName, symmetry);
                        this.colorMapper.setXmlAttributes(xml);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "MapToColor";
                    }
                }
                MapToColor.COLORMAPPER_ATTR_NAME = "colorMapper";
                edits.MapToColor = MapToColor;
                MapToColor["__class"] = "com.vzome.core.edits.MapToColor";
                (function (MapToColor) {
                    class ColorMapManifestation {
                        constructor(__parent, manifestation, color) {
                            this.__parent = __parent;
                            if (this.mManifestation === undefined)
                                this.mManifestation = null;
                            if (this.oldColor === undefined)
                                this.oldColor = null;
                            if (this.newColor === undefined)
                                this.newColor = null;
                            this.mManifestation = manifestation;
                            this.newColor = color;
                            this.oldColor = manifestation.getColor();
                        }
                        /**
                         *
                         */
                        redo() {
                            this.__parent.mManifestations.setColor(this.mManifestation, this.newColor);
                        }
                        /**
                         *
                         */
                        undo() {
                            this.__parent.mManifestations.setColor(this.mManifestation, this.oldColor);
                        }
                        /**
                         *
                         * @param {*} doc
                         * @return {*}
                         */
                        getXml(doc) {
                            let result = doc.createElement("color");
                            com.vzome.xml.DomUtils.addAttribute(result, "rgb", this.newColor.toString());
                            let man = this.mManifestation.getXml(doc);
                            result.appendChild(man);
                            return result;
                        }
                    }
                    MapToColor.ColorMapManifestation = ColorMapManifestation;
                    ColorMapManifestation["__class"] = "com.vzome.core.edits.MapToColor.ColorMapManifestation";
                    ColorMapManifestation["__interfaces"] = ["com.vzome.core.editor.api.SideEffects.SideEffect"];
                })(MapToColor = edits.MapToColor || (edits.MapToColor = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ColorManifestations extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editorModel) {
                        super(editorModel);
                        if (this.color === undefined)
                            this.color = null;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        let mode = props.get("mode");
                        if (mode != null)
                            this.initialize(new com.vzome.core.construction.Color(mode));
                    }
                    /*private*/ initialize(color) {
                        this.color = color;
                        for (let index294 = this.mSelection.iterator(); index294.hasNext();) {
                            let m = index294.next();
                            {
                                if (m.isRendered())
                                    this.colorManifestation(m, color);
                                this.unselect$com_vzome_core_model_Manifestation$boolean(m, true);
                            }
                        }
                    }
                    /**
                     *
                     * @param {*} result
                     */
                    getXmlAttributes(result) {
                        result.setAttribute("red", "" + this.color.getRed());
                        result.setAttribute("green", "" + this.color.getGreen());
                        result.setAttribute("blue", "" + this.color.getBlue());
                        let alpha = this.color.getAlpha();
                        if (alpha < 255)
                            result.setAttribute("alpha", "" + alpha);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        if (format.loadToRender()) {
                            let red = xml.getAttribute("red");
                            let green = xml.getAttribute("green");
                            let blue = xml.getAttribute("blue");
                            let alphaStr = xml.getAttribute("alpha");
                            let alpha = (alphaStr == null || /* isEmpty */ (alphaStr.length === 0)) ? 255 : javaemul.internal.IntegerHelper.parseInt(alphaStr);
                            this.initialize(new com.vzome.core.construction.Color(javaemul.internal.IntegerHelper.parseInt(red), javaemul.internal.IntegerHelper.parseInt(green), javaemul.internal.IntegerHelper.parseInt(blue), alpha));
                        }
                        else
                            this.initialize(null);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "setItemColor";
                    }
                }
                edits.ColorManifestations = ColorManifestations;
                ColorManifestations["__class"] = "com.vzome.core.edits.ColorManifestations";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ImportMesh extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        if (this.meshData === undefined)
                            this.meshData = null;
                        if (this.scale === undefined)
                            this.scale = null;
                        if (this.projection === undefined)
                            this.projection = null;
                        if (this.editor === undefined)
                            this.editor = null;
                        this.editor = editor;
                    }
                    /**
                     *
                     * @param {*} params
                     */
                    configure(params) {
                        let field = this.mManifestations.getField();
                        this.meshData = params.get("vef");
                        this.projection = params.get("projection");
                        this.scale = params.get("scale");
                        if (this.scale == null) {
                            this.scale = field.one();
                        }
                        let mode = params.getOrDefault("mode", "");
                        switch ((mode)) {
                            case "":
                                break;
                            case "clipboard":
                                if (this.meshData != null && !((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(this.meshData, "vZome VEF") && !((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(this.meshData, "{"))
                                    this.meshData = null;
                                break;
                            case "Quaternion":
                                break;
                            default:
                                this.setProjection(mode, field);
                                break;
                        }
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return this.meshData == null;
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.scale != null)
                            com.vzome.xml.DomUtils.addAttribute(element, "scale", this.scale.toString(com.vzome.core.algebra.AlgebraicField.ZOMIC_FORMAT));
                        if (this.projection != null) {
                            let name = this.projection.getProjectionName();
                            if (!((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })("", name)) {
                                com.vzome.xml.DomUtils.addAttribute(element, "projection", this.projection.getProjectionName());
                                this.projection.getXmlAttributes(element);
                            }
                        }
                        let textNode = element.getOwnerDocument().createTextNode(com.vzome.core.commands.XmlSaveFormat.escapeNewlines(this.meshData));
                        element.appendChild(textNode);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        let field = format.getField();
                        this.scale = format.parseRationalNumber(xml, "scale");
                        if (this.scale == null) {
                            this.scale = field.one();
                        }
                        this.meshData = xml.getTextContent();
                        let projectionName = xml.getAttribute("projection");
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("", projectionName)) {
                            let quaternion = format.parseRationalVector(xml, "quaternion");
                            this.projection = quaternion == null ? null : new com.vzome.core.math.QuaternionProjection(field, null, quaternion);
                        }
                        else {
                            this.setProjection(projectionName, field);
                        }
                        if (this.projection != null) {
                            this.projection.setXmlAttributes(xml);
                        }
                    }
                    setProjection(projectionName, field) {
                        switch ((projectionName)) {
                            case "Quaternion":
                                this.projection = new com.vzome.core.math.QuaternionProjection(field, null, null);
                                break;
                            case "SixCube":
                                this.projection = new com.vzome.core.math.SixCubeProjection(field);
                                break;
                            case "Tetrahedral":
                                this.projection = new com.vzome.core.math.TetrahedralProjection(field);
                                break;
                            case "Perspective":
                                this.projection = new com.vzome.core.math.PerspectiveProjection(field, null);
                                break;
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.meshData == null)
                            return;
                        let offset = null;
                        let pointFound = false;
                        for (let index295 = this.mSelection.iterator(); index295.hasNext();) {
                            let man = index295.next();
                            {
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    let nextPoint = man.getFirstConstruction();
                                    if (!pointFound) {
                                        pointFound = true;
                                        offset = nextPoint.getLocation();
                                    }
                                    else {
                                        offset = null;
                                        break;
                                    }
                                }
                                if (this.deselectInputs())
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        let field = this.mManifestations.getField();
                        let events = new com.vzome.core.editor.api.ManifestConstructions(this);
                        let registry = new ImportMesh.ImportMesh$0(this, field);
                        if (this.projection == null)
                            this.projection = new com.vzome.core.math.Projection.Default(field);
                        try {
                            this.parseMeshData(offset, events, registry);
                        }
                        catch (e) {
                            throw new com.vzome.core.commands.Command.Failure("The selected file has incorrect content for this import.\n" + e.message);
                        }
                        ;
                        this.redo();
                    }
                    deselectInputs() {
                        return true;
                    }
                }
                edits.ImportMesh = ImportMesh;
                ImportMesh["__class"] = "com.vzome.core.edits.ImportMesh";
                (function (ImportMesh) {
                    class ImportMesh$0 {
                        constructor(__parent, field) {
                            this.field = field;
                            this.__parent = __parent;
                        }
                        /**
                         *
                         * @param {string} name
                         * @return {*}
                         */
                        getField(name) {
                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(this.field.getName(), name))
                                return this.field;
                            else
                                return null;
                        }
                    }
                    ImportMesh.ImportMesh$0 = ImportMesh$0;
                    ImportMesh$0["__interfaces"] = ["com.vzome.core.algebra.AlgebraicField.Registry"];
                })(ImportMesh = edits.ImportMesh || (edits.ImportMesh = {}));
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class Delete extends com.vzome.core.editor.api.ChangeManifestations {
                    /**
                     *
                     */
                    perform() {
                        let inputs = (new java.util.ArrayList());
                        for (let index296 = this.mSelection.iterator(); index296.hasNext();) {
                            let man = index296.next();
                            {
                                inputs.add(man);
                                this.unselect$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        this.redo();
                        for (let index297 = inputs.iterator(); index297.hasNext();) {
                            let man = index297.next();
                            {
                                this.deleteManifestation(man);
                            }
                        }
                        super.perform();
                    }
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "Delete";
                    }
                }
                edits.Delete = Delete;
                Delete["__class"] = "com.vzome.core.edits.Delete";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class AffineTransformAll extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editorModel) {
                        super(editorModel);
                        if (this.center === undefined)
                            this.center = null;
                        this.center = editorModel.getCenterPoint();
                    }
                    /**
                     *
                     */
                    perform() {
                        let s1 = null;
                        let s2 = null;
                        let s3 = null;
                        for (let index298 = this.mSelection.iterator(); index298.hasNext();) {
                            let man = index298.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (s1 == null)
                                        s1 = man.getFirstConstruction();
                                    else if (s2 == null)
                                        s2 = man.getFirstConstruction();
                                    else if (s3 == null)
                                        s3 = man.getFirstConstruction();
                                }
                            }
                        }
                        if (s3 == null || s2 == null || s1 == null)
                            throw new com.vzome.core.commands.Command.Failure("three struts required");
                        this.redo();
                        let transform = new com.vzome.core.construction.ChangeOfBasis(s1, s2, s3, this.center, true);
                        for (let index299 = this.mManifestations.iterator(); index299.hasNext();) {
                            let m = index299.next();
                            {
                                if (!m.isRendered())
                                    continue;
                                let c = m.getFirstConstruction();
                                let result = transform.transform$com_vzome_core_construction_Construction(c);
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(result));
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "AffineTransformAll";
                    }
                }
                edits.AffineTransformAll = AffineTransformAll;
                AffineTransformAll["__class"] = "com.vzome.core.edits.AffineTransformAll";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class Parallelepiped extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "Parallelepiped";
                    }
                    /**
                     *
                     */
                    perform() {
                        let errorMsg = "Parallelepiped command requires three selected struts with a common vertex.";
                        let strut1 = null;
                        let strut2 = null;
                        let strut3 = null;
                        for (let index300 = this.mSelection.iterator(); index300.hasNext();) {
                            let man = index300.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (strut1 == null) {
                                        strut1 = "com.vzome.core.model.Strut".cast(man);
                                    }
                                    else if (strut2 == null) {
                                        strut2 = "com.vzome.core.model.Strut".cast(man);
                                    }
                                    else if (strut3 == null) {
                                        strut3 = "com.vzome.core.model.Strut".cast(man);
                                    }
                                    else
                                        this.fail(errorMsg);
                                }
                                else
                                    this.fail(errorMsg);
                            }
                        }
                        if (strut1 == null || strut2 == null || strut3 == null) {
                            this.fail(errorMsg);
                        }
                        let s1 = com.vzome.core.construction.Segment.cast(strut1.getFirstConstruction());
                        let s2 = com.vzome.core.construction.Segment.cast(strut2.getFirstConstruction());
                        let s3 = com.vzome.core.construction.Segment.cast(strut3.getFirstConstruction());
                        let offset1 = s1.getOffset();
                        let offset2 = s2.getOffset();
                        let offset3 = s3.getOffset();
                        let v0 = null;
                        let v1 = null;
                        let v2 = null;
                        let v3 = null;
                        {
                            let s1s = s1.getStart();
                            let s1e = s1.getEnd();
                            let s2s = s2.getStart();
                            let s2e = s2.getEnd();
                            if (s1s.equals(s2s)) {
                                v1 = s1e;
                                v2 = s2e;
                                v0 = s2s;
                            }
                            else if (s1e.equals(s2s)) {
                                v1 = s1s;
                                v2 = s2e;
                                v0 = s2s;
                                offset1 = offset1.negate();
                            }
                            else if (s1e.equals(s2e)) {
                                v1 = s1s;
                                v2 = s2s;
                                v0 = s2e;
                                offset2 = offset2.negate();
                                offset1 = offset1.negate();
                            }
                            else if (s1s.equals(s2e)) {
                                v1 = s1e;
                                v2 = s2s;
                                v0 = s2e;
                                offset2 = offset2.negate();
                            }
                            else {
                                this.fail(errorMsg);
                            }
                            let s3s = s3.getStart();
                            let s3e = s3.getEnd();
                            if (s3s.equals(v0)) {
                                v3 = s3e;
                            }
                            else if (s3e.equals(v0)) {
                                v3 = s3s;
                                offset3 = offset3.negate();
                            }
                            else {
                                this.fail(errorMsg);
                            }
                        }
                        ;
                        this.redo();
                        let p0 = new com.vzome.core.construction.FreePoint(v0);
                        let p1 = new com.vzome.core.construction.FreePoint(v1);
                        let p2 = new com.vzome.core.construction.FreePoint(v2);
                        let p3 = new com.vzome.core.construction.FreePoint(v3);
                        this.manifestConstruction(p0);
                        this.manifestConstruction(p1);
                        this.manifestConstruction(p2);
                        this.manifestConstruction(p3);
                        this.redo();
                        let v4 = v2.plus(offset3);
                        let p4 = new com.vzome.core.construction.FreePoint(v4);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p4));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p2, p4)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p3, p4)));
                        let v5 = v3.plus(offset1);
                        let p5 = new com.vzome.core.construction.FreePoint(v5);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p5));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p1, p5)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p3, p5)));
                        let v6 = v1.plus(offset2);
                        let p6 = new com.vzome.core.construction.FreePoint(v6);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p6));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p1, p6)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p2, p6)));
                        let v7 = v4.plus(offset1);
                        let p7 = new com.vzome.core.construction.FreePoint(v7);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(p7));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p4, p7)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p5, p7)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(p6, p7)));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p0, p3, p4, p2])));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p0, p1, p5, p3])));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p0, p2, p6, p1])));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p7, p4, p3, p5])));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p7, p6, p2, p4])));
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices([p7, p5, p1, p6])));
                        this.redo();
                    }
                }
                edits.Parallelepiped = Parallelepiped;
                Parallelepiped["__class"] = "com.vzome.core.edits.Parallelepiped";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                /**
                 * @author David Hall
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class SelectCollinear extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(editor) {
                        super(editor);
                        this.vector1 = null;
                        this.vector2 = null;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        let strut = props.get("picked");
                        if (strut != null) {
                            this.vector1 = strut.getLocation();
                            this.vector2 = strut.getEnd();
                        }
                    }
                    /**
                     *
                     */
                    perform() {
                        if (this.vector1 == null || this.vector2 == null) {
                            let lastStrut = this.getLastSelectedStrut();
                            if (lastStrut != null) {
                                this.vector1 = lastStrut.getLocation();
                                this.vector2 = lastStrut.getEnd();
                            }
                            else {
                                for (let index301 = this.getSelectedConnectors().iterator(); index301.hasNext();) {
                                    let ball = index301.next();
                                    {
                                        this.vector1 = this.vector2;
                                        this.vector2 = ball.getLocation();
                                    }
                                }
                            }
                        }
                        if (this.vector1 == null || this.vector2 == null) {
                            throw new com.vzome.core.commands.Command.Failure("select a strut or two balls as a reference.");
                        }
                        this.unselectAll();
                        let balls = (new java.util.TreeSet());
                        for (let index302 = this.getVisibleConnectors$java_util_function_Predicate((ball) => { return this.isCollinearWith(ball); }).iterator(); index302.hasNext();) {
                            let ball = index302.next();
                            {
                                balls.add(ball);
                            }
                        }
                        let struts = (new java.util.TreeSet());
                        for (let index303 = this.getVisibleStruts$().iterator(); index303.hasNext();) {
                            let strut = index303.next();
                            {
                                if (this.isCollinearWith$com_vzome_core_model_Strut(strut)) {
                                    struts.add(strut);
                                }
                            }
                        }
                        for (let index304 = struts.iterator(); index304.hasNext();) {
                            let strut = index304.next();
                            {
                                this.select$com_vzome_core_model_Manifestation(strut);
                            }
                        }
                        for (let index305 = balls.iterator(); index305.hasNext();) {
                            let ball = index305.next();
                            {
                                this.select$com_vzome_core_model_Manifestation(ball);
                            }
                        }
                        let level = java.util.logging.Level.FINER;
                        if (com.vzome.core.editor.api.ChangeSelection.logger_$LI$().isLoggable(level)) {
                            let sb = new java.lang.StringBuilder("Selected:\n");
                            let indent = "  ";
                            for (let index306 = struts.iterator(); index306.hasNext();) {
                                let strut = index306.next();
                                {
                                    sb.append(indent).append(strut.toString()).append("\n");
                                }
                            }
                            for (let index307 = balls.iterator(); index307.hasNext();) {
                                let ball = index307.next();
                                {
                                    sb.append(indent).append(ball.toString()).append("\n");
                                }
                            }
                            com.vzome.core.editor.api.ChangeSelection.logger_$LI$().log(level, sb.toString());
                        }
                        super.perform();
                    }
                    isCollinearWith$com_vzome_core_model_Connector(ball) {
                        return this.isCollinear(ball.getLocation());
                    }
                    isCollinearWith(ball) {
                        if (((ball != null && (ball["__interfaces"] != null && ball["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || ball.constructor != null && ball.constructor["__interfaces"] != null && ball.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || ball === null)) {
                            return this.isCollinearWith$com_vzome_core_model_Connector(ball);
                        }
                        else if (((ball != null && (ball["__interfaces"] != null && ball["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || ball.constructor != null && ball.constructor["__interfaces"] != null && ball.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || ball === null)) {
                            return this.isCollinearWith$com_vzome_core_model_Strut(ball);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /*private*/ isCollinearWith$com_vzome_core_model_Strut(strut) {
                        return this.isCollinear(strut.getLocation()) && this.isCollinear(strut.getEnd());
                    }
                    /*private*/ isCollinear(vec) {
                        return com.vzome.core.algebra.AlgebraicVectors.areCollinear$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector$com_vzome_core_algebra_AlgebraicVector(vec, this.vector1, this.vector2);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SelectCollinear";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        com.vzome.xml.DomUtils.addAttribute(element, "vector1", this.vector1.toParsableString());
                        com.vzome.xml.DomUtils.addAttribute(element, "vector2", this.vector2.toParsableString());
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.vector1 = format.parseRationalVector(xml, "vector1");
                        this.vector2 = format.parseRationalVector(xml, "vector2");
                    }
                }
                edits.SelectCollinear = SelectCollinear;
                SelectCollinear["__class"] = "com.vzome.core.edits.SelectCollinear";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor_5) {
                /**
                 * Just a mechanism to incorporate the legacy edit mechanism into the new undo/redo.
                 *
                 * @author Scott Vorthmann 2006
                 * @param {com.vzome.core.commands.AbstractCommand} cmd
                 * @param {*} editor
                 * @class
                 * @extends com.vzome.core.editor.api.ChangeManifestations
                 */
                class CommandEdit extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(cmd, editor) {
                        super(editor);
                        if (this.mEditorModel === undefined)
                            this.mEditorModel = null;
                        if (this.mCommand === undefined)
                            this.mCommand = null;
                        if (this.mAttrs === undefined)
                            this.mAttrs = null;
                        this.mEditorModel = editor;
                        this.mCommand = cmd;
                    }
                    static logger_$LI$() { if (CommandEdit.logger == null)
                        CommandEdit.logger = java.util.logging.Logger.getLogger("com.vzome.core.editor.CommandEdit"); return CommandEdit.logger; }
                    ;
                    static loadAndPerformLgger_$LI$() { if (CommandEdit.loadAndPerformLgger == null)
                        CommandEdit.loadAndPerformLgger = java.util.logging.Logger.getLogger("com.vzome.core.editor.CommandEdit.loadAndPerform"); return CommandEdit.loadAndPerformLgger; }
                    ;
                    /**
                     *
                     * @return {boolean}
                     */
                    groupingAware() {
                        return true;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        let cmdName = (c => c["__class"] ? c["__class"] : c["name"])(this.mCommand.constructor);
                        let lastDot = cmdName.lastIndexOf('.');
                        return cmdName.substring(lastDot + 1 + "Command".length);
                    }
                    /**
                     *
                     * @param {*} result
                     */
                    getXmlAttributes(result) {
                        this.mCommand.getXml(result, this.mAttrs);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.mAttrs = this.mCommand.setXml(xml, format);
                        this.mAttrs.put(com.vzome.core.commands.Command.LOADING_FROM_FILE, javaemul.internal.BooleanHelper.TRUE);
                    }
                    /**
                     *
                     */
                    perform() {
                        let isHide = (this.mCommand != null && this.mCommand instanceof com.vzome.core.commands.CommandHide);
                        if (CommandEdit.logger_$LI$().isLoggable(java.util.logging.Level.FINER)) {
                            CommandEdit.logger_$LI$().finer("------------------- CommandEdit");
                        }
                        if (this.mCommand.ordersSelection())
                            this.setOrderedSelection(true);
                        let constrsBefore = new com.vzome.core.construction.ConstructionList();
                        for (let index308 = this.mSelection.iterator(); index308.hasNext();) {
                            let man = index308.next();
                            {
                                if (CommandEdit.logger_$LI$().isLoggable(java.util.logging.Level.FINER)) {
                                    CommandEdit.logger_$LI$().finer("----------- manifestation: " + man.toString());
                                    for (let iterator = man.getConstructions(); iterator.hasNext();) {
                                        {
                                            let c = iterator.next();
                                            CommandEdit.logger_$LI$().finer("   " + c.toString());
                                        }
                                        ;
                                    }
                                }
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (isHide)
                                    this.hideManifestation(man);
                                else {
                                    let construction = man.getFirstConstruction();
                                    constrsBefore.add(construction);
                                }
                            }
                        }
                        this.redo();
                        if (isHide)
                            return;
                        if (this.mAttrs == null)
                            this.mAttrs = new com.vzome.core.commands.AttributeMap();
                        let symmAxis = this.mEditorModel.getSymmetrySegment();
                        if (symmAxis != null)
                            this.mAttrs.put(com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME, symmAxis);
                        this.mAttrs.put(com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME, this.mEditorModel.getCenterPoint());
                        this.mAttrs.put(com.vzome.core.commands.Command.FIELD_ATTR_NAME, this.mManifestations.getField());
                        let news = new CommandEdit.NewConstructions();
                        let selectionAfter = null;
                        let signature = this.mCommand.getParameterSignature();
                        let actualsLen = constrsBefore.size();
                        if ((signature.length === actualsLen) || (signature.length === 1 && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(signature[0][0], com.vzome.core.commands.Command.GENERIC_PARAM_NAME))) {
                            try {
                                selectionAfter = this.mCommand.apply(constrsBefore, this.mAttrs, news);
                            }
                            catch (f) {
                                this.undo();
                                throw f;
                            }
                            ;
                        }
                        else if (signature.length > actualsLen) {
                            this.fail("Too few objects in the selection.");
                        }
                        else if (signature.length === 1) {
                            let partial;
                            selectionAfter = new com.vzome.core.construction.ConstructionList();
                            for (let i = 0; i < actualsLen; i++) {
                                {
                                    let param = constrsBefore.get(i);
                                    if (signature[0][1].isAssignableFrom(param.constructor)) {
                                        let single = new com.vzome.core.construction.ConstructionList();
                                        single.addConstruction(param);
                                        partial = this.mCommand.apply(single, this.mAttrs, news);
                                        selectionAfter.addAll(partial);
                                    }
                                    else
                                        selectionAfter.add(param);
                                }
                                ;
                            }
                        }
                        else
                            this.fail("Too many objects in the selection.");
                        for (let index309 = news.iterator(); index309.hasNext();) {
                            let c = index309.next();
                            {
                                this.manifestConstruction(c);
                            }
                        }
                        for (let index310 = selectionAfter.iterator(); index310.hasNext();) {
                            let cons = index310.next();
                            {
                                if (cons.failed()) {
                                    CommandEdit.logBugAccommodation("failed construction");
                                    this.mEditorModel.addFailedConstruction(cons);
                                    continue;
                                }
                                let man = this.manifestConstruction(cons);
                                if (man != null)
                                    this.select$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     * @param {*} context
                     */
                    loadAndPerform(xml, format, context) {
                        let cmdName = null;
                        if (format.selectionsNotSaved())
                            cmdName = xml.getLocalName();
                        else if (format.commandEditsCompacted())
                            cmdName = "Command" + xml.getLocalName();
                        else
                            cmdName = xml.getAttribute("command");
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(cmdName, "CommandIcosahedralSymmetry"))
                            cmdName = "CommandSymmetry";
                        this.mCommand = context.createLegacyCommand(cmdName);
                        if (format.selectionsNotSaved()) {
                            let selectedBefore = (new java.util.LinkedHashSet());
                            context.performAndRecord(new com.vzome.core.editor.BeginBlock(null));
                            this.mAttrs = new com.vzome.core.commands.AttributeMap();
                            let nodes = xml.getChildNodes();
                            for (let j = 0; j < nodes.getLength(); j++) {
                                {
                                    let kid2 = nodes.item(j);
                                    if (kid2 != null && (kid2["__interfaces"] != null && kid2["__interfaces"].indexOf("org.w3c.dom.Element") >= 0 || kid2.constructor != null && kid2.constructor["__interfaces"] != null && kid2.constructor["__interfaces"].indexOf("org.w3c.dom.Element") >= 0)) {
                                        let attrOrParam = kid2;
                                        let apName = attrOrParam.getLocalName();
                                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                            return o1.equals(o2);
                                        }
                                        else {
                                            return o1 === o2;
                                        } })(apName, "attr")) {
                                            let attrName = attrOrParam.getAttribute("name");
                                            if ( /* endsWith */((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(attrName, ".symmetry.center"))
                                                attrName = com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME;
                                            else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                                return o1.equals(o2);
                                            }
                                            else {
                                                return o1 === o2;
                                            } })(attrName, "reflection.mirror.normal.segment"))
                                                attrName = com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME;
                                            let val = com.vzome.xml.DomUtils.getFirstChildElement$org_w3c_dom_Element(attrOrParam);
                                            let valName = val.getLocalName();
                                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                                return o1.equals(o2);
                                            }
                                            else {
                                                return o1 === o2;
                                            } })(valName, "FreePoint"))
                                                valName = "point";
                                            let value = format.parseAlgebraicObject(valName, val);
                                            if (value === com.vzome.core.commands.XmlSaveFormat.NOT_AN_ATTRIBUTE_$LI$())
                                                value = format.parseConstruction$java_lang_String$org_w3c_dom_Element(valName, val);
                                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                                return o1.equals(o2);
                                            }
                                            else {
                                                return o1 === o2;
                                            } })(attrName, com.vzome.core.commands.CommandTransform.SYMMETRY_CENTER_ATTR_NAME)) {
                                                let c = new com.vzome.core.construction.FreePoint(value.getLocation().projectTo3d(true));
                                                context.performAndRecord(new com.vzome.core.edits.SymmetryCenterChange(this.mEditorModel, c));
                                            }
                                            else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                                return o1.equals(o2);
                                            }
                                            else {
                                                return o1 === o2;
                                            } })(attrName, com.vzome.core.commands.CommandTransform.SYMMETRY_AXIS_ATTR_NAME)) {
                                                context.performAndRecord(new com.vzome.core.edits.SymmetryAxisChange(this.mEditorModel, value));
                                                if (!this.mCommand.attributeIs3D(attrName)) {
                                                    let vector = value.getOffset();
                                                    this.mCommand.setQuaternion(vector);
                                                }
                                            }
                                            else
                                                this.mAttrs.put(attrName, value);
                                        }
                                        else {
                                            let c = format.parseConstruction$java_lang_String$org_w3c_dom_Element(apName, attrOrParam);
                                            if (c != null) {
                                                if (this.mEditorModel.hasFailedConstruction(c)) {
                                                    CommandEdit.logBugAccommodation("skip selecting a failed construction");
                                                    continue;
                                                }
                                                let m = this.getManifestation(c);
                                                if (m == null || m.isUnnecessary()) {
                                                    CommandEdit.loadAndPerformLgger_$LI$().severe("CommandEdit parameter: " + attrOrParam.toString());
                                                    throw new com.vzome.core.commands.Command.Failure("no manifestation to be selected.");
                                                }
                                                if (!selectedBefore.contains(m))
                                                    selectedBefore.add(m);
                                            }
                                        }
                                    }
                                }
                                ;
                            }
                            if (selectedBefore.size() > (this.mManifestations.size() / 2 | 0)) {
                                let toUnselect = (new java.util.ArrayList());
                                for (let index311 = this.mManifestations.iterator(); index311.hasNext();) {
                                    let m = index311.next();
                                    {
                                        if (!selectedBefore.contains(m))
                                            toUnselect.add(m);
                                    }
                                }
                                let edit = new com.vzome.core.edits.SelectAll(this.mEditorModel);
                                context.performAndRecord(edit);
                                for (let index312 = toUnselect.iterator(); index312.hasNext();) {
                                    let m = index312.next();
                                    {
                                        edit = new com.vzome.core.edits.SelectManifestation(this.mEditorModel, m);
                                        context.performAndRecord(edit);
                                    }
                                }
                            }
                            else {
                                let edit = new com.vzome.core.edits.DeselectAll(this.mEditorModel);
                                context.performAndRecord(edit);
                                for (let index313 = selectedBefore.iterator(); index313.hasNext();) {
                                    let m = index313.next();
                                    {
                                        edit = new com.vzome.core.edits.SelectManifestation(this.mEditorModel, m);
                                        context.performAndRecord(edit);
                                    }
                                }
                            }
                            context.performAndRecord(new com.vzome.core.editor.EndBlock(null));
                            this.redo();
                            if (this.mCommand != null && this.mCommand instanceof com.vzome.core.commands.CommandObliquePentagon) {
                                let edit = new com.vzome.core.edits.AffinePentagon(this.mEditorModel);
                                context.performAndRecord(edit);
                                return;
                            }
                            this.mCommand.setFixedAttributes(this.mAttrs, format);
                            this.mAttrs.put(com.vzome.core.commands.Command.LOADING_FROM_FILE, javaemul.internal.BooleanHelper.TRUE);
                            context.performAndRecord(this);
                        }
                        else
                            super.loadAndPerform(xml, format, context);
                    }
                }
                editor_5.CommandEdit = CommandEdit;
                CommandEdit["__class"] = "com.vzome.core.editor.CommandEdit";
                (function (CommandEdit) {
                    class NewConstructions extends java.util.ArrayList {
                        /**
                         *
                         * @param {com.vzome.core.construction.Construction} c
                         */
                        constructionAdded(c) {
                            this.add(c);
                        }
                        constructor() {
                            super();
                        }
                    }
                    CommandEdit.NewConstructions = NewConstructions;
                    NewConstructions["__class"] = "com.vzome.core.editor.CommandEdit.NewConstructions";
                    NewConstructions["__interfaces"] = ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "com.vzome.core.construction.ConstructionChanges", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
                })(CommandEdit = editor_5.CommandEdit || (editor_5.CommandEdit = {}));
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class Tool extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(id, tools) {
                        super(tools.getEditorModel());
                        if (this.id === undefined)
                            this.id = null;
                        if (this.tools === undefined)
                            this.tools = null;
                        this.parameters = (new java.util.ArrayList());
                        if (this.category === undefined)
                            this.category = null;
                        if (this.predefined === undefined)
                            this.predefined = false;
                        if (this.hidden === undefined)
                            this.hidden = false;
                        if (this.label === undefined)
                            this.label = null;
                        if (this.selectInputs === undefined)
                            this.selectInputs = false;
                        if (this.deleteInputs === undefined)
                            this.deleteInputs = false;
                        this.pcs = new java.beans.PropertyChangeSupport(this);
                        this.tools = tools;
                        this.id = id;
                        this.selectInputs = true;
                        this.deleteInputs = false;
                    }
                    isSelectInputs() {
                        return this.selectInputs;
                    }
                    isDeleteInputs() {
                        return this.deleteInputs;
                    }
                    setInputBehaviors(selectInputs, deleteInputs) {
                        this.selectInputs = selectInputs;
                        this.deleteInputs = deleteInputs;
                    }
                    addPropertyChangeListener(listener) {
                        this.pcs.addPropertyChangeListener(listener);
                    }
                    setCategory(category) {
                        this.category = category;
                    }
                    addParameter(c) {
                        this.parameters.add(c);
                    }
                    getParameters() {
                        return this.parameters;
                    }
                    setPredefined(value) {
                        this.predefined = value;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return false;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return true;
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     */
                    perform() {
                        let error = this.checkSelection(true);
                        if (error != null)
                            throw new com.vzome.core.commands.Command.Failure(error);
                        this.tools.put(this.getId(), this);
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("name", this.id);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getId() {
                        return this.id;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return this.category;
                    }
                    /**
                     *
                     * @param {boolean} selectInputs
                     * @param {boolean} deleteInputs
                     * @param {boolean} createOutputs
                     * @param {boolean} selectOutputs
                     */
                    apply(selectInputs, deleteInputs, createOutputs, selectOutputs) {
                        this.tools.applyTool(this, selectInputs, deleteInputs, createOutputs, selectOutputs);
                    }
                    /**
                     *
                     */
                    selectParameters() {
                        this.tools.selectToolParameters(this);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isPredefined() {
                        return this.predefined;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getLabel() {
                        return this.label;
                    }
                    /**
                     *
                     * @param {string} label
                     */
                    setLabel(label) {
                        this.label = label;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isHidden() {
                        return this.hidden;
                    }
                    /**
                     *
                     * @param {boolean} hidden
                     */
                    setHidden(hidden) {
                        this.hidden = hidden;
                        this.tools.hideTool(this);
                    }
                }
                editor.Tool = Tool;
                Tool["__class"] = "com.vzome.core.editor.Tool";
                Tool["__interfaces"] = ["com.vzome.api.Tool"];
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class ApplyTool extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(tools, tool, selectInputs, deleteInputs, createOutputs, selectOutputs, redundantOutputs) {
                        super(tools.getEditorModel());
                        if (this.tool === undefined)
                            this.tool = null;
                        if (this.selectInputs === undefined)
                            this.selectInputs = false;
                        if (this.deselectOutputs === undefined)
                            this.deselectOutputs = false;
                        if (this.justSelect === undefined)
                            this.justSelect = false;
                        if (this.hideInputs === undefined)
                            this.hideInputs = false;
                        if (this.deleteInputs === undefined)
                            this.deleteInputs = false;
                        if (this.redundantOutputs === undefined)
                            this.redundantOutputs = false;
                        if (this.tools === undefined)
                            this.tools = null;
                        this.tools = tools;
                        this.tool = tool;
                        this.selectInputs = selectInputs;
                        this.deleteInputs = deleteInputs;
                        this.hideInputs = false;
                        this.deselectOutputs = !selectOutputs;
                        this.justSelect = !createOutputs;
                        this.redundantOutputs = redundantOutputs;
                    }
                    /**
                     *
                     */
                    perform() {
                        let inputs = (new java.util.ArrayList());
                        for (let index314 = this.mSelection.iterator(); index314.hasNext();) {
                            let man = index314.next();
                            {
                                if (this.deleteInputs && this.tool.needsInput()) {
                                    super.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                                    super.deleteManifestation(man);
                                }
                                else if (this.hideInputs && this.tool.needsInput()) {
                                    super.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                                    super.hideManifestation(man);
                                }
                                else if (!this.selectInputs)
                                    super.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                                if (this.tool.needsInput())
                                    inputs.add(man);
                            }
                        }
                        this.redo();
                        this.tool.prepare(this);
                        if (this.tool.needsInput()) {
                            for (let index315 = inputs.iterator(); index315.hasNext();) {
                                let man = index315.next();
                                {
                                    let c = man.toConstruction();
                                    c.setColor(man.getColor());
                                    this.tool.performEdit(c, this);
                                }
                            }
                        }
                        else {
                            for (let index316 = this.mManifestations.iterator(); index316.hasNext();) {
                                let man = index316.next();
                                {
                                    this.tool.performSelect(man, this);
                                }
                            }
                        }
                        this.tool.complete(this);
                        this.redo();
                        super.perform();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        if (this.redundantOutputs)
                            return "ApplyTool";
                        else
                            return "ToolApplied";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("name", this.tool.getId());
                        if (this.selectInputs)
                            element.setAttribute("selectInputs", "true");
                        if (this.deselectOutputs)
                            element.setAttribute("deselectOutputs", "true");
                        if (this.justSelect)
                            element.setAttribute("justSelect", "true");
                        if (this.hideInputs)
                            element.setAttribute("hideInputs", "true");
                        if (this.deleteInputs)
                            element.setAttribute("deleteInputs", "true");
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        let toolName = element.getAttribute("name");
                        this.tool = this.tools.get(toolName);
                        this.selectInputs = this.isAttributeTrue(element, "selectInputs");
                        this.deselectOutputs = this.isAttributeTrue(element, "deselectOutputs");
                        this.justSelect = this.isAttributeTrue(element, "justSelect");
                        this.hideInputs = this.isAttributeTrue(element, "hideInputs");
                        this.deleteInputs = this.isAttributeTrue(element, "deleteInputs");
                    }
                    /*private*/ isAttributeTrue(element, name) {
                        let value = element.getAttribute(name);
                        return value != null && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(value, "true");
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.Construction} c
                     * @return {*}
                     */
                    manifestConstruction(c) {
                        let m = this.getManifestation(c);
                        let preExistsNotHidden = (m != null && m.isRendered());
                        if (this.justSelect) {
                            if (preExistsNotHidden)
                                super.select$com_vzome_core_model_Manifestation$boolean(m, false);
                        }
                        else if (this.redundantOutputs || !preExistsNotHidden) {
                            m = super.manifestConstruction(c);
                            if (!this.deselectOutputs)
                                super.select$com_vzome_core_model_Manifestation$boolean(m, true);
                        }
                        return m;
                    }
                    select(man, ignoreGroups) {
                        if (((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                            super.select(man, ignoreGroups);
                        }
                        else if (((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                            return this.select$com_vzome_core_model_Manifestation(man);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    select$com_vzome_core_model_Manifestation(m) {
                        if (this.tool.needsInput())
                            throw new java.lang.UnsupportedOperationException("select is not supported within Tool.performEdit");
                        if (!m.isRendered())
                            super.showManifestation(m);
                        super.select$com_vzome_core_model_Manifestation$boolean(m, true);
                    }
                    unselect(man, ignoreGroups) {
                        if (((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                            super.unselect(man, ignoreGroups);
                        }
                        else if (((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                            return this.unselect$com_vzome_core_model_Manifestation(man);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    unselect$com_vzome_core_model_Manifestation(man) {
                        throw new java.lang.UnsupportedOperationException("unselect is not supported within Tool.performEdit");
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    showManifestation(m) {
                        throw new java.lang.UnsupportedOperationException("showManifestation is not supported within Tool.performEdit");
                    }
                    /**
                     *
                     * @param {*} m
                     */
                    hideManifestation(m) {
                        throw new java.lang.UnsupportedOperationException("hideManifestation is not supported within Tool.performEdit");
                    }
                }
                editor.ApplyTool = ApplyTool;
                ApplyTool["__class"] = "com.vzome.core.editor.ApplyTool";
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var editor;
            (function (editor) {
                class SelectToolParameters extends com.vzome.core.editor.api.ChangeManifestations {
                    constructor(tools, tool) {
                        super(tools.getEditorModel());
                        if (this.tool === undefined)
                            this.tool = null;
                        if (this.tools === undefined)
                            this.tools = null;
                        this.tools = tools;
                        this.tool = tool;
                    }
                    /**
                     *
                     */
                    perform() {
                        for (let index317 = this.mSelection.iterator(); index317.hasNext();) {
                            let man = index317.next();
                            super.unselect$com_vzome_core_model_Manifestation$boolean(man, true);
                        }
                        this.redo();
                        for (let index318 = this.tool.getParameters().iterator(); index318.hasNext();) {
                            let con = index318.next();
                            {
                                let man = this.manifestConstruction(con);
                                this.select$com_vzome_core_model_Manifestation(man);
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SelectToolParameters";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("name", this.tool.getId());
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        let toolName = element.getAttribute("name");
                        this.tool = this.tools.get(toolName);
                    }
                }
                editor.SelectToolParameters = SelectToolParameters;
                SelectToolParameters["__class"] = "com.vzome.core.editor.SelectToolParameters";
            })(editor = core.editor || (core.editor = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectByDiameter extends com.vzome.core.edits.SelectByBoundary {
                    constructor(editor) {
                        super(editor);
                        if (this.center === undefined)
                            this.center = null;
                        if (this.maxRadiusSquared === undefined)
                            this.maxRadiusSquared = null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return SelectByDiameter.NAME;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    usage() {
                        return "This command requires two connectors which define the\ndiameter of a sphere centered at their midpoint.\n\nAll parts that are completely within the sphere will be selected.\n";
                    }
                    adjustBoundary(vectors) {
                        switch ((vectors.size())) {
                            case 1:
                                return null;
                            case 2:
                                this.center = com.vzome.core.algebra.AlgebraicVectors.calculateCentroid(vectors);
                                let v1 = vectors.get(0).minus(this.center);
                                this.maxRadiusSquared = v1.dot(v1);
                                return null;
                        }
                        return "Too many connectors are selected.";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    setBoundary() {
                        this.center = null;
                        this.maxRadiusSquared = null;
                        let vectors = (new java.util.ArrayList());
                        for (let index319 = this.mSelection.iterator(); index319.hasNext();) {
                            let man = index319.next();
                            {
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    vectors.add(man.getLocation());
                                    let errMsg = this.adjustBoundary(vectors);
                                    if (errMsg != null) {
                                        return errMsg;
                                    }
                                }
                            }
                        }
                        if (vectors.isEmpty()) {
                            return "No connectors are selected.";
                        }
                        if (this.center == null || this.maxRadiusSquared == null) {
                            let n = vectors.size();
                            return n === 1 ? "Only one connector is selected." : "Only " + n + " connectors are selected.";
                        }
                        return null;
                    }
                    boundaryContains$com_vzome_core_algebra_AlgebraicVector(v) {
                        v = v.minus(this.center);
                        let vSq = v.dot(v);
                        return vSq.compareTo(this.maxRadiusSquared) <= 0;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v
                     * @return {boolean}
                     */
                    boundaryContains(v) {
                        if (((v != null && v instanceof com.vzome.core.algebra.AlgebraicVector) || v === null)) {
                            return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v);
                        }
                        else if (((v != null && (v["__interfaces"] != null && v["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || v === null)) {
                            super.boundaryContains(v);
                        }
                        else if (((v != null && (v["__interfaces"] != null && v["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Strut(v);
                        }
                        else if (((v != null && (v["__interfaces"] != null && v["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Panel(v);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                SelectByDiameter.NAME = "SelectByDiameter";
                edits.SelectByDiameter = SelectByDiameter;
                SelectByDiameter["__class"] = "com.vzome.core.edits.SelectByDiameter";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectByPlane extends com.vzome.core.edits.SelectByBoundary {
                    constructor(editor) {
                        super(editor);
                        if (this.plane === undefined)
                            this.plane = null;
                        if (this.anchor === undefined)
                            this.anchor = null;
                        if (this.desiredOrientation === undefined)
                            this.desiredOrientation = 0;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return SelectByPlane.NAME;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    usage() {
                        return "This command requires four selected connectors.\n\nThe first three connectors must not be collinear,\nso that they define a plane.\nThe fourth connector must lie outside of that plane,\nand defines which half space you wish to select.\n\nAll parts that are completely within that half-space will be selected.\n";
                    }
                    /**
                     *
                     */
                    perform() {
                        this.setOrderedSelection(true);
                        super.perform();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    setBoundary() {
                        let p1 = null;
                        let p2 = null;
                        let p3 = null;
                        let p4 = null;
                        for (let index320 = this.mSelection.iterator(); index320.hasNext();) {
                            let man = index320.next();
                            {
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (p1 == null) {
                                        p1 = man.getLocation();
                                        continue;
                                    }
                                    if (p2 == null) {
                                        p2 = man.getLocation();
                                        continue;
                                    }
                                    if (p3 == null) {
                                        p3 = man.getLocation();
                                        continue;
                                    }
                                    if (p4 == null) {
                                        p4 = man.getLocation();
                                        continue;
                                    }
                                    else {
                                        return "You have selected more than four connectors.";
                                    }
                                }
                            }
                        }
                        if (p4 == null)
                            return "You have selected fewer than four connectors.";
                        let v1 = new com.vzome.core.algebra.Vector3d(p2.minus(p1));
                        let v2 = new com.vzome.core.algebra.Vector3d(p3.minus(p1));
                        this.plane = v1.outer(v2);
                        this.anchor = p1;
                        this.desiredOrientation = this.orient(p4);
                        if (this.desiredOrientation === 0) {
                            return "Your last selected connector lies in the plane of the other three.";
                        }
                        return null;
                    }
                    /*private*/ orient(point) {
                        let diff = point.minus(this.anchor);
                        let v = new com.vzome.core.algebra.Vector3d(diff);
                        let volume = this.plane.outer(v);
                        if (volume.isZero())
                            return 0;
                        else {
                            let volD = volume.evaluate();
                            return (volD > 0.0) ? 1 : -1;
                        }
                    }
                    boundaryContains$com_vzome_core_algebra_AlgebraicVector(v) {
                        let orientation = this.orient(v);
                        return (orientation === 0) || (orientation === this.desiredOrientation);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v
                     * @return {boolean}
                     */
                    boundaryContains(v) {
                        if (((v != null && v instanceof com.vzome.core.algebra.AlgebraicVector) || v === null)) {
                            return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v);
                        }
                        else if (((v != null && (v["__interfaces"] != null && v["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || v === null)) {
                            super.boundaryContains(v);
                        }
                        else if (((v != null && (v["__interfaces"] != null && v["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Strut(v);
                        }
                        else if (((v != null && (v["__interfaces"] != null && v["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Panel(v);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                SelectByPlane.NAME = "SelectByPlane";
                edits.SelectByPlane = SelectByPlane;
                SelectByPlane["__class"] = "com.vzome.core.edits.SelectByPlane";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ConvexHull3d extends com.vzome.core.edits.ConvexHull {
                    constructor(editorModel) {
                        super(editorModel);
                        this.mode = null;
                        this.generateStruts = true;
                        this.generatePanels = true;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return ConvexHull3d.NAME;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isNoOp() {
                        return (this.generateStruts || this.generatePanels) ? super.isNoOp() : true;
                    }
                    /**
                     *
                     * @param {*} props
                     */
                    configure(props) {
                        this.setMode(props.get("mode"));
                    }
                    /*private*/ setMode(newMode) {
                        this.mode = "";
                        this.generateStruts = true;
                        this.generatePanels = true;
                        if (newMode != null)
                            switch ((newMode)) {
                                case "":
                                    this.mode = newMode;
                                    this.generateStruts = true;
                                    this.generatePanels = true;
                                    break;
                                case "noPanels":
                                    this.mode = newMode;
                                    this.generateStruts = true;
                                    this.generatePanels = false;
                                    break;
                                case "onlyPanels":
                                    this.mode = newMode;
                                    this.generateStruts = false;
                                    this.generatePanels = true;
                                    break;
                                default:
                                    if (com.vzome.core.editor.api.ChangeSelection.logger_$LI$().isLoggable(java.util.logging.Level.WARNING)) {
                                        com.vzome.core.editor.api.ChangeSelection.logger_$LI$().warning(ConvexHull3d.NAME + ": Ignoring unknown mode: \"" + newMode + "\".");
                                    }
                                    break;
                            }
                    }
                    /**
                     *
                     */
                    perform() {
                        let hull3d = new com.vzome.core.math.convexhull.QuickHull3D();
                        hull3d.build$java_util_Collection(this.getSelectedVertexSet(true));
                        this.redo();
                        let vertices = hull3d.getVertices$();
                        let pointMap = (new java.util.HashMap(vertices.length));
                        for (let index321 = 0; index321 < vertices.length; index321++) {
                            let vertex = vertices[index321];
                            {
                                let point = new com.vzome.core.construction.FreePoint(vertex);
                                pointMap.put(vertex, point);
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(point));
                            }
                        }
                        let faces = hull3d.getFaces$();
                        for (let index322 = 0; index322 < faces.length; index322++) {
                            let face = faces[index322];
                            {
                                let points = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(face.length);
                                let startIndex = face[face.length - 1];
                                let start = pointMap.get(vertices[startIndex]);
                                for (let i = 0; i < face.length; i++) {
                                    {
                                        let endIndex = startIndex;
                                        startIndex = face[i];
                                        let end = points[i] = pointMap.get(vertices[startIndex]);
                                        if (this.generateStruts && (startIndex < endIndex)) {
                                            this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, end)));
                                        }
                                        start = end;
                                    }
                                    ;
                                }
                                if (this.generatePanels) {
                                    this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices(points)));
                                }
                            }
                        }
                        this.redo();
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.mode != null) {
                            element.setAttribute("mode", this.mode);
                        }
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        this.setMode(xml.getAttribute("mode"));
                    }
                }
                ConvexHull3d.NAME = "ConvexHull3d";
                edits.ConvexHull3d = ConvexHull3d;
                ConvexHull3d["__class"] = "com.vzome.core.edits.ConvexHull3d";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ConvexHull2d extends com.vzome.core.edits.ConvexHull {
                    constructor(editorModel) {
                        super(editorModel);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return ConvexHull2d.NAME;
                    }
                    /**
                     *
                     */
                    perform() {
                        let hull2d = com.vzome.core.math.convexhull.GrahamScan2D.buildHull(this.getSelectedVertexSet(true));
                        this.redo();
                        let vertices = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(hull2d.length);
                        let p = 0;
                        let pointMap = (new java.util.HashMap(hull2d.length));
                        for (let index323 = 0; index323 < hull2d.length; index323++) {
                            let vertex = hull2d[index323];
                            {
                                let point = new com.vzome.core.construction.FreePoint(vertex);
                                pointMap.put(vertex, point);
                                vertices[p++] = point;
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(point));
                            }
                        }
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.PolygonFromVertices(vertices)));
                        let start = pointMap.get(hull2d[0]);
                        for (let i = 1; i < hull2d.length; i++) {
                            {
                                let end = pointMap.get(hull2d[i]);
                                this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, end)));
                                start = end;
                            }
                            ;
                        }
                        let end = pointMap.get(hull2d[0]);
                        this.select$com_vzome_core_model_Manifestation(this.manifestConstruction(new com.vzome.core.construction.SegmentJoiningPoints(start, end)));
                        this.redo();
                    }
                }
                ConvexHull2d.NAME = "ConvexHull2d";
                edits.ConvexHull2d = ConvexHull2d;
                ConvexHull2d["__class"] = "com.vzome.core.edits.ConvexHull2d";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class StrutMove extends com.vzome.core.edits.StrutCreation {
                    constructor(editor) {
                        super(editor);
                        if (this.oldStrut === undefined)
                            this.oldStrut = null;
                    }
                    /**
                     *
                     * @param {*} params
                     */
                    configure(params) {
                        super.configure(params);
                        this.oldStrut = params.get("oldStrut");
                    }
                    /**
                     *
                     */
                    perform() {
                        this.deleteManifestation(this.oldStrut);
                        this.manifestConstruction(this.mAnchor);
                        super.redo();
                        super.perform();
                    }
                    /**
                     *
                     * @param {*} xml
                     */
                    getXmlAttributes(xml) {
                        com.vzome.core.commands.XmlSaveFormat.serializeSegment(xml, "startSegment", "endSegment", this.oldStrut.getFirstConstruction());
                        super.getXmlAttributes(xml);
                    }
                    /**
                     *
                     * @param {*} xml
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(xml, format) {
                        let construction = format.parseSegment$org_w3c_dom_Element$java_lang_String$java_lang_String(xml, "startSegment", "endSegment");
                        if (construction != null)
                            this.oldStrut = this.getManifestation(construction);
                        super.setXmlAttributes(xml, format);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "StrutMove";
                    }
                }
                edits.StrutMove = StrutMove;
                StrutMove["__class"] = "com.vzome.core.edits.StrutMove";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ImportSimpleMeshJson extends com.vzome.core.edits.ImportMesh {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} offset
                     * @param {com.vzome.core.editor.api.ManifestConstructions} events
                     * @param {*} registry
                     */
                    parseMeshData(offset, events, registry) {
                        com.vzome.core.model.SimpleMeshJson.parse(this.meshData, offset, this.projection, events, registry);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ImportSimpleMeshJson";
                    }
                }
                edits.ImportSimpleMeshJson = ImportSimpleMeshJson;
                ImportSimpleMeshJson["__class"] = "com.vzome.core.edits.ImportSimpleMeshJson";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class ImportColoredMeshJson extends com.vzome.core.edits.ImportMesh {
                    constructor(editor) {
                        super(editor);
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} offset
                     * @param {com.vzome.core.editor.api.ManifestConstructions} events
                     * @param {*} registry
                     */
                    parseMeshData(offset, events, registry) {
                        com.vzome.core.model.ColoredMeshJson.parse(this.meshData, offset, this.projection, events, registry);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ImportColoredMeshJson";
                    }
                }
                edits.ImportColoredMeshJson = ImportColoredMeshJson;
                ImportColoredMeshJson["__class"] = "com.vzome.core.edits.ImportColoredMeshJson";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class LoadVEF extends com.vzome.core.edits.ImportMesh {
                    constructor(editor) {
                        super(editor);
                    }
                    deselectInputs() {
                        return false;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} offset
                     * @param {com.vzome.core.editor.api.ManifestConstructions} events
                     * @param {*} registry
                     */
                    parseMeshData(offset, events, registry) {
                        let v2m = new com.vzome.core.construction.VefToModel(this.projection, events, this.scale, offset);
                        v2m.parseVEF(this.meshData, this.mManifestations.getField());
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "LoadVEF";
                    }
                }
                edits.LoadVEF = LoadVEF;
                LoadVEF["__class"] = "com.vzome.core.edits.LoadVEF";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_4) {
                class TransformationTool extends com.vzome.core.editor.Tool {
                    constructor(id, tools) {
                        super(id, tools);
                        if (this.transforms === undefined)
                            this.transforms = null;
                        if (this.originPoint === undefined)
                            this.originPoint = null;
                        this.originPoint = tools.getOriginPoint();
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    prepare(applyTool) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    complete(applyTool) {
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    needsInput() {
                        return true;
                    }
                    /**
                     *
                     * @param {*} that
                     * @return {boolean}
                     */
                    equals(that) {
                        if (this === that) {
                            return true;
                        }
                        if (that == null) {
                            return false;
                        }
                        if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(that.constructor, this.constructor)) {
                            return false;
                        }
                        let other = that;
                        if (this.originPoint == null) {
                            if (other.originPoint != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.originPoint, other.originPoint)) {
                            return false;
                        }
                        if (!java.util.Arrays.equals(this.transforms, other.transforms)) {
                            return false;
                        }
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.Construction} c
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performEdit(c, applyTool) {
                        for (let index324 = 0; index324 < this.transforms.length; index324++) {
                            let transform = this.transforms[index324];
                            {
                                let result = transform.transform$com_vzome_core_construction_Construction(c);
                                if (result == null)
                                    continue;
                                let color = c.getColor();
                                result.setColor(color);
                                let m = applyTool.manifestConstruction(result);
                                if (m != null)
                                    if (color != null)
                                        applyTool.colorManifestation(m, c.getColor());
                            }
                        }
                        applyTool.redo();
                    }
                    /**
                     *
                     * @param {*} man
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performSelect(man, applyTool) {
                    }
                    unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups) {
                        let c = man.getFirstConstruction();
                        this.addParameter(c);
                        super.unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups);
                    }
                    /**
                     *
                     * @param {*} man
                     * @param {boolean} ignoreGroups
                     */
                    unselect(man, ignoreGroups) {
                        if (((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ((typeof ignoreGroups === 'boolean') || ignoreGroups === null)) {
                            return this.unselect$com_vzome_core_model_Manifestation$boolean(man, ignoreGroups);
                        }
                        else if (((man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Manifestation") >= 0)) || man === null) && ignoreGroups === undefined) {
                            return this.unselect$com_vzome_core_model_Manifestation(man);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    isAutomatic() {
                        return /* contains */ (this.getId().indexOf(".auto/") != -1);
                    }
                }
                tools_4.TransformationTool = TransformationTool;
                TransformationTool["__class"] = "com.vzome.core.tools.TransformationTool";
                TransformationTool["__interfaces"] = ["com.vzome.api.Tool"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_5) {
                class PlaneSelectionTool extends com.vzome.core.editor.Tool {
                    constructor(id, tools) {
                        super(id, tools);
                        if (this.plane === undefined)
                            this.plane = null;
                        if (this.anchor === undefined)
                            this.anchor = null;
                        this.halfSpace = true;
                        this.boundaryOpen = false;
                        this.above = true;
                        this.includeBalls = true;
                        this.includeStruts = true;
                        this.includePanels = true;
                        this.includePartials = false;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return true;
                    }
                    /**
                     *
                     */
                    perform() {
                        let p1 = null;
                        let p2 = null;
                        let p3 = null;
                        for (let index325 = this.mSelection.iterator(); index325.hasNext();) {
                            let man = index325.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (p1 == null) {
                                        p1 = man.getLocation();
                                        continue;
                                    }
                                    if (p2 == null) {
                                        p2 = man.getLocation();
                                        continue;
                                    }
                                    if (p3 == null) {
                                        p3 = man.getLocation();
                                        continue;
                                    }
                                    else {
                                        throw new com.vzome.core.commands.Command.Failure("half-space selection tool requires exactly three balls");
                                    }
                                }
                            }
                        }
                        if (p3 == null)
                            throw new com.vzome.core.commands.Command.Failure("half-space selection tool requires exactly three balls");
                        let v1 = new com.vzome.core.algebra.Vector3d(p2.minus(p1));
                        let v2 = new com.vzome.core.algebra.Vector3d(p3.minus(p1));
                        this.plane = v1.outer(v2);
                        this.anchor = p1;
                        super.perform();
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    prepare(applyTool) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    complete(applyTool) {
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    needsInput() {
                        return false;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.Construction} c
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performEdit(c, applyTool) {
                    }
                    /**
                     *
                     * @param {*} man
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performSelect(man, applyTool) {
                        if (man.isHidden())
                            return;
                        if (!man.isRendered())
                            return;
                        if (this.includePanels && (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)))
                            return;
                        if (this.includeBalls && (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0))) {
                            let c = man;
                            let orientation = this.orient(c.getLocation());
                            if (!this.boundaryOpen && orientation === 0)
                                applyTool.select$com_vzome_core_model_Manifestation(man);
                            else if (this.halfSpace && this.above && orientation > 0)
                                applyTool.select$com_vzome_core_model_Manifestation(man);
                            else if (this.halfSpace && !this.above && orientation < 0)
                                applyTool.select$com_vzome_core_model_Manifestation(man);
                        }
                        else if (this.includeStruts && (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0))) {
                            let o1 = this.orient(man.getLocation());
                            let o2 = this.orient(man.getEnd());
                            if (this.includePartials) {
                                if (!this.boundaryOpen && (o1 === 0 || o2 === 0))
                                    applyTool.select$com_vzome_core_model_Manifestation(man);
                                else if (this.halfSpace) {
                                    if (this.above && (o1 > 0 || o2 > 0))
                                        applyTool.select$com_vzome_core_model_Manifestation(man);
                                    else if (!this.above && (o1 < 0 || o2 < 0))
                                        applyTool.select$com_vzome_core_model_Manifestation(man);
                                }
                            }
                            else {
                                if (!this.halfSpace && o1 === 0 && o2 === 0)
                                    applyTool.select$com_vzome_core_model_Manifestation(man);
                                else if (this.halfSpace) {
                                    if (this.boundaryOpen) {
                                        if (this.above && (o1 > 0 && o2 > 0))
                                            applyTool.select$com_vzome_core_model_Manifestation(man);
                                        else if (!this.above && (o1 < 0 && o2 < 0))
                                            applyTool.select$com_vzome_core_model_Manifestation(man);
                                    }
                                    else {
                                        if (this.above && (o1 >= 0 && o2 >= 0))
                                            applyTool.select$com_vzome_core_model_Manifestation(man);
                                        else if (!this.above && (o1 <= 0 && o2 <= 0))
                                            applyTool.select$com_vzome_core_model_Manifestation(man);
                                    }
                                }
                            }
                        }
                        applyTool.redo();
                    }
                    orient(point) {
                        let diff = point.minus(this.anchor);
                        let v = new com.vzome.core.algebra.Vector3d(diff);
                        let volume = this.plane.outer(v);
                        if (volume.isZero())
                            return 0;
                        else {
                            let volD = volume.evaluate();
                            return (volD > 0.0) ? 1 : -1;
                        }
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "PlaneSelectionTool";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("name", this.getId());
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        super.setXmlAttributes(element, format);
                        this.includeBalls = !((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("false", element.getAttribute("balls"));
                        this.includeStruts = !((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("false", element.getAttribute("struts"));
                        this.includePanels = /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("true", element.getAttribute("panels"));
                        this.includePartials = /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("any", element.getAttribute("vertices"));
                        this.boundaryOpen = /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("true", element.getAttribute("open"));
                        let halfSpace = element.getAttribute("halfSpace");
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("above", halfSpace)) {
                            this.halfSpace = true;
                            this.above = true;
                        }
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("below", halfSpace)) {
                            this.halfSpace = true;
                            this.above = false;
                        }
                        else {
                            this.halfSpace = false;
                            this.boundaryOpen = false;
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return "plane";
                    }
                    getDefaultName() {
                        return "plane";
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        return null;
                    }
                }
                tools_5.PlaneSelectionTool = PlaneSelectionTool;
                PlaneSelectionTool["__class"] = "com.vzome.core.tools.PlaneSelectionTool";
                PlaneSelectionTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (PlaneSelectionTool) {
                    class Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools) {
                            super(tools, null, "plane", "", "");
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            return (total === 3 && balls === 3);
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            return new com.vzome.core.tools.PlaneSelectionTool(id, this.getToolsModel());
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            return true;
                        }
                    }
                    PlaneSelectionTool.Factory = Factory;
                    Factory["__class"] = "com.vzome.core.tools.PlaneSelectionTool.Factory";
                    Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(PlaneSelectionTool = tools_5.PlaneSelectionTool || (tools_5.PlaneSelectionTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_6) {
                class BookmarkTool extends com.vzome.core.editor.Tool {
                    constructor(id, tools) {
                        super(id, tools);
                        this.bookmarkedConstructions = (new java.util.ArrayList());
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return true;
                    }
                    /**
                     *
                     */
                    perform() {
                        let duper = new com.vzome.core.editor.Duplicator(null, null);
                        if (this.mSelection.size() === 0)
                            this.bookmarkedConstructions.add(new com.vzome.core.construction.FreePoint(this.mManifestations.getField().origin(3)));
                        else
                            for (let index326 = this.mSelection.iterator(); index326.hasNext();) {
                                let man = index326.next();
                                {
                                    let result = duper.duplicateConstruction(man);
                                    this.bookmarkedConstructions.add(result);
                                    this.addParameter(result);
                                }
                            }
                        super.perform();
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    needsInput() {
                        return false;
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} edit
                     */
                    prepare(edit) {
                        if (this.bookmarkedConstructions.isEmpty()) {
                            edit.manifestConstruction(new com.vzome.core.construction.FreePoint(this.mManifestations.getField().origin(3)));
                        }
                        else
                            for (let index327 = this.bookmarkedConstructions.iterator(); index327.hasNext();) {
                                let con = index327.next();
                                {
                                    edit.manifestConstruction(con);
                                }
                            }
                        edit.redo();
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    complete(applyTool) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.Construction} c
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performEdit(c, applyTool) {
                    }
                    /**
                     *
                     * @param {*} man
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performSelect(man, applyTool) {
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "BookmarkTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return BookmarkTool.ID;
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        return null;
                    }
                }
                BookmarkTool.ID = "bookmark";
                BookmarkTool.LABEL = "Create a selection bookmark";
                BookmarkTool.TOOLTIP = "<p>A selection bookmark lets you re-create<br>any selection at a later time.</p>";
                tools_6.BookmarkTool = BookmarkTool;
                BookmarkTool["__class"] = "com.vzome.core.tools.BookmarkTool";
                BookmarkTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (BookmarkTool) {
                    class Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools) {
                            super(tools, null, com.vzome.core.tools.BookmarkTool.ID, com.vzome.core.tools.BookmarkTool.LABEL, com.vzome.core.tools.BookmarkTool.TOOLTIP);
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            return (total > 0);
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            return new com.vzome.core.tools.BookmarkTool(id, this.getToolsModel());
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            return true;
                        }
                    }
                    BookmarkTool.Factory = Factory;
                    Factory["__class"] = "com.vzome.core.tools.BookmarkTool.Factory";
                    Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(BookmarkTool = tools_6.BookmarkTool || (tools_6.BookmarkTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_7) {
                class ModuleTool extends com.vzome.core.editor.Tool {
                    constructor(id, tools) {
                        super(id, tools);
                        if (this.name === undefined)
                            this.name = null;
                        this.bookmarkedSelection = (new java.util.ArrayList());
                        this.mSelection.copy(this.bookmarkedSelection);
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isSticky() {
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    prepare(applyTool) {
                    }
                    /**
                     *
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    complete(applyTool) {
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    needsInput() {
                        return true;
                    }
                    /**
                     *
                     * @param {com.vzome.core.construction.Construction} c
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performEdit(c, applyTool) {
                        if (!(c != null && c instanceof com.vzome.core.construction.Point))
                            return;
                        let p = c;
                        let loc = p.getLocation();
                        let duper = new com.vzome.core.editor.Duplicator(applyTool, loc);
                        for (let index328 = this.bookmarkedSelection.iterator(); index328.hasNext();) {
                            let man = index328.next();
                            {
                                duper.duplicateManifestation(man);
                            }
                        }
                        applyTool.redo();
                    }
                    /**
                     *
                     * @param {*} man
                     * @param {com.vzome.core.editor.api.ChangeManifestations} applyTool
                     */
                    performSelect(man, applyTool) {
                    }
                    /**
                     *
                     */
                    redo() {
                    }
                    /**
                     *
                     */
                    undo() {
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ModuleTool";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("name", this.name);
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        this.name = element.getAttribute("name");
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return ModuleTool.ID;
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        return null;
                    }
                }
                ModuleTool.ID = "module";
                ModuleTool.LABEL = "Create a module tool";
                ModuleTool.TOOLTIP = "<p>Each tool duplicates the original module.<br></p>";
                tools_7.ModuleTool = ModuleTool;
                ModuleTool["__class"] = "com.vzome.core.tools.ModuleTool";
                ModuleTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (ModuleTool) {
                    class Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools) {
                            super(tools, null, com.vzome.core.tools.ModuleTool.ID, com.vzome.core.tools.ModuleTool.LABEL, com.vzome.core.tools.ModuleTool.TOOLTIP);
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            return (total > 0);
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            return new com.vzome.core.tools.ModuleTool(id, this.getToolsModel());
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            return true;
                        }
                    }
                    ModuleTool.Factory = Factory;
                    Factory["__class"] = "com.vzome.core.tools.ModuleTool.Factory";
                    Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(ModuleTool = tools_7.ModuleTool || (tools_7.ModuleTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var edits;
            (function (edits) {
                class SelectByRadius extends com.vzome.core.edits.SelectByDiameter {
                    constructor(editor) {
                        super(editor);
                        if (this.minRadiusSquared === undefined)
                            this.minRadiusSquared = null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return SelectByRadius.NAME;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    usage() {
                        return "This command requires either two or three selected connectors.\n\nThe first connector marks the center of a sphere.\nThe second connector defines its radius.\nAn optional third connector defines the radius of\n a second sphere with the same center.\n\nAll parts that are completely within the larger sphere will be selected.\n\nIf a second sphere is defined then any parts\n     within the smaller sphere, even partially, will be excluded.\n";
                    }
                    /**
                     *
                     */
                    perform() {
                        this.setOrderedSelection(true);
                        super.perform();
                    }
                    /**
                     *
                     * @param {*} vectors
                     * @return {string}
                     */
                    adjustBoundary(vectors) {
                        let v = vectors.get(vectors.size() - 1);
                        switch ((vectors.size())) {
                            case 1:
                                this.center = v;
                                this.maxRadiusSquared = null;
                                this.minRadiusSquared = null;
                                return null;
                            case 2:
                                let v2 = v.minus(this.center);
                                this.maxRadiusSquared = v2.dot(v2);
                                return null;
                            case 3:
                                let v3 = v.minus(this.center);
                                this.minRadiusSquared = v3.dot(v3);
                                if (this.maxRadiusSquared.compareTo(this.minRadiusSquared) < 0) {
                                    let temp = this.maxRadiusSquared;
                                    this.maxRadiusSquared = this.minRadiusSquared;
                                    this.minRadiusSquared = temp;
                                }
                                return null;
                        }
                        return super.adjustBoundary(vectors);
                    }
                    boundaryContains$com_vzome_core_algebra_AlgebraicVector(v) {
                        if (super.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v)) {
                            if (this.minRadiusSquared != null) {
                                let v1 = v.minus(this.center);
                                return v1.dot(v1).compareTo(this.minRadiusSquared) >= 0;
                            }
                            return true;
                        }
                        return false;
                    }
                    /**
                     *
                     * @param {com.vzome.core.algebra.AlgebraicVector} v
                     * @return {boolean}
                     */
                    boundaryContains(v) {
                        if (((v != null && v instanceof com.vzome.core.algebra.AlgebraicVector) || v === null)) {
                            return this.boundaryContains$com_vzome_core_algebra_AlgebraicVector(v);
                        }
                        else if (((v != null && (v["__interfaces"] != null && v["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) || v === null)) {
                            super.boundaryContains(v);
                        }
                        else if (((v != null && (v["__interfaces"] != null && v["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Strut(v);
                        }
                        else if (((v != null && (v["__interfaces"] != null && v["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || v.constructor != null && v.constructor["__interfaces"] != null && v.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) || v === null)) {
                            return this.boundaryContains$com_vzome_core_model_Panel(v);
                        }
                        else
                            throw new Error('invalid overload');
                    }
                }
                SelectByRadius.NAME = "SelectByRadius";
                edits.SelectByRadius = SelectByRadius;
                SelectByRadius["__class"] = "com.vzome.core.edits.SelectByRadius";
            })(edits = core.edits || (core.edits = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_8) {
                class InversionTool extends com.vzome.core.tools.TransformationTool {
                    constructor(toolName, tools) {
                        super(toolName, tools);
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let center = null;
                        if (!this.isAutomatic())
                            for (let index329 = this.mSelection.iterator(); index329.hasNext();) {
                                let man = index329.next();
                                {
                                    if (prepareTool)
                                        this.unselect$com_vzome_core_model_Manifestation(man);
                                    if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        if (center != null)
                                            return "more than one center selected";
                                        center = man.getFirstConstruction();
                                    }
                                    else if (!prepareTool)
                                        return "panel or strut selected";
                                }
                            }
                        if (center == null) {
                            if (prepareTool) {
                                center = this.originPoint;
                                this.addParameter(center);
                            }
                            else
                                return "No symmetry center selected";
                        }
                        if (prepareTool) {
                            this.transforms = [null];
                            this.transforms[0] = new com.vzome.core.construction.PointReflection(center);
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "InversionTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return InversionTool.ID;
                    }
                }
                InversionTool.ID = "point reflection";
                InversionTool.LABEL = "Create a point reflection tool";
                InversionTool.TOOLTIP = "<p>Each tool duplicates the selection by reflecting<br>each point through the defined center.  To create a<br>tool, select a single ball that defines that center.<br></p>";
                tools_8.InversionTool = InversionTool;
                InversionTool["__class"] = "com.vzome.core.tools.InversionTool";
                InversionTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (InversionTool) {
                    class Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools) {
                            super(tools, null, com.vzome.core.tools.InversionTool.ID, com.vzome.core.tools.InversionTool.LABEL, com.vzome.core.tools.InversionTool.TOOLTIP);
                            if (this.center === undefined)
                                this.center = null;
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            return (total === 1 && balls === 1);
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            return new com.vzome.core.tools.InversionTool(id, this.getToolsModel());
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            for (let index330 = selection.iterator(); index330.hasNext();) {
                                let man = index330.next();
                                this.center = man;
                            }
                            return true;
                        }
                    }
                    InversionTool.Factory = Factory;
                    Factory["__class"] = "com.vzome.core.tools.InversionTool.Factory";
                    Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(InversionTool = tools_8.InversionTool || (tools_8.InversionTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_9) {
                class AxialStretchTool extends com.vzome.core.tools.TransformationTool {
                    constructor(id, symmetry, tools, stretch, red, first, category) {
                        super(id, tools);
                        if (this.symmetry === undefined)
                            this.symmetry = null;
                        if (this.stretch === undefined)
                            this.stretch = false;
                        if (this.red === undefined)
                            this.red = false;
                        if (this.first === undefined)
                            this.first = false;
                        if (this.__com_vzome_core_tools_AxialStretchTool_category === undefined)
                            this.__com_vzome_core_tools_AxialStretchTool_category = null;
                        this.symmetry = symmetry;
                        this.stretch = stretch;
                        this.red = red;
                        this.first = first;
                        this.__com_vzome_core_tools_AxialStretchTool_category = category;
                        this.setInputBehaviors(false, true);
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let center = null;
                        let axis = null;
                        for (let index331 = this.mSelection.iterator(); index331.hasNext();) {
                            let man = index331.next();
                            {
                                if (prepareTool)
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (center != null)
                                        return "Only one ball may be selected";
                                    center = man.getFirstConstruction();
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (axis != null)
                                        return "Only one strut may be selected";
                                    axis = man.getFirstConstruction();
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    return "Panels are not supported.";
                                }
                            }
                        }
                        if (center == null)
                            return "Exactly one ball must be selected.";
                        if (axis == null)
                            return "Exactly one strut must be selected.";
                        let zone = this.symmetry.getAxis$com_vzome_core_algebra_AlgebraicVector(axis.getOffset());
                        if (zone == null)
                            return "Selected alignment strut is not an appropriate axis.";
                        let o0;
                        let o1;
                        let o2;
                        let n0;
                        let n1;
                        let n2;
                        switch ((zone.getDirection().getName())) {
                            case "yellow":
                                if (this.red)
                                    return "A red axis strut must be selected.";
                                let blueOrbit = this.symmetry.getDirection("blue");
                                let blueScale = blueOrbit.getUnitLength();
                                o0 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 2).normal().scale(blueScale);
                                o1 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 54).normal().scale(blueScale);
                                o2 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 36).normal().scale(blueScale);
                                let redOrbit = this.symmetry.getDirection("red");
                                let redScale = redOrbit.getUnitLength();
                                n0 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 2).normal().scale(redScale);
                                n1 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 46).normal().scale(redScale);
                                n2 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 16).normal().scale(redScale);
                                break;
                            case "red":
                                if (!this.red)
                                    return "A yellow axis strut must be selected.";
                                blueOrbit = this.symmetry.getDirection("blue");
                                blueScale = blueOrbit.getUnitLength();
                                redOrbit = this.symmetry.getDirection("red");
                                redScale = redOrbit.getUnitLength();
                                if (this.first) {
                                    o0 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 56).normal().scale(blueScale);
                                    o1 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 38).normal().scale(blueScale);
                                    o2 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 40).normal().scale(blueScale);
                                    n0 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 46).normal().scale(redScale);
                                    n1 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1).normal().scale(redScale);
                                    n2 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 2).normal().scale(redScale);
                                }
                                else {
                                    o0 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 37).normal().scale(blueScale);
                                    o1 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 25).normal().scale(blueScale);
                                    o2 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 45).normal().scale(blueScale);
                                    n0 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 37).normal().scale(blueScale);
                                    n1 = blueOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 25).normal().scale(blueScale);
                                    redScale = redScale['times$com_vzome_core_algebra_AlgebraicNumber'](this.symmetry.getField()['createPower$int'](-1));
                                    n2 = redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 45).normal().scale(redScale);
                                }
                                break;
                            default:
                                return "Selected alignment strut is not an appropriate axis.";
                        }
                        if (prepareTool) {
                            let orientation = this.symmetry.getMatrix(zone.getOrientation());
                            let inverse = orientation.inverse();
                            let oldBasis = new com.vzome.core.algebra.AlgebraicMatrix(o0, o1, o2);
                            let newBasis = new com.vzome.core.algebra.AlgebraicMatrix(n0, n1, n2);
                            if (this.stretch) {
                                let temp = oldBasis;
                                oldBasis = newBasis;
                                newBasis = temp;
                            }
                            let matrix = orientation.times(newBasis.times(oldBasis.inverse()).times(inverse));
                            this.transforms = [null];
                            this.transforms[0] = new com.vzome.core.construction.MatrixTransformation(matrix, center.getLocation());
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "AxialStretchTool";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        super.getXmlAttributes(element);
                        if (this.stretch)
                            element.setAttribute("stretch", "true");
                        element.setAttribute("orbit", this.red ? "red" : "yellow");
                        if (!this.first)
                            element.setAttribute("first", "false");
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        let value = element.getAttribute("stretch");
                        this.stretch = value != null && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(value, "true");
                        value = element.getAttribute("orbit");
                        this.red = /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(value, "red");
                        value = element.getAttribute("first");
                        this.first = value == null || !((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(value, "false");
                        this.symmetry = format.parseSymmetry("icosahedral");
                        super.setXmlAttributes(element, format);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return this.__com_vzome_core_tools_AxialStretchTool_category;
                    }
                }
                AxialStretchTool.TOOLTIP_REDSQUASH1 = "<p>Each tool applies a \"squash\" transformation to the<br>selected objects, compressing along a red axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>red strut as the direction of the compression.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the mapping that transforms the central,<br>blue dodecahedron into the compressed form in the next<br>layer outward.<br><br>By default, the input selection will be removed, and replaced<br>with the squashed equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                AxialStretchTool.TOOLTIP_REDSTRETCH1 = "<p>Each tool applies a \"stretch\" transformation to the<br>selected objects, stretching along a red axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>red strut as the direction of the stretch.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the inverse of the mapping that transforms<br>the central, blue dodecahedron into the compressed form in<br>the next layer outward.<br><br>By default, the input selection will be removed, and replaced<br>with the stretched equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                AxialStretchTool.TOOLTIP_YELLOWSQUASH = "<p>Each tool applies a \"squash\" transformation to the<br>selected objects, compressing along a yellow axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>yellow strut as the direction of the compression.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the mapping that transforms the central,<br>blue dodecahedron into the compressed form along a yellow axis.<br><br>By default, the input selection will be removed, and replaced<br>with the squashed equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                AxialStretchTool.TOOLTIP_YELLOWSTRETCH = "<p>Each tool applies a \"stretch\" transformation to the<br>selected objects, stretching along a yellow axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>yellow strut as the direction of the stretch.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the inverse of the mapping that transforms<br>the central, blue dodecahedron into the compressed form along<br>a yellow axis.<br><br>By default, the input selection will be removed, and replaced<br>with the stretched equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                AxialStretchTool.TOOLTIP_REDSQUASH2 = "<p>Each tool applies a \"squash\" transformation to the<br>selected objects, compressing along a red axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>red strut as the direction of the compression.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the mapping that transforms the central,<br>blue dodecahedron into the compressed form in the second<br>layer outward along a red axis.<br><br>By default, the input selection will be removed, and replaced<br>with the squashed equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                AxialStretchTool.TOOLTIP_REDSTRETCH2 = "<p>Each tool applies a \"stretch\" transformation to the<br>selected objects, stretching along a red axis.  To create<br>a tool, select a ball as the center of the mapping, and a<br>red strut as the direction of the stretch.  The ball and<br>strut need not be collinear.<br><br>The mapping comes from the usual Zome projection of the<br>120-cell.  It is the inverse of the mapping that transforms<br>the central, blue dodecahedron into the compressed form in<br>the second layer outward along a red axis.<br><br>By default, the input selection will be removed, and replaced<br>with the stretched equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                tools_9.AxialStretchTool = AxialStretchTool;
                AxialStretchTool["__class"] = "com.vzome.core.tools.AxialStretchTool";
                AxialStretchTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (AxialStretchTool) {
                    class Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools, symmetry, red, stretch, first) {
                            super(tools, symmetry, Factory.getCategory(red, stretch, first), Factory.getLabel(red, stretch, first), Factory.getToolTip(red, stretch, first));
                            if (this.red === undefined)
                                this.red = false;
                            if (this.stretch === undefined)
                                this.stretch = false;
                            if (this.first === undefined)
                                this.first = false;
                            this.red = red;
                            this.stretch = stretch;
                            this.first = first;
                        }
                        static getCategory(red, stretch, first) {
                            if (red)
                                if (first)
                                    return stretch ? "redstretch1" : "redsquash1";
                                else
                                    return stretch ? "redstretch2" : "redsquash2";
                            else
                                return stretch ? "yellowstretch" : "yellowsquash";
                        }
                        static getLabel(red, stretch, first) {
                            let label;
                            if (red)
                                if (first)
                                    label = stretch ? "weak red stretch" : "weak red squash";
                                else
                                    label = stretch ? "strong red stretch" : "strong red squash";
                            else
                                label = stretch ? "yellow stretch" : "yellow squash";
                            return "Create a " + label + " tool";
                        }
                        static getToolTip(red, stretch, first) {
                            if (red)
                                if (first)
                                    return stretch ? com.vzome.core.tools.AxialStretchTool.TOOLTIP_REDSTRETCH1 : com.vzome.core.tools.AxialStretchTool.TOOLTIP_REDSQUASH1;
                                else
                                    return stretch ? com.vzome.core.tools.AxialStretchTool.TOOLTIP_REDSTRETCH2 : com.vzome.core.tools.AxialStretchTool.TOOLTIP_REDSQUASH2;
                            else
                                return stretch ? com.vzome.core.tools.AxialStretchTool.TOOLTIP_YELLOWSTRETCH : com.vzome.core.tools.AxialStretchTool.TOOLTIP_YELLOWSQUASH;
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            return (total === 2 && balls === 1 && struts === 1);
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            let category = Factory.getCategory(this.red, this.stretch, this.first);
                            return new com.vzome.core.tools.AxialStretchTool(id, this.getSymmetry(), this.getToolsModel(), this.stretch, this.red, this.first, category);
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            let symmetry = this.getSymmetry();
                            for (let index332 = selection.iterator(); index332.hasNext();) {
                                let man = index332.next();
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    let axisStrut = man;
                                    let vector = axisStrut.getOffset();
                                    vector = symmetry.getField().projectTo3d(vector, true);
                                    let axis = symmetry.getAxis$com_vzome_core_algebra_AlgebraicVector(vector);
                                    if (axis == null)
                                        return false;
                                    let orbitName = axis.getDirection().getName();
                                    if (this.red)
                                        return /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                            return o1.equals(o2);
                                        }
                                        else {
                                            return o1 === o2;
                                        } })(orbitName, "red");
                                    else
                                        return /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                            return o1.equals(o2);
                                        }
                                        else {
                                            return o1 === o2;
                                        } })(orbitName, "yellow");
                                }
                            }
                            return true;
                        }
                    }
                    AxialStretchTool.Factory = Factory;
                    Factory["__class"] = "com.vzome.core.tools.AxialStretchTool.Factory";
                    Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(AxialStretchTool = tools_9.AxialStretchTool || (tools_9.AxialStretchTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_10) {
                class SymmetryTool extends com.vzome.core.tools.TransformationTool {
                    constructor(id, symmetry, tools) {
                        super(id, tools);
                        if (this.symmetry === undefined)
                            this.symmetry = null;
                        this.symmetry = symmetry;
                    }
                    /**
                     *
                     * @return {number}
                     */
                    hashCode() {
                        let prime = 31;
                        let result = 1;
                        result = prime * result + ((this.symmetry == null) ? 0 : /* hashCode */ ((o) => { if (o.hashCode) {
                            return o.hashCode();
                        }
                        else {
                            return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                        } })(this.symmetry));
                        return result;
                    }
                    /**
                     *
                     * @param {*} that
                     * @return {boolean}
                     */
                    equals(that) {
                        if (this === that) {
                            return true;
                        }
                        if (!super.equals(that)) {
                            return false;
                        }
                        if (this.constructor !== that.constructor) {
                            return false;
                        }
                        let other = that;
                        if (this.symmetry == null) {
                            if (other.symmetry != null) {
                                return false;
                            }
                        }
                        else if (!((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.symmetry, other.symmetry)) {
                            return false;
                        }
                        return true;
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let center = null;
                        let axis = null;
                        let correct = true;
                        let hasPanels = false;
                        if (!this.isAutomatic())
                            for (let index333 = this.mSelection.iterator(); index333.hasNext();) {
                                let man = index333.next();
                                {
                                    if (prepareTool)
                                        this.unselect$com_vzome_core_model_Manifestation(man);
                                    if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        if (center != null)
                                            return "No unique symmetry center selected";
                                        center = man.getFirstConstruction();
                                    }
                                    else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                        if (axis != null)
                                            correct = false;
                                        else
                                            axis = man;
                                    }
                                    else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                        hasPanels = true;
                                    }
                                }
                            }
                        if (center == null) {
                            if (prepareTool) {
                                center = this.originPoint;
                                this.addParameter(center);
                            }
                            else
                                return "No symmetry center selected";
                        }
                        if (hasPanels) {
                            if (!prepareTool)
                                return "panels are selected";
                        }
                        let closure = this.symmetry.subgroup(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL);
                        switch ((this.symmetry.getName())) {
                            case "icosahedral":
                                if (!prepareTool && (axis != null) && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                                    return o1.equals(o2);
                                }
                                else {
                                    return o1 === o2;
                                } })(this.getCategory(), "icosahedral"))
                                    return "No struts needed for icosahedral symmetry.";
                                switch ((this.getCategory())) {
                                    case "tetrahedral":
                                        if (!correct)
                                            return "no unique alignment strut selected.";
                                        if (axis == null) {
                                            if (!prepareTool)
                                                return "no aligment strut selected.";
                                        }
                                        else {
                                            let icosa = this.symmetry;
                                            let zone = icosa.getAxis$com_vzome_core_algebra_AlgebraicVector(axis.getOffset());
                                            if (zone == null)
                                                return "selected alignment strut is not a tetrahedral axis.";
                                            let allowYellow = prepareTool;
                                            closure = icosa.subgroup$java_lang_String$com_vzome_core_math_symmetry_Axis$boolean(com.vzome.core.math.symmetry.Symmetry.TETRAHEDRAL, zone, allowYellow);
                                            if (closure == null)
                                                return "selected alignment strut is not a tetrahedral axis.";
                                        }
                                        if (prepareTool) {
                                            let order = closure.length;
                                            this.transforms = (s => { let a = []; while (s-- > 0)
                                                a.push(null); return a; })(order - 1);
                                            for (let i = 0; i < order - 1; i++) {
                                                this.transforms[i] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, closure[i + 1], center);
                                            }
                                        }
                                        break;
                                    case "octahedral":
                                        let orientation = null;
                                        if (!correct)
                                            return "no unique alignment strut selected.";
                                        if (axis == null) {
                                            if (!prepareTool)
                                                return "no aligment strut selected.";
                                        }
                                        else {
                                            let icosa = this.symmetry;
                                            let zone = icosa.getAxis$com_vzome_core_algebra_AlgebraicVector(axis.getOffset());
                                            if (zone == null)
                                                return "selected alignment strut is not an octahedral axis.";
                                            let blueIndex = 0;
                                            switch ((zone.getDirection().getName())) {
                                                case "green":
                                                    blueIndex = icosa.blueTetrahedralFromGreen(zone.getOrientation());
                                                    break;
                                                case "blue":
                                                    blueIndex = zone.getOrientation();
                                                    break;
                                                default:
                                                    return "selected alignment strut is not an octahedral axis.";
                                            }
                                            orientation = this.symmetry.getMatrix(blueIndex);
                                        }
                                        if (prepareTool) {
                                            let inverse = orientation.inverse();
                                            let octa = (this.symmetry != null && this.symmetry instanceof com.vzome.core.math.symmetry.OctahedralSymmetry) ? this.symmetry : new com.vzome.core.math.symmetry.OctahedralSymmetry(this.symmetry.getField());
                                            let order = octa.getChiralOrder();
                                            this.transforms = (s => { let a = []; while (s-- > 0)
                                                a.push(null); return a; })(order - 1);
                                            for (let i = 0; i < order - 1; i++) {
                                                {
                                                    let matrix = octa.getMatrix(i + 1);
                                                    matrix = orientation.times(matrix.times(inverse));
                                                    this.transforms[i] = new com.vzome.core.construction.MatrixTransformation(matrix, center.getLocation());
                                                }
                                                ;
                                            }
                                        }
                                        break;
                                    default:
                                        if (prepareTool)
                                            this.prepareFullSymmetry(center);
                                        break;
                                }
                                break;
                            case "octahedral":
                                if (prepareTool) {
                                    if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                        return o1.equals(o2);
                                    }
                                    else {
                                        return o1 === o2;
                                    } })(this.getCategory(), "tetrahedral")) {
                                        let order = closure.length;
                                        this.transforms = (s => { let a = []; while (s-- > 0)
                                            a.push(null); return a; })(order - 1);
                                        for (let i = 0; i < order - 1; i++) {
                                            this.transforms[i] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, closure[i + 1], center);
                                        }
                                    }
                                    else {
                                        this.prepareFullSymmetry(center);
                                    }
                                }
                                else {
                                    if (axis != null)
                                        return "No struts needed for symmetry";
                                }
                                break;
                            default:
                                if (prepareTool)
                                    this.prepareFullSymmetry(center);
                                break;
                        }
                        return null;
                    }
                    prepareFullSymmetry(center) {
                        let order = this.symmetry.getChiralOrder();
                        this.transforms = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(order - 1);
                        for (let i = 0; i < order - 1; i++) {
                            this.transforms[i] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, i + 1, center);
                        }
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "SymmetryTool";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        element.setAttribute("symmetry", this.symmetry.getName());
                        super.getXmlAttributes(element);
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        let symmName = element.getAttribute("symmetry");
                        this.symmetry = format.parseSymmetry(symmName);
                        super.setXmlAttributes(element, format);
                    }
                }
                SymmetryTool.ID = "symmetry";
                SymmetryTool.LABEL = "Create a general symmetry tool";
                SymmetryTool.TOOLTIP = "<p>General symmetry tool.<br></p>";
                tools_10.SymmetryTool = SymmetryTool;
                SymmetryTool["__class"] = "com.vzome.core.tools.SymmetryTool";
                SymmetryTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (SymmetryTool) {
                    class Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools, symmetry) {
                            super(tools, symmetry, com.vzome.core.tools.SymmetryTool.ID, com.vzome.core.tools.SymmetryTool.LABEL, com.vzome.core.tools.SymmetryTool.TOOLTIP);
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            return (total === 1 && balls === 1);
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            return new com.vzome.core.tools.SymmetryTool(id, this.getSymmetry(), this.getToolsModel());
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            return selection.size() === 1 && (selection.iterator().next() != null && (selection.iterator().next()["__interfaces"] != null && selection.iterator().next()["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || selection.iterator().next().constructor != null && selection.iterator().next().constructor["__interfaces"] != null && selection.iterator().next().constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0));
                        }
                    }
                    SymmetryTool.Factory = Factory;
                    Factory["__class"] = "com.vzome.core.tools.SymmetryTool.Factory";
                    Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(SymmetryTool = tools_10.SymmetryTool || (tools_10.SymmetryTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_11) {
                class LinearMapTool extends com.vzome.core.tools.TransformationTool {
                    constructor(name, tools, originalScaling) {
                        super(name, tools);
                        if (this.originalScaling === undefined)
                            this.originalScaling = false;
                        this.originalScaling = originalScaling;
                        this.setInputBehaviors(false, true);
                    }
                    checkSelection(prepareTool) {
                        let oldBasis = [null, null, null];
                        let newBasis = [null, null, null];
                        let index = 0;
                        let correct = true;
                        let center = null;
                        for (let index334 = this.mSelection.iterator(); index334.hasNext();) {
                            let man = index334.next();
                            {
                                if (prepareTool)
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (center != null) {
                                        correct = false;
                                        break;
                                    }
                                    center = man.getFirstConstruction();
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (index >= 6) {
                                        correct = false;
                                        break;
                                    }
                                    if ((index / 3 | 0) === 0) {
                                        oldBasis[index % 3] = man.getFirstConstruction();
                                    }
                                    else {
                                        newBasis[index % 3] = man.getFirstConstruction();
                                    }
                                    ++index;
                                }
                            }
                        }
                        correct = correct && ((index === 3) || (index === 6));
                        if (!correct)
                            return "linear map tool requires three adjacent, non-parallel struts (or two sets of three) and a single (optional) center ball";
                        if (prepareTool) {
                            if (center == null)
                                center = this.originPoint;
                            this.transforms = [null];
                            if (index === 6)
                                this.transforms[0] = new com.vzome.core.construction.ChangeOfBasis(oldBasis, newBasis, center);
                            else
                                this.transforms[0] = new com.vzome.core.construction.ChangeOfBasis(oldBasis[0], oldBasis[1], oldBasis[2], center, this.originalScaling);
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "LinearTransformTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return LinearMapTool.CATEGORY;
                    }
                }
                LinearMapTool.CATEGORY = "linear map";
                LinearMapTool.LABEL = "Create a linear map tool";
                LinearMapTool.TOOLTIP = "<p><b>For experts and Linear Algebra students...</b><br><br>Each tool applies a linear transformation to the selected<br>objects, possibly rotating, stretching, and compressing.  To<br>create a tool, select a ball as the center of the mapping,<br>three struts (in order) to define the input basis, and three<br>more struts to define the output basis.<br><br>You can omit the input basis if it would consist of three<br>identical blue struts at right angles; the three struts you<br>select will be interpreted as the output basis.<br><br>By default, the input selection will be removed, and replaced<br>with the transformed equivalent.  If you want to keep the inputs,<br>you can right-click after creating the tool, to configure it.<br></p>";
                tools_11.LinearMapTool = LinearMapTool;
                LinearMapTool["__class"] = "com.vzome.core.tools.LinearMapTool";
                LinearMapTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (LinearMapTool) {
                    class Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools, symmetry, originalScaling) {
                            super(tools, symmetry, com.vzome.core.tools.LinearMapTool.CATEGORY, com.vzome.core.tools.LinearMapTool.LABEL, com.vzome.core.tools.LinearMapTool.TOOLTIP);
                            if (this.originalScaling === undefined)
                                this.originalScaling = false;
                            this.originalScaling = originalScaling;
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            return (total === 7 && balls === 1 && struts === 6) || (total === 4 && balls === 1 && struts === 3);
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            return new com.vzome.core.tools.LinearMapTool(id, this.getToolsModel(), this.originalScaling);
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            return true;
                        }
                    }
                    LinearMapTool.Factory = Factory;
                    Factory["__class"] = "com.vzome.core.tools.LinearMapTool.Factory";
                    Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(LinearMapTool = tools_11.LinearMapTool || (tools_11.LinearMapTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_12) {
                class ProjectionTool extends com.vzome.core.tools.TransformationTool {
                    constructor(id, tools) {
                        super(id, tools);
                        this.setInputBehaviors(false, true);
                    }
                    /**
                     *
                     */
                    perform() {
                        let plane = null;
                        let line = null;
                        for (let index335 = this.mSelection.iterator(); index335.hasNext();) {
                            let man = index335.next();
                            {
                                this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                    if (plane == null) {
                                        let panel = man;
                                        let polygon = panel.toConstruction();
                                        plane = new com.vzome.core.construction.PlaneExtensionOfPolygon(polygon);
                                        continue;
                                    }
                                    else {
                                        throw new com.vzome.core.commands.Command.Failure("Projection tool requires a single selected panel");
                                    }
                                }
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (line == null) {
                                        let strut = man;
                                        let segment = strut.toConstruction();
                                        line = new com.vzome.core.construction.LineExtensionOfSegment(segment);
                                        continue;
                                    }
                                    else {
                                        throw new com.vzome.core.commands.Command.Failure("Projection tool allows only a single selected strut");
                                    }
                                }
                            }
                        }
                        if (plane == null)
                            throw new com.vzome.core.commands.Command.Failure("Projection tool requires a selected panel");
                        this.transforms = [null];
                        this.transforms[0] = new com.vzome.core.construction.PlaneProjection(plane, line);
                        if (line != null) {
                            let test = this.transforms[0].transform$com_vzome_core_algebra_AlgebraicVector(line.getDirection());
                            if (test == null)
                                throw new com.vzome.core.commands.Command.Failure("Selected strut and plane must not be parallel");
                        }
                        super.perform();
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ProjectionTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return ProjectionTool.ID;
                    }
                }
                ProjectionTool.ID = "projection";
                ProjectionTool.LABEL = "Create a plane projection tool";
                ProjectionTool.TOOLTIP = "<p>Created tools project selected objects to a 2D plane.  To create a<br>tool, define the projection plane by selecting a single plane.<br>Optionally, select a strut to define a line of projection;<br>the default line is orthogonal to the projection plane.<br></p>";
                tools_12.ProjectionTool = ProjectionTool;
                ProjectionTool["__class"] = "com.vzome.core.tools.ProjectionTool";
                ProjectionTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (ProjectionTool) {
                    class Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools) {
                            super(tools, null, com.vzome.core.tools.ProjectionTool.ID, com.vzome.core.tools.ProjectionTool.LABEL, com.vzome.core.tools.ProjectionTool.TOOLTIP);
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            return (total === 2 && panels === 1 && struts === 1) || (total === 1 && panels === 1);
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            return new com.vzome.core.tools.ProjectionTool(id, this.getToolsModel());
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            return true;
                        }
                    }
                    ProjectionTool.Factory = Factory;
                    Factory["__class"] = "com.vzome.core.tools.ProjectionTool.Factory";
                    Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(ProjectionTool = tools_12.ProjectionTool || (tools_12.ProjectionTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_13) {
                class MirrorTool extends com.vzome.core.tools.TransformationTool {
                    constructor(id, tools) {
                        super(id, tools);
                        if (this.symmSys === undefined)
                            this.symmSys = null;
                        this.symmSys = tools.getEditorModel()['getSymmetrySystem$']();
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let center = null;
                        let axis = null;
                        let mirrorPanel = null;
                        if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.getId(), "mirror.builtin/reflection through XY plane")) {
                            center = this.originPoint;
                            this.addParameter(center);
                            let field = this.originPoint.getField();
                            let zAxis = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).scale(field['createPower$int'](com.vzome.core.math.symmetry.Direction.USER_SCALE));
                            let p2 = new com.vzome.core.construction.FreePoint(zAxis);
                            axis = new com.vzome.core.construction.SegmentJoiningPoints(center, p2);
                            this.addParameter(axis);
                        }
                        else if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(this.getId(), "mirror.builtin/reflection through red plane")) {
                            center = this.originPoint;
                            this.addParameter(center);
                            let redAxis = this.symmSys.getSymmetry().getSpecialOrbit(com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.RED).getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 0).normal();
                            let p2 = new com.vzome.core.construction.FreePoint(redAxis);
                            axis = new com.vzome.core.construction.SegmentJoiningPoints(center, p2);
                            this.addParameter(axis);
                        }
                        else if (this.isAutomatic()) {
                            center = this.originPoint;
                            let field = this.originPoint.getField();
                            let xAxis = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                            let p2 = new com.vzome.core.construction.FreePoint(xAxis);
                            axis = new com.vzome.core.construction.SegmentJoiningPoints(center, p2);
                        }
                        else
                            for (let index336 = this.mSelection.iterator(); index336.hasNext();) {
                                let man = index336.next();
                                {
                                    if (prepareTool)
                                        this.unselect$com_vzome_core_model_Manifestation(man);
                                    if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        if (center != null) {
                                            if (prepareTool)
                                                break;
                                            else
                                                return "Only one center ball may be selected";
                                        }
                                        center = man.getFirstConstruction();
                                    }
                                    else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                        if (axis != null) {
                                            if (prepareTool)
                                                break;
                                            else
                                                return "Only one mirror axis strut may be selected";
                                        }
                                        axis = man.getFirstConstruction();
                                    }
                                    else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0)) {
                                        if (mirrorPanel != null) {
                                            if (prepareTool)
                                                break;
                                            else
                                                return "Only one mirror panel may be selected";
                                        }
                                        mirrorPanel = man.getFirstConstruction();
                                    }
                                }
                            }
                        if (center == null) {
                            if (prepareTool)
                                center = this.originPoint;
                            else if (mirrorPanel == null)
                                return "No symmetry center selected";
                        }
                        let mirrorPlane = null;
                        if (axis != null && center != null && mirrorPanel == null) {
                            if (prepareTool)
                                mirrorPlane = new com.vzome.core.construction.PlaneFromNormalSegment(center, axis);
                        }
                        else if (axis == null && mirrorPanel != null) {
                            if (prepareTool)
                                mirrorPlane = new com.vzome.core.construction.PlaneExtensionOfPolygon(mirrorPanel);
                            else if (center != null)
                                return "mirror tool requires a single panel,\nor a single strut and a single center ball";
                        }
                        else {
                            let msg = "mirror tool requires a single panel,\nor a single strut and a single center ball";
                            if (prepareTool) {
                                throw new java.lang.IllegalStateException("Failed to prepare tool: " + msg);
                            }
                            else {
                                return msg;
                            }
                        }
                        if (prepareTool) {
                            this.transforms = [null];
                            this.transforms[0] = new com.vzome.core.construction.PlaneReflection(mirrorPlane);
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "MirrorTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return MirrorTool.ID;
                    }
                }
                MirrorTool.ID = "mirror";
                MirrorTool.LABEL = "Create a mirror reflection tool";
                MirrorTool.TOOLTIP = "<p>Each tool duplicates the selection by reflecting<br>each object in a mirror plane.  To create a<br>tool, define the mirror plane by selecting a single<br>panel, or by selecting a strut orthogonal to the<br>plane and a ball lying in the plane.<br></p>";
                tools_13.MirrorTool = MirrorTool;
                MirrorTool["__class"] = "com.vzome.core.tools.MirrorTool";
                MirrorTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (MirrorTool) {
                    class Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools) {
                            super(tools, null, com.vzome.core.tools.MirrorTool.ID, com.vzome.core.tools.MirrorTool.LABEL, com.vzome.core.tools.MirrorTool.TOOLTIP);
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            return (total === 2 && balls === 1 && struts === 1) || (total === 1 && panels === 1);
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            return new com.vzome.core.tools.MirrorTool(id, this.getToolsModel());
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            return true;
                        }
                    }
                    MirrorTool.Factory = Factory;
                    Factory["__class"] = "com.vzome.core.tools.MirrorTool.Factory";
                    Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(MirrorTool = tools_13.MirrorTool || (tools_13.MirrorTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_14) {
                class TranslationTool extends com.vzome.core.tools.TransformationTool {
                    constructor(id, tools) {
                        super(id, tools);
                        this.setInputBehaviors(false, true);
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let p1 = null;
                        let p2 = null;
                        let correct = true;
                        if (!this.isAutomatic())
                            for (let index337 = this.mSelection.iterator(); index337.hasNext();) {
                                let man = index337.next();
                                {
                                    if (prepareTool)
                                        this.unselect$com_vzome_core_model_Manifestation(man);
                                    if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                        if (p2 != null) {
                                            correct = false;
                                            break;
                                        }
                                        if (p1 == null)
                                            p1 = man.getFirstConstruction();
                                        else
                                            p2 = man.getFirstConstruction();
                                    }
                                    else if (!prepareTool) {
                                        return "Only balls can be selected for this tool.";
                                    }
                                }
                            }
                        if (p1 == null) {
                            if (this.isAutomatic() || this.isPredefined()) {
                                p1 = this.originPoint;
                                this.addParameter(p1);
                                let field = this.originPoint.getField();
                                let xAxis = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X);
                                let scale = field['createPower$int'](3);
                                scale = scale['times$com_vzome_core_algebra_AlgebraicNumber'](field['createRational$long'](2));
                                xAxis = xAxis.scale(scale);
                                p2 = new com.vzome.core.construction.FreePoint(xAxis);
                                this.addParameter(p2);
                            }
                            else {
                                correct = false;
                            }
                        }
                        else if (p2 == null)
                            if (prepareTool) {
                                p2 = p1;
                                p1 = this.originPoint;
                            }
                            else
                                correct = false;
                        if (!correct)
                            return "translation tool requires start and end points, or just an end point";
                        if (prepareTool) {
                            this.transforms = [null];
                            this.transforms[0] = new com.vzome.core.construction.PointToPointTranslation(p1, p2);
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "TranslationTool";
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return TranslationTool.ID;
                    }
                }
                TranslationTool.ID = "translation";
                TranslationTool.LABEL = "Create a translation tool";
                TranslationTool.TOOLTIP = "<p>Each tool moves the selected objects to a new location.<br>To create a tool, select two balls that are separated by<br>your desired translation offset.  Order of selection<br>matters: the first ball selected is the \"from\" location,<br>and the second is the \"to\" location.<br><br>By default, the input selection will be moved to the new<br>location.  If you want to copy rather than move, you can<br>right-click after creating the tool, to configure it.<br></p>";
                tools_14.TranslationTool = TranslationTool;
                TranslationTool["__class"] = "com.vzome.core.tools.TranslationTool";
                TranslationTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (TranslationTool) {
                    class Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools) {
                            super(tools, null, com.vzome.core.tools.TranslationTool.ID, com.vzome.core.tools.TranslationTool.LABEL, com.vzome.core.tools.TranslationTool.TOOLTIP);
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            return (total === 2 && balls === 2);
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            return new com.vzome.core.tools.TranslationTool(id, this.getToolsModel());
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            return true;
                        }
                    }
                    TranslationTool.Factory = Factory;
                    Factory["__class"] = "com.vzome.core.tools.TranslationTool.Factory";
                    Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(TranslationTool = tools_14.TranslationTool || (tools_14.TranslationTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_15) {
                class RotationTool extends com.vzome.core.tools.SymmetryTool {
                    constructor(id, symmetry, tools, full) {
                        if (((typeof id === 'string') || id === null) && ((symmetry != null && (symmetry["__interfaces"] != null && symmetry["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0 || symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null) && ((tools != null && tools instanceof com.vzome.core.editor.ToolsModel) || tools === null) && ((typeof full === 'boolean') || full === null)) {
                            let __args = arguments;
                            super(id, symmetry, tools);
                            if (this.fullRotation === undefined)
                                this.fullRotation = false;
                            if (this.corrected === undefined)
                                this.corrected = false;
                            if (this.fullRotation === undefined)
                                this.fullRotation = false;
                            if (this.corrected === undefined)
                                this.corrected = false;
                            (() => {
                                this.fullRotation = full;
                                this.corrected = true;
                                if (full)
                                    this.setInputBehaviors(true, false);
                                else
                                    this.setInputBehaviors(false, true);
                            })();
                        }
                        else if (((typeof id === 'string') || id === null) && ((symmetry != null && (symmetry["__interfaces"] != null && symmetry["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0 || symmetry.constructor != null && symmetry.constructor["__interfaces"] != null && symmetry.constructor["__interfaces"].indexOf("com.vzome.core.math.symmetry.Symmetry") >= 0)) || symmetry === null) && ((tools != null && tools instanceof com.vzome.core.editor.ToolsModel) || tools === null) && full === undefined) {
                            let __args = arguments;
                            let editor = __args[2];
                            {
                                let __args = arguments;
                                let tools = editor;
                                let full = false;
                                super(id, symmetry, tools);
                                if (this.fullRotation === undefined)
                                    this.fullRotation = false;
                                if (this.corrected === undefined)
                                    this.corrected = false;
                                if (this.fullRotation === undefined)
                                    this.fullRotation = false;
                                if (this.corrected === undefined)
                                    this.corrected = false;
                                (() => {
                                    this.fullRotation = full;
                                    this.corrected = true;
                                    if (full)
                                        this.setInputBehaviors(true, false);
                                    else
                                        this.setInputBehaviors(false, true);
                                })();
                            }
                            (() => {
                                this.corrected = false;
                            })();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        if (this.fullRotation)
                            return "axial symmetry";
                        else
                            return RotationTool.__com_vzome_core_tools_RotationTool_ID;
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        let center = null;
                        let axisStrut = null;
                        let correct = true;
                        for (let index338 = this.mSelection.iterator(); index338.hasNext();) {
                            let man = index338.next();
                            {
                                if (prepareTool)
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (center != null) {
                                        correct = false;
                                        break;
                                    }
                                    center = man.getFirstConstruction();
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (axisStrut != null) {
                                        correct = false;
                                        break;
                                    }
                                    axisStrut = man.getFirstConstruction();
                                }
                            }
                        }
                        if (axisStrut == null) {
                            let preferredAxis = this.symmetry.getPreferredAxis();
                            if (preferredAxis != null) {
                                let field = this.symmetry.getField();
                                center = this.originPoint;
                                this.addParameter(center);
                                axisStrut = new com.vzome.core.construction.AnchoredSegment(preferredAxis, field.one(), center);
                                this.addParameter(axisStrut);
                            }
                            else if (this.isPredefined()) {
                                center = this.originPoint;
                                this.addParameter(center);
                                let redOrbit = this.symmetry.getSpecialOrbit(com.vzome.core.math.symmetry.Symmetry.SpecialOrbit.RED);
                                let field = this.symmetry.getField();
                                let redScale = redOrbit.getUnitLength()['times$com_vzome_core_algebra_AlgebraicNumber'](field['createPower$int'](com.vzome.core.math.symmetry.Direction.USER_SCALE));
                                axisStrut = new com.vzome.core.construction.AnchoredSegment(redOrbit.getAxis$int$int(com.vzome.core.math.symmetry.Symmetry.PLUS, 1), redScale, center);
                                this.addParameter(axisStrut);
                            }
                            else if (this.isAutomatic()) {
                                center = this.originPoint;
                                this.addParameter(center);
                                let field = this.symmetry.getField();
                                let zAxis = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z);
                                let len = field['createPower$int'](2);
                                axisStrut = new com.vzome.core.construction.AnchoredSegment(this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](zAxis), len, center);
                                this.addParameter(axisStrut);
                            }
                            else
                                correct = false;
                        }
                        else if (center == null)
                            center = new com.vzome.core.construction.SegmentEndPoint(axisStrut);
                        if (!correct)
                            return "rotation tool requires a single axis strut,\nand optionally a separate center point";
                        let vector = axisStrut.getOffset();
                        vector = axisStrut.getField().projectTo3d(vector, true);
                        let axis = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
                        if (axis == null)
                            return "selected strut is not an axis of rotation";
                        let perm = axis.getRotationPermutation();
                        if (perm == null)
                            return "selected strut is not an axis of rotation";
                        let rotation = this.corrected ? perm.mapIndex(0) : axis.getRotation();
                        if (prepareTool) {
                            if (this.fullRotation) {
                                let order = perm.getOrder();
                                this.transforms = (s => { let a = []; while (s-- > 0)
                                    a.push(null); return a; })(order - 1);
                                for (let i = 0; i < this.transforms.length; i++) {
                                    {
                                        this.transforms[i] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, rotation, center);
                                        rotation = perm.mapIndex(rotation);
                                    }
                                    ;
                                }
                            }
                            else {
                                this.transforms = [null];
                                this.transforms[0] = new com.vzome.core.construction.SymmetryTransformation(this.symmetry, rotation, center);
                            }
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "RotationTool";
                    }
                    /**
                     *
                     * @param {*} element
                     */
                    getXmlAttributes(element) {
                        if (this.fullRotation)
                            element.setAttribute("full", "true");
                        if (this.corrected)
                            element.setAttribute("corrected", "true");
                        super.getXmlAttributes(element);
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        let value = element.getAttribute("full");
                        this.fullRotation = (value != null) && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("true", value);
                        value = element.getAttribute("corrected");
                        this.corrected = (value != null) && /* equals */ ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("true", value);
                        super.setXmlAttributes(element, format);
                    }
                }
                RotationTool.__com_vzome_core_tools_RotationTool_ID = "rotation";
                RotationTool.__com_vzome_core_tools_RotationTool_LABEL = "Create a rotation tool";
                RotationTool.__com_vzome_core_tools_RotationTool_TOOLTIP = "<p>Each tool rotates the selected objects around an axis<br>of symmetry.  To create a tool, select a strut that<br>defines that axis.  You can also define the direction<br>and center independently, by selecting a ball for the<br>center and a strut for the axis.  Note: not all struts<br>correspond to rotational symmetries!<br><br>The direction of rotation depends on the strut<br>orientation, which is hard to discover, but easy to<br>control, by dragging out a new strut.<br><br>By default, the input selection will be moved to the new,<br>rotated orientation.  After creating a tool, you can<br>right-click to configure the tool to create a copy, instead.<br></p>";
                tools_15.RotationTool = RotationTool;
                RotationTool["__class"] = "com.vzome.core.tools.RotationTool";
                RotationTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (RotationTool) {
                    class __com_vzome_core_tools_RotationTool_Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools, symmetry, id = com.vzome.core.tools.RotationTool.__com_vzome_core_tools_RotationTool_ID, label = com.vzome.core.tools.RotationTool.__com_vzome_core_tools_RotationTool_LABEL, tooltip = com.vzome.core.tools.RotationTool.__com_vzome_core_tools_RotationTool_TOOLTIP) {
                            super(tools, symmetry, id, label, tooltip);
                            if (this.noStrut === undefined)
                                this.noStrut = false;
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            if (total === 1 && balls === 1) {
                                this.noStrut = true;
                                return true;
                            }
                            else if ((total === 1 && struts === 1) || (total === 2 && balls === 1 && struts === 1)) {
                                this.noStrut = false;
                                return true;
                            }
                            return false;
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            return new com.vzome.core.tools.RotationTool(id, this.getSymmetry(), this.getToolsModel(), false);
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            let symmetry = this.getSymmetry();
                            for (let index339 = selection.iterator(); index339.hasNext();) {
                                let man = index339.next();
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    let axisStrut = man;
                                    let vector = axisStrut.getOffset();
                                    vector = symmetry.getField().projectTo3d(vector, true);
                                    let axis = symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](vector);
                                    if (axis == null)
                                        return false;
                                    let perm = axis.getRotationPermutation();
                                    if (perm == null)
                                        return false;
                                }
                                else if (this.noStrut) {
                                    let axis = symmetry.getPreferredAxis();
                                    if (axis == null)
                                        return false;
                                }
                            }
                            return true;
                        }
                    }
                    RotationTool.__com_vzome_core_tools_RotationTool_Factory = __com_vzome_core_tools_RotationTool_Factory;
                    __com_vzome_core_tools_RotationTool_Factory["__class"] = "com.vzome.core.tools.RotationTool.Factory";
                    __com_vzome_core_tools_RotationTool_Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(RotationTool = tools_15.RotationTool || (tools_15.RotationTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_16) {
                class ScalingTool extends com.vzome.core.tools.SymmetryTool {
                    constructor(id, symmetry, tools) {
                        super(id, symmetry, tools);
                        if (this.scaleFactor === undefined)
                            this.scaleFactor = null;
                        this.scaleFactor = null;
                        this.setInputBehaviors(false, true);
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getCategory() {
                        return ScalingTool.__com_vzome_core_tools_ScalingTool_ID;
                    }
                    setScaleFactor(scaleFactor) {
                        this.scaleFactor = scaleFactor;
                    }
                    /**
                     *
                     * @param {boolean} prepareTool
                     * @return {string}
                     */
                    checkSelection(prepareTool) {
                        if (this.scaleFactor != null) {
                            let field = this.scaleFactor.getField();
                            this.transforms = [null];
                            let column1 = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X).scale(this.scaleFactor);
                            let column2 = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Y).scale(this.scaleFactor);
                            let column3 = field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.Z).scale(this.scaleFactor);
                            let p1 = new com.vzome.core.construction.FreePoint(field.basisVector(3, com.vzome.core.algebra.AlgebraicVector.X).scale(field['createPower$int'](4)));
                            let p2 = new com.vzome.core.construction.FreePoint(column2.scale(field['createPower$int'](4)));
                            this.addParameter(this.originPoint);
                            this.addParameter(new com.vzome.core.construction.SegmentJoiningPoints(this.originPoint, p1));
                            this.addParameter(new com.vzome.core.construction.SegmentJoiningPoints(this.originPoint, p2));
                            let transform = new com.vzome.core.algebra.AlgebraicMatrix(column1, column2, column3);
                            this.transforms[0] = new com.vzome.core.construction.MatrixTransformation(transform, this.originPoint.getLocation());
                            return null;
                        }
                        let s1 = null;
                        let s2 = null;
                        let center = null;
                        let correct = true;
                        let hasPanels = false;
                        for (let index340 = this.mSelection.iterator(); index340.hasNext();) {
                            let man = index340.next();
                            {
                                if (prepareTool)
                                    this.unselect$com_vzome_core_model_Manifestation(man);
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Connector") >= 0)) {
                                    if (center != null) {
                                        correct = false;
                                        break;
                                    }
                                    center = man.getFirstConstruction();
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    if (s2 != null) {
                                        correct = false;
                                        break;
                                    }
                                    if (s1 == null)
                                        s1 = man.getFirstConstruction();
                                    else
                                        s2 = man.getFirstConstruction();
                                }
                                else if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Panel") >= 0))
                                    hasPanels = true;
                            }
                        }
                        if (center == null) {
                            if (prepareTool)
                                center = this.originPoint;
                            else
                                return "No symmetry center selected";
                        }
                        correct = correct && s2 != null;
                        if (!prepareTool && hasPanels)
                            correct = false;
                        if (!correct)
                            return "scaling tool requires before and after struts, and a single center";
                        let zone1 = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](s1.getOffset());
                        let zone2 = this.symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](s2.getOffset());
                        if (zone1 == null || zone2 == null)
                            return "struts cannot be automatic";
                        let orbit = zone1.getDirection();
                        if (orbit !== zone2.getDirection())
                            return "before and after struts must be from the same orbit";
                        if (prepareTool) {
                            this.transforms = [null];
                            this.transforms[0] = new com.vzome.core.construction.Scaling(s1, s2, center, this.symmetry);
                        }
                        return null;
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getXmlElementName() {
                        return "ScalingTool";
                    }
                    /**
                     *
                     * @param {*} element
                     * @param {com.vzome.core.commands.XmlSaveFormat} format
                     */
                    setXmlAttributes(element, format) {
                        let symmName = element.getAttribute("symmetry");
                        if (symmName == null || /* isEmpty */ (symmName.length === 0)) {
                            element.setAttribute("symmetry", "icosahedral");
                            SideEffects.logBugAccommodation("scaling tool serialized with no symmetry; assuming icosahedral");
                        }
                        super.setXmlAttributes(element, format);
                    }
                }
                ScalingTool.__com_vzome_core_tools_ScalingTool_ID = "scaling";
                ScalingTool.__com_vzome_core_tools_ScalingTool_LABEL = "Create a scaling tool";
                ScalingTool.__com_vzome_core_tools_ScalingTool_TOOLTIP = "<p>Each tool enlarges or shrinks the selected objects,<br>relative to a central point.  To create a tool,<br>select a ball representing the central point, and<br>two struts from the same orbit (color) with different<br>sizes.<br><br>The selection order matters.  First select a strut<br>that you want to enlarge or shrink, then select a<br>strut that has the desired target size.<br></p>";
                tools_16.ScalingTool = ScalingTool;
                ScalingTool["__class"] = "com.vzome.core.tools.ScalingTool";
                ScalingTool["__interfaces"] = ["com.vzome.api.Tool"];
                (function (ScalingTool) {
                    class __com_vzome_core_tools_ScalingTool_Factory extends com.vzome.core.editor.AbstractToolFactory {
                        constructor(tools, symmetry) {
                            super(tools, symmetry, com.vzome.core.tools.ScalingTool.__com_vzome_core_tools_ScalingTool_ID, com.vzome.core.tools.ScalingTool.__com_vzome_core_tools_ScalingTool_LABEL, com.vzome.core.tools.ScalingTool.__com_vzome_core_tools_ScalingTool_TOOLTIP);
                        }
                        /**
                         *
                         * @param {number} total
                         * @param {number} balls
                         * @param {number} struts
                         * @param {number} panels
                         * @return {boolean}
                         */
                        countsAreValid(total, balls, struts, panels) {
                            return (total === 3 && balls === 1 && struts === 2);
                        }
                        /**
                         *
                         * @param {string} id
                         * @return {com.vzome.core.editor.Tool}
                         */
                        createToolInternal(id) {
                            let tool = new com.vzome.core.tools.ScalingTool(id, this.getSymmetry(), this.getToolsModel());
                            let scalePower = 0;
                            switch ((id)) {
                                case "scaling.builtin/scale up":
                                    scalePower = 1;
                                    break;
                                case "scaling.builtin/scale down":
                                    scalePower = -1;
                                    break;
                                default:
                                    return tool;
                            }
                            let field = this.getToolsModel().getEditorModel().getRealizedModel().getField();
                            tool.setScaleFactor(field['createPower$int'](scalePower));
                            return tool;
                        }
                        /**
                         *
                         * @param {*} selection
                         * @return {boolean}
                         */
                        bindParameters(selection) {
                            let symmetry = this.getSymmetry();
                            let offset1 = null;
                            let offset2 = null;
                            for (let index341 = selection.iterator(); index341.hasNext();) {
                                let man = index341.next();
                                if (man != null && (man["__interfaces"] != null && man["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0 || man.constructor != null && man.constructor["__interfaces"] != null && man.constructor["__interfaces"].indexOf("com.vzome.core.model.Strut") >= 0)) {
                                    let strut = man;
                                    if (offset1 == null)
                                        offset1 = strut.getOffset();
                                    else
                                        offset2 = strut.getOffset();
                                }
                            }
                            let zone1 = symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](offset1);
                            let zone2 = symmetry['getAxis$com_vzome_core_algebra_AlgebraicVector'](offset2);
                            if (zone1 == null || zone2 == null)
                                return false;
                            let orbit1 = zone1.getDirection();
                            let orbit2 = zone2.getDirection();
                            if (orbit1 !== orbit2)
                                return false;
                            if (orbit1.isAutomatic())
                                return false;
                            let l1 = zone1.getLength(offset1);
                            let l2 = zone2.getLength(offset2);
                            if ( /* equals */((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(l1, l2))
                                return false;
                            return true;
                        }
                    }
                    ScalingTool.__com_vzome_core_tools_ScalingTool_Factory = __com_vzome_core_tools_ScalingTool_Factory;
                    __com_vzome_core_tools_ScalingTool_Factory["__class"] = "com.vzome.core.tools.ScalingTool.Factory";
                    __com_vzome_core_tools_ScalingTool_Factory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
                })(ScalingTool = tools_16.ScalingTool || (tools_16.ScalingTool = {}));
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
(function (com) {
    var vzome;
    (function (vzome) {
        var core;
        (function (core) {
            var tools;
            (function (tools_17) {
                class AxialSymmetryToolFactory extends com.vzome.core.tools.RotationTool.__com_vzome_core_tools_RotationTool_Factory {
                    constructor(tools, symmetry) {
                        super(tools, symmetry, AxialSymmetryToolFactory.ID, AxialSymmetryToolFactory.LABEL, AxialSymmetryToolFactory.TOOLTIP);
                    }
                    /**
                     *
                     * @param {string} id
                     * @return {com.vzome.core.editor.Tool}
                     */
                    createToolInternal(id) {
                        return new com.vzome.core.tools.RotationTool(id, this.getSymmetry(), this.getToolsModel(), true);
                    }
                }
                AxialSymmetryToolFactory.ID = "axial symmetry";
                AxialSymmetryToolFactory.LABEL = "Create a rotational symmetry tool";
                AxialSymmetryToolFactory.TOOLTIP = "<p>Each tool creates enough copies of the selected objects to<br>create rotational symmetry around an axis.  To create a tool,<br>select a strut that defines that axis,  You can also define<br>the direction and center independently, by selecting a ball<br>for the center and a strut for the axis.  Note: not all struts<br>correspond to rotational symmetries!<br><br>Combine with a point reflection or mirror reflection tool to<br>achieve more symmetries.<br></p>";
                tools_17.AxialSymmetryToolFactory = AxialSymmetryToolFactory;
                AxialSymmetryToolFactory["__class"] = "com.vzome.core.tools.AxialSymmetryToolFactory";
                AxialSymmetryToolFactory["__interfaces"] = ["com.vzome.core.editor.SelectionSummary.Listener", "com.vzome.api.Tool.Factory"];
            })(tools = core.tools || (core.tools = {}));
        })(core = vzome.core || (vzome.core = {}));
    })(vzome = com.vzome || (com.vzome = {}));
})(com || (com = {}));
com.vzome.core.editor.CommandEdit.loadAndPerformLgger_$LI$();
com.vzome.core.editor.CommandEdit.logger_$LI$();
com.vzome.core.commands.CommandTetrahedralSymmetry.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandQuaternionSymmetry.LEFT_SYMMETRY_GROUP_ATTR_NAME_$LI$();
com.vzome.core.commands.CommandUniformH4Polytope.logger_$LI$();
com.vzome.core.editor.api.ChangeSelection.logger_$LI$();
com.vzome.core.commands.CommandCentroid.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandCentroid.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandPolygon.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandPolygon.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandTauDivision.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandTauDivision.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandBuildAnchoredSegment.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandTransform.GROUP_ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandTransform.AXIS_ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandTransform.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandTransform.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandJoinPoints.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandJoinPoints.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandMidpoint.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandMidpoint.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandObliquePentagon.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandObliquePentagon.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandLinePlaneIntersect.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandLinePlaneIntersect.PARAM_SIGNATURE_$LI$();
com.vzome.core.construction.SegmentRotated4D.logger_$LI$();
com.vzome.core.commands.CommandImportVEFData.logger_$LI$();
com.vzome.core.commands.CommandImportVEFData.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandImportVEFData.PARAM_SIGNATURE_$LI$();
com.vzome.core.math.RealVector.DIRECTION_0_$LI$();
com.vzome.core.math.RealVector.FORMAT_$LI$();
com.vzome.core.math.RealVector.ORIGIN_$LI$();
com.vzome.core.math.RealVector.__static_initialize();
com.vzome.core.commands.CommandLoad.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandLoad.PARAM_SIGNATURE_$LI$();
com.vzome.core.editor.api.SideEffects.BUG_ACCOMMODATION_LOGGER_$LI$();
com.vzome.core.commands.CommandSetColor.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandHide.ATTR_SIGNATURE_$LI$();
com.vzome.core.commands.CommandHide.PARAM_SIGNATURE_$LI$();
com.vzome.core.commands.CommandFreePoint.PARAMS_$LI$();
com.vzome.core.commands.XmlSymmetryFormat.__com_vzome_core_commands_XmlSymmetryFormat_logger_$LI$();
com.vzome.core.commands.XmlSymmetryFormat.__static_initialize();
com.vzome.core.construction.VefToModel.logger_$LI$();
com.vzome.core.viewing.ExportedVEFShapes.logger_$LI$();
com.vzome.core.viewing.ExportedVEFShapes.INJECTED_$LI$();
com.vzome.xml.ResourceLoader.INJECTED_RESOURCES_$LI$();
com.vzome.core.editor.SymmetrySystem.logger_$LI$();
com.vzome.core.edits.ManifestationColorMappers.colorMappers_$LI$();
com.vzome.core.edits.ManifestationColorMappers.__static_initialize();
com.vzome.core.commands.Command.Failure.logger_$LI$();
com.vzome.core.commands.XmlSaveFormat.NOT_AN_ATTRIBUTE_$LI$();
com.vzome.core.commands.XmlSaveFormat.logger_$LI$();
com.vzome.core.commands.XmlSaveFormat.FORMATS_$LI$();
com.vzome.core.construction.Color.GREY_TRANSPARENT_$LI$();
com.vzome.core.construction.Color.WHITE_$LI$();
com.vzome.core.construction.Color.BLACK_$LI$();
com.vzome.core.math.symmetry.B4Group.B4_PERMS_$LI$();
com.vzome.core.math.symmetry.Direction.logger_$LI$();
com.vzome.core.math.symmetry.DirectionNaming.SIGN_$LI$();
com.vzome.core.math.symmetry.D4Group.D4_PERMS_$LI$();
com.vzome.core.math.symmetry.A4Group.S5_PERMS_$LI$();
com.vzome.core.math.Polyhedron.logger_$LI$();
com.vzome.core.viewing.ExportedVEFStrutGeometry.LOGGER_$LI$();
com.vzome.core.render.RenderedManifestation.logger_$LI$();
com.vzome.core.render.Colors.NO_VECTOR_$LI$();
com.vzome.core.render.Colors.PLANE_$LI$();
com.vzome.core.render.Colors.DIRECTION_$LI$();
com.vzome.core.render.Colors.CONNECTOR_$LI$();
com.vzome.core.render.Colors.HIGHLIGHT_MAC_$LI$();
com.vzome.core.render.Colors.HIGHLIGHT_$LI$();
com.vzome.core.render.Colors.PANEL_$LI$();
com.vzome.core.render.Colors.BACKGROUND_$LI$();
